/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/file-saver/dist/FileSaver.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/file-saver/dist/FileSaver.min.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(this,function(){\"use strict\";function b(a,b){return\"undefined\"==typeof b?b={autoBom:!1}:\"object\"!=typeof b&&(console.warn(\"Deprecated: Expected third argument to be a object\"),b={autoBom:!b}),b.autoBom&&/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type)?new Blob([\"\\uFEFF\",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(\"GET\",a),d.responseType=\"blob\",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error(\"could not download file\")},d.send()}function d(a){var b=new XMLHttpRequest;b.open(\"HEAD\",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(\"click\"))}catch(c){var b=document.createEvent(\"MouseEvents\");b.initMouseEvent(\"click\",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f=\"object\"==typeof window&&window.window===window?window:\"object\"==typeof self&&self.self===self?self:\"object\"==typeof __webpack_require__.g&&__webpack_require__.g.global===__webpack_require__.g?__webpack_require__.g:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||(\"object\"!=typeof window||window!==f?function(){}:\"download\"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(\"a\");g=g||b.name||\"download\",j.download=g,j.rel=\"noopener\",\"string\"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=\"_blank\")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:\"msSaveOrOpenBlob\"in navigator?function(f,g,h){if(g=g||f.name||\"download\",\"string\"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(\"a\");i.href=f,i.target=\"_blank\",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open(\"\",\"_blank\"),g&&(g.document.title=g.document.body.innerText=\"downloading...\"),\"string\"==typeof b)return c(b,d,e);var h=\"application/octet-stream\"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\\/[\\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&\"undefined\"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,\"data:attachment/file;\"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g, true&&(module.exports=g)});\n\n//# sourceMappingURL=FileSaver.min.js.map\n\n//# sourceURL=webpack://webgpu-prog-iso/./node_modules/file-saver/dist/FileSaver.min.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ARRAY_TYPE\": () => (/* binding */ ARRAY_TYPE),\n/* harmony export */   \"EPSILON\": () => (/* binding */ EPSILON),\n/* harmony export */   \"RANDOM\": () => (/* binding */ RANDOM),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"setMatrixArrayType\": () => (/* binding */ setMatrixArrayType),\n/* harmony export */   \"toRadian\": () => (/* binding */ toRadian)\n/* harmony export */ });\n/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n\n//# sourceURL=webpack://webgpu-prog-iso/./node_modules/gl-matrix/esm/common.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"adjoint\": () => (/* binding */ adjoint),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"determinant\": () => (/* binding */ determinant),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"frob\": () => (/* binding */ frob),\n/* harmony export */   \"fromMat2d\": () => (/* binding */ fromMat2d),\n/* harmony export */   \"fromMat4\": () => (/* binding */ fromMat4),\n/* harmony export */   \"fromQuat\": () => (/* binding */ fromQuat),\n/* harmony export */   \"fromRotation\": () => (/* binding */ fromRotation),\n/* harmony export */   \"fromScaling\": () => (/* binding */ fromScaling),\n/* harmony export */   \"fromTranslation\": () => (/* binding */ fromTranslation),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"multiplyScalar\": () => (/* binding */ multiplyScalar),\n/* harmony export */   \"multiplyScalarAndAdd\": () => (/* binding */ multiplyScalarAndAdd),\n/* harmony export */   \"normalFromMat4\": () => (/* binding */ normalFromMat4),\n/* harmony export */   \"projection\": () => (/* binding */ projection),\n/* harmony export */   \"rotate\": () => (/* binding */ rotate),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"sub\": () => (/* binding */ sub),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"translate\": () => (/* binding */ translate),\n/* harmony export */   \"transpose\": () => (/* binding */ transpose)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\nfunction fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\nfunction set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\n\nfunction translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nfunction rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\nfunction fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nfunction normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nfunction projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nfunction str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack://webgpu-prog-iso/./node_modules/gl-matrix/esm/mat3.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"adjoint\": () => (/* binding */ adjoint),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"determinant\": () => (/* binding */ determinant),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"frob\": () => (/* binding */ frob),\n/* harmony export */   \"fromQuat\": () => (/* binding */ fromQuat),\n/* harmony export */   \"fromQuat2\": () => (/* binding */ fromQuat2),\n/* harmony export */   \"fromRotation\": () => (/* binding */ fromRotation),\n/* harmony export */   \"fromRotationTranslation\": () => (/* binding */ fromRotationTranslation),\n/* harmony export */   \"fromRotationTranslationScale\": () => (/* binding */ fromRotationTranslationScale),\n/* harmony export */   \"fromRotationTranslationScaleOrigin\": () => (/* binding */ fromRotationTranslationScaleOrigin),\n/* harmony export */   \"fromScaling\": () => (/* binding */ fromScaling),\n/* harmony export */   \"fromTranslation\": () => (/* binding */ fromTranslation),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"fromXRotation\": () => (/* binding */ fromXRotation),\n/* harmony export */   \"fromYRotation\": () => (/* binding */ fromYRotation),\n/* harmony export */   \"fromZRotation\": () => (/* binding */ fromZRotation),\n/* harmony export */   \"frustum\": () => (/* binding */ frustum),\n/* harmony export */   \"getRotation\": () => (/* binding */ getRotation),\n/* harmony export */   \"getScaling\": () => (/* binding */ getScaling),\n/* harmony export */   \"getTranslation\": () => (/* binding */ getTranslation),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"lookAt\": () => (/* binding */ lookAt),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"multiplyScalar\": () => (/* binding */ multiplyScalar),\n/* harmony export */   \"multiplyScalarAndAdd\": () => (/* binding */ multiplyScalarAndAdd),\n/* harmony export */   \"ortho\": () => (/* binding */ ortho),\n/* harmony export */   \"orthoNO\": () => (/* binding */ orthoNO),\n/* harmony export */   \"orthoZO\": () => (/* binding */ orthoZO),\n/* harmony export */   \"perspective\": () => (/* binding */ perspective),\n/* harmony export */   \"perspectiveFromFieldOfView\": () => (/* binding */ perspectiveFromFieldOfView),\n/* harmony export */   \"perspectiveNO\": () => (/* binding */ perspectiveNO),\n/* harmony export */   \"perspectiveZO\": () => (/* binding */ perspectiveZO),\n/* harmony export */   \"rotate\": () => (/* binding */ rotate),\n/* harmony export */   \"rotateX\": () => (/* binding */ rotateX),\n/* harmony export */   \"rotateY\": () => (/* binding */ rotateY),\n/* harmony export */   \"rotateZ\": () => (/* binding */ rotateZ),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"sub\": () => (/* binding */ sub),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"targetTo\": () => (/* binding */ targetTo),\n/* harmony export */   \"translate\": () => (/* binding */ translate),\n/* harmony export */   \"transpose\": () => (/* binding */ transpose)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nfunction translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nfunction fromQuat2(out, a) {\n  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nfunction getRotation(out, mat) {\n  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nvar perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nvar ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nfunction str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack://webgpu-prog-iso/./node_modules/gl-matrix/esm/mat4.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"calculateW\": () => (/* binding */ calculateW),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"conjugate\": () => (/* binding */ conjugate),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"exp\": () => (/* binding */ exp),\n/* harmony export */   \"fromEuler\": () => (/* binding */ fromEuler),\n/* harmony export */   \"fromMat3\": () => (/* binding */ fromMat3),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"getAngle\": () => (/* binding */ getAngle),\n/* harmony export */   \"getAxisAngle\": () => (/* binding */ getAxisAngle),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"len\": () => (/* binding */ len),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"ln\": () => (/* binding */ ln),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"pow\": () => (/* binding */ pow),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"rotateX\": () => (/* binding */ rotateX),\n/* harmony export */   \"rotateY\": () => (/* binding */ rotateY),\n/* harmony export */   \"rotateZ\": () => (/* binding */ rotateZ),\n/* harmony export */   \"rotationTo\": () => (/* binding */ rotationTo),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"setAxes\": () => (/* binding */ setAxes),\n/* harmony export */   \"setAxisAngle\": () => (/* binding */ setAxisAngle),\n/* harmony export */   \"slerp\": () => (/* binding */ slerp),\n/* harmony export */   \"sqlerp\": () => (/* binding */ sqlerp),\n/* harmony export */   \"sqrLen\": () => (/* binding */ sqrLen),\n/* harmony export */   \"squaredLength\": () => (/* binding */ squaredLength),\n/* harmony export */   \"str\": () => (/* binding */ str)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ \"./node_modules/gl-matrix/esm/mat3.js\");\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ \"./node_modules/gl-matrix/esm/vec3.js\");\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vec4.js */ \"./node_modules/gl-matrix/esm/vec4.js\");\n\n\n\n\n/**\n * Quaternion\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\n\nfunction setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\n\nfunction getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\n\nfunction getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\n\nfunction multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\n\nfunction calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nfunction exp(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nfunction ln(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\n\nfunction pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nfunction random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();\n  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();\n  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\n\nfunction invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\n\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\n\nfunction fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} Angle to rotate around X axis in degrees.\n * @param {y} Angle to rotate around Y axis in degrees.\n * @param {z} Angle to rotate around Z axis in degrees.\n * @returns {quat} out\n * @function\n */\n\nfunction fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\n * Returns a string representation of a quatenion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\n\nvar clone = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.clone;\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\n\nvar fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.fromValues;\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\n\nvar copy = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.copy;\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\n\nvar set = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.set;\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\n\nvar add = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.add;\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\n\nvar scale = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.scale;\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\n\nvar dot = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.dot;\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\n\nvar lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.lerp;\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nvar length = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.length;\n/**\n * Alias for {@link quat.length}\n * @function\n */\n\nvar len = length;\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\n\nvar squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.squaredLength;\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\n\nvar sqrLen = squaredLength;\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\n\nvar normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.normalize;\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nvar exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.exactEquals;\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {ReadonlyQuat} a The first vector.\n * @param {ReadonlyQuat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nvar equals = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.equals;\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\n\nvar rotationTo = function () {\n  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.create();\n  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(1, 0, 0);\n  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.dot(a, b);\n\n    if (dot < -0.999999) {\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, xUnitVec3, a);\n      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__.len(tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, yUnitVec3, a);\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nvar sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\n\nvar setAxes = function () {\n  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_3__.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();\n\n//# sourceURL=webpack://webgpu-prog-iso/./node_modules/gl-matrix/esm/quat.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec2.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"angle\": () => (/* binding */ angle),\n/* harmony export */   \"ceil\": () => (/* binding */ ceil),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"cross\": () => (/* binding */ cross),\n/* harmony export */   \"dist\": () => (/* binding */ dist),\n/* harmony export */   \"distance\": () => (/* binding */ distance),\n/* harmony export */   \"div\": () => (/* binding */ div),\n/* harmony export */   \"divide\": () => (/* binding */ divide),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"floor\": () => (/* binding */ floor),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"inverse\": () => (/* binding */ inverse),\n/* harmony export */   \"len\": () => (/* binding */ len),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"negate\": () => (/* binding */ negate),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"rotate\": () => (/* binding */ rotate),\n/* harmony export */   \"round\": () => (/* binding */ round),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"scaleAndAdd\": () => (/* binding */ scaleAndAdd),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"sqrDist\": () => (/* binding */ sqrDist),\n/* harmony export */   \"sqrLen\": () => (/* binding */ sqrLen),\n/* harmony export */   \"squaredDistance\": () => (/* binding */ squaredDistance),\n/* harmony export */   \"squaredLength\": () => (/* binding */ squaredLength),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"sub\": () => (/* binding */ sub),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"transformMat2\": () => (/* binding */ transformMat2),\n/* harmony export */   \"transformMat2d\": () => (/* binding */ transformMat2d),\n/* harmony export */   \"transformMat3\": () => (/* binding */ transformMat3),\n/* harmony export */   \"transformMat4\": () => (/* binding */ transformMat4),\n/* harmony export */   \"zero\": () => (/* binding */ zero)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nfunction fromValues(x, y) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nfunction set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nfunction cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nfunction rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nfunction angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nvar len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nvar sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nvar div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nvar dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nvar sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nvar sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack://webgpu-prog-iso/./node_modules/gl-matrix/esm/vec2.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"angle\": () => (/* binding */ angle),\n/* harmony export */   \"bezier\": () => (/* binding */ bezier),\n/* harmony export */   \"ceil\": () => (/* binding */ ceil),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"cross\": () => (/* binding */ cross),\n/* harmony export */   \"dist\": () => (/* binding */ dist),\n/* harmony export */   \"distance\": () => (/* binding */ distance),\n/* harmony export */   \"div\": () => (/* binding */ div),\n/* harmony export */   \"divide\": () => (/* binding */ divide),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"floor\": () => (/* binding */ floor),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"hermite\": () => (/* binding */ hermite),\n/* harmony export */   \"inverse\": () => (/* binding */ inverse),\n/* harmony export */   \"len\": () => (/* binding */ len),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"negate\": () => (/* binding */ negate),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"rotateX\": () => (/* binding */ rotateX),\n/* harmony export */   \"rotateY\": () => (/* binding */ rotateY),\n/* harmony export */   \"rotateZ\": () => (/* binding */ rotateZ),\n/* harmony export */   \"round\": () => (/* binding */ round),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"scaleAndAdd\": () => (/* binding */ scaleAndAdd),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"sqrDist\": () => (/* binding */ sqrDist),\n/* harmony export */   \"sqrLen\": () => (/* binding */ sqrLen),\n/* harmony export */   \"squaredDistance\": () => (/* binding */ squaredDistance),\n/* harmony export */   \"squaredLength\": () => (/* binding */ squaredLength),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"sub\": () => (/* binding */ sub),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"transformMat3\": () => (/* binding */ transformMat3),\n/* harmony export */   \"transformMat4\": () => (/* binding */ transformMat4),\n/* harmony export */   \"transformQuat\": () => (/* binding */ transformQuat),\n/* harmony export */   \"zero\": () => (/* binding */ zero)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nfunction fromValues(x, y, z) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;\n  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nfunction angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nvar sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nvar div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nvar dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nvar sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nvar len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nvar sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack://webgpu-prog-iso/./node_modules/gl-matrix/esm/vec3.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"ceil\": () => (/* binding */ ceil),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"cross\": () => (/* binding */ cross),\n/* harmony export */   \"dist\": () => (/* binding */ dist),\n/* harmony export */   \"distance\": () => (/* binding */ distance),\n/* harmony export */   \"div\": () => (/* binding */ div),\n/* harmony export */   \"divide\": () => (/* binding */ divide),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"floor\": () => (/* binding */ floor),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"inverse\": () => (/* binding */ inverse),\n/* harmony export */   \"len\": () => (/* binding */ len),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"negate\": () => (/* binding */ negate),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"round\": () => (/* binding */ round),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"scaleAndAdd\": () => (/* binding */ scaleAndAdd),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"sqrDist\": () => (/* binding */ sqrDist),\n/* harmony export */   \"sqrLen\": () => (/* binding */ sqrLen),\n/* harmony export */   \"squaredDistance\": () => (/* binding */ squaredDistance),\n/* harmony export */   \"squaredLength\": () => (/* binding */ squaredLength),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"sub\": () => (/* binding */ sub),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"transformMat4\": () => (/* binding */ transformMat4),\n/* harmony export */   \"transformQuat\": () => (/* binding */ transformQuat),\n/* harmony export */   \"zero\": () => (/* binding */ zero)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nfunction fromValues(x, y, z, w) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nfunction cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;\n    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;\n    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nfunction transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nvar sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nvar div = divide;\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nvar dist = distance;\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nvar sqrDist = squaredDistance;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nvar len = length;\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nvar sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack://webgpu-prog-iso/./node_modules/gl-matrix/esm/vec4.js?");

/***/ }),

/***/ "./node_modules/jimp/browser/lib/jimp.js":
/*!***********************************************!*\
  !*** ./node_modules/jimp/browser/lib/jimp.js ***!
  \***********************************************/
/***/ (() => {

eval("/*! For license information please see jimp.js.LICENSE.txt */\n(()=>{var __webpack_modules__={236:(t,e,r)=>{var i=r(4618);function n(t,e){var r=new i(t,e);return function(t){return r.convert(t)}}n.BIN=\"01\",n.OCT=\"01234567\",n.DEC=\"0123456789\",n.HEX=\"0123456789abcdef\",t.exports=n},4618:t=>{\"use strict\";function e(t,e){if(!(t&&e&&t.length&&e.length))throw new Error(\"Bad alphabet\");this.srcAlphabet=t,this.dstAlphabet=e}e.prototype.convert=function(t){var e,r,i,n={},a=this.srcAlphabet.length,o=this.dstAlphabet.length,s=t.length,h=\"string\"==typeof t?\"\":[];if(!this.isValid(t))throw new Error('Number \"'+t+'\" contains of non-alphabetic digits ('+this.srcAlphabet+\")\");if(this.srcAlphabet===this.dstAlphabet)return t;for(e=0;e<s;e++)n[e]=this.srcAlphabet.indexOf(t[e]);do{for(r=0,i=0,e=0;e<s;e++)(r=r*a+n[e])>=o?(n[i++]=parseInt(r/o,10),r%=o):i>0&&(n[i++]=0);s=i,h=this.dstAlphabet.slice(r,r+1).concat(h)}while(0!==i);return h},e.prototype.isValid=function(t){for(var e=0;e<t.length;++e)if(-1===this.srcAlphabet.indexOf(t[e]))return!1;return!0},t.exports=e},5766:(t,e)=>{\"use strict\";e.byteLength=function(t){var e=h(t),r=e[0],i=e[1];return 3*(r+i)/4-i},e.toByteArray=function(t){var e,r,a=h(t),o=a[0],s=a[1],l=new n(function(t,e,r){return 3*(e+r)/4-r}(0,o,s)),f=0,u=s>0?o-4:o;for(r=0;r<u;r+=4)e=i[t.charCodeAt(r)]<<18|i[t.charCodeAt(r+1)]<<12|i[t.charCodeAt(r+2)]<<6|i[t.charCodeAt(r+3)],l[f++]=e>>16&255,l[f++]=e>>8&255,l[f++]=255&e;return 2===s&&(e=i[t.charCodeAt(r)]<<2|i[t.charCodeAt(r+1)]>>4,l[f++]=255&e),1===s&&(e=i[t.charCodeAt(r)]<<10|i[t.charCodeAt(r+1)]<<4|i[t.charCodeAt(r+2)]>>2,l[f++]=e>>8&255,l[f++]=255&e),l},e.fromByteArray=function(t){for(var e,i=t.length,n=i%3,a=[],o=16383,s=0,h=i-n;s<h;s+=o)a.push(l(t,s,s+o>h?h:s+o));return 1===n?(e=t[i-1],a.push(r[e>>2]+r[e<<4&63]+\"==\")):2===n&&(e=(t[i-2]<<8)+t[i-1],a.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+\"=\")),a.join(\"\")};for(var r=[],i=[],n=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,a=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",o=0,s=a.length;o<s;++o)r[o]=a[o],i[a.charCodeAt(o)]=o;function h(t){var e=t.length;if(e%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");var r=t.indexOf(\"=\");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function l(t,e,i){for(var n,a,o=[],s=e;s<i;s+=3)n=(t[s]<<16&16711680)+(t[s+1]<<8&65280)+(255&t[s+2]),o.push(r[(a=n)>>18&63]+r[a>>12&63]+r[a>>6&63]+r[63&a]);return o.join(\"\")}i[\"-\".charCodeAt(0)]=62,i[\"_\".charCodeAt(0)]=63},486:(t,e,r)=>{var i=r(5433),n=r(1651);t.exports={encode:i,decode:n}},1651:(t,e,r)=>{var i=r(8834).lW;function n(t,e){if(this.pos=0,this.buffer=t,this.is_with_alpha=!!e,this.bottom_up=!0,this.flag=this.buffer.toString(\"utf-8\",0,this.pos+=2),\"BM\"!=this.flag)throw new Error(\"Invalid BMP File\");this.parseHeader(),this.parseRGBA()}n.prototype.parseHeader=function(){if(this.fileSize=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.reserved=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.offset=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.headerSize=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.width=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.height=this.buffer.readInt32LE(this.pos),this.pos+=4,this.planes=this.buffer.readUInt16LE(this.pos),this.pos+=2,this.bitPP=this.buffer.readUInt16LE(this.pos),this.pos+=2,this.compress=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.rawSize=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.hr=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.vr=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.colors=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.importantColors=this.buffer.readUInt32LE(this.pos),this.pos+=4,16===this.bitPP&&this.is_with_alpha&&(this.bitPP=15),this.bitPP<15){var t=0===this.colors?1<<this.bitPP:this.colors;this.palette=new Array(t);for(var e=0;e<t;e++){var r=this.buffer.readUInt8(this.pos++),i=this.buffer.readUInt8(this.pos++),n=this.buffer.readUInt8(this.pos++),a=this.buffer.readUInt8(this.pos++);this.palette[e]={red:n,green:i,blue:r,quad:a}}}this.height<0&&(this.height*=-1,this.bottom_up=!1)},n.prototype.parseRGBA=function(){var t=\"bit\"+this.bitPP,e=this.width*this.height*4;this.data=new i(e),this[t]()},n.prototype.bit1=function(){var t=Math.ceil(this.width/8),e=t%4,r=this.height>=0?this.height-1:-this.height;for(r=this.height-1;r>=0;r--){for(var i=this.bottom_up?r:this.height-1-r,n=0;n<t;n++)for(var a=this.buffer.readUInt8(this.pos++),o=i*this.width*4+8*n*4,s=0;s<8&&8*n+s<this.width;s++){var h=this.palette[a>>7-s&1];this.data[o+4*s]=0,this.data[o+4*s+1]=h.blue,this.data[o+4*s+2]=h.green,this.data[o+4*s+3]=h.red}0!=e&&(this.pos+=4-e)}},n.prototype.bit4=function(){if(2==this.compress){this.data.fill(255);for(var t=0,e=this.bottom_up?this.height-1:0,r=!1;t<this.data.length;){var i=this.buffer.readUInt8(this.pos++),n=this.buffer.readUInt8(this.pos++);if(0==i){if(0==n){this.bottom_up?e--:e++,t=e*this.width*4,r=!1;continue}if(1==n)break;if(2==n){var a=this.buffer.readUInt8(this.pos++),o=this.buffer.readUInt8(this.pos++);this.bottom_up?e-=o:e+=o,t+=o*this.width*4+4*a}else{for(var s=this.buffer.readUInt8(this.pos++),h=0;h<n;h++)r?l.call(this,15&s):l.call(this,(240&s)>>4),1&h&&h+1<n&&(s=this.buffer.readUInt8(this.pos++)),r=!r;1==(n+1>>1&1)&&this.pos++}}else for(h=0;h<i;h++)r?l.call(this,15&n):l.call(this,(240&n)>>4),r=!r}function l(e){var r=this.palette[e];this.data[t]=0,this.data[t+1]=r.blue,this.data[t+2]=r.green,this.data[t+3]=r.red,t+=4}}else{var f=Math.ceil(this.width/2),u=f%4;for(o=this.height-1;o>=0;o--){var c=this.bottom_up?o:this.height-1-o;for(a=0;a<f;a++){n=this.buffer.readUInt8(this.pos++),t=c*this.width*4+2*a*4;var d=n>>4,p=15&n,m=this.palette[d];if(this.data[t]=0,this.data[t+1]=m.blue,this.data[t+2]=m.green,this.data[t+3]=m.red,2*a+1>=this.width)break;m=this.palette[p],this.data[t+4]=0,this.data[t+4+1]=m.blue,this.data[t+4+2]=m.green,this.data[t+4+3]=m.red}0!=u&&(this.pos+=4-u)}}},n.prototype.bit8=function(){if(1==this.compress){this.data.fill(255);for(var t=0,e=this.bottom_up?this.height-1:0;t<this.data.length;){var r=this.buffer.readUInt8(this.pos++),i=this.buffer.readUInt8(this.pos++);if(0==r){if(0==i){this.bottom_up?e--:e++,t=e*this.width*4;continue}if(1==i)break;if(2==i){var n=this.buffer.readUInt8(this.pos++),a=this.buffer.readUInt8(this.pos++);this.bottom_up?e-=a:e+=a,t+=a*this.width*4+4*n}else{for(var o=0;o<i;o++){var s=this.buffer.readUInt8(this.pos++);h.call(this,s)}!0&i&&this.pos++}}else for(o=0;o<r;o++)h.call(this,i)}function h(e){var r=this.palette[e];this.data[t]=0,this.data[t+1]=r.blue,this.data[t+2]=r.green,this.data[t+3]=r.red,t+=4}}else{var l=this.width%4;for(a=this.height-1;a>=0;a--){var f=this.bottom_up?a:this.height-1-a;for(n=0;n<this.width;n++)if(i=this.buffer.readUInt8(this.pos++),t=f*this.width*4+4*n,i<this.palette.length){var u=this.palette[i];this.data[t]=0,this.data[t+1]=u.blue,this.data[t+2]=u.green,this.data[t+3]=u.red}else this.data[t]=0,this.data[t+1]=255,this.data[t+2]=255,this.data[t+3]=255;0!=l&&(this.pos+=4-l)}}},n.prototype.bit15=function(){for(var t=this.width%3,e=parseInt(\"11111\",2),r=this.height-1;r>=0;r--){for(var i=this.bottom_up?r:this.height-1-r,n=0;n<this.width;n++){var a=this.buffer.readUInt16LE(this.pos);this.pos+=2;var o=(a&e)/e*255|0,s=(a>>5&e)/e*255|0,h=(a>>10&e)/e*255|0,l=a>>15?255:0,f=i*this.width*4+4*n;this.data[f]=l,this.data[f+1]=o,this.data[f+2]=s,this.data[f+3]=h}this.pos+=t}},n.prototype.bit16=function(){var t=this.width%2*2;this.maskRed=31744,this.maskGreen=992,this.maskBlue=31,this.mask0=0,3==this.compress&&(this.maskRed=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.maskGreen=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.maskBlue=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.mask0=this.buffer.readUInt32LE(this.pos),this.pos+=4);for(var e=[0,0,0],r=0;r<16;r++)this.maskRed>>r&1&&e[0]++,this.maskGreen>>r&1&&e[1]++,this.maskBlue>>r&1&&e[2]++;e[1]+=e[0],e[2]+=e[1],e[0]=8-e[0],e[1]-=8,e[2]-=8;for(var i=this.height-1;i>=0;i--){for(var n=this.bottom_up?i:this.height-1-i,a=0;a<this.width;a++){var o=this.buffer.readUInt16LE(this.pos);this.pos+=2;var s=(o&this.maskBlue)<<e[0],h=(o&this.maskGreen)>>e[1],l=(o&this.maskRed)>>e[2],f=n*this.width*4+4*a;this.data[f]=0,this.data[f+1]=s,this.data[f+2]=h,this.data[f+3]=l}this.pos+=t}},n.prototype.bit24=function(){for(var t=this.height-1;t>=0;t--){for(var e=this.bottom_up?t:this.height-1-t,r=0;r<this.width;r++){var i=this.buffer.readUInt8(this.pos++),n=this.buffer.readUInt8(this.pos++),a=this.buffer.readUInt8(this.pos++),o=e*this.width*4+4*r;this.data[o]=0,this.data[o+1]=i,this.data[o+2]=n,this.data[o+3]=a}this.pos+=this.width%4}},n.prototype.bit32=function(){if(3==this.compress){this.maskRed=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.maskGreen=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.maskBlue=this.buffer.readUInt32LE(this.pos),this.pos+=4,this.mask0=this.buffer.readUInt32LE(this.pos),this.pos+=4;for(var t=this.height-1;t>=0;t--)for(var e=this.bottom_up?t:this.height-1-t,r=0;r<this.width;r++){var i=this.buffer.readUInt8(this.pos++),n=this.buffer.readUInt8(this.pos++),a=this.buffer.readUInt8(this.pos++),o=this.buffer.readUInt8(this.pos++),s=e*this.width*4+4*r;this.data[s]=i,this.data[s+1]=n,this.data[s+2]=a,this.data[s+3]=o}}else for(t=this.height-1;t>=0;t--)for(e=this.bottom_up?t:this.height-1-t,r=0;r<this.width;r++)n=this.buffer.readUInt8(this.pos++),a=this.buffer.readUInt8(this.pos++),o=this.buffer.readUInt8(this.pos++),i=this.buffer.readUInt8(this.pos++),s=e*this.width*4+4*r,this.data[s]=i,this.data[s+1]=n,this.data[s+2]=a,this.data[s+3]=o},n.prototype.getData=function(){return this.data},t.exports=function(t){return new n(t)}},5433:(t,e,r)=>{var i=r(8834).lW;function n(t){this.buffer=t.data,this.width=t.width,this.height=t.height,this.extraBytes=this.width%4,this.rgbSize=this.height*(3*this.width+this.extraBytes),this.headerInfoSize=40,this.data=[],this.flag=\"BM\",this.reserved=0,this.offset=54,this.fileSize=this.rgbSize+this.offset,this.planes=1,this.bitPP=24,this.compress=0,this.hr=0,this.vr=0,this.colors=0,this.importantColors=0}n.prototype.encode=function(){var t=new i(this.offset+this.rgbSize);this.pos=0,t.write(this.flag,this.pos,2),this.pos+=2,t.writeUInt32LE(this.fileSize,this.pos),this.pos+=4,t.writeUInt32LE(this.reserved,this.pos),this.pos+=4,t.writeUInt32LE(this.offset,this.pos),this.pos+=4,t.writeUInt32LE(this.headerInfoSize,this.pos),this.pos+=4,t.writeUInt32LE(this.width,this.pos),this.pos+=4,t.writeInt32LE(-this.height,this.pos),this.pos+=4,t.writeUInt16LE(this.planes,this.pos),this.pos+=2,t.writeUInt16LE(this.bitPP,this.pos),this.pos+=2,t.writeUInt32LE(this.compress,this.pos),this.pos+=4,t.writeUInt32LE(this.rgbSize,this.pos),this.pos+=4,t.writeUInt32LE(this.hr,this.pos),this.pos+=4,t.writeUInt32LE(this.vr,this.pos),this.pos+=4,t.writeUInt32LE(this.colors,this.pos),this.pos+=4,t.writeUInt32LE(this.importantColors,this.pos),this.pos+=4;for(var e=0,r=3*this.width+this.extraBytes,n=0;n<this.height;n++){for(var a=0;a<this.width;a++){var o=this.pos+n*r+3*a;e++,t[o]=this.buffer[e++],t[o+1]=this.buffer[e++],t[o+2]=this.buffer[e++]}if(this.extraBytes>0){var s=this.pos+n*r+3*this.width;t.fill(0,s,s+this.extraBytes)}}return t},t.exports=function(t,e){return void 0===e&&(e=100),{data:new n(t).encode(),width:t.width,height:t.height}}},5137:(t,e,r)=>{var i=r(8834).lW;t.exports=function(t,e){if(i.isBuffer(t)&&i.isBuffer(e)){if(\"function\"==typeof t.equals)return t.equals(e);if(t.length!==e.length)return!1;for(var r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}}},8834:(t,e,r)=>{\"use strict\";var i=r(5766),n=r(4181);e.lW=s,e.h2=50;var a=2147483647;function o(t){if(t>a)throw new RangeError('The value \"'+t+'\" is invalid for option \"size\"');var e=new Uint8Array(t);return e.__proto__=s.prototype,e}function s(t,e,r){if(\"number\"==typeof t){if(\"string\"==typeof e)throw new TypeError('The \"string\" argument must be of type string. Received type number');return f(t)}return h(t,e,r)}function h(t,e,r){if(\"string\"==typeof t)return function(t,e){if(\"string\"==typeof e&&\"\"!==e||(e=\"utf8\"),!s.isEncoding(e))throw new TypeError(\"Unknown encoding: \"+e);var r=0|d(t,e),i=o(r),n=i.write(t,e);return n!==r&&(i=i.slice(0,n)),i}(t,e);if(ArrayBuffer.isView(t))return u(t);if(null==t)throw TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof t);if(F(t,ArrayBuffer)||t&&F(t.buffer,ArrayBuffer))return function(t,e,r){if(e<0||t.byteLength<e)throw new RangeError('\"offset\" is outside of buffer bounds');if(t.byteLength<e+(r||0))throw new RangeError('\"length\" is outside of buffer bounds');var i;return(i=void 0===e&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,e):new Uint8Array(t,e,r)).__proto__=s.prototype,i}(t,e,r);if(\"number\"==typeof t)throw new TypeError('The \"value\" argument must not be of type number. Received type number');var i=t.valueOf&&t.valueOf();if(null!=i&&i!==t)return s.from(i,e,r);var n=function(t){if(s.isBuffer(t)){var e=0|c(t.length),r=o(e);return 0===r.length||t.copy(r,0,0,e),r}return void 0!==t.length?\"number\"!=typeof t.length||j(t.length)?o(0):u(t):\"Buffer\"===t.type&&Array.isArray(t.data)?u(t.data):void 0}(t);if(n)return n;if(\"undefined\"!=typeof Symbol&&null!=Symbol.toPrimitive&&\"function\"==typeof t[Symbol.toPrimitive])return s.from(t[Symbol.toPrimitive](\"string\"),e,r);throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof t)}function l(t){if(\"number\"!=typeof t)throw new TypeError('\"size\" argument must be of type number');if(t<0)throw new RangeError('The value \"'+t+'\" is invalid for option \"size\"')}function f(t){return l(t),o(t<0?0:0|c(t))}function u(t){for(var e=t.length<0?0:0|c(t.length),r=o(e),i=0;i<e;i+=1)r[i]=255&t[i];return r}function c(t){if(t>=a)throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+a.toString(16)+\" bytes\");return 0|t}function d(t,e){if(s.isBuffer(t))return t.length;if(ArrayBuffer.isView(t)||F(t,ArrayBuffer))return t.byteLength;if(\"string\"!=typeof t)throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof t);var r=t.length,i=arguments.length>2&&!0===arguments[2];if(!i&&0===r)return 0;for(var n=!1;;)switch(e){case\"ascii\":case\"latin1\":case\"binary\":return r;case\"utf8\":case\"utf-8\":return z(t).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return 2*r;case\"hex\":return r>>>1;case\"base64\":return D(t).length;default:if(n)return i?-1:z(t).length;e=(\"\"+e).toLowerCase(),n=!0}}function p(t,e,r){var i=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return\"\";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return\"\";if((r>>>=0)<=(e>>>=0))return\"\";for(t||(t=\"utf8\");;)switch(t){case\"hex\":return B(this,e,r);case\"utf8\":case\"utf-8\":return S(this,e,r);case\"ascii\":return A(this,e,r);case\"latin1\":case\"binary\":return I(this,e,r);case\"base64\":return k(this,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return T(this,e,r);default:if(i)throw new TypeError(\"Unknown encoding: \"+t);t=(t+\"\").toLowerCase(),i=!0}}function m(t,e,r){var i=t[e];t[e]=t[r],t[r]=i}function g(t,e,r,i,n){if(0===t.length)return-1;if(\"string\"==typeof r?(i=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),j(r=+r)&&(r=n?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(n)return-1;r=t.length-1}else if(r<0){if(!n)return-1;r=0}if(\"string\"==typeof e&&(e=s.from(e,i)),s.isBuffer(e))return 0===e.length?-1:b(t,e,r,i,n);if(\"number\"==typeof e)return e&=255,\"function\"==typeof Uint8Array.prototype.indexOf?n?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):b(t,[e],r,i,n);throw new TypeError(\"val must be string, number or Buffer\")}function b(t,e,r,i,n){var a,o=1,s=t.length,h=e.length;if(void 0!==i&&(\"ucs2\"===(i=String(i).toLowerCase())||\"ucs-2\"===i||\"utf16le\"===i||\"utf-16le\"===i)){if(t.length<2||e.length<2)return-1;o=2,s/=2,h/=2,r/=2}function l(t,e){return 1===o?t[e]:t.readUInt16BE(e*o)}if(n){var f=-1;for(a=r;a<s;a++)if(l(t,a)===l(e,-1===f?0:a-f)){if(-1===f&&(f=a),a-f+1===h)return f*o}else-1!==f&&(a-=a-f),f=-1}else for(r+h>s&&(r=s-h),a=r;a>=0;a--){for(var u=!0,c=0;c<h;c++)if(l(t,a+c)!==l(e,c)){u=!1;break}if(u)return a}return-1}function _(t,e,r,i){r=Number(r)||0;var n=t.length-r;i?(i=Number(i))>n&&(i=n):i=n;var a=e.length;i>a/2&&(i=a/2);for(var o=0;o<i;++o){var s=parseInt(e.substr(2*o,2),16);if(j(s))return o;t[r+o]=s}return o}function y(t,e,r,i){return N(z(e,t.length-r),t,r,i)}function w(t,e,r,i){return N(function(t){for(var e=[],r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,i)}function v(t,e,r,i){return w(t,e,r,i)}function x(t,e,r,i){return N(D(e),t,r,i)}function E(t,e,r,i){return N(function(t,e){for(var r,i,n,a=[],o=0;o<t.length&&!((e-=2)<0);++o)i=(r=t.charCodeAt(o))>>8,n=r%256,a.push(n),a.push(i);return a}(e,t.length-r),t,r,i)}function k(t,e,r){return 0===e&&r===t.length?i.fromByteArray(t):i.fromByteArray(t.slice(e,r))}function S(t,e,r){r=Math.min(t.length,r);for(var i=[],n=e;n<r;){var a,o,s,h,l=t[n],f=null,u=l>239?4:l>223?3:l>191?2:1;if(n+u<=r)switch(u){case 1:l<128&&(f=l);break;case 2:128==(192&(a=t[n+1]))&&(h=(31&l)<<6|63&a)>127&&(f=h);break;case 3:a=t[n+1],o=t[n+2],128==(192&a)&&128==(192&o)&&(h=(15&l)<<12|(63&a)<<6|63&o)>2047&&(h<55296||h>57343)&&(f=h);break;case 4:a=t[n+1],o=t[n+2],s=t[n+3],128==(192&a)&&128==(192&o)&&128==(192&s)&&(h=(15&l)<<18|(63&a)<<12|(63&o)<<6|63&s)>65535&&h<1114112&&(f=h)}null===f?(f=65533,u=1):f>65535&&(f-=65536,i.push(f>>>10&1023|55296),f=56320|1023&f),i.push(f),n+=u}return function(t){var e=t.length;if(e<=M)return String.fromCharCode.apply(String,t);for(var r=\"\",i=0;i<e;)r+=String.fromCharCode.apply(String,t.slice(i,i+=M));return r}(i)}s.TYPED_ARRAY_SUPPORT=function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()}catch(t){return!1}}(),s.TYPED_ARRAY_SUPPORT||\"undefined\"==typeof console||\"function\"!=typeof console.error||console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"),Object.defineProperty(s.prototype,\"parent\",{enumerable:!0,get:function(){if(s.isBuffer(this))return this.buffer}}),Object.defineProperty(s.prototype,\"offset\",{enumerable:!0,get:function(){if(s.isBuffer(this))return this.byteOffset}}),\"undefined\"!=typeof Symbol&&null!=Symbol.species&&s[Symbol.species]===s&&Object.defineProperty(s,Symbol.species,{value:null,configurable:!0,enumerable:!1,writable:!1}),s.poolSize=8192,s.from=function(t,e,r){return h(t,e,r)},s.prototype.__proto__=Uint8Array.prototype,s.__proto__=Uint8Array,s.alloc=function(t,e,r){return function(t,e,r){return l(t),t<=0?o(t):void 0!==e?\"string\"==typeof r?o(t).fill(e,r):o(t).fill(e):o(t)}(t,e,r)},s.allocUnsafe=function(t){return f(t)},s.allocUnsafeSlow=function(t){return f(t)},s.isBuffer=function(t){return null!=t&&!0===t._isBuffer&&t!==s.prototype},s.compare=function(t,e){if(F(t,Uint8Array)&&(t=s.from(t,t.offset,t.byteLength)),F(e,Uint8Array)&&(e=s.from(e,e.offset,e.byteLength)),!s.isBuffer(t)||!s.isBuffer(e))throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');if(t===e)return 0;for(var r=t.length,i=e.length,n=0,a=Math.min(r,i);n<a;++n)if(t[n]!==e[n]){r=t[n],i=e[n];break}return r<i?-1:i<r?1:0},s.isEncoding=function(t){switch(String(t).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},s.concat=function(t,e){if(!Array.isArray(t))throw new TypeError('\"list\" argument must be an Array of Buffers');if(0===t.length)return s.alloc(0);var r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;var i=s.allocUnsafe(e),n=0;for(r=0;r<t.length;++r){var a=t[r];if(F(a,Uint8Array)&&(a=s.from(a)),!s.isBuffer(a))throw new TypeError('\"list\" argument must be an Array of Buffers');a.copy(i,n),n+=a.length}return i},s.byteLength=d,s.prototype._isBuffer=!0,s.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(var e=0;e<t;e+=2)m(this,e,e+1);return this},s.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(var e=0;e<t;e+=4)m(this,e,e+3),m(this,e+1,e+2);return this},s.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(var e=0;e<t;e+=8)m(this,e,e+7),m(this,e+1,e+6),m(this,e+2,e+5),m(this,e+3,e+4);return this},s.prototype.toString=function(){var t=this.length;return 0===t?\"\":0===arguments.length?S(this,0,t):p.apply(this,arguments)},s.prototype.toLocaleString=s.prototype.toString,s.prototype.equals=function(t){if(!s.isBuffer(t))throw new TypeError(\"Argument must be a Buffer\");return this===t||0===s.compare(this,t)},s.prototype.inspect=function(){var t=\"\",r=e.h2;return t=this.toString(\"hex\",0,r).replace(/(.{2})/g,\"$1 \").trim(),this.length>r&&(t+=\" ... \"),\"<Buffer \"+t+\">\"},s.prototype.compare=function(t,e,r,i,n){if(F(t,Uint8Array)&&(t=s.from(t,t.offset,t.byteLength)),!s.isBuffer(t))throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type '+typeof t);if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===i&&(i=0),void 0===n&&(n=this.length),e<0||r>t.length||i<0||n>this.length)throw new RangeError(\"out of range index\");if(i>=n&&e>=r)return 0;if(i>=n)return-1;if(e>=r)return 1;if(this===t)return 0;for(var a=(n>>>=0)-(i>>>=0),o=(r>>>=0)-(e>>>=0),h=Math.min(a,o),l=this.slice(i,n),f=t.slice(e,r),u=0;u<h;++u)if(l[u]!==f[u]){a=l[u],o=f[u];break}return a<o?-1:o<a?1:0},s.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},s.prototype.indexOf=function(t,e,r){return g(this,t,e,r,!0)},s.prototype.lastIndexOf=function(t,e,r){return g(this,t,e,r,!1)},s.prototype.write=function(t,e,r,i){if(void 0===e)i=\"utf8\",r=this.length,e=0;else if(void 0===r&&\"string\"==typeof e)i=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");e>>>=0,isFinite(r)?(r>>>=0,void 0===i&&(i=\"utf8\")):(i=r,r=void 0)}var n=this.length-e;if((void 0===r||r>n)&&(r=n),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");i||(i=\"utf8\");for(var a=!1;;)switch(i){case\"hex\":return _(this,t,e,r);case\"utf8\":case\"utf-8\":return y(this,t,e,r);case\"ascii\":return w(this,t,e,r);case\"latin1\":case\"binary\":return v(this,t,e,r);case\"base64\":return x(this,t,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return E(this,t,e,r);default:if(a)throw new TypeError(\"Unknown encoding: \"+i);i=(\"\"+i).toLowerCase(),a=!0}},s.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};var M=4096;function A(t,e,r){var i=\"\";r=Math.min(t.length,r);for(var n=e;n<r;++n)i+=String.fromCharCode(127&t[n]);return i}function I(t,e,r){var i=\"\";r=Math.min(t.length,r);for(var n=e;n<r;++n)i+=String.fromCharCode(t[n]);return i}function B(t,e,r){var i,n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);for(var a=\"\",o=e;o<r;++o)a+=(i=t[o])<16?\"0\"+i.toString(16):i.toString(16);return a}function T(t,e,r){for(var i=t.slice(e,r),n=\"\",a=0;a<i.length;a+=2)n+=String.fromCharCode(i[a]+256*i[a+1]);return n}function R(t,e,r){if(t%1!=0||t<0)throw new RangeError(\"offset is not uint\");if(t+e>r)throw new RangeError(\"Trying to access beyond buffer length\")}function P(t,e,r,i,n,a){if(!s.isBuffer(t))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(e>n||e<a)throw new RangeError('\"value\" argument is out of bounds');if(r+i>t.length)throw new RangeError(\"Index out of range\")}function O(t,e,r,i,n,a){if(r+i>t.length)throw new RangeError(\"Index out of range\");if(r<0)throw new RangeError(\"Index out of range\")}function L(t,e,r,i,a){return e=+e,r>>>=0,a||O(t,0,r,4),n.write(t,e,r,i,23,4),r+4}function C(t,e,r,i,a){return e=+e,r>>>=0,a||O(t,0,r,8),n.write(t,e,r,i,52,8),r+8}s.prototype.slice=function(t,e){var r=this.length;(t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=void 0===e?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t);var i=this.subarray(t,e);return i.__proto__=s.prototype,i},s.prototype.readUIntLE=function(t,e,r){t>>>=0,e>>>=0,r||R(t,e,this.length);for(var i=this[t],n=1,a=0;++a<e&&(n*=256);)i+=this[t+a]*n;return i},s.prototype.readUIntBE=function(t,e,r){t>>>=0,e>>>=0,r||R(t,e,this.length);for(var i=this[t+--e],n=1;e>0&&(n*=256);)i+=this[t+--e]*n;return i},s.prototype.readUInt8=function(t,e){return t>>>=0,e||R(t,1,this.length),this[t]},s.prototype.readUInt16LE=function(t,e){return t>>>=0,e||R(t,2,this.length),this[t]|this[t+1]<<8},s.prototype.readUInt16BE=function(t,e){return t>>>=0,e||R(t,2,this.length),this[t]<<8|this[t+1]},s.prototype.readUInt32LE=function(t,e){return t>>>=0,e||R(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},s.prototype.readUInt32BE=function(t,e){return t>>>=0,e||R(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},s.prototype.readIntLE=function(t,e,r){t>>>=0,e>>>=0,r||R(t,e,this.length);for(var i=this[t],n=1,a=0;++a<e&&(n*=256);)i+=this[t+a]*n;return i>=(n*=128)&&(i-=Math.pow(2,8*e)),i},s.prototype.readIntBE=function(t,e,r){t>>>=0,e>>>=0,r||R(t,e,this.length);for(var i=e,n=1,a=this[t+--i];i>0&&(n*=256);)a+=this[t+--i]*n;return a>=(n*=128)&&(a-=Math.pow(2,8*e)),a},s.prototype.readInt8=function(t,e){return t>>>=0,e||R(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},s.prototype.readInt16LE=function(t,e){t>>>=0,e||R(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},s.prototype.readInt16BE=function(t,e){t>>>=0,e||R(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},s.prototype.readInt32LE=function(t,e){return t>>>=0,e||R(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},s.prototype.readInt32BE=function(t,e){return t>>>=0,e||R(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},s.prototype.readFloatLE=function(t,e){return t>>>=0,e||R(t,4,this.length),n.read(this,t,!0,23,4)},s.prototype.readFloatBE=function(t,e){return t>>>=0,e||R(t,4,this.length),n.read(this,t,!1,23,4)},s.prototype.readDoubleLE=function(t,e){return t>>>=0,e||R(t,8,this.length),n.read(this,t,!0,52,8)},s.prototype.readDoubleBE=function(t,e){return t>>>=0,e||R(t,8,this.length),n.read(this,t,!1,52,8)},s.prototype.writeUIntLE=function(t,e,r,i){t=+t,e>>>=0,r>>>=0,i||P(this,t,e,r,Math.pow(2,8*r)-1,0);var n=1,a=0;for(this[e]=255&t;++a<r&&(n*=256);)this[e+a]=t/n&255;return e+r},s.prototype.writeUIntBE=function(t,e,r,i){t=+t,e>>>=0,r>>>=0,i||P(this,t,e,r,Math.pow(2,8*r)-1,0);var n=r-1,a=1;for(this[e+n]=255&t;--n>=0&&(a*=256);)this[e+n]=t/a&255;return e+r},s.prototype.writeUInt8=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,1,255,0),this[e]=255&t,e+1},s.prototype.writeUInt16LE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,2,65535,0),this[e]=255&t,this[e+1]=t>>>8,e+2},s.prototype.writeUInt16BE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=255&t,e+2},s.prototype.writeUInt32LE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t,e+4},s.prototype.writeUInt32BE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},s.prototype.writeIntLE=function(t,e,r,i){if(t=+t,e>>>=0,!i){var n=Math.pow(2,8*r-1);P(this,t,e,r,n-1,-n)}var a=0,o=1,s=0;for(this[e]=255&t;++a<r&&(o*=256);)t<0&&0===s&&0!==this[e+a-1]&&(s=1),this[e+a]=(t/o>>0)-s&255;return e+r},s.prototype.writeIntBE=function(t,e,r,i){if(t=+t,e>>>=0,!i){var n=Math.pow(2,8*r-1);P(this,t,e,r,n-1,-n)}var a=r-1,o=1,s=0;for(this[e+a]=255&t;--a>=0&&(o*=256);)t<0&&0===s&&0!==this[e+a+1]&&(s=1),this[e+a]=(t/o>>0)-s&255;return e+r},s.prototype.writeInt8=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=255&t,e+1},s.prototype.writeInt16LE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,2,32767,-32768),this[e]=255&t,this[e+1]=t>>>8,e+2},s.prototype.writeInt16BE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=255&t,e+2},s.prototype.writeInt32LE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,4,2147483647,-2147483648),this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},s.prototype.writeInt32BE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},s.prototype.writeFloatLE=function(t,e,r){return L(this,t,e,!0,r)},s.prototype.writeFloatBE=function(t,e,r){return L(this,t,e,!1,r)},s.prototype.writeDoubleLE=function(t,e,r){return C(this,t,e,!0,r)},s.prototype.writeDoubleBE=function(t,e,r){return C(this,t,e,!1,r)},s.prototype.copy=function(t,e,r,i){if(!s.isBuffer(t))throw new TypeError(\"argument should be a Buffer\");if(r||(r=0),i||0===i||(i=this.length),e>=t.length&&(e=t.length),e||(e=0),i>0&&i<r&&(i=r),i===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError(\"targetStart out of bounds\");if(r<0||r>=this.length)throw new RangeError(\"Index out of range\");if(i<0)throw new RangeError(\"sourceEnd out of bounds\");i>this.length&&(i=this.length),t.length-e<i-r&&(i=t.length-e+r);var n=i-r;if(this===t&&\"function\"==typeof Uint8Array.prototype.copyWithin)this.copyWithin(e,r,i);else if(this===t&&r<e&&e<i)for(var a=n-1;a>=0;--a)t[a+e]=this[a+r];else Uint8Array.prototype.set.call(t,this.subarray(r,i),e);return n},s.prototype.fill=function(t,e,r,i){if(\"string\"==typeof t){if(\"string\"==typeof e?(i=e,e=0,r=this.length):\"string\"==typeof r&&(i=r,r=this.length),void 0!==i&&\"string\"!=typeof i)throw new TypeError(\"encoding must be a string\");if(\"string\"==typeof i&&!s.isEncoding(i))throw new TypeError(\"Unknown encoding: \"+i);if(1===t.length){var n=t.charCodeAt(0);(\"utf8\"===i&&n<128||\"latin1\"===i)&&(t=n)}}else\"number\"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<r)throw new RangeError(\"Out of range index\");if(r<=e)return this;var a;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),\"number\"==typeof t)for(a=e;a<r;++a)this[a]=t;else{var o=s.isBuffer(t)?t:s.from(t,i),h=o.length;if(0===h)throw new TypeError('The value \"'+t+'\" is invalid for argument \"value\"');for(a=0;a<r-e;++a)this[a+e]=o[a%h]}return this};var U=/[^+/0-9A-Za-z-_]/g;function z(t,e){var r;e=e||1/0;for(var i=t.length,n=null,a=[],o=0;o<i;++o){if((r=t.charCodeAt(o))>55295&&r<57344){if(!n){if(r>56319){(e-=3)>-1&&a.push(239,191,189);continue}if(o+1===i){(e-=3)>-1&&a.push(239,191,189);continue}n=r;continue}if(r<56320){(e-=3)>-1&&a.push(239,191,189),n=r;continue}r=65536+(n-55296<<10|r-56320)}else n&&(e-=3)>-1&&a.push(239,191,189);if(n=null,r<128){if((e-=1)<0)break;a.push(r)}else if(r<2048){if((e-=2)<0)break;a.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;a.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error(\"Invalid code point\");if((e-=4)<0)break;a.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return a}function D(t){return i.toByteArray(function(t){if((t=(t=t.split(\"=\")[0]).trim().replace(U,\"\")).length<2)return\"\";for(;t.length%4!=0;)t+=\"=\";return t}(t))}function N(t,e,r,i){for(var n=0;n<i&&!(n+r>=e.length||n>=t.length);++n)e[n+r]=t[n];return n}function F(t,e){return t instanceof e||null!=t&&null!=t.constructor&&null!=t.constructor.name&&t.constructor.name===e.name}function j(t){return t!=t}},4181:(t,e)=>{e.read=function(t,e,r,i,n){var a,o,s=8*n-i-1,h=(1<<s)-1,l=h>>1,f=-7,u=r?n-1:0,c=r?-1:1,d=t[e+u];for(u+=c,a=d&(1<<-f)-1,d>>=-f,f+=s;f>0;a=256*a+t[e+u],u+=c,f-=8);for(o=a&(1<<-f)-1,a>>=-f,f+=i;f>0;o=256*o+t[e+u],u+=c,f-=8);if(0===a)a=1-l;else{if(a===h)return o?NaN:1/0*(d?-1:1);o+=Math.pow(2,i),a-=l}return(d?-1:1)*o*Math.pow(2,a-i)},e.write=function(t,e,r,i,n,a){var o,s,h,l=8*a-n-1,f=(1<<l)-1,u=f>>1,c=23===n?Math.pow(2,-24)-Math.pow(2,-77):0,d=i?0:a-1,p=i?1:-1,m=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,o=f):(o=Math.floor(Math.log(e)/Math.LN2),e*(h=Math.pow(2,-o))<1&&(o--,h*=2),(e+=o+u>=1?c/h:c*Math.pow(2,1-u))*h>=2&&(o++,h/=2),o+u>=f?(s=0,o=f):o+u>=1?(s=(e*h-1)*Math.pow(2,n),o+=u):(s=e*Math.pow(2,u-1)*Math.pow(2,n),o=0));n>=8;t[r+d]=255&s,d+=p,s/=256,n-=8);for(o=o<<n|s,l+=n;l>0;t[r+d]=255&o,d+=p,o/=256,l-=8);t[r+d-p]|=128*m}},2699:t=>{\"use strict\";var e,r=\"object\"==typeof Reflect?Reflect:null,i=r&&\"function\"==typeof r.apply?r.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};e=r&&\"function\"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var n=Number.isNaN||function(t){return t!=t};function a(){a.init.call(this)}t.exports=a,t.exports.once=function(t,e){return new Promise((function(r,i){function n(r){t.removeListener(e,a),i(r)}function a(){\"function\"==typeof t.removeListener&&t.removeListener(\"error\",n),r([].slice.call(arguments))}m(t,e,a,{once:!0}),\"error\"!==e&&function(t,e,r){\"function\"==typeof t.on&&m(t,\"error\",e,{once:!0})}(t,n)}))},a.EventEmitter=a,a.prototype._events=void 0,a.prototype._eventsCount=0,a.prototype._maxListeners=void 0;var o=10;function s(t){if(\"function\"!=typeof t)throw new TypeError('The \"listener\" argument must be of type Function. Received type '+typeof t)}function h(t){return void 0===t._maxListeners?a.defaultMaxListeners:t._maxListeners}function l(t,e,r,i){var n,a,o,l;if(s(r),void 0===(a=t._events)?(a=t._events=Object.create(null),t._eventsCount=0):(void 0!==a.newListener&&(t.emit(\"newListener\",e,r.listener?r.listener:r),a=t._events),o=a[e]),void 0===o)o=a[e]=r,++t._eventsCount;else if(\"function\"==typeof o?o=a[e]=i?[r,o]:[o,r]:i?o.unshift(r):o.push(r),(n=h(t))>0&&o.length>n&&!o.warned){o.warned=!0;var f=new Error(\"Possible EventEmitter memory leak detected. \"+o.length+\" \"+String(e)+\" listeners added. Use emitter.setMaxListeners() to increase limit\");f.name=\"MaxListenersExceededWarning\",f.emitter=t,f.type=e,f.count=o.length,l=f,console&&console.warn&&console.warn(l)}return t}function f(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function u(t,e,r){var i={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},n=f.bind(i);return n.listener=r,i.wrapFn=n,n}function c(t,e,r){var i=t._events;if(void 0===i)return[];var n=i[e];return void 0===n?[]:\"function\"==typeof n?r?[n.listener||n]:[n]:r?function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(n):p(n,n.length)}function d(t){var e=this._events;if(void 0!==e){var r=e[t];if(\"function\"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function p(t,e){for(var r=new Array(e),i=0;i<e;++i)r[i]=t[i];return r}function m(t,e,r,i){if(\"function\"==typeof t.on)i.once?t.once(e,r):t.on(e,r);else{if(\"function\"!=typeof t.addEventListener)throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type '+typeof t);t.addEventListener(e,(function n(a){i.once&&t.removeEventListener(e,n),r(a)}))}}Object.defineProperty(a,\"defaultMaxListeners\",{enumerable:!0,get:function(){return o},set:function(t){if(\"number\"!=typeof t||t<0||n(t))throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received '+t+\".\");o=t}}),a.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},a.prototype.setMaxListeners=function(t){if(\"number\"!=typeof t||t<0||n(t))throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received '+t+\".\");return this._maxListeners=t,this},a.prototype.getMaxListeners=function(){return h(this)},a.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var n=\"error\"===t,a=this._events;if(void 0!==a)n=n&&void 0===a.error;else if(!n)return!1;if(n){var o;if(e.length>0&&(o=e[0]),o instanceof Error)throw o;var s=new Error(\"Unhandled error.\"+(o?\" (\"+o.message+\")\":\"\"));throw s.context=o,s}var h=a[t];if(void 0===h)return!1;if(\"function\"==typeof h)i(h,this,e);else{var l=h.length,f=p(h,l);for(r=0;r<l;++r)i(f[r],this,e)}return!0},a.prototype.addListener=function(t,e){return l(this,t,e,!1)},a.prototype.on=a.prototype.addListener,a.prototype.prependListener=function(t,e){return l(this,t,e,!0)},a.prototype.once=function(t,e){return s(e),this.on(t,u(this,t,e)),this},a.prototype.prependOnceListener=function(t,e){return s(e),this.prependListener(t,u(this,t,e)),this},a.prototype.removeListener=function(t,e){var r,i,n,a,o;if(s(e),void 0===(i=this._events))return this;if(void 0===(r=i[t]))return this;if(r===e||r.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete i[t],i.removeListener&&this.emit(\"removeListener\",t,r.listener||e));else if(\"function\"!=typeof r){for(n=-1,a=r.length-1;a>=0;a--)if(r[a]===e||r[a].listener===e){o=r[a].listener,n=a;break}if(n<0)return this;0===n?r.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(r,n),1===r.length&&(i[t]=r[0]),void 0!==i.removeListener&&this.emit(\"removeListener\",t,o||e)}return this},a.prototype.off=a.prototype.removeListener,a.prototype.removeAllListeners=function(t){var e,r,i;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[t]),this;if(0===arguments.length){var n,a=Object.keys(r);for(i=0;i<a.length;++i)\"removeListener\"!==(n=a[i])&&this.removeAllListeners(n);return this.removeAllListeners(\"removeListener\"),this._events=Object.create(null),this._eventsCount=0,this}if(\"function\"==typeof(e=r[t]))this.removeListener(t,e);else if(void 0!==e)for(i=e.length-1;i>=0;i--)this.removeListener(t,e[i]);return this},a.prototype.listeners=function(t){return c(this,t,!0)},a.prototype.rawListeners=function(t){return c(this,t,!1)},a.listenerCount=function(t,e){return\"function\"==typeof t.listenerCount?t.listenerCount(e):d.call(t,e)},a.prototype.listenerCount=d,a.prototype.eventNames=function(){return this._eventsCount>0?e(this._events):[]}},6551:(t,e,r)=>{var i=r(453);t.exports={create:function(t,e){if(t instanceof(e=e||(0,eval)(\"this\")).ArrayBuffer){var n=r(909);return new i(new n(t,0,t.byteLength,!0,e))}var a=r(3684);return new i(new a(t,0,t.length,!0))}}},3684:t=>{function e(t,e,r,i){this.buffer=t,this.offset=e||0,r=\"number\"==typeof r?r:t.length,this.endPosition=this.offset+r,this.setBigEndian(i)}e.prototype={setBigEndian:function(t){this.bigEndian=!!t},nextUInt8:function(){var t=this.buffer.readUInt8(this.offset);return this.offset+=1,t},nextInt8:function(){var t=this.buffer.readInt8(this.offset);return this.offset+=1,t},nextUInt16:function(){var t=this.bigEndian?this.buffer.readUInt16BE(this.offset):this.buffer.readUInt16LE(this.offset);return this.offset+=2,t},nextUInt32:function(){var t=this.bigEndian?this.buffer.readUInt32BE(this.offset):this.buffer.readUInt32LE(this.offset);return this.offset+=4,t},nextInt16:function(){var t=this.bigEndian?this.buffer.readInt16BE(this.offset):this.buffer.readInt16LE(this.offset);return this.offset+=2,t},nextInt32:function(){var t=this.bigEndian?this.buffer.readInt32BE(this.offset):this.buffer.readInt32LE(this.offset);return this.offset+=4,t},nextFloat:function(){var t=this.bigEndian?this.buffer.readFloatBE(this.offset):this.buffer.readFloatLE(this.offset);return this.offset+=4,t},nextDouble:function(){var t=this.bigEndian?this.buffer.readDoubleBE(this.offset):this.buffer.readDoubleLE(this.offset);return this.offset+=8,t},nextBuffer:function(t){var e=this.buffer.slice(this.offset,this.offset+t);return this.offset+=t,e},remainingLength:function(){return this.endPosition-this.offset},nextString:function(t){var e=this.buffer.toString(\"utf8\",this.offset,this.offset+t);return this.offset+=t,e},mark:function(){var t=this;return{openWithOffset:function(r){return r=(r||0)+this.offset,new e(t.buffer,r,t.endPosition-r,t.bigEndian)},offset:this.offset}},offsetFrom:function(t){return this.offset-t.offset},skip:function(t){this.offset+=t},branch:function(t,r){return r=\"number\"==typeof r?r:this.endPosition-(this.offset+t),new e(this.buffer,this.offset+t,r,this.bigEndian)}},t.exports=e},565:t=>{function e(t){return parseInt(t,10)}var r=3600,i=60;function n(t,r){t=t.map(e),r=r.map(e);var i=t[0],n=t[1]-1,a=t[2],o=r[0],s=r[1],h=r[2];return Date.UTC(i,n,a,o,s,h,0)/1e3}function a(t){var a=t.substr(0,10).split(\"-\"),o=t.substr(11,8).split(\":\"),s=t.substr(19,6).split(\":\").map(e),h=s[0]*r+s[1]*i,l=n(a,o);if(\"number\"==typeof(l-=h)&&!isNaN(l))return l}function o(t){var e=t.split(\" \"),r=n(e[0].split(\":\"),e[1].split(\":\"));if(\"number\"==typeof r&&!isNaN(r))return r}t.exports={parseDateWithSpecFormat:o,parseDateWithTimezoneFormat:a,parseExifDate:function(t){var e=19===t.length&&\":\"===t.charAt(4);return 25===t.length&&\"T\"===t.charAt(10)?a(t):e?o(t):void 0}}},909:t=>{function e(t,e,r,i,n,a){this.global=n,e=e||0,r=r||t.byteLength-e,this.arrayBuffer=t.slice(e,e+r),this.view=new n.DataView(this.arrayBuffer,0,this.arrayBuffer.byteLength),this.setBigEndian(i),this.offset=0,this.parentOffset=(a||0)+e}e.prototype={setBigEndian:function(t){this.littleEndian=!t},nextUInt8:function(){var t=this.view.getUint8(this.offset);return this.offset+=1,t},nextInt8:function(){var t=this.view.getInt8(this.offset);return this.offset+=1,t},nextUInt16:function(){var t=this.view.getUint16(this.offset,this.littleEndian);return this.offset+=2,t},nextUInt32:function(){var t=this.view.getUint32(this.offset,this.littleEndian);return this.offset+=4,t},nextInt16:function(){var t=this.view.getInt16(this.offset,this.littleEndian);return this.offset+=2,t},nextInt32:function(){var t=this.view.getInt32(this.offset,this.littleEndian);return this.offset+=4,t},nextFloat:function(){var t=this.view.getFloat32(this.offset,this.littleEndian);return this.offset+=4,t},nextDouble:function(){var t=this.view.getFloat64(this.offset,this.littleEndian);return this.offset+=8,t},nextBuffer:function(t){var e=this.arrayBuffer.slice(this.offset,this.offset+t);return this.offset+=t,e},remainingLength:function(){return this.arrayBuffer.byteLength-this.offset},nextString:function(t){var e=this.arrayBuffer.slice(this.offset,this.offset+t);return e=String.fromCharCode.apply(null,new this.global.Uint8Array(e)),this.offset+=t,e},mark:function(){var t=this;return{openWithOffset:function(r){return r=(r||0)+this.offset,new e(t.arrayBuffer,r,t.arrayBuffer.byteLength-r,!t.littleEndian,t.global,t.parentOffset)},offset:this.offset,getParentOffset:function(){return t.parentOffset}}},offsetFrom:function(t){return this.parentOffset+this.offset-(t.offset+t.getParentOffset())},skip:function(t){this.offset+=t},branch:function(t,r){return r=\"number\"==typeof r?r:this.arrayBuffer.byteLength-(this.offset+t),new e(this.arrayBuffer,this.offset+t,r,!this.littleEndian,this.global,this.parentOffset)}},t.exports=e},3332:t=>{t.exports={exif:{1:\"InteropIndex\",2:\"InteropVersion\",11:\"ProcessingSoftware\",254:\"SubfileType\",255:\"OldSubfileType\",256:\"ImageWidth\",257:\"ImageHeight\",258:\"BitsPerSample\",259:\"Compression\",262:\"PhotometricInterpretation\",263:\"Thresholding\",264:\"CellWidth\",265:\"CellLength\",266:\"FillOrder\",269:\"DocumentName\",270:\"ImageDescription\",271:\"Make\",272:\"Model\",273:\"StripOffsets\",274:\"Orientation\",277:\"SamplesPerPixel\",278:\"RowsPerStrip\",279:\"StripByteCounts\",280:\"MinSampleValue\",281:\"MaxSampleValue\",282:\"XResolution\",283:\"YResolution\",284:\"PlanarConfiguration\",285:\"PageName\",286:\"XPosition\",287:\"YPosition\",288:\"FreeOffsets\",289:\"FreeByteCounts\",290:\"GrayResponseUnit\",291:\"GrayResponseCurve\",292:\"T4Options\",293:\"T6Options\",296:\"ResolutionUnit\",297:\"PageNumber\",300:\"ColorResponseUnit\",301:\"TransferFunction\",305:\"Software\",306:\"ModifyDate\",315:\"Artist\",316:\"HostComputer\",317:\"Predictor\",318:\"WhitePoint\",319:\"PrimaryChromaticities\",320:\"ColorMap\",321:\"HalftoneHints\",322:\"TileWidth\",323:\"TileLength\",324:\"TileOffsets\",325:\"TileByteCounts\",326:\"BadFaxLines\",327:\"CleanFaxData\",328:\"ConsecutiveBadFaxLines\",330:\"SubIFD\",332:\"InkSet\",333:\"InkNames\",334:\"NumberofInks\",336:\"DotRange\",337:\"TargetPrinter\",338:\"ExtraSamples\",339:\"SampleFormat\",340:\"SMinSampleValue\",341:\"SMaxSampleValue\",342:\"TransferRange\",343:\"ClipPath\",344:\"XClipPathUnits\",345:\"YClipPathUnits\",346:\"Indexed\",347:\"JPEGTables\",351:\"OPIProxy\",400:\"GlobalParametersIFD\",401:\"ProfileType\",402:\"FaxProfile\",403:\"CodingMethods\",404:\"VersionYear\",405:\"ModeNumber\",433:\"Decode\",434:\"DefaultImageColor\",435:\"T82Options\",437:\"JPEGTables\",512:\"JPEGProc\",513:\"ThumbnailOffset\",514:\"ThumbnailLength\",515:\"JPEGRestartInterval\",517:\"JPEGLosslessPredictors\",518:\"JPEGPointTransforms\",519:\"JPEGQTables\",520:\"JPEGDCTables\",521:\"JPEGACTables\",529:\"YCbCrCoefficients\",530:\"YCbCrSubSampling\",531:\"YCbCrPositioning\",532:\"ReferenceBlackWhite\",559:\"StripRowCounts\",700:\"ApplicationNotes\",999:\"USPTOMiscellaneous\",4096:\"RelatedImageFileFormat\",4097:\"RelatedImageWidth\",4098:\"RelatedImageHeight\",18246:\"Rating\",18247:\"XP_DIP_XML\",18248:\"StitchInfo\",18249:\"RatingPercent\",32781:\"ImageID\",32931:\"WangTag1\",32932:\"WangAnnotation\",32933:\"WangTag3\",32934:\"WangTag4\",32995:\"Matteing\",32996:\"DataType\",32997:\"ImageDepth\",32998:\"TileDepth\",33405:\"Model2\",33421:\"CFARepeatPatternDim\",33422:\"CFAPattern2\",33423:\"BatteryLevel\",33424:\"KodakIFD\",33432:\"Copyright\",33434:\"ExposureTime\",33437:\"FNumber\",33445:\"MDFileTag\",33446:\"MDScalePixel\",33447:\"MDColorTable\",33448:\"MDLabName\",33449:\"MDSampleInfo\",33450:\"MDPrepDate\",33451:\"MDPrepTime\",33452:\"MDFileUnits\",33550:\"PixelScale\",33589:\"AdventScale\",33590:\"AdventRevision\",33628:\"UIC1Tag\",33629:\"UIC2Tag\",33630:\"UIC3Tag\",33631:\"UIC4Tag\",33723:\"IPTC-NAA\",33918:\"IntergraphPacketData\",33919:\"IntergraphFlagRegisters\",33920:\"IntergraphMatrix\",33921:\"INGRReserved\",33922:\"ModelTiePoint\",34016:\"Site\",34017:\"ColorSequence\",34018:\"IT8Header\",34019:\"RasterPadding\",34020:\"BitsPerRunLength\",34021:\"BitsPerExtendedRunLength\",34022:\"ColorTable\",34023:\"ImageColorIndicator\",34024:\"BackgroundColorIndicator\",34025:\"ImageColorValue\",34026:\"BackgroundColorValue\",34027:\"PixelIntensityRange\",34028:\"TransparencyIndicator\",34029:\"ColorCharacterization\",34030:\"HCUsage\",34031:\"TrapIndicator\",34032:\"CMYKEquivalent\",34118:\"SEMInfo\",34152:\"AFCP_IPTC\",34232:\"PixelMagicJBIGOptions\",34264:\"ModelTransform\",34306:\"WB_GRGBLevels\",34310:\"LeafData\",34377:\"PhotoshopSettings\",34665:\"ExifOffset\",34675:\"ICC_Profile\",34687:\"TIFF_FXExtensions\",34688:\"MultiProfiles\",34689:\"SharedData\",34690:\"T88Options\",34732:\"ImageLayer\",34735:\"GeoTiffDirectory\",34736:\"GeoTiffDoubleParams\",34737:\"GeoTiffAsciiParams\",34850:\"ExposureProgram\",34852:\"SpectralSensitivity\",34853:\"GPSInfo\",34855:\"ISO\",34856:\"Opto-ElectricConvFactor\",34857:\"Interlace\",34858:\"TimeZoneOffset\",34859:\"SelfTimerMode\",34864:\"SensitivityType\",34865:\"StandardOutputSensitivity\",34866:\"RecommendedExposureIndex\",34867:\"ISOSpeed\",34868:\"ISOSpeedLatitudeyyy\",34869:\"ISOSpeedLatitudezzz\",34908:\"FaxRecvParams\",34909:\"FaxSubAddress\",34910:\"FaxRecvTime\",34954:\"LeafSubIFD\",36864:\"ExifVersion\",36867:\"DateTimeOriginal\",36868:\"CreateDate\",37121:\"ComponentsConfiguration\",37122:\"CompressedBitsPerPixel\",37377:\"ShutterSpeedValue\",37378:\"ApertureValue\",37379:\"BrightnessValue\",37380:\"ExposureCompensation\",37381:\"MaxApertureValue\",37382:\"SubjectDistance\",37383:\"MeteringMode\",37384:\"LightSource\",37385:\"Flash\",37386:\"FocalLength\",37387:\"FlashEnergy\",37388:\"SpatialFrequencyResponse\",37389:\"Noise\",37390:\"FocalPlaneXResolution\",37391:\"FocalPlaneYResolution\",37392:\"FocalPlaneResolutionUnit\",37393:\"ImageNumber\",37394:\"SecurityClassification\",37395:\"ImageHistory\",37396:\"SubjectArea\",37397:\"ExposureIndex\",37398:\"TIFF-EPStandardID\",37399:\"SensingMethod\",37434:\"CIP3DataFile\",37435:\"CIP3Sheet\",37436:\"CIP3Side\",37439:\"StoNits\",37500:\"MakerNote\",37510:\"UserComment\",37520:\"SubSecTime\",37521:\"SubSecTimeOriginal\",37522:\"SubSecTimeDigitized\",37679:\"MSDocumentText\",37680:\"MSPropertySetStorage\",37681:\"MSDocumentTextPosition\",37724:\"ImageSourceData\",40091:\"XPTitle\",40092:\"XPComment\",40093:\"XPAuthor\",40094:\"XPKeywords\",40095:\"XPSubject\",40960:\"FlashpixVersion\",40961:\"ColorSpace\",40962:\"ExifImageWidth\",40963:\"ExifImageHeight\",40964:\"RelatedSoundFile\",40965:\"InteropOffset\",41483:\"FlashEnergy\",41484:\"SpatialFrequencyResponse\",41485:\"Noise\",41486:\"FocalPlaneXResolution\",41487:\"FocalPlaneYResolution\",41488:\"FocalPlaneResolutionUnit\",41489:\"ImageNumber\",41490:\"SecurityClassification\",41491:\"ImageHistory\",41492:\"SubjectLocation\",41493:\"ExposureIndex\",41494:\"TIFF-EPStandardID\",41495:\"SensingMethod\",41728:\"FileSource\",41729:\"SceneType\",41730:\"CFAPattern\",41985:\"CustomRendered\",41986:\"ExposureMode\",41987:\"WhiteBalance\",41988:\"DigitalZoomRatio\",41989:\"FocalLengthIn35mmFormat\",41990:\"SceneCaptureType\",41991:\"GainControl\",41992:\"Contrast\",41993:\"Saturation\",41994:\"Sharpness\",41995:\"DeviceSettingDescription\",41996:\"SubjectDistanceRange\",42016:\"ImageUniqueID\",42032:\"OwnerName\",42033:\"SerialNumber\",42034:\"LensInfo\",42035:\"LensMake\",42036:\"LensModel\",42037:\"LensSerialNumber\",42112:\"GDALMetadata\",42113:\"GDALNoData\",42240:\"Gamma\",44992:\"ExpandSoftware\",44993:\"ExpandLens\",44994:\"ExpandFilm\",44995:\"ExpandFilterLens\",44996:\"ExpandScanner\",44997:\"ExpandFlashLamp\",48129:\"PixelFormat\",48130:\"Transformation\",48131:\"Uncompressed\",48132:\"ImageType\",48256:\"ImageWidth\",48257:\"ImageHeight\",48258:\"WidthResolution\",48259:\"HeightResolution\",48320:\"ImageOffset\",48321:\"ImageByteCount\",48322:\"AlphaOffset\",48323:\"AlphaByteCount\",48324:\"ImageDataDiscard\",48325:\"AlphaDataDiscard\",50215:\"OceScanjobDesc\",50216:\"OceApplicationSelector\",50217:\"OceIDNumber\",50218:\"OceImageLogic\",50255:\"Annotations\",50341:\"PrintIM\",50560:\"USPTOOriginalContentType\",50706:\"DNGVersion\",50707:\"DNGBackwardVersion\",50708:\"UniqueCameraModel\",50709:\"LocalizedCameraModel\",50710:\"CFAPlaneColor\",50711:\"CFALayout\",50712:\"LinearizationTable\",50713:\"BlackLevelRepeatDim\",50714:\"BlackLevel\",50715:\"BlackLevelDeltaH\",50716:\"BlackLevelDeltaV\",50717:\"WhiteLevel\",50718:\"DefaultScale\",50719:\"DefaultCropOrigin\",50720:\"DefaultCropSize\",50721:\"ColorMatrix1\",50722:\"ColorMatrix2\",50723:\"CameraCalibration1\",50724:\"CameraCalibration2\",50725:\"ReductionMatrix1\",50726:\"ReductionMatrix2\",50727:\"AnalogBalance\",50728:\"AsShotNeutral\",50729:\"AsShotWhiteXY\",50730:\"BaselineExposure\",50731:\"BaselineNoise\",50732:\"BaselineSharpness\",50733:\"BayerGreenSplit\",50734:\"LinearResponseLimit\",50735:\"CameraSerialNumber\",50736:\"DNGLensInfo\",50737:\"ChromaBlurRadius\",50738:\"AntiAliasStrength\",50739:\"ShadowScale\",50740:\"DNGPrivateData\",50741:\"MakerNoteSafety\",50752:\"RawImageSegmentation\",50778:\"CalibrationIlluminant1\",50779:\"CalibrationIlluminant2\",50780:\"BestQualityScale\",50781:\"RawDataUniqueID\",50784:\"AliasLayerMetadata\",50827:\"OriginalRawFileName\",50828:\"OriginalRawFileData\",50829:\"ActiveArea\",50830:\"MaskedAreas\",50831:\"AsShotICCProfile\",50832:\"AsShotPreProfileMatrix\",50833:\"CurrentICCProfile\",50834:\"CurrentPreProfileMatrix\",50879:\"ColorimetricReference\",50898:\"PanasonicTitle\",50899:\"PanasonicTitle2\",50931:\"CameraCalibrationSig\",50932:\"ProfileCalibrationSig\",50933:\"ProfileIFD\",50934:\"AsShotProfileName\",50935:\"NoiseReductionApplied\",50936:\"ProfileName\",50937:\"ProfileHueSatMapDims\",50938:\"ProfileHueSatMapData1\",50939:\"ProfileHueSatMapData2\",50940:\"ProfileToneCurve\",50941:\"ProfileEmbedPolicy\",50942:\"ProfileCopyright\",50964:\"ForwardMatrix1\",50965:\"ForwardMatrix2\",50966:\"PreviewApplicationName\",50967:\"PreviewApplicationVersion\",50968:\"PreviewSettingsName\",50969:\"PreviewSettingsDigest\",50970:\"PreviewColorSpace\",50971:\"PreviewDateTime\",50972:\"RawImageDigest\",50973:\"OriginalRawFileDigest\",50974:\"SubTileBlockSize\",50975:\"RowInterleaveFactor\",50981:\"ProfileLookTableDims\",50982:\"ProfileLookTableData\",51008:\"OpcodeList1\",51009:\"OpcodeList2\",51022:\"OpcodeList3\",51041:\"NoiseProfile\",51043:\"TimeCodes\",51044:\"FrameRate\",51058:\"TStop\",51081:\"ReelName\",51089:\"OriginalDefaultFinalSize\",51090:\"OriginalBestQualitySize\",51091:\"OriginalDefaultCropSize\",51105:\"CameraLabel\",51107:\"ProfileHueSatMapEncoding\",51108:\"ProfileLookTableEncoding\",51109:\"BaselineExposureOffset\",51110:\"DefaultBlackRender\",51111:\"NewRawImageDigest\",51112:\"RawToPreviewGain\",51125:\"DefaultUserCrop\",59932:\"Padding\",59933:\"OffsetSchema\",65e3:\"OwnerName\",65001:\"SerialNumber\",65002:\"Lens\",65024:\"KDC_IFD\",65100:\"RawFile\",65101:\"Converter\",65102:\"WhiteBalance\",65105:\"Exposure\",65106:\"Shadows\",65107:\"Brightness\",65108:\"Contrast\",65109:\"Saturation\",65110:\"Sharpness\",65111:\"Smoothness\",65112:\"MoireFilter\"},gps:{0:\"GPSVersionID\",1:\"GPSLatitudeRef\",2:\"GPSLatitude\",3:\"GPSLongitudeRef\",4:\"GPSLongitude\",5:\"GPSAltitudeRef\",6:\"GPSAltitude\",7:\"GPSTimeStamp\",8:\"GPSSatellites\",9:\"GPSStatus\",10:\"GPSMeasureMode\",11:\"GPSDOP\",12:\"GPSSpeedRef\",13:\"GPSSpeed\",14:\"GPSTrackRef\",15:\"GPSTrack\",16:\"GPSImgDirectionRef\",17:\"GPSImgDirection\",18:\"GPSMapDatum\",19:\"GPSDestLatitudeRef\",20:\"GPSDestLatitude\",21:\"GPSDestLongitudeRef\",22:\"GPSDestLongitude\",23:\"GPSDestBearingRef\",24:\"GPSDestBearing\",25:\"GPSDestDistanceRef\",26:\"GPSDestDistance\",27:\"GPSProcessingMethod\",28:\"GPSAreaInformation\",29:\"GPSDateStamp\",30:\"GPSDifferential\",31:\"GPSHPositioningError\"}}},592:t=>{function e(t,e){switch(t){case 1:return e.nextUInt8();case 3:case 8:return e.nextUInt16();case 4:case 9:return e.nextUInt32();case 5:return[e.nextUInt32(),e.nextUInt32()];case 6:return e.nextInt8();case 10:return[e.nextInt32(),e.nextInt32()];case 11:return e.nextFloat();case 12:return e.nextDouble();default:throw new Error(\"Invalid format while decoding: \"+t)}}function r(t,r){var i,n,a=r.nextUInt16(),o=r.nextUInt16(),s=function(t){switch(t){case 1:case 2:case 6:case 7:return 1;case 3:case 8:return 2;case 4:case 9:case 11:return 4;case 5:case 10:case 12:return 8;default:return 0}}(o),h=r.nextUInt32(),l=s*h;if(l>4&&(r=t.openWithOffset(r.nextUInt32())),2===o){var f=(i=r.nextString(h)).indexOf(\"\\0\");-1!==f&&(i=i.substr(0,f))}else if(7===o)i=r.nextBuffer(h);else if(0!==o)for(i=[],n=0;n<h;++n)i.push(e(o,r));return l<4&&r.skip(4-l),[a,i,o]}function i(t,e,i){var n,a,o=e.nextUInt16();for(a=0;a<o;++a)i((n=r(t,e))[0],n[1],n[2])}t.exports={IFD0:1,IFD1:2,GPSIFD:3,SubIFD:4,InteropIFD:5,parseTags:function(t,e){var r,n,a,o;try{r=function(t){if(\"Exif\\0\\0\"!==t.nextString(6))throw new Error(\"Invalid EXIF header\");var e=t.mark(),r=t.nextUInt16();if(18761===r)t.setBigEndian(!1);else{if(19789!==r)throw new Error(\"Invalid TIFF header\");t.setBigEndian(!0)}if(42!==t.nextUInt16())throw new Error(\"Invalid TIFF data\");return e}(t)}catch(t){return!1}var s=r.openWithOffset(t.nextUInt32()),h=this.IFD0;i(r,s,(function(t,r,i){switch(t){case 34853:a=r[0];break;case 34665:n=r[0];break;default:e(h,t,r,i)}}));var l=s.nextUInt32();if(0!==l){var f=r.openWithOffset(l);i(r,f,e.bind(null,this.IFD1))}if(a){var u=r.openWithOffset(a);i(r,u,e.bind(null,this.GPSIFD))}if(n){var c=r.openWithOffset(n),d=this.InteropIFD;i(r,c,(function(t,r,i){40965===t?o=r[0]:e(d,t,r,i)}))}if(o){var p=r.openWithOffset(o);i(r,p,e.bind(null,this.InteropIFD))}return!0}}},656:t=>{t.exports={parseSections:function(t,e){var r,i;for(t.setBigEndian(!0);t.remainingLength()>0&&218!==i;){if(255!==t.nextUInt8())throw new Error(\"Invalid JPEG section offset\");r=(i=t.nextUInt8())>=208&&i<=217||218===i?0:t.nextUInt16()-2,e(i,t.branch(0,r)),t.skip(r)}},getSizeFromSOFSection:function(t){return t.skip(1),{height:t.nextUInt16(),width:t.nextUInt16()}},getSectionName:function(t){var e,r;switch(t){case 216:e=\"SOI\";break;case 196:e=\"DHT\";break;case 219:e=\"DQT\";break;case 221:e=\"DRI\";break;case 218:e=\"SOS\";break;case 254:e=\"COM\";break;case 217:e=\"EOI\";break;default:t>=224&&t<=239?(e=\"APP\",r=t-224):t>=192&&t<=207&&196!==t&&200!==t&&204!==t?(e=\"SOF\",r=t-192):t>=208&&t<=215&&(e=\"RST\",r=t-208)}var i={name:e};return\"number\"==typeof r&&(i.index=r),i}}},453:(t,e,r)=>{var i=r(656),n=r(592),a=r(3814);function o(t,e,r,i,n,a,o){this.startMarker=t,this.tags=e,this.imageSize=r,this.thumbnailOffset=i,this.thumbnailLength=n,this.thumbnailType=a,this.app1Offset=o}function s(t){this.stream=t,this.flags={readBinaryTags:!1,resolveTagNames:!0,simplifyValues:!0,imageSize:!0,hidePointers:!0,returnTags:!0}}o.prototype={hasThumbnail:function(t){return!(!this.thumbnailOffset||!this.thumbnailLength||\"string\"==typeof t&&(\"image/jpeg\"===t.toLowerCase().trim()?6!==this.thumbnailType:\"image/tiff\"!==t.toLowerCase().trim()||1!==this.thumbnailType))},getThumbnailOffset:function(){return this.app1Offset+6+this.thumbnailOffset},getThumbnailLength:function(){return this.thumbnailLength},getThumbnailBuffer:function(){return this._getThumbnailStream().nextBuffer(this.thumbnailLength)},_getThumbnailStream:function(){return this.startMarker.openWithOffset(this.getThumbnailOffset())},getImageSize:function(){return this.imageSize},getThumbnailSize:function(){var t,e=this._getThumbnailStream();return i.parseSections(e,(function(e,r){\"SOF\"===i.getSectionName(e).name&&(t=i.getSizeFromSOFSection(r))})),t}},s.prototype={enableBinaryFields:function(t){return this.flags.readBinaryTags=!!t,this},enablePointers:function(t){return this.flags.hidePointers=!t,this},enableTagNames:function(t){return this.flags.resolveTagNames=!!t,this},enableImageSize:function(t){return this.flags.imageSize=!!t,this},enableReturnTags:function(t){return this.flags.returnTags=!!t,this},enableSimpleValues:function(t){return this.flags.simplifyValues=!!t,this},parse:function(){var t,e,s,h,l,f,u,c,d,p=this.stream.mark(),m=p.openWithOffset(0),g=this.flags;return g.resolveTagNames&&(u=r(3332)),g.resolveTagNames?(t={},c=function(e){return t[e.name]},d=function(e,r){t[e.name]=r}):(t=[],c=function(e){var r;for(r=0;r<t.length;++r)if(t[r].type===e.type&&t[r].section===e.section)return t.value},d=function(e,r){var i;for(i=0;i<t.length;++i)if(t[i].type===e.type&&t[i].section===e.section)return void(t.value=r)}),i.parseSections(m,(function(r,o){var c=o.offsetFrom(p);225===r?n.parseTags(o,(function(e,r,i,o){if(g.readBinaryTags||7!==o){if(513===r){if(s=i[0],g.hidePointers)return}else if(514===r){if(h=i[0],g.hidePointers)return}else if(259===r&&(l=i[0],g.hidePointers))return;if(g.returnTags)if(g.simplifyValues&&(i=a.simplifyValue(i,o)),g.resolveTagNames){var f=(e===n.GPSIFD?u.gps:u.exif)[r];f||(f=u.exif[r]),t.hasOwnProperty(f)||(t[f]=i)}else t.push({section:e,type:r,value:i})}}))&&(f=c):g.imageSize&&\"SOF\"===i.getSectionName(r).name&&(e=i.getSizeFromSOFSection(o))})),g.simplifyValues&&(a.castDegreeValues(c,d),a.castDateValues(c,d)),new o(p,t,e,s,h,l,f)}},t.exports=s},3814:(t,e,r)=>{var i=r(592),n=r(565),a=[{section:i.GPSIFD,type:2,name:\"GPSLatitude\",refType:1,refName:\"GPSLatitudeRef\",posVal:\"N\"},{section:i.GPSIFD,type:4,name:\"GPSLongitude\",refType:3,refName:\"GPSLongitudeRef\",posVal:\"E\"}],o=[{section:i.SubIFD,type:306,name:\"ModifyDate\"},{section:i.SubIFD,type:36867,name:\"DateTimeOriginal\"},{section:i.SubIFD,type:36868,name:\"CreateDate\"},{section:i.SubIFD,type:306,name:\"ModifyDate\"}];t.exports={castDegreeValues:function(t,e){a.forEach((function(r){var i=t(r);if(i){var n=t({section:r.section,type:r.refType,name:r.refName})===r.posVal?1:-1,a=(i[0]+i[1]/60+i[2]/3600)*n;e(r,a)}}))},castDateValues:function(t,e){o.forEach((function(r){var i=t(r);if(i){var a=n.parseExifDate(i);void 0!==a&&e(r,a)}}))},simplifyValue:function(t,e){return Array.isArray(t)&&1===(t=t.map((function(t){return 10===e||5===e?t[0]/t[1]:t}))).length&&(t=t[0]),t}}},8789:(module,__unused_webpack_exports,__nested_webpack_require_59601__)=>{\"use strict\";var Buffer=__nested_webpack_require_59601__(8834).lW;const Token=__nested_webpack_require_59601__(5010),strtok3=__nested_webpack_require_59601__(7378),{stringToBytes,tarHeaderChecksumMatches,uint32SyncSafeToken}=__nested_webpack_require_59601__(7044),supported=__nested_webpack_require_59601__(4078),minimumBytes=4100;async function fromStream(t){const e=await strtok3.fromStream(t);try{return await fromTokenizer(e)}finally{await e.close()}}async function fromBuffer(t){if(!(t instanceof Uint8Array||t instanceof ArrayBuffer||Buffer.isBuffer(t)))throw new TypeError(`Expected the \\`input\\` argument to be of type \\`Uint8Array\\` or \\`Buffer\\` or \\`ArrayBuffer\\`, got \\`${typeof t}\\``);const e=t instanceof Buffer?t:Buffer.from(t);if(e&&e.length>1)return fromTokenizer(strtok3.fromBuffer(e))}function _check(t,e,r){r={offset:0,...r};for(const[i,n]of e.entries())if(r.mask){if(n!==(r.mask[i]&t[i+r.offset]))return!1}else if(n!==t[i+r.offset])return!1;return!0}async function fromTokenizer(t){try{return _fromTokenizer(t)}catch(t){if(!(t instanceof strtok3.EndOfStreamError))throw t}}async function _fromTokenizer(t){let e=Buffer.alloc(minimumBytes);const r=(t,r)=>_check(e,t,r),i=(t,e)=>r(stringToBytes(t),e);if(t.fileInfo.size||(t.fileInfo.size=Number.MAX_SAFE_INTEGER),await t.peekBuffer(e,{length:12,mayBeLess:!0}),r([66,77]))return{ext:\"bmp\",mime:\"image/bmp\"};if(r([11,119]))return{ext:\"ac3\",mime:\"audio/vnd.dolby.dd-raw\"};if(r([120,1]))return{ext:\"dmg\",mime:\"application/x-apple-diskimage\"};if(r([77,90]))return{ext:\"exe\",mime:\"application/x-msdownload\"};if(r([37,33]))return await t.peekBuffer(e,{length:24,mayBeLess:!0}),i(\"PS-Adobe-\",{offset:2})&&i(\" EPSF-\",{offset:14})?{ext:\"eps\",mime:\"application/eps\"}:{ext:\"ps\",mime:\"application/postscript\"};if(r([31,160])||r([31,157]))return{ext:\"Z\",mime:\"application/x-compress\"};if(r([255,216,255]))return{ext:\"jpg\",mime:\"image/jpeg\"};if(r([73,73,188]))return{ext:\"jxr\",mime:\"image/vnd.ms-photo\"};if(r([31,139,8]))return{ext:\"gz\",mime:\"application/gzip\"};if(r([66,90,104]))return{ext:\"bz2\",mime:\"application/x-bzip2\"};if(i(\"ID3\")){await t.ignore(6);const n=await t.readToken(uint32SyncSafeToken);return t.position+n>t.fileInfo.size?{ext:\"mp3\",mime:\"audio/mpeg\"}:(await t.ignore(n),fromTokenizer(t))}if(i(\"MP+\"))return{ext:\"mpc\",mime:\"audio/x-musepack\"};if((67===e[0]||70===e[0])&&r([87,83],{offset:1}))return{ext:\"swf\",mime:\"application/x-shockwave-flash\"};if(r([71,73,70]))return{ext:\"gif\",mime:\"image/gif\"};if(i(\"FLIF\"))return{ext:\"flif\",mime:\"image/flif\"};if(i(\"8BPS\"))return{ext:\"psd\",mime:\"image/vnd.adobe.photoshop\"};if(i(\"WEBP\",{offset:8}))return{ext:\"webp\",mime:\"image/webp\"};if(i(\"MPCK\"))return{ext:\"mpc\",mime:\"audio/x-musepack\"};if(i(\"FORM\"))return{ext:\"aif\",mime:\"audio/aiff\"};if(i(\"icns\",{offset:0}))return{ext:\"icns\",mime:\"image/icns\"};if(r([80,75,3,4])){try{for(;t.position+30<t.fileInfo.size;){await t.readBuffer(e,{length:30});const a={compressedSize:e.readUInt32LE(18),uncompressedSize:e.readUInt32LE(22),filenameLength:e.readUInt16LE(26),extraFieldLength:e.readUInt16LE(28)};if(a.filename=await t.readToken(new Token.StringType(a.filenameLength,\"utf-8\")),await t.ignore(a.extraFieldLength),\"META-INF/mozilla.rsa\"===a.filename)return{ext:\"xpi\",mime:\"application/x-xpinstall\"};if(a.filename.endsWith(\".rels\")||a.filename.endsWith(\".xml\"))switch(a.filename.split(\"/\")[0]){case\"_rels\":default:break;case\"word\":return{ext:\"docx\",mime:\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"};case\"ppt\":return{ext:\"pptx\",mime:\"application/vnd.openxmlformats-officedocument.presentationml.presentation\"};case\"xl\":return{ext:\"xlsx\",mime:\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"}}if(a.filename.startsWith(\"xl/\"))return{ext:\"xlsx\",mime:\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"};if(a.filename.startsWith(\"3D/\")&&a.filename.endsWith(\".model\"))return{ext:\"3mf\",mime:\"model/3mf\"};if(\"mimetype\"===a.filename&&a.compressedSize===a.uncompressedSize)switch(await t.readToken(new Token.StringType(a.compressedSize,\"utf-8\"))){case\"application/epub+zip\":return{ext:\"epub\",mime:\"application/epub+zip\"};case\"application/vnd.oasis.opendocument.text\":return{ext:\"odt\",mime:\"application/vnd.oasis.opendocument.text\"};case\"application/vnd.oasis.opendocument.spreadsheet\":return{ext:\"ods\",mime:\"application/vnd.oasis.opendocument.spreadsheet\"};case\"application/vnd.oasis.opendocument.presentation\":return{ext:\"odp\",mime:\"application/vnd.oasis.opendocument.presentation\"}}if(0===a.compressedSize){let o=-1;for(;o<0&&t.position<t.fileInfo.size;)await t.peekBuffer(e,{mayBeLess:!0}),o=e.indexOf(\"504B0304\",0,\"hex\"),await t.ignore(o>=0?o:e.length)}else await t.ignore(a.compressedSize)}}catch(s){if(!(s instanceof strtok3.EndOfStreamError))throw s}return{ext:\"zip\",mime:\"application/zip\"}}if(i(\"OggS\")){await t.ignore(28);const h=Buffer.alloc(8);return await t.readBuffer(h),_check(h,[79,112,117,115,72,101,97,100])?{ext:\"opus\",mime:\"audio/opus\"}:_check(h,[128,116,104,101,111,114,97])?{ext:\"ogv\",mime:\"video/ogg\"}:_check(h,[1,118,105,100,101,111,0])?{ext:\"ogm\",mime:\"video/ogg\"}:_check(h,[127,70,76,65,67])?{ext:\"oga\",mime:\"audio/ogg\"}:_check(h,[83,112,101,101,120,32,32])?{ext:\"spx\",mime:\"audio/ogg\"}:_check(h,[1,118,111,114,98,105,115])?{ext:\"ogg\",mime:\"audio/ogg\"}:{ext:\"ogx\",mime:\"application/ogg\"}}if(r([80,75])&&(3===e[2]||5===e[2]||7===e[2])&&(4===e[3]||6===e[3]||8===e[3]))return{ext:\"zip\",mime:\"application/zip\"};if(i(\"ftyp\",{offset:4})&&0!=(96&e[8])){const l=e.toString(\"binary\",8,12).replace(\"\\0\",\" \").trim();switch(l){case\"avif\":return{ext:\"avif\",mime:\"image/avif\"};case\"mif1\":return{ext:\"heic\",mime:\"image/heif\"};case\"msf1\":return{ext:\"heic\",mime:\"image/heif-sequence\"};case\"heic\":case\"heix\":return{ext:\"heic\",mime:\"image/heic\"};case\"hevc\":case\"hevx\":return{ext:\"heic\",mime:\"image/heic-sequence\"};case\"qt\":return{ext:\"mov\",mime:\"video/quicktime\"};case\"M4V\":case\"M4VH\":case\"M4VP\":return{ext:\"m4v\",mime:\"video/x-m4v\"};case\"M4P\":return{ext:\"m4p\",mime:\"video/mp4\"};case\"M4B\":return{ext:\"m4b\",mime:\"audio/mp4\"};case\"M4A\":return{ext:\"m4a\",mime:\"audio/x-m4a\"};case\"F4V\":return{ext:\"f4v\",mime:\"video/mp4\"};case\"F4P\":return{ext:\"f4p\",mime:\"video/mp4\"};case\"F4A\":return{ext:\"f4a\",mime:\"audio/mp4\"};case\"F4B\":return{ext:\"f4b\",mime:\"audio/mp4\"};case\"crx\":return{ext:\"cr3\",mime:\"image/x-canon-cr3\"};default:return l.startsWith(\"3g\")?l.startsWith(\"3g2\")?{ext:\"3g2\",mime:\"video/3gpp2\"}:{ext:\"3gp\",mime:\"video/3gpp\"}:{ext:\"mp4\",mime:\"video/mp4\"}}}if(i(\"MThd\"))return{ext:\"mid\",mime:\"audio/midi\"};if(i(\"wOFF\")&&(r([0,1,0,0],{offset:4})||i(\"OTTO\",{offset:4})))return{ext:\"woff\",mime:\"font/woff\"};if(i(\"wOF2\")&&(r([0,1,0,0],{offset:4})||i(\"OTTO\",{offset:4})))return{ext:\"woff2\",mime:\"font/woff2\"};if(r([212,195,178,161])||r([161,178,195,212]))return{ext:\"pcap\",mime:\"application/vnd.tcpdump.pcap\"};if(i(\"DSD \"))return{ext:\"dsf\",mime:\"audio/x-dsf\"};if(i(\"LZIP\"))return{ext:\"lz\",mime:\"application/x-lzip\"};if(i(\"fLaC\"))return{ext:\"flac\",mime:\"audio/x-flac\"};if(r([66,80,71,251]))return{ext:\"bpg\",mime:\"image/bpg\"};if(i(\"wvpk\"))return{ext:\"wv\",mime:\"audio/wavpack\"};if(i(\"%PDF\")){await t.ignore(1350);const f=10485760,u=Buffer.alloc(Math.min(f,t.fileInfo.size));return await t.readBuffer(u,{mayBeLess:!0}),u.includes(Buffer.from(\"AIPrivateData\"))?{ext:\"ai\",mime:\"application/postscript\"}:{ext:\"pdf\",mime:\"application/pdf\"}}if(r([0,97,115,109]))return{ext:\"wasm\",mime:\"application/wasm\"};if(r([73,73,42,0]))return i(\"CR\",{offset:8})?{ext:\"cr2\",mime:\"image/x-canon-cr2\"}:r([28,0,254,0],{offset:8})||r([31,0,11,0],{offset:8})?{ext:\"nef\",mime:\"image/x-nikon-nef\"}:r([8,0,0,0],{offset:4})&&(r([45,0,254,0],{offset:8})||r([39,0,254,0],{offset:8}))?{ext:\"dng\",mime:\"image/x-adobe-dng\"}:(e=Buffer.alloc(24),await t.peekBuffer(e),(r([16,251,134,1],{offset:4})||r([8,0,0,0],{offset:4}))&&r([0,254,0,4,0,1,0,0,0,1,0,0,0,3,1],{offset:9})?{ext:\"arw\",mime:\"image/x-sony-arw\"}:{ext:\"tif\",mime:\"image/tiff\"});if(r([77,77,0,42]))return{ext:\"tif\",mime:\"image/tiff\"};if(i(\"MAC \"))return{ext:\"ape\",mime:\"audio/ape\"};if(r([26,69,223,163])){async function c(){const e=await t.peekNumber(Token.UINT8);let r=128,i=0;for(;0==(e&r)&&0!==r;)++i,r>>=1;const n=Buffer.alloc(i+1);return await t.readBuffer(n),n}async function d(){const t=await c(),e=await c();e[0]^=128>>e.length-1;const r=Math.min(6,e.length);return{id:t.readUIntBE(0,t.length),len:e.readUIntBE(e.length-r,r)}}async function p(e,r){for(;r>0;){const e=await d();if(17026===e.id)return t.readToken(new Token.StringType(e.len,\"utf-8\"));await t.ignore(e.len),--r}}const m=await d();switch(await p(0,m.len)){case\"webm\":return{ext:\"webm\",mime:\"video/webm\"};case\"matroska\":return{ext:\"mkv\",mime:\"video/x-matroska\"};default:return}}if(r([82,73,70,70])){if(r([65,86,73],{offset:8}))return{ext:\"avi\",mime:\"video/vnd.avi\"};if(r([87,65,86,69],{offset:8}))return{ext:\"wav\",mime:\"audio/vnd.wave\"};if(r([81,76,67,77],{offset:8}))return{ext:\"qcp\",mime:\"audio/qcelp\"}}if(i(\"SQLi\"))return{ext:\"sqlite\",mime:\"application/x-sqlite3\"};if(r([78,69,83,26]))return{ext:\"nes\",mime:\"application/x-nintendo-nes-rom\"};if(i(\"Cr24\"))return{ext:\"crx\",mime:\"application/x-google-chrome-extension\"};if(i(\"MSCF\")||i(\"ISc(\"))return{ext:\"cab\",mime:\"application/vnd.ms-cab-compressed\"};if(r([237,171,238,219]))return{ext:\"rpm\",mime:\"application/x-rpm\"};if(r([197,208,211,198]))return{ext:\"eps\",mime:\"application/eps\"};if(r([40,181,47,253]))return{ext:\"zst\",mime:\"application/zstd\"};if(r([79,84,84,79,0]))return{ext:\"otf\",mime:\"font/otf\"};if(i(\"#!AMR\"))return{ext:\"amr\",mime:\"audio/amr\"};if(i(\"{\\\\rtf\"))return{ext:\"rtf\",mime:\"application/rtf\"};if(r([70,76,86,1]))return{ext:\"flv\",mime:\"video/x-flv\"};if(i(\"IMPM\"))return{ext:\"it\",mime:\"audio/x-it\"};if(i(\"-lh0-\",{offset:2})||i(\"-lh1-\",{offset:2})||i(\"-lh2-\",{offset:2})||i(\"-lh3-\",{offset:2})||i(\"-lh4-\",{offset:2})||i(\"-lh5-\",{offset:2})||i(\"-lh6-\",{offset:2})||i(\"-lh7-\",{offset:2})||i(\"-lzs-\",{offset:2})||i(\"-lz4-\",{offset:2})||i(\"-lz5-\",{offset:2})||i(\"-lhd-\",{offset:2}))return{ext:\"lzh\",mime:\"application/x-lzh-compressed\"};if(r([0,0,1,186])){if(r([33],{offset:4,mask:[241]}))return{ext:\"mpg\",mime:\"video/MP1S\"};if(r([68],{offset:4,mask:[196]}))return{ext:\"mpg\",mime:\"video/MP2P\"}}if(i(\"ITSF\"))return{ext:\"chm\",mime:\"application/vnd.ms-htmlhelp\"};if(r([253,55,122,88,90,0]))return{ext:\"xz\",mime:\"application/x-xz\"};if(i(\"<?xml \"))return{ext:\"xml\",mime:\"application/xml\"};if(r([55,122,188,175,39,28]))return{ext:\"7z\",mime:\"application/x-7z-compressed\"};if(r([82,97,114,33,26,7])&&(0===e[6]||1===e[6]))return{ext:\"rar\",mime:\"application/x-rar-compressed\"};if(i(\"solid \"))return{ext:\"stl\",mime:\"model/stl\"};if(i(\"BLENDER\"))return{ext:\"blend\",mime:\"application/x-blender\"};if(i(\"!<arch>\"))return await t.ignore(8),\"debian-binary\"===await t.readToken(new Token.StringType(13,\"ascii\"))?{ext:\"deb\",mime:\"application/x-deb\"}:{ext:\"ar\",mime:\"application/x-unix-archive\"};if(r([137,80,78,71,13,10,26,10])){async function g(){return{length:await t.readToken(Token.INT32_BE),type:await t.readToken(new Token.StringType(4,\"binary\"))}}await t.ignore(8);do{const b=await g();if(b.length<0)return;switch(b.type){case\"IDAT\":return{ext:\"png\",mime:\"image/png\"};case\"acTL\":return{ext:\"apng\",mime:\"image/apng\"};default:await t.ignore(b.length+4)}}while(t.position+8<t.fileInfo.size);return{ext:\"png\",mime:\"image/png\"}}if(r([65,82,82,79,87,49,0,0]))return{ext:\"arrow\",mime:\"application/x-apache-arrow\"};if(r([103,108,84,70,2,0,0,0]))return{ext:\"glb\",mime:\"model/gltf-binary\"};if(r([102,114,101,101],{offset:4})||r([109,100,97,116],{offset:4})||r([109,111,111,118],{offset:4})||r([119,105,100,101],{offset:4}))return{ext:\"mov\",mime:\"video/quicktime\"};if(r([73,73,82,79,8,0,0,0,24]))return{ext:\"orf\",mime:\"image/x-olympus-orf\"};if(i(\"gimp xcf \"))return{ext:\"xcf\",mime:\"image/x-xcf\"};if(r([73,73,85,0,24,0,0,0,136,231,116,216]))return{ext:\"rw2\",mime:\"image/x-panasonic-rw2\"};if(r([48,38,178,117,142,102,207,17,166,217])){async function _(){const e=Buffer.alloc(16);return await t.readBuffer(e),{id:e,size:Number(await t.readToken(Token.UINT64_LE))}}for(await t.ignore(30);t.position+24<t.fileInfo.size;){const y=await _();let w=y.size-24;if(_check(y.id,[145,7,220,183,183,169,207,17,142,230,0,192,12,32,83,101])){const v=Buffer.alloc(16);if(w-=await t.readBuffer(v),_check(v,[64,158,105,248,77,91,207,17,168,253,0,128,95,92,68,43]))return{ext:\"asf\",mime:\"audio/x-ms-asf\"};if(_check(v,[192,239,25,188,77,91,207,17,168,253,0,128,95,92,68,43]))return{ext:\"asf\",mime:\"video/x-ms-asf\"};break}await t.ignore(w)}return{ext:\"asf\",mime:\"application/vnd.ms-asf\"}}if(r([171,75,84,88,32,49,49,187,13,10,26,10]))return{ext:\"ktx\",mime:\"image/ktx\"};if((r([126,16,4])||r([126,24,4]))&&r([48,77,73,69],{offset:4}))return{ext:\"mie\",mime:\"application/x-mie\"};if(r([39,10,0,0,0,0,0,0,0,0,0,0],{offset:2}))return{ext:\"shp\",mime:\"application/x-esri-shape\"};if(r([0,0,0,12,106,80,32,32,13,10,135,10]))switch(await t.ignore(20),await t.readToken(new Token.StringType(4,\"ascii\"))){case\"jp2 \":return{ext:\"jp2\",mime:\"image/jp2\"};case\"jpx \":return{ext:\"jpx\",mime:\"image/jpx\"};case\"jpm \":return{ext:\"jpm\",mime:\"image/jpm\"};case\"mjp2\":return{ext:\"mj2\",mime:\"image/mj2\"};default:return}if(r([255,10])||r([0,0,0,12,74,88,76,32,13,10,135,10]))return{ext:\"jxl\",mime:\"image/jxl\"};if(r([0,0,1,186])||r([0,0,1,179]))return{ext:\"mpg\",mime:\"video/mpeg\"};if(r([0,1,0,0,0]))return{ext:\"ttf\",mime:\"font/ttf\"};if(r([0,0,1,0]))return{ext:\"ico\",mime:\"image/x-icon\"};if(r([0,0,2,0]))return{ext:\"cur\",mime:\"image/x-icon\"};if(r([208,207,17,224,161,177,26,225]))return{ext:\"cfb\",mime:\"application/x-cfb\"};if(await t.peekBuffer(e,{length:Math.min(256,t.fileInfo.size),mayBeLess:!0}),i(\"BEGIN:\")){if(i(\"VCARD\",{offset:6}))return{ext:\"vcf\",mime:\"text/vcard\"};if(i(\"VCALENDAR\",{offset:6}))return{ext:\"ics\",mime:\"text/calendar\"}}if(i(\"FUJIFILMCCD-RAW\"))return{ext:\"raf\",mime:\"image/x-fujifilm-raf\"};if(i(\"Extended Module:\"))return{ext:\"xm\",mime:\"audio/x-xm\"};if(i(\"Creative Voice File\"))return{ext:\"voc\",mime:\"audio/x-voc\"};if(r([4,0,0,0])&&e.length>=16){const x=e.readUInt32LE(12);if(x>12&&e.length>=x+16)try{const E=e.slice(16,x+16).toString();if(JSON.parse(E).files)return{ext:\"asar\",mime:\"application/x-asar\"}}catch(k){}}if(r([6,14,43,52,2,5,1,1,13,1,2,1,1,2]))return{ext:\"mxf\",mime:\"application/mxf\"};if(i(\"SCRM\",{offset:44}))return{ext:\"s3m\",mime:\"audio/x-s3m\"};if(r([71],{offset:4})&&(r([71],{offset:192})||r([71],{offset:196})))return{ext:\"mts\",mime:\"video/mp2t\"};if(r([66,79,79,75,77,79,66,73],{offset:60}))return{ext:\"mobi\",mime:\"application/x-mobipocket-ebook\"};if(r([68,73,67,77],{offset:128}))return{ext:\"dcm\",mime:\"application/dicom\"};if(r([76,0,0,0,1,20,2,0,0,0,0,0,192,0,0,0,0,0,0,70]))return{ext:\"lnk\",mime:\"application/x.ms.shortcut\"};if(r([98,111,111,107,0,0,0,0,109,97,114,107,0,0,0,0]))return{ext:\"alias\",mime:\"application/x.apple.alias\"};if(r([76,80],{offset:34})&&(r([0,0,1],{offset:8})||r([1,0,2],{offset:8})||r([2,0,2],{offset:8})))return{ext:\"eot\",mime:\"application/vnd.ms-fontobject\"};if(r([6,6,237,245,216,29,70,229,189,49,239,231,254,116,183,29]))return{ext:\"indd\",mime:\"application/x-indesign\"};if(await t.peekBuffer(e,{length:Math.min(512,t.fileInfo.size),mayBeLess:!0}),tarHeaderChecksumMatches(e))return{ext:\"tar\",mime:\"application/x-tar\"};if(r([255,254,255,14,83,0,107,0,101,0,116,0,99,0,104,0,85,0,112,0,32,0,77,0,111,0,100,0,101,0,108,0]))return{ext:\"skp\",mime:\"application/vnd.sketchup.skp\"};if(i(\"-----BEGIN PGP MESSAGE-----\"))return{ext:\"pgp\",mime:\"application/pgp-encrypted\"};if(e.length>=2&&r([255,224],{offset:0,mask:[255,224]})){if(r([16],{offset:1,mask:[22]}))return r([8],{offset:1,mask:[8]}),{ext:\"aac\",mime:\"audio/aac\"};if(r([2],{offset:1,mask:[6]}))return{ext:\"mp3\",mime:\"audio/mpeg\"};if(r([4],{offset:1,mask:[6]}))return{ext:\"mp2\",mime:\"audio/mpeg\"};if(r([6],{offset:1,mask:[6]}))return{ext:\"mp1\",mime:\"audio/mpeg\"}}}const stream=readableStream=>new Promise(((resolve,reject)=>{const stream=eval(\"require\")(\"stream\");readableStream.on(\"error\",reject),readableStream.once(\"readable\",(async()=>{const t=new stream.PassThrough;let e;e=stream.pipeline?stream.pipeline(readableStream,t,(()=>{})):readableStream.pipe(t);const r=readableStream.read(minimumBytes)||readableStream.read()||Buffer.alloc(0);try{const e=await fromBuffer(r);t.fileType=e}catch(t){reject(t)}resolve(e)}))})),fileType={fromStream,fromTokenizer,fromBuffer,stream};Object.defineProperty(fileType,\"extensions\",{get:()=>new Set(supported.extensions)}),Object.defineProperty(fileType,\"mimeTypes\",{get:()=>new Set(supported.mimeTypes)}),module.exports=fileType},5025:(t,e,r)=>{\"use strict\";const i=r(3569),n=r(8789),a={fromFile:async function(t){const e=await i.fromFile(t);try{return await n.fromTokenizer(e)}finally{await e.close()}}};Object.assign(a,n),Object.defineProperty(a,\"extensions\",{get:()=>n.extensions}),Object.defineProperty(a,\"mimeTypes\",{get:()=>n.mimeTypes}),t.exports=a},4078:t=>{\"use strict\";t.exports={extensions:[\"jpg\",\"png\",\"apng\",\"gif\",\"webp\",\"flif\",\"xcf\",\"cr2\",\"cr3\",\"orf\",\"arw\",\"dng\",\"nef\",\"rw2\",\"raf\",\"tif\",\"bmp\",\"icns\",\"jxr\",\"psd\",\"indd\",\"zip\",\"tar\",\"rar\",\"gz\",\"bz2\",\"7z\",\"dmg\",\"mp4\",\"mid\",\"mkv\",\"webm\",\"mov\",\"avi\",\"mpg\",\"mp2\",\"mp3\",\"m4a\",\"oga\",\"ogg\",\"ogv\",\"opus\",\"flac\",\"wav\",\"spx\",\"amr\",\"pdf\",\"epub\",\"exe\",\"swf\",\"rtf\",\"wasm\",\"woff\",\"woff2\",\"eot\",\"ttf\",\"otf\",\"ico\",\"flv\",\"ps\",\"xz\",\"sqlite\",\"nes\",\"crx\",\"xpi\",\"cab\",\"deb\",\"ar\",\"rpm\",\"Z\",\"lz\",\"cfb\",\"mxf\",\"mts\",\"blend\",\"bpg\",\"docx\",\"pptx\",\"xlsx\",\"3gp\",\"3g2\",\"jp2\",\"jpm\",\"jpx\",\"mj2\",\"aif\",\"qcp\",\"odt\",\"ods\",\"odp\",\"xml\",\"mobi\",\"heic\",\"cur\",\"ktx\",\"ape\",\"wv\",\"dcm\",\"ics\",\"glb\",\"pcap\",\"dsf\",\"lnk\",\"alias\",\"voc\",\"ac3\",\"m4v\",\"m4p\",\"m4b\",\"f4v\",\"f4p\",\"f4b\",\"f4a\",\"mie\",\"asf\",\"ogm\",\"ogx\",\"mpc\",\"arrow\",\"shp\",\"aac\",\"mp1\",\"it\",\"s3m\",\"xm\",\"ai\",\"skp\",\"avif\",\"eps\",\"lzh\",\"pgp\",\"asar\",\"stl\",\"chm\",\"3mf\",\"zst\",\"jxl\",\"vcf\"],mimeTypes:[\"image/jpeg\",\"image/png\",\"image/gif\",\"image/webp\",\"image/flif\",\"image/x-xcf\",\"image/x-canon-cr2\",\"image/x-canon-cr3\",\"image/tiff\",\"image/bmp\",\"image/vnd.ms-photo\",\"image/vnd.adobe.photoshop\",\"application/x-indesign\",\"application/epub+zip\",\"application/x-xpinstall\",\"application/vnd.oasis.opendocument.text\",\"application/vnd.oasis.opendocument.spreadsheet\",\"application/vnd.oasis.opendocument.presentation\",\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\"application/zip\",\"application/x-tar\",\"application/x-rar-compressed\",\"application/gzip\",\"application/x-bzip2\",\"application/x-7z-compressed\",\"application/x-apple-diskimage\",\"application/x-apache-arrow\",\"video/mp4\",\"audio/midi\",\"video/x-matroska\",\"video/webm\",\"video/quicktime\",\"video/vnd.avi\",\"audio/vnd.wave\",\"audio/qcelp\",\"audio/x-ms-asf\",\"video/x-ms-asf\",\"application/vnd.ms-asf\",\"video/mpeg\",\"video/3gpp\",\"audio/mpeg\",\"audio/mp4\",\"audio/opus\",\"video/ogg\",\"audio/ogg\",\"application/ogg\",\"audio/x-flac\",\"audio/ape\",\"audio/wavpack\",\"audio/amr\",\"application/pdf\",\"application/x-msdownload\",\"application/x-shockwave-flash\",\"application/rtf\",\"application/wasm\",\"font/woff\",\"font/woff2\",\"application/vnd.ms-fontobject\",\"font/ttf\",\"font/otf\",\"image/x-icon\",\"video/x-flv\",\"application/postscript\",\"application/eps\",\"application/x-xz\",\"application/x-sqlite3\",\"application/x-nintendo-nes-rom\",\"application/x-google-chrome-extension\",\"application/vnd.ms-cab-compressed\",\"application/x-deb\",\"application/x-unix-archive\",\"application/x-rpm\",\"application/x-compress\",\"application/x-lzip\",\"application/x-cfb\",\"application/x-mie\",\"application/mxf\",\"video/mp2t\",\"application/x-blender\",\"image/bpg\",\"image/jp2\",\"image/jpx\",\"image/jpm\",\"image/mj2\",\"audio/aiff\",\"application/xml\",\"application/x-mobipocket-ebook\",\"image/heif\",\"image/heif-sequence\",\"image/heic\",\"image/heic-sequence\",\"image/icns\",\"image/ktx\",\"application/dicom\",\"audio/x-musepack\",\"text/calendar\",\"text/vcard\",\"model/gltf-binary\",\"application/vnd.tcpdump.pcap\",\"audio/x-dsf\",\"application/x.ms.shortcut\",\"application/x.apple.alias\",\"audio/x-voc\",\"audio/vnd.dolby.dd-raw\",\"audio/x-m4a\",\"image/apng\",\"image/x-olympus-orf\",\"image/x-sony-arw\",\"image/x-adobe-dng\",\"image/x-nikon-nef\",\"image/x-panasonic-rw2\",\"image/x-fujifilm-raf\",\"video/x-m4v\",\"video/3gpp2\",\"application/x-esri-shape\",\"audio/aac\",\"audio/x-it\",\"audio/x-s3m\",\"audio/x-xm\",\"video/MP1S\",\"video/MP2P\",\"application/vnd.sketchup.skp\",\"image/avif\",\"application/x-lzh-compressed\",\"application/pgp-encrypted\",\"application/x-asar\",\"model/stl\",\"application/vnd.ms-htmlhelp\",\"model/3mf\",\"image/jxl\",\"application/zstd\"]}},7044:(t,e)=>{\"use strict\";e.stringToBytes=t=>[...t].map((t=>t.charCodeAt(0))),e.tarHeaderChecksumMatches=(t,e=0)=>{const r=parseInt(t.toString(\"utf8\",148,154).replace(/\\0.*$/,\"\").trim(),8);if(isNaN(r))return!1;let i=256;for(let r=e;r<e+148;r++)i+=t[r];for(let r=e+156;r<e+512;r++)i+=t[r];return r===i},e.uint32SyncSafeToken={get:(t,e)=>127&t[e+3]|t[e+2]<<7|t[e+1]<<14|t[e]<<21,len:4}},3243:(t,e,r)=>{\"use strict\";var i=r(9680),n=Object.prototype.toString,a=Object.prototype.hasOwnProperty,o=function(t,e,r){for(var i=0,n=t.length;i<n;i++)a.call(t,i)&&(null==r?e(t[i],i,t):e.call(r,t[i],i,t))},s=function(t,e,r){for(var i=0,n=t.length;i<n;i++)null==r?e(t.charAt(i),i,t):e.call(r,t.charAt(i),i,t)},h=function(t,e,r){for(var i in t)a.call(t,i)&&(null==r?e(t[i],i,t):e.call(r,t[i],i,t))};t.exports=function(t,e,r){if(!i(e))throw new TypeError(\"iterator must be a function\");var a;arguments.length>=3&&(a=r),\"[object Array]\"===n.call(t)?o(t,e,a):\"string\"==typeof t?s(t,e,a):h(t,e,a)}},2855:(t,e)=>{\"use strict\";function r(t,e,r,i){for(var n=t[e++],a=1<<n,o=a+1,s=o+1,h=n+1,l=(1<<h)-1,f=0,u=0,c=0,d=t[e++],p=new Int32Array(4096),m=null;;){for(;f<16&&0!==d;)u|=t[e++]<<f,f+=8,1===d?d=t[e++]:--d;if(f<h)break;var g=u&l;if(u>>=h,f-=h,g!==a){if(g===o)break;for(var b=g<s?g:m,_=0,y=b;y>a;)y=p[y]>>8,++_;var w=y;if(c+_+(b!==g?1:0)>i)return void console.log(\"Warning, gif stream longer than expected.\");r[c++]=w;var v=c+=_;for(b!==g&&(r[c++]=w),y=b;_--;)y=p[y],r[--v]=255&y,y>>=8;null!==m&&s<4096&&(p[s++]=m<<8|w,s>=l+1&&h<12&&(++h,l=l<<1|1)),m=g}else s=o+1,l=(1<<(h=n+1))-1,m=null}return c!==i&&console.log(\"Warning, gif stream shorter than expected.\"),r}try{e.GifWriter=function(t,e,r,i){var n=0,a=void 0===(i=void 0===i?{}:i).loop?null:i.loop,o=void 0===i.palette?null:i.palette;if(e<=0||r<=0||e>65535||r>65535)throw new Error(\"Width/Height invalid.\");function s(t){var e=t.length;if(e<2||e>256||e&e-1)throw new Error(\"Invalid code/color length, must be power of 2 and 2 .. 256.\");return e}t[n++]=71,t[n++]=73,t[n++]=70,t[n++]=56,t[n++]=57,t[n++]=97;var h=0,l=0;if(null!==o){for(var f=s(o);f>>=1;)++h;if(f=1<<h,--h,void 0!==i.background){if((l=i.background)>=f)throw new Error(\"Background index out of range.\");if(0===l)throw new Error(\"Background index explicitly passed as 0.\")}}if(t[n++]=255&e,t[n++]=e>>8&255,t[n++]=255&r,t[n++]=r>>8&255,t[n++]=(null!==o?128:0)|h,t[n++]=l,t[n++]=0,null!==o)for(var u=0,c=o.length;u<c;++u){var d=o[u];t[n++]=d>>16&255,t[n++]=d>>8&255,t[n++]=255&d}if(null!==a){if(a<0||a>65535)throw new Error(\"Loop count invalid.\");t[n++]=33,t[n++]=255,t[n++]=11,t[n++]=78,t[n++]=69,t[n++]=84,t[n++]=83,t[n++]=67,t[n++]=65,t[n++]=80,t[n++]=69,t[n++]=50,t[n++]=46,t[n++]=48,t[n++]=3,t[n++]=1,t[n++]=255&a,t[n++]=a>>8&255,t[n++]=0}var p=!1;this.addFrame=function(e,r,i,a,h,l){if(!0===p&&(--n,p=!1),l=void 0===l?{}:l,e<0||r<0||e>65535||r>65535)throw new Error(\"x/y invalid.\");if(i<=0||a<=0||i>65535||a>65535)throw new Error(\"Width/Height invalid.\");if(h.length<i*a)throw new Error(\"Not enough pixels for the frame size.\");var f=!0,u=l.palette;if(null==u&&(f=!1,u=o),null==u)throw new Error(\"Must supply either a local or global palette.\");for(var c=s(u),d=0;c>>=1;)++d;c=1<<d;var m=void 0===l.delay?0:l.delay,g=void 0===l.disposal?0:l.disposal;if(g<0||g>3)throw new Error(\"Disposal out of range.\");var b=!1,_=0;if(void 0!==l.transparent&&null!==l.transparent&&(b=!0,(_=l.transparent)<0||_>=c))throw new Error(\"Transparent color index.\");if((0!==g||b||0!==m)&&(t[n++]=33,t[n++]=249,t[n++]=4,t[n++]=g<<2|(!0===b?1:0),t[n++]=255&m,t[n++]=m>>8&255,t[n++]=_,t[n++]=0),t[n++]=44,t[n++]=255&e,t[n++]=e>>8&255,t[n++]=255&r,t[n++]=r>>8&255,t[n++]=255&i,t[n++]=i>>8&255,t[n++]=255&a,t[n++]=a>>8&255,t[n++]=!0===f?128|d-1:0,!0===f)for(var y=0,w=u.length;y<w;++y){var v=u[y];t[n++]=v>>16&255,t[n++]=v>>8&255,t[n++]=255&v}return n=function(t,e,r,i){t[e++]=r;var n=e++,a=1<<r,o=a-1,s=a+1,h=s+1,l=r+1,f=0,u=0;function c(r){for(;f>=r;)t[e++]=255&u,u>>=8,f-=8,e===n+256&&(t[n]=255,n=e++)}function d(t){u|=t<<f,f+=l,c(8)}var p=i[0]&o,m={};d(a);for(var g=1,b=i.length;g<b;++g){var _=i[g]&o,y=p<<8|_,w=m[y];if(void 0===w){for(u|=p<<f,f+=l;f>=8;)t[e++]=255&u,u>>=8,f-=8,e===n+256&&(t[n]=255,n=e++);4096===h?(d(a),h=s+1,l=r+1,m={}):(h>=1<<l&&++l,m[y]=h++),p=_}else p=w}return d(p),d(s),c(1),n+1===e?t[n]=0:(t[n]=e-n-1,t[e++]=0),e}(t,n,d<2?2:d,h),n},this.end=function(){return!1===p&&(t[n++]=59,p=!0),n},this.getOutputBuffer=function(){return t},this.setOutputBuffer=function(e){t=e},this.getOutputBufferPosition=function(){return n},this.setOutputBufferPosition=function(t){n=t}},e.GifReader=function(t){var e=0;if(71!==t[e++]||73!==t[e++]||70!==t[e++]||56!==t[e++]||56!=(t[e++]+1&253)||97!==t[e++])throw new Error(\"Invalid GIF 87a/89a header.\");var i=t[e++]|t[e++]<<8,n=t[e++]|t[e++]<<8,a=t[e++],o=a>>7,s=1<<1+(7&a);t[e++],t[e++];var h=null,l=null;o&&(h=e,l=s,e+=3*s);var f=!0,u=[],c=0,d=null,p=0,m=null;for(this.width=i,this.height=n;f&&e<t.length;)switch(t[e++]){case 33:switch(t[e++]){case 255:if(11!==t[e]||78==t[e+1]&&69==t[e+2]&&84==t[e+3]&&83==t[e+4]&&67==t[e+5]&&65==t[e+6]&&80==t[e+7]&&69==t[e+8]&&50==t[e+9]&&46==t[e+10]&&48==t[e+11]&&3==t[e+12]&&1==t[e+13]&&0==t[e+16])e+=14,m=t[e++]|t[e++]<<8,e++;else for(e+=12;;){if(!((I=t[e++])>=0))throw Error(\"Invalid block size\");if(0===I)break;e+=I}break;case 249:if(4!==t[e++]||0!==t[e+4])throw new Error(\"Invalid graphics extension block.\");var g=t[e++];c=t[e++]|t[e++]<<8,d=t[e++],0==(1&g)&&(d=null),p=g>>2&7,e++;break;case 254:for(;;){if(!((I=t[e++])>=0))throw Error(\"Invalid block size\");if(0===I)break;e+=I}break;default:throw new Error(\"Unknown graphic control label: 0x\"+t[e-1].toString(16))}break;case 44:var b=t[e++]|t[e++]<<8,_=t[e++]|t[e++]<<8,y=t[e++]|t[e++]<<8,w=t[e++]|t[e++]<<8,v=t[e++],x=v>>6&1,E=1<<1+(7&v),k=h,S=l,M=!1;v>>7&&(M=!0,k=e,S=E,e+=3*E);var A=e;for(e++;;){var I;if(!((I=t[e++])>=0))throw Error(\"Invalid block size\");if(0===I)break;e+=I}u.push({x:b,y:_,width:y,height:w,has_local_palette:M,palette_offset:k,palette_size:S,data_offset:A,data_length:e-A,transparent_index:d,interlaced:!!x,delay:c,disposal:p});break;case 59:f=!1;break;default:throw new Error(\"Unknown gif block: 0x\"+t[e-1].toString(16))}this.numFrames=function(){return u.length},this.loopCount=function(){return m},this.frameInfo=function(t){if(t<0||t>=u.length)throw new Error(\"Frame index out of range.\");return u[t]},this.decodeAndBlitFrameBGRA=function(e,n){var a=this.frameInfo(e),o=a.width*a.height,s=new Uint8Array(o);r(t,a.data_offset,s,o);var h=a.palette_offset,l=a.transparent_index;null===l&&(l=256);var f=a.width,u=i-f,c=f,d=4*(a.y*i+a.x),p=4*((a.y+a.height)*i+a.x),m=d,g=4*u;!0===a.interlaced&&(g+=4*i*7);for(var b=8,_=0,y=s.length;_<y;++_){var w=s[_];if(0===c&&(c=f,(m+=g)>=p&&(g=4*u+4*i*(b-1),m=d+(f+u)*(b<<1),b>>=1)),w===l)m+=4;else{var v=t[h+3*w],x=t[h+3*w+1],E=t[h+3*w+2];n[m++]=E,n[m++]=x,n[m++]=v,n[m++]=255}--c}},this.decodeAndBlitFrameRGBA=function(e,n){var a=this.frameInfo(e),o=a.width*a.height,s=new Uint8Array(o);r(t,a.data_offset,s,o);var h=a.palette_offset,l=a.transparent_index;null===l&&(l=256);var f=a.width,u=i-f,c=f,d=4*(a.y*i+a.x),p=4*((a.y+a.height)*i+a.x),m=d,g=4*u;!0===a.interlaced&&(g+=4*i*7);for(var b=8,_=0,y=s.length;_<y;++_){var w=s[_];if(0===c&&(c=f,(m+=g)>=p&&(g=4*u+4*i*(b-1),m=d+(f+u)*(b<<1),b>>=1)),w===l)m+=4;else{var v=t[h+3*w],x=t[h+3*w+1],E=t[h+3*w+2];n[m++]=v,n[m++]=x,n[m++]=E,n[m++]=255}--c}}}}catch(t){}},7604:(t,e,r)=>{\"use strict\";var i=r(8834).lW;class n{constructor(...t){if(0===t.length)throw new Error(\"constructor requires parameters\");const e=t[0];if(null!==e&&\"object\"==typeof e)if(e instanceof n){const t=e.bitmap;this.bitmap={width:t.width,height:t.height,data:new i(t.width*t.height*4)},t.data.copy(this.bitmap.data)}else{if(!(e.width&&e.height&&e.data))throw new Error(\"unrecognized constructor parameters\");this.bitmap=e}else{if(\"number\"!=typeof e||\"number\"!=typeof t[1])throw new Error(\"unrecognized constructor parameters\");{const r=e,n=t[1],a=t[2];this.bitmap={width:r,height:n},i.isBuffer(a)?this.bitmap.data=a:(this.bitmap.data=new i(r*n*4),\"number\"==typeof a&&this.fillRGBA(a))}}}blit(t,e,r,i,n,a,o){if(i+a>this.bitmap.width)throw new Error(\"copy exceeds width of source bitmap\");if(e+a>t.bitmap.width)throw new Error(\"copy exceeds width of target bitmap\");if(n+o>this.bitmap.height)throw new Error(\"copy exceeds height of source bitmap\");if(r+o>t.bitmap.height)throw new Erro(\"copy exceeds height of target bitmap\");const s=this.bitmap.data,h=t.bitmap.data,l=4*this.bitmap.width,f=4*t.bitmap.width,u=4*a;let c=n*l+4*i,d=r*f+4*e;for(;--o>=0;)s.copy(h,d,c,c+u),c+=l,d+=f;return this}fillRGBA(t){const e=this.bitmap.data,r=4*this.bitmap.height;let i=0;for(;i<r;)e.writeUInt32BE(t,i),i+=4;for(;i<e.length;)e.copy(e,i,0,r),i+=r;return this}getRGBA(t,e){const r=4*(e*this.bitmap.width+t);return this.bitmap.data.readUInt32BE(r)}getRGBASet(){const t=new Set,e=this.bitmap.data;for(let r=0;r<e.length;r+=4)t.add(e.readUInt32BE(r,!0));return t}greyscale(){const t=this.bitmap.data;return this.scan(0,0,this.bitmap.width,this.bitmap.height,((e,r,i)=>{const n=Math.round(.299*t[i]+.587*t[i+1]+.114*t[i+2]);t[i]=n,t[i+1]=n,t[i+2]=n})),this}reframe(t,e,r,i,a){const o=t<0?0:t,s=e<0?0:e,h=r+o>this.bitmap.width?this.bitmap.width-o:r,l=i+s>this.bitmap.height?this.bitmap.height-s:i,f=t<0?-t:0,u=e<0?-e:0;let c;if(void 0===a){if(o!==t||s!=e||h!==r||l!==i)throw new GifError(\"fillRGBA required for this reframing\");c=new n(r,i)}else c=new n(r,i,a);return this.blit(c,f,u,o,s,h,l),this.bitmap=c.bitmap,this}scale(t){if(1===t)return;if(!Number.isInteger(t)||t<1)throw new Error(\"the scale must be an integer >= 1\");const e=this.bitmap.width,r=this.bitmap.height,n=e*t*4,a=this.bitmap.data,o=new i(r*n*t);let s,h=0,l=0;for(let i=0;i<r;++i){s=l;for(let r=0;r<e;++r){const e=a.readUInt32BE(h,!0);for(let r=0;r<t;++r)o.writeUInt32BE(e,l),l+=4;h+=4}for(let e=1;e<t;++e)o.copy(o,l,s,l),l+=n,s+=n}return this.bitmap={width:e*t,height:r*t,data:o},this}scanAllCoords(t){const e=this.bitmap.width,r=this.bitmap.data.length;let i=0,n=0;for(let a=0;a<r;a+=4)t(i,n,a),++i===e&&(i=0,++n)}scanAllIndexes(t){const e=this.bitmap.data.length;for(let r=0;r<e;r+=4)t(r)}}t.exports=n},4364:(t,e)=>{\"use strict\";class r{constructor(t,e,r){this.width=r.width,this.height=r.height,this.loops=r.loops,this.usesTransparency=r.usesTransparency,this.colorScope=r.colorScope,this.frames=e,this.buffer=t}}r.GlobalColorsPreferred=0,r.GlobalColorsOnly=1,r.LocalColorsOnly=2;class i extends Error{constructor(t){super(t),t instanceof Error&&(this.stack=\"Gif\"+t.stack)}}e.Gif=r,e.GifError=i},6512:(t,e,r)=>{\"use strict\";var i=r(8834).lW;const n=r(2855),{Gif:a,GifError:o}=r(4364);function s(){const t=r(4602);return s=function(){return t},t}const{GifFrame:h}=r(5585),l=100;function f(t,e){const r=t.indexOf(e);return-1===r?null:r}function u(t,e){for(var r,i=0,n=t.length-1;i<=n;)if(t[r=Math.floor((i+n)/2)]>e)n=r-1;else{if(!(t[r]<e))return r;i=r+1}return null}function c(t){const e=t.colors;t.usesTransparency&&e.push(0);const r=e.length;let i=2;for(;r>i;)i<<=1;e.length=i,e.fill(0,r)}function d(t,e){let r=t.bitmap.width*t.bitmap.height;return r=Math.ceil(r*e/8),r+=Math.ceil(r/255),l+r+768}function p(t){let e=t.indexCount,r=0;for(--e;e;)++r,e>>=1;return r>0?r:1}function m(t,e,r,n,a){if(r.interlaced)throw new o(\"writing interlaced GIFs is not supported\");const s=function(t,e,r){const n=r.colors,a=n.length<=8?f:u,s=e.bitmap.data,h=new i(s.length/4);let l=n.length,c=0,d=0;for(;c<s.length;){if(0!==s[c+3]){const t=s.readUInt32BE(c,!0)>>8&16777215;h[d]=a(n,t)}else h[d]=l;c+=4,++d}if(r.usesTransparency){if(256===l)throw new o(`Frame ${t} already has 256 colorsand so can't use transparency`)}else l=null;return{buffer:h,transparentIndex:l}}(e,r,n),h={delay:r.delayCentisecs,disposal:r.disposalMethod,transparent:s.transparentIndex};a&&(c(n),h.palette=n.colors);try{let e,n=t.getOutputBuffer(),a=t.getOutputBufferPosition(),o=!0;for(;o;)if(e=t.addFrame(r.xOffset,r.yOffset,r.bitmap.width,r.bitmap.height,s.buffer,h),o=!1,e>=n.length-1){const e=new i(1.5*n.length);n.copy(e),t.setOutputBuffer(e),t.setOutputBufferPosition(a),n=e,o=!0}return n}catch(t){throw new o(t)}}e.GifCodec=class{constructor(t={}){this._transparentRGB=null,\"number\"==typeof t.transparentRGB&&0!==t.transparentRGB&&(this._transparentRGBA=256*t.transparentRGB),this._testInitialBufferSize=0}decodeGif(t){try{let e;try{e=new n.GifReader(t)}catch(t){throw new o(t)}const r=e.numFrames(),i=[],s={width:e.width,height:e.height,loops:e.loopCount(),usesTransparency:!1};for(let t=0;t<r;++t){const r=this._decodeFrame(e,t,s.usesTransparency);i.push(r.frame),r.usesTransparency&&(s.usesTransparency=!0)}return Promise.resolve(new a(t,i,s))}catch(t){return Promise.reject(t)}}encodeGif(t,e={}){try{if(null===t||0===t.length)throw new o(\"there are no frames\");const r=s().getMaxDimensions(t);return(e=Object.assign({},e)).width=r.maxWidth,e.height=r.maxHeight,void 0===e.loops&&(e.loops=0),e.colorScope=e.colorScope||a.GlobalColorsPreferred,Promise.resolve(this._encodeGif(t,e))}catch(t){return Promise.reject(t)}}_decodeFrame(t,e,r){let n,a;try{if(n=t.frameInfo(e),a=new i(t.width*t.height*4),t.decodeAndBlitFrameRGBA(e,a),n.width!==t.width||n.height!==t.height){if(n.y&&(a=a.slice(n.y*t.width*4)),t.width>n.width)for(let e=0;e<n.height;++e)a.copy(a,e*n.width*4,4*(n.x+e*t.width),4*(n.x+e*t.width)+4*n.width);a=a.slice(0,n.width*n.height*4)}}catch(t){throw new o(t)}let s=!1;if(null===this._transparentRGBA){if(!r)for(let t=3;t<a.length;t+=4)0===a[t]&&(s=!0,t=a.length)}else for(let t=3;t<a.length;t+=4)0===a[t]&&(a.writeUInt32BE(this._transparentRGBA,t-3),s=!0);return{frame:new h(n.width,n.height,a,{xOffset:n.x,yOffset:n.y,disposalMethod:n.disposal,interlaced:n.interlaced,delayCentisecs:n.delay}),usesTransparency:s}}_encodeGif(t,e){let r;if(e.colorScope===a.LocalColorsOnly)r=s().getColorInfo(t,0);else if(r=s().getColorInfo(t,256),!r.colors){if(e.colorScope===a.GlobalColorsOnly)throw new o(\"Too many color indexes for global color table\");e.colorScope=a.LocalColorsOnly}e.usesTransparency=r.usesTransparency;const h=r.palettes;return e.colorScope===a.LocalColorsOnly?function(t,e,r,s){const h={loop:e.loops};let l,f=new i(2e3);try{l=new n.GifWriter(f,e.width,e.height,h)}catch(t){throw new o(t)}for(let e=0;e<t.length;++e)f=m(l,e,t[e],s[e],!0);return new a(f.slice(0,l.end()),t,e)}(t,e,0,h):function(t,e,r,s){const h={colors:s.colors.slice(),usesTransparency:s.usesTransparency};c(h);const l={palette:h.colors,loop:e.loops};let f,u=new i(2e3);try{f=new n.GifWriter(u,e.width,e.height,l)}catch(t){throw new o(t)}for(let e=0;e<t.length;++e)u=m(f,e,t[e],s,!1);return new a(u.slice(0,f.end()),t,e)}(t,e,0,r)}_getSizeEstimateGlobal(t,e){if(this._testInitialBufferSize>0)return this._testInitialBufferSize;let r=968;const i=p(t);return e.forEach((t=>{r+=d(t,i)})),r}_getSizeEstimateLocal(t,e){if(this._testInitialBufferSize>0)return this._testInitialBufferSize;let r=200;for(let i=0;i<e.length;++i){const n=p(t[i]);r+=d(e[i],n)}return r}}},5585:(t,e,r)=>{\"use strict\";const i=r(7604),{GifError:n}=r(4364);class a extends i{constructor(...t){if(super(...t),t[0]instanceof a){const e=t[0];this.xOffset=e.xOffset,this.yOffset=e.yOffset,this.disposalMethod=e.disposalMethod,this.delayCentisecs=e.delayCentisecs,this.interlaced=e.interlaced}else{const e=t[t.length-1];let r={};\"object\"!=typeof e||e instanceof i||(r=e),this.xOffset=r.xOffset||0,this.yOffset=r.yOffset||0,this.disposalMethod=void 0!==r.disposalMethod?r.disposalMethod:a.DisposeToBackgroundColor,this.delayCentisecs=r.delayCentisecs||8,this.interlaced=r.interlaced||!1}}getPalette(){const t=new Set,e=this.bitmap.data;let r=0,i=!1;for(;r<e.length;){if(0===e[r+3])i=!0;else{const i=e.readUInt32BE(r,!0)>>8&16777215;t.add(i)}r+=4}const n=new Array(t.size),a=t.values();for(r=0;r<n.length;++r)n[r]=a.next().value;n.sort(((t,e)=>t-e));let o=n.length;return i&&++o,{colors:n,usesTransparency:i,indexCount:o}}}a.DisposeToAnything=0,a.DisposeNothing=1,a.DisposeToBackgroundColor=2,a.DisposeToPrevious=3,e.GifFrame=a},4602:(t,e,r)=>{\"use strict\";var i=r(8834).lW;const n=r(8522),a=r(2460),o=r(7604),{GifFrame:s}=r(5585),{GifError:h}=r(4364),{GifCodec:l}=r(6512),f=[\".jpg\",\".jpeg\",\".png\",\".bmp\"],u=new l;function c(t,e,r,i,n){const o=Array.isArray(t)?t:[t];if(n){if([\"FloydSteinberg\",\"FalseFloydSteinberg\",\"Stucki\",\"Atkinson\",\"Jarvis\",\"Burkes\",\"Sierra\",\"TwoSierra\",\"SierraLite\"].indexOf(n.ditherAlgorithm)<0)throw new Error(`Invalid ditherAlgorithm '${n.ditherAlgorithm}'`);void 0===n.serpentine&&(n.serpentine=!0),void 0===n.minimumColorDistanceToDither&&(n.minimumColorDistanceToDither=0),void 0===n.calculateErrorLikeGIMP&&(n.calculateErrorLikeGIMP=!1)}const s=new a.distance.Euclidean,h=new a.palette[e](s,r,i);let l;l=n?new a.image.ErrorDiffusionArray(s,a.image.ErrorDiffusionArrayKernel[n.ditherAlgorithm],n.serpentine,n.minimumColorDistanceToDither,n.calculateErrorLikeGIMP):new a.image.NearestColor(s);const f=[];o.forEach((t=>{const e=t.bitmap.data,r=new ArrayBuffer(e.length),i=new Uint32Array(r);for(let t=0,r=0;t<e.length;t+=4,++r)i[r]=e.readUInt32LE(t,!0);const n=a.utils.PointContainer.fromUint32Array(i,t.bitmap.width,t.bitmap.height);h.sample(n),f.push(n)}));const u=h.quantizeSync();for(let t=0;t<o.length;++t){const e=o[t].bitmap.data,r=l.quantizeSync(f[t],u).toUint32Array();for(let t=0,i=0;t<e.length;t+=4,++i)e.writeUInt32LE(r[i],t)}}e.cloneFrames=function(t){let e=[];return t.forEach((t=>{e.push(new s(t))})),e},e.getColorInfo=function(t,e){let r=!1;const i=[];for(let e=0;e<t.length;++e){let n=t[e].getPalette();if(n.usesTransparency&&(r=!0),n.indexCount>256)throw new h(`Frame ${e} uses more than 256 color indexes`);i.push(n)}if(0===e)return{usesTransparency:r,palettes:i};const n=new Set;i.forEach((t=>{t.colors.forEach((t=>{n.add(t)}))}));let a=n.size;if(r&&++a,e&&a>e)return{usesTransparency:r,palettes:i};const o=new Array(n.size),s=n.values();for(let t=0;t<o.length;++t)o[t]=s.next().value;return o.sort(((t,e)=>t-e)),{colors:o,indexCount:a,usesTransparency:r,palettes:i}},e.copyAsJimp=function(t,r){return e.shareAsJimp(t,new o(r))},e.getMaxDimensions=function(t){let e=0,r=0;return t.forEach((t=>{const i=t.xOffset+t.bitmap.width;i>e&&(e=i);const n=t.yOffset+t.bitmap.height;n>r&&(r=n)})),{maxWidth:e,maxHeight:r}},e.quantizeDekker=function(t,e,r){c(t,\"NeuQuantFloat\",e=e||256,0,r)},e.quantizeSorokin=function(t,e,r,i){let n;switch(e=e||256,r=r||\"min-pop\"){case\"min-pop\":n=2;break;case\"top-pop\":n=1;break;default:throw new Error(`Invalid quantizeSorokin histogram '${r}'`)}c(t,\"RGBQuant\",e,n,i)},e.quantizeWu=function(t,e,r,i){if(e=e||256,(r=r||5)<1||r>8)throw new Error(\"Invalid quantization quality\");c(t,\"WuQuant\",e,r,i)},e.read=function(t,e){return e=e||u,i.isBuffer(t)?e.decodeGif(t):(r=t,new Promise(((t,e)=>{n.readFile(r,((r,i)=>r?e(r):t(i)))}))).then((t=>e.decodeGif(t)));var r},e.shareAsJimp=function(t,e){const r=new t(e.bitmap.width,e.bitmap.height,0);return r.bitmap.data=e.bitmap.data,r},e.write=function(t,e,r,i){i=i||u;const a=t.match(/\\.[a-zA-Z]+$/);if(null!==a&&f.includes(a[0].toLowerCase()))throw new Error(`GIF '${t}' has an unexpected suffix`);return i.encodeGif(e,r).then((e=>function(t,e){return new Promise(((r,i)=>{n.writeFile(t,e,(t=>t?i(t):r()))}))}(t,e.buffer).then((()=>e))))}},9455:(t,e,r)=>{\"use strict\";const i=r(7604),{Gif:n,GifError:a}=r(4364),{GifCodec:o}=r(6512),{GifFrame:s}=r(5585),h=r(4602);t.exports={BitmapImage:i,Gif:n,GifCodec:o,GifFrame:s,GifUtil:h,GifError:a}},5048:(t,e,r)=>{var i;i=\"undefined\"!=typeof window?window:void 0!==r.g?r.g:\"undefined\"!=typeof self?self:{},t.exports=i},2333:(t,e)=>{e.read=function(t,e,r,i,n){var a,o,s=8*n-i-1,h=(1<<s)-1,l=h>>1,f=-7,u=r?n-1:0,c=r?-1:1,d=t[e+u];for(u+=c,a=d&(1<<-f)-1,d>>=-f,f+=s;f>0;a=256*a+t[e+u],u+=c,f-=8);for(o=a&(1<<-f)-1,a>>=-f,f+=i;f>0;o=256*o+t[e+u],u+=c,f-=8);if(0===a)a=1-l;else{if(a===h)return o?NaN:1/0*(d?-1:1);o+=Math.pow(2,i),a-=l}return(d?-1:1)*o*Math.pow(2,a-i)},e.write=function(t,e,r,i,n,a){var o,s,h,l=8*a-n-1,f=(1<<l)-1,u=f>>1,c=23===n?Math.pow(2,-24)-Math.pow(2,-77):0,d=i?0:a-1,p=i?1:-1,m=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,o=f):(o=Math.floor(Math.log(e)/Math.LN2),e*(h=Math.pow(2,-o))<1&&(o--,h*=2),(e+=o+u>=1?c/h:c*Math.pow(2,1-u))*h>=2&&(o++,h/=2),o+u>=f?(s=0,o=f):o+u>=1?(s=(e*h-1)*Math.pow(2,n),o+=u):(s=e*Math.pow(2,u-1)*Math.pow(2,n),o=0));n>=8;t[r+d]=255&s,d+=p,s/=256,n-=8);for(o=o<<n|s,l+=n;l>0;t[r+d]=255&o,d+=p,o/=256,l-=8);t[r+d-p]|=128*m}},9680:t=>{\"use strict\";var e=Function.prototype.toString,r=/^\\s*class\\b/,i=function(t){try{var i=e.call(t);return r.test(i)}catch(t){return!1}},n=Object.prototype.toString,a=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.toStringTag;t.exports=function(t){if(!t)return!1;if(\"function\"!=typeof t&&\"object\"!=typeof t)return!1;if(\"function\"==typeof t&&!t.prototype)return!0;if(a)return function(t){try{return!i(t)&&(e.call(t),!0)}catch(t){return!1}}(t);if(i(t))return!1;var r=n.call(t);return\"[object Function]\"===r||\"[object GeneratorFunction]\"===r}},9748:t=>{t.exports=function(t){var r=e.call(t);return\"[object Function]\"===r||\"function\"==typeof t&&\"[object RegExp]\"!==r||\"undefined\"!=typeof window&&(t===window.setTimeout||t===window.alert||t===window.confirm||t===window.prompt)};var e=Object.prototype.toString},9307:(t,e,r)=>{r(6168),t.exports=self.fetch.bind(self)},2691:(t,e,r)=>{var i=r(706),n=r(770);t.exports={encode:i,decode:n}},770:(t,e,r)=>{var i=r(8834).lW,n=function(){\"use strict\";var t=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),e=4017,r=799,i=3406,n=2276,a=1567,o=3784,s=5793,h=2896;function l(){}function f(t,e){for(var r,i,n=0,a=[],o=16;o>0&&!t[o-1];)o--;a.push({children:[],index:0});var s,h=a[0];for(r=0;r<o;r++){for(i=0;i<t[r];i++){for((h=a.pop()).children[h.index]=e[n];h.index>0;){if(0===a.length)throw new Error(\"Could not recreate Huffman Table\");h=a.pop()}for(h.index++,a.push(h);a.length<=r;)a.push(s={children:[],index:0}),h.children[h.index]=s.children,h=s;n++}r+1<o&&(a.push(s={children:[],index:0}),h.children[h.index]=s.children,h=s)}return a[0].children}function u(e,r,i,n,a,o,s,h,l,f){i.precision,i.samplesPerLine,i.scanLines;var u=i.mcusPerLine,c=i.progressive,d=(i.maxH,i.maxV,r),p=0,m=0;function g(){if(m>0)return m--,p>>m&1;if(255==(p=e[r++])){var t=e[r++];if(t)throw new Error(\"unexpected marker: \"+(p<<8|t).toString(16))}return m=7,p>>>7}function b(t){for(var e,r=t;null!==(e=g());){if(\"number\"==typeof(r=r[e]))return r;if(\"object\"!=typeof r)throw new Error(\"invalid huffman sequence\")}return null}function _(t){for(var e=0;t>0;){var r=g();if(null===r)return;e=e<<1|r,t--}return e}function y(t){var e=_(t);return e>=1<<t-1?e:e+(-1<<t)+1}var w,v=0,x=0;function E(t,e,r,i,n){var a=r%u,o=(r/u|0)*t.v+i,s=a*t.h+n;void 0===t.blocks[o]&&f.tolerantDecoding||e(t,t.blocks[o][s])}function k(t,e,r){var i=r/t.blocksPerLine|0,n=r%t.blocksPerLine;void 0===t.blocks[i]&&f.tolerantDecoding||e(t,t.blocks[i][n])}var S,M,A,I,B,T,R=n.length;T=c?0===o?0===h?function(t,e){var r=b(t.huffmanTableDC),i=0===r?0:y(r)<<l;e[0]=t.pred+=i}:function(t,e){e[0]|=g()<<l}:0===h?function(e,r){if(v>0)v--;else for(var i=o,n=s;i<=n;){var a=b(e.huffmanTableAC),h=15&a,f=a>>4;if(0!==h)r[t[i+=f]]=y(h)*(1<<l),i++;else{if(f<15){v=_(f)+(1<<f)-1;break}i+=16}}}:function(e,r){for(var i=o,n=s,a=0;i<=n;){var h=t[i],f=r[h]<0?-1:1;switch(x){case 0:var u=b(e.huffmanTableAC),c=15&u;if(a=u>>4,0===c)a<15?(v=_(a)+(1<<a),x=4):(a=16,x=1);else{if(1!==c)throw new Error(\"invalid ACn encoding\");w=y(c),x=a?2:3}continue;case 1:case 2:r[h]?r[h]+=(g()<<l)*f:0==--a&&(x=2==x?3:0);break;case 3:r[h]?r[h]+=(g()<<l)*f:(r[h]=w<<l,x=0);break;case 4:r[h]&&(r[h]+=(g()<<l)*f)}i++}4===x&&0==--v&&(x=0)}:function(e,r){var i=b(e.huffmanTableDC),n=0===i?0:y(i);r[0]=e.pred+=n;for(var a=1;a<64;){var o=b(e.huffmanTableAC),s=15&o,h=o>>4;if(0!==s)r[t[a+=h]]=y(s),a++;else{if(h<15)break;a+=16}}};var P,O,L,C,U=0;for(O=1==R?n[0].blocksPerLine*n[0].blocksPerColumn:u*i.mcusPerColumn,a||(a=O);U<O;){for(M=0;M<R;M++)n[M].pred=0;if(v=0,1==R)for(S=n[0],B=0;B<a;B++)k(S,T,U),U++;else for(B=0;B<a;B++){for(M=0;M<R;M++)for(L=(S=n[M]).h,C=S.v,A=0;A<C;A++)for(I=0;I<L;I++)E(S,T,U,A,I);if(++U===O)break}if(U===O)do{if(255===e[r]&&0!==e[r+1])break;r+=1}while(r<e.length-2);if(m=0,(P=e[r]<<8|e[r+1])<65280)throw new Error(\"marker was not found\");if(!(P>=65488&&P<=65495))break;r+=2}return r-d}function c(t,l){var f,u,c=[],d=l.blocksPerLine,p=l.blocksPerColumn,m=d<<3,b=new Int32Array(64),_=new Uint8Array(64);function y(t,f,u){var c,d,p,m,g,b,_,y,w,v,x=l.quantizationTable,E=u;for(v=0;v<64;v++)E[v]=t[v]*x[v];for(v=0;v<8;++v){var k=8*v;0!=E[1+k]||0!=E[2+k]||0!=E[3+k]||0!=E[4+k]||0!=E[5+k]||0!=E[6+k]||0!=E[7+k]?(c=s*E[0+k]+128>>8,d=s*E[4+k]+128>>8,p=E[2+k],m=E[6+k],g=h*(E[1+k]-E[7+k])+128>>8,y=h*(E[1+k]+E[7+k])+128>>8,b=E[3+k]<<4,_=E[5+k]<<4,w=c-d+1>>1,c=c+d+1>>1,d=w,w=p*o+m*a+128>>8,p=p*a-m*o+128>>8,m=w,w=g-_+1>>1,g=g+_+1>>1,_=w,w=y+b+1>>1,b=y-b+1>>1,y=w,w=c-m+1>>1,c=c+m+1>>1,m=w,w=d-p+1>>1,d=d+p+1>>1,p=w,w=g*n+y*i+2048>>12,g=g*i-y*n+2048>>12,y=w,w=b*r+_*e+2048>>12,b=b*e-_*r+2048>>12,_=w,E[0+k]=c+y,E[7+k]=c-y,E[1+k]=d+_,E[6+k]=d-_,E[2+k]=p+b,E[5+k]=p-b,E[3+k]=m+g,E[4+k]=m-g):(w=s*E[0+k]+512>>10,E[0+k]=w,E[1+k]=w,E[2+k]=w,E[3+k]=w,E[4+k]=w,E[5+k]=w,E[6+k]=w,E[7+k]=w)}for(v=0;v<8;++v){var S=v;0!=E[8+S]||0!=E[16+S]||0!=E[24+S]||0!=E[32+S]||0!=E[40+S]||0!=E[48+S]||0!=E[56+S]?(c=s*E[0+S]+2048>>12,d=s*E[32+S]+2048>>12,p=E[16+S],m=E[48+S],g=h*(E[8+S]-E[56+S])+2048>>12,y=h*(E[8+S]+E[56+S])+2048>>12,b=E[24+S],_=E[40+S],w=c-d+1>>1,c=c+d+1>>1,d=w,w=p*o+m*a+2048>>12,p=p*a-m*o+2048>>12,m=w,w=g-_+1>>1,g=g+_+1>>1,_=w,w=y+b+1>>1,b=y-b+1>>1,y=w,w=c-m+1>>1,c=c+m+1>>1,m=w,w=d-p+1>>1,d=d+p+1>>1,p=w,w=g*n+y*i+2048>>12,g=g*i-y*n+2048>>12,y=w,w=b*r+_*e+2048>>12,b=b*e-_*r+2048>>12,_=w,E[0+S]=c+y,E[56+S]=c-y,E[8+S]=d+_,E[48+S]=d-_,E[16+S]=p+b,E[40+S]=p-b,E[24+S]=m+g,E[32+S]=m-g):(w=s*u[v+0]+8192>>14,E[0+S]=w,E[8+S]=w,E[16+S]=w,E[24+S]=w,E[32+S]=w,E[40+S]=w,E[48+S]=w,E[56+S]=w)}for(v=0;v<64;++v){var M=128+(E[v]+8>>4);f[v]=M<0?0:M>255?255:M}}g(m*p*8);for(var w=0;w<p;w++){var v=w<<3;for(f=0;f<8;f++)c.push(new Uint8Array(m));for(var x=0;x<d;x++){y(l.blocks[w][x],_,b);var E=0,k=x<<3;for(u=0;u<8;u++){var S=c[v+u];for(f=0;f<8;f++)S[k+f]=_[E++]}}}return c}function d(t){return t<0?0:t>255?255:t}l.prototype={load:function(t){var e=new XMLHttpRequest;e.open(\"GET\",t,!0),e.responseType=\"arraybuffer\",e.onload=function(){var t=new Uint8Array(e.response||e.mozResponseArrayBuffer);this.parse(t),this.onload&&this.onload()}.bind(this),e.send(null)},parse:function(e){var r=1e3*this.opts.maxResolutionInMP*1e3,i=0;function n(){var t=e[i]<<8|e[i+1];return i+=2,t}function a(t){var e,r,i=1,n=1;for(r in t.components)t.components.hasOwnProperty(r)&&(i<(e=t.components[r]).h&&(i=e.h),n<e.v&&(n=e.v));var a=Math.ceil(t.samplesPerLine/8/i),o=Math.ceil(t.scanLines/8/n);for(r in t.components)if(t.components.hasOwnProperty(r)){e=t.components[r];var s=Math.ceil(Math.ceil(t.samplesPerLine/8)*e.h/i),h=Math.ceil(Math.ceil(t.scanLines/8)*e.v/n),l=a*e.h,f=o*e.v,u=[];g(f*l*256);for(var c=0;c<f;c++){for(var d=[],p=0;p<l;p++)d.push(new Int32Array(64));u.push(d)}e.blocksPerLine=s,e.blocksPerColumn=h,e.blocks=u}t.maxH=i,t.maxV=n,t.mcusPerLine=a,t.mcusPerColumn=o}e.length;var o,s,h,l,d=null,p=null,m=[],b=[],_=[],y=[],w=n(),v=-1;if(this.comments=[],65496!=w)throw new Error(\"SOI not found\");for(w=n();65497!=w;){switch(w){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var x=(h=void 0,l=void 0,h=n(),l=e.subarray(i,i+h-2),i+=l.length,l);if(65534===w){var E=String.fromCharCode.apply(null,x);this.comments.push(E)}65504===w&&74===x[0]&&70===x[1]&&73===x[2]&&70===x[3]&&0===x[4]&&(d={version:{major:x[5],minor:x[6]},densityUnits:x[7],xDensity:x[8]<<8|x[9],yDensity:x[10]<<8|x[11],thumbWidth:x[12],thumbHeight:x[13],thumbData:x.subarray(14,14+3*x[12]*x[13])}),65505===w&&69===x[0]&&120===x[1]&&105===x[2]&&102===x[3]&&0===x[4]&&(this.exifBuffer=x.subarray(5,x.length)),65518===w&&65===x[0]&&100===x[1]&&111===x[2]&&98===x[3]&&101===x[4]&&0===x[5]&&(p={version:x[6],flags0:x[7]<<8|x[8],flags1:x[9]<<8|x[10],transformCode:x[11]});break;case 65499:for(var k=n()+i-2;i<k;){var S=e[i++];g(256);var M=new Int32Array(64);if(S>>4==0)for(V=0;V<64;V++)M[t[V]]=e[i++];else{if(S>>4!=1)throw new Error(\"DQT: invalid table spec\");for(V=0;V<64;V++)M[t[V]]=n()}m[15&S]=M}break;case 65472:case 65473:case 65474:n(),(o={}).extended=65473===w,o.progressive=65474===w,o.precision=e[i++],o.scanLines=n(),o.samplesPerLine=n(),o.components={},o.componentsOrder=[];var A=o.scanLines*o.samplesPerLine;if(A>r){var I=Math.ceil((A-r)/1e6);throw new Error(`maxResolutionInMP limit exceeded by ${I}MP`)}var B,T=e[i++];for(Z=0;Z<T;Z++){B=e[i];var R=e[i+1]>>4,P=15&e[i+1],O=e[i+2];if(R<=0||P<=0)throw new Error(\"Invalid sampling factor, expected values above 0\");o.componentsOrder.push(B),o.components[B]={h:R,v:P,quantizationIdx:O},i+=3}a(o),b.push(o);break;case 65476:var L=n();for(Z=2;Z<L;){var C=e[i++],U=new Uint8Array(16),z=0;for(V=0;V<16;V++,i++)z+=U[V]=e[i];g(16+z);var D=new Uint8Array(z);for(V=0;V<z;V++,i++)D[V]=e[i];Z+=17+z,(C>>4==0?y:_)[15&C]=f(U,D)}break;case 65501:n(),s=n();break;case 65500:n(),n();break;case 65498:n();var N=e[i++],F=[];for(Z=0;Z<N;Z++){X=o.components[e[i++]];var j=e[i++];X.huffmanTableDC=y[j>>4],X.huffmanTableAC=_[15&j],F.push(X)}var G=e[i++],H=e[i++],W=e[i++],q=u(e,i,o,F,s,G,H,W>>4,15&W,this.opts);i+=q;break;case 65535:255!==e[i]&&i--;break;default:if(255==e[i-3]&&e[i-2]>=192&&e[i-2]<=254){i-=3;break}if(224===w||225==w){if(-1!==v)throw new Error(`first unknown JPEG marker at offset ${v.toString(16)}, second unknown JPEG marker ${w.toString(16)} at offset ${(i-1).toString(16)}`);v=i-1;const t=n();if(255===e[i+t-2]){i+=t-2;break}}throw new Error(\"unknown JPEG marker \"+w.toString(16))}w=n()}if(1!=b.length)throw new Error(\"only single frame JPEGs supported\");for(var Z=0;Z<b.length;Z++){var Y=b[Z].components;for(var V in Y)Y[V].quantizationTable=m[Y[V].quantizationIdx],delete Y[V].quantizationIdx}for(this.width=o.samplesPerLine,this.height=o.scanLines,this.jfif=d,this.adobe=p,this.components=[],Z=0;Z<o.componentsOrder.length;Z++){var X=o.components[o.componentsOrder[Z]];this.components.push({lines:c(0,X),scaleX:X.h/o.maxH,scaleY:X.v/o.maxV})}},getData:function(t,e){var r,i,n,a,o,s,h,l,f,u,c,p,m,b,_,y,w,v,x,E,k,S=this.width/t,M=this.height/e,A=0,I=t*e*this.components.length;g(I);var B=new Uint8Array(I);switch(this.components.length){case 1:for(r=this.components[0],u=0;u<e;u++)for(o=r.lines[0|u*r.scaleY*M],f=0;f<t;f++)c=o[0|f*r.scaleX*S],B[A++]=c;break;case 2:for(r=this.components[0],i=this.components[1],u=0;u<e;u++)for(o=r.lines[0|u*r.scaleY*M],s=i.lines[0|u*i.scaleY*M],f=0;f<t;f++)c=o[0|f*r.scaleX*S],B[A++]=c,c=s[0|f*i.scaleX*S],B[A++]=c;break;case 3:for(k=!0,this.adobe&&this.adobe.transformCode?k=!0:void 0!==this.opts.colorTransform&&(k=!!this.opts.colorTransform),r=this.components[0],i=this.components[1],n=this.components[2],u=0;u<e;u++)for(o=r.lines[0|u*r.scaleY*M],s=i.lines[0|u*i.scaleY*M],h=n.lines[0|u*n.scaleY*M],f=0;f<t;f++)k?(c=o[0|f*r.scaleX*S],p=s[0|f*i.scaleX*S],v=d(c+1.402*((m=h[0|f*n.scaleX*S])-128)),x=d(c-.3441363*(p-128)-.71413636*(m-128)),E=d(c+1.772*(p-128))):(v=o[0|f*r.scaleX*S],x=s[0|f*i.scaleX*S],E=h[0|f*n.scaleX*S]),B[A++]=v,B[A++]=x,B[A++]=E;break;case 4:if(!this.adobe)throw new Error(\"Unsupported color mode (4 components)\");for(k=!1,this.adobe&&this.adobe.transformCode?k=!0:void 0!==this.opts.colorTransform&&(k=!!this.opts.colorTransform),r=this.components[0],i=this.components[1],n=this.components[2],a=this.components[3],u=0;u<e;u++)for(o=r.lines[0|u*r.scaleY*M],s=i.lines[0|u*i.scaleY*M],h=n.lines[0|u*n.scaleY*M],l=a.lines[0|u*a.scaleY*M],f=0;f<t;f++)k?(c=o[0|f*r.scaleX*S],p=s[0|f*i.scaleX*S],m=h[0|f*n.scaleX*S],b=l[0|f*a.scaleX*S],_=255-d(c+1.402*(m-128)),y=255-d(c-.3441363*(p-128)-.71413636*(m-128)),w=255-d(c+1.772*(p-128))):(_=o[0|f*r.scaleX*S],y=s[0|f*i.scaleX*S],w=h[0|f*n.scaleX*S],b=l[0|f*a.scaleX*S]),B[A++]=255-_,B[A++]=255-y,B[A++]=255-w,B[A++]=255-b;break;default:throw new Error(\"Unsupported color mode\")}return B},copyToImageData:function(t,e){var r,i,n,a,o,s,h,l,f,u=t.width,c=t.height,p=t.data,m=this.getData(u,c),g=0,b=0;switch(this.components.length){case 1:for(i=0;i<c;i++)for(r=0;r<u;r++)n=m[g++],p[b++]=n,p[b++]=n,p[b++]=n,e&&(p[b++]=255);break;case 3:for(i=0;i<c;i++)for(r=0;r<u;r++)h=m[g++],l=m[g++],f=m[g++],p[b++]=h,p[b++]=l,p[b++]=f,e&&(p[b++]=255);break;case 4:for(i=0;i<c;i++)for(r=0;r<u;r++)o=m[g++],s=m[g++],n=m[g++],h=255-d(o*(1-(a=m[g++])/255)+a),l=255-d(s*(1-a/255)+a),f=255-d(n*(1-a/255)+a),p[b++]=h,p[b++]=l,p[b++]=f,e&&(p[b++]=255);break;default:throw new Error(\"Unsupported color mode\")}}};var p=0,m=0;function g(t=0){var e=p+t;if(e>m){var r=Math.ceil((e-m)/1024/1024);throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${r}MB`)}p=e}return l.resetMaxMemoryUsage=function(t){p=0,m=t},l.getBytesAllocated=function(){return p},l.requestMemoryAllocation=g,l}();t.exports=function(t,e={}){var r={colorTransform:void 0,useTArray:!1,formatAsRGBA:!0,tolerantDecoding:!0,maxResolutionInMP:100,maxMemoryUsageInMB:512,...e},a=new Uint8Array(t),o=new n;o.opts=r,n.resetMaxMemoryUsage(1024*r.maxMemoryUsageInMB*1024),o.parse(a);var s=r.formatAsRGBA?4:3,h=o.width*o.height*s;try{n.requestMemoryAllocation(h);var l={width:o.width,height:o.height,exifBuffer:o.exifBuffer,data:r.useTArray?new Uint8Array(h):i.alloc(h)};o.comments.length>0&&(l.comments=o.comments)}catch(t){if(t instanceof RangeError)throw new Error(\"Could not allocate enough memory for the image. Required: \"+h);if(t instanceof ReferenceError&&\"Buffer is not defined\"===t.message)throw new Error(\"Buffer is not globally defined in this environment. Consider setting useTArray to true\");throw t}return o.copyToImageData(l,r.formatAsRGBA),l}},706:(t,e,r)=>{var i=r(8834).lW;function n(t){Math.round;var e,r,n,a,o,s=Math.floor,h=new Array(64),l=new Array(64),f=new Array(64),u=new Array(64),c=new Array(65535),d=new Array(65535),p=new Array(64),m=new Array(64),g=[],b=0,_=7,y=new Array(64),w=new Array(64),v=new Array(64),x=new Array(256),E=new Array(2048),k=[0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63],S=[0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],M=[0,1,2,3,4,5,6,7,8,9,10,11],A=[0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],I=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],B=[0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],T=[0,1,2,3,4,5,6,7,8,9,10,11],R=[0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],P=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function O(t,e){for(var r=0,i=0,n=new Array,a=1;a<=16;a++){for(var o=1;o<=t[a];o++)n[e[i]]=[],n[e[i]][0]=r,n[e[i]][1]=a,i++,r++;r*=2}return n}function L(t){for(var e=t[0],r=t[1]-1;r>=0;)e&1<<r&&(b|=1<<_),r--,--_<0&&(255==b?(C(255),C(0)):C(b),_=7,b=0)}function C(t){g.push(t)}function U(t){C(t>>8&255),C(255&t)}function z(t,e,r,i,n){for(var a,o=n[0],s=n[240],h=function(t,e){var r,i,n,a,o,s,h,l,f,u,c=0;for(f=0;f<8;++f){r=t[c],i=t[c+1],n=t[c+2],a=t[c+3],o=t[c+4],s=t[c+5],h=t[c+6];var d=r+(l=t[c+7]),m=r-l,g=i+h,b=i-h,_=n+s,y=n-s,w=a+o,v=a-o,x=d+w,E=d-w,k=g+_,S=g-_;t[c]=x+k,t[c+4]=x-k;var M=.707106781*(S+E);t[c+2]=E+M,t[c+6]=E-M;var A=.382683433*((x=v+y)-(S=b+m)),I=.5411961*x+A,B=1.306562965*S+A,T=.707106781*(k=y+b),R=m+T,P=m-T;t[c+5]=P+I,t[c+3]=P-I,t[c+1]=R+B,t[c+7]=R-B,c+=8}for(c=0,f=0;f<8;++f){r=t[c],i=t[c+8],n=t[c+16],a=t[c+24],o=t[c+32],s=t[c+40],h=t[c+48];var O=r+(l=t[c+56]),L=r-l,C=i+h,U=i-h,z=n+s,D=n-s,N=a+o,F=a-o,j=O+N,G=O-N,H=C+z,W=C-z;t[c]=j+H,t[c+32]=j-H;var q=.707106781*(W+G);t[c+16]=G+q,t[c+48]=G-q;var Z=.382683433*((j=F+D)-(W=U+L)),Y=.5411961*j+Z,V=1.306562965*W+Z,X=.707106781*(H=D+U),J=L+X,Q=L-X;t[c+40]=Q+Y,t[c+24]=Q-Y,t[c+8]=J+V,t[c+56]=J-V,c++}for(f=0;f<64;++f)u=t[f]*e[f],p[f]=u>0?u+.5|0:u-.5|0;return p}(t,e),l=0;l<64;++l)m[k[l]]=h[l];var f=m[0]-r;r=m[0],0==f?L(i[0]):(L(i[d[a=32767+f]]),L(c[a]));for(var u=63;u>0&&0==m[u];u--);if(0==u)return L(o),r;for(var g,b=1;b<=u;){for(var _=b;0==m[b]&&b<=u;++b);var y=b-_;if(y>=16){g=y>>4;for(var w=1;w<=g;++w)L(s);y&=15}a=32767+m[b],L(n[(y<<4)+d[a]]),L(c[a]),b++}return 63!=u&&L(o),r}function D(t){t<=0&&(t=1),t>100&&(t=100),o!=t&&(function(t){for(var e=[16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99],r=0;r<64;r++){var i=s((e[r]*t+50)/100);i<1?i=1:i>255&&(i=255),h[k[r]]=i}for(var n=[17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99],a=0;a<64;a++){var o=s((n[a]*t+50)/100);o<1?o=1:o>255&&(o=255),l[k[a]]=o}for(var c=[1,1.387039845,1.306562965,1.175875602,1,.785694958,.5411961,.275899379],d=0,p=0;p<8;p++)for(var m=0;m<8;m++)f[d]=1/(h[k[d]]*c[p]*c[m]*8),u[d]=1/(l[k[d]]*c[p]*c[m]*8),d++}(t<50?Math.floor(5e3/t):Math.floor(200-2*t)),o=t)}this.encode=function(t,o){var s;(new Date).getTime(),o&&D(o),g=new Array,b=0,_=7,U(65496),U(65504),U(16),C(74),C(70),C(73),C(70),C(0),C(1),C(1),C(0),U(1),U(1),C(0),C(0),void 0!==(s=t.comments)&&s.constructor===Array&&s.forEach((t=>{if(\"string\"==typeof t){U(65534);var e,r=t.length;for(U(r+2),e=0;e<r;e++)C(t.charCodeAt(e))}})),function(t){if(t){U(65505),69===t[0]&&120===t[1]&&105===t[2]&&102===t[3]?U(t.length+2):(U(t.length+5+2),C(69),C(120),C(105),C(102),C(0));for(var e=0;e<t.length;e++)C(t[e])}}(t.exifBuffer),function(){U(65499),U(132),C(0);for(var t=0;t<64;t++)C(h[t]);C(1);for(var e=0;e<64;e++)C(l[e])}(),function(t,e){U(65472),U(17),C(8),U(e),U(t),C(3),C(1),C(17),C(0),C(2),C(17),C(1),C(3),C(17),C(1)}(t.width,t.height),function(){U(65476),U(418),C(0);for(var t=0;t<16;t++)C(S[t+1]);for(var e=0;e<=11;e++)C(M[e]);C(16);for(var r=0;r<16;r++)C(A[r+1]);for(var i=0;i<=161;i++)C(I[i]);C(1);for(var n=0;n<16;n++)C(B[n+1]);for(var a=0;a<=11;a++)C(T[a]);C(17);for(var o=0;o<16;o++)C(R[o+1]);for(var s=0;s<=161;s++)C(P[s])}(),U(65498),U(12),C(3),C(1),C(0),C(2),C(17),C(3),C(17),C(0),C(63),C(0);var c=0,d=0,p=0;b=0,_=7,this.encode.displayName=\"_encode_\";for(var m,x,k,O,N,F,j,G,H,W=t.data,q=t.width,Z=t.height,Y=4*q,V=0;V<Z;){for(m=0;m<Y;){for(F=N=Y*V+m,j=-1,G=0,H=0;H<64;H++)F=N+(G=H>>3)*Y+(j=4*(7&H)),V+G>=Z&&(F-=Y*(V+1+G-Z)),m+j>=Y&&(F-=m+j-Y+4),x=W[F++],k=W[F++],O=W[F++],y[H]=(E[x]+E[k+256>>0]+E[O+512>>0]>>16)-128,w[H]=(E[x+768>>0]+E[k+1024>>0]+E[O+1280>>0]>>16)-128,v[H]=(E[x+1280>>0]+E[k+1536>>0]+E[O+1792>>0]>>16)-128;c=z(y,f,c,e,n),d=z(w,u,d,r,a),p=z(v,u,p,r,a),m+=32}V+=8}if(_>=0){var X=[];X[1]=_+1,X[0]=(1<<_+1)-1,L(X)}return U(65497),i.from(g)},(new Date).getTime(),t||(t=50),function(){for(var t=String.fromCharCode,e=0;e<256;e++)x[e]=t(e)}(),e=O(S,M),r=O(B,T),n=O(A,I),a=O(R,P),function(){for(var t=1,e=2,r=1;r<=15;r++){for(var i=t;i<e;i++)d[32767+i]=r,c[32767+i]=[],c[32767+i][1]=r,c[32767+i][0]=i;for(var n=-(e-1);n<=-t;n++)d[32767+n]=r,c[32767+n]=[],c[32767+n][1]=r,c[32767+n][0]=e-1+n;t<<=1,e<<=1}}(),function(){for(var t=0;t<256;t++)E[t]=19595*t,E[t+256>>0]=38470*t,E[t+512>>0]=7471*t+32768,E[t+768>>0]=-11059*t,E[t+1024>>0]=-21709*t,E[t+1280>>0]=32768*t+8421375,E[t+1536>>0]=-27439*t,E[t+1792>>0]=-5329*t}(),D(t),(new Date).getTime()}t.exports=function(t,e){return void 0===e&&(e=50),{data:new n(e).encode(t,e),width:t.width,height:t.height}}},8058:(t,e,r)=>{var i=r(8834).lW,n=r(6290),a=function(){},o=r(4398),s=r(5947),h=r(8438),l=r(5565),f=r(1960),u=self.XMLHttpRequest&&\"withCredentials\"in new XMLHttpRequest;t.exports=function(t,e){e=\"function\"==typeof e?e:a,\"string\"==typeof t?t={uri:t}:t||(t={}),t.binary&&(t=function(t){if(u)return f(t,{responseType:\"arraybuffer\"});if(void 0===self.XMLHttpRequest)throw new Error(\"your browser does not support XHR loading\");var e=new self.XMLHttpRequest;return e.overrideMimeType(\"text/plain; charset=x-user-defined\"),f({xhr:e},t)}(t)),n(t,(function(r,n,f){if(r)return e(r);if(!/^2/.test(n.statusCode))return e(new Error(\"http status code: \"+n.statusCode));if(!f)return e(new Error(\"no body result\"));var u,c,d=!1;if(u=f,\"[object ArrayBuffer]\"===Object.prototype.toString.call(u)){var p=new Uint8Array(f);f=i.from(p,\"binary\")}l(f)&&(d=!0,\"string\"==typeof f&&(f=i.from(f,\"binary\"))),d||(i.isBuffer(f)&&(f=f.toString(t.encoding)),f=f.trim());try{var m=n.headers[\"content-type\"];c=d?h(f):/json/.test(m)||\"{\"===f.charAt(0)?JSON.parse(f):/xml/.test(m)||\"<\"===f.charAt(0)?s(f):o(f)}catch(t){e(new Error(\"error parsing font \"+t.message)),e=a}e(null,c)}))}},5565:(t,e,r)=>{var i=r(8834).lW,n=r(5137),a=i.from([66,77,70,3]);t.exports=function(t){return\"string\"==typeof t?\"BMF\"===t.substring(0,3):t.length>4&&n(t.slice(0,4),a)}},63:(t,e)=>{\"use strict\";function r(t,e,r,i){for(var n=t[e++],a=1<<n,o=a+1,s=o+1,h=n+1,l=(1<<h)-1,f=0,u=0,c=0,d=t[e++],p=new Int32Array(4096),m=null;;){for(;f<16&&0!==d;)u|=t[e++]<<f,f+=8,1===d?d=t[e++]:--d;if(f<h)break;var g=u&l;if(u>>=h,f-=h,g!==a){if(g===o)break;for(var b=g<s?g:m,_=0,y=b;y>a;)y=p[y]>>8,++_;var w=y;if(c+_+(b!==g?1:0)>i)return void console.log(\"Warning, gif stream longer than expected.\");r[c++]=w;var v=c+=_;for(b!==g&&(r[c++]=w),y=b;_--;)y=p[y],r[--v]=255&y,y>>=8;null!==m&&s<4096&&(p[s++]=m<<8|w,s>=l+1&&h<12&&(++h,l=l<<1|1)),m=g}else s=o+1,l=(1<<(h=n+1))-1,m=null}return c!==i&&console.log(\"Warning, gif stream shorter than expected.\"),r}try{e.N=function(t){var e=0;if(71!==t[e++]||73!==t[e++]||70!==t[e++]||56!==t[e++]||56!=(t[e++]+1&253)||97!==t[e++])throw new Error(\"Invalid GIF 87a/89a header.\");var i=t[e++]|t[e++]<<8,n=t[e++]|t[e++]<<8,a=t[e++],o=a>>7,s=1<<1+(7&a);t[e++],t[e++];var h=null,l=null;o&&(h=e,l=s,e+=3*s);var f=!0,u=[],c=0,d=null,p=0,m=null;for(this.width=i,this.height=n;f&&e<t.length;)switch(t[e++]){case 33:switch(t[e++]){case 255:if(11!==t[e]||78==t[e+1]&&69==t[e+2]&&84==t[e+3]&&83==t[e+4]&&67==t[e+5]&&65==t[e+6]&&80==t[e+7]&&69==t[e+8]&&50==t[e+9]&&46==t[e+10]&&48==t[e+11]&&3==t[e+12]&&1==t[e+13]&&0==t[e+16])e+=14,m=t[e++]|t[e++]<<8,e++;else for(e+=12;;){if(!((I=t[e++])>=0))throw Error(\"Invalid block size\");if(0===I)break;e+=I}break;case 249:if(4!==t[e++]||0!==t[e+4])throw new Error(\"Invalid graphics extension block.\");var g=t[e++];c=t[e++]|t[e++]<<8,d=t[e++],0==(1&g)&&(d=null),p=g>>2&7,e++;break;case 254:for(;;){if(!((I=t[e++])>=0))throw Error(\"Invalid block size\");if(0===I)break;e+=I}break;default:throw new Error(\"Unknown graphic control label: 0x\"+t[e-1].toString(16))}break;case 44:var b=t[e++]|t[e++]<<8,_=t[e++]|t[e++]<<8,y=t[e++]|t[e++]<<8,w=t[e++]|t[e++]<<8,v=t[e++],x=v>>6&1,E=1<<1+(7&v),k=h,S=l,M=!1;v>>7&&(M=!0,k=e,S=E,e+=3*E);var A=e;for(e++;;){var I;if(!((I=t[e++])>=0))throw Error(\"Invalid block size\");if(0===I)break;e+=I}u.push({x:b,y:_,width:y,height:w,has_local_palette:M,palette_offset:k,palette_size:S,data_offset:A,data_length:e-A,transparent_index:d,interlaced:!!x,delay:c,disposal:p});break;case 59:f=!1;break;default:throw new Error(\"Unknown gif block: 0x\"+t[e-1].toString(16))}this.numFrames=function(){return u.length},this.loopCount=function(){return m},this.frameInfo=function(t){if(t<0||t>=u.length)throw new Error(\"Frame index out of range.\");return u[t]},this.decodeAndBlitFrameBGRA=function(e,n){var a=this.frameInfo(e),o=a.width*a.height,s=new Uint8Array(o);r(t,a.data_offset,s,o);var h=a.palette_offset,l=a.transparent_index;null===l&&(l=256);var f=a.width,u=i-f,c=f,d=4*(a.y*i+a.x),p=4*((a.y+a.height)*i+a.x),m=d,g=4*u;!0===a.interlaced&&(g+=4*i*7);for(var b=8,_=0,y=s.length;_<y;++_){var w=s[_];if(0===c&&(c=f,(m+=g)>=p&&(g=4*u+4*i*(b-1),m=d+(f+u)*(b<<1),b>>=1)),w===l)m+=4;else{var v=t[h+3*w],x=t[h+3*w+1],E=t[h+3*w+2];n[m++]=E,n[m++]=x,n[m++]=v,n[m++]=255}--c}},this.decodeAndBlitFrameRGBA=function(e,n){var a=this.frameInfo(e),o=a.width*a.height,s=new Uint8Array(o);r(t,a.data_offset,s,o);var h=a.palette_offset,l=a.transparent_index;null===l&&(l=256);var f=a.width,u=i-f,c=f,d=4*(a.y*i+a.x),p=4*((a.y+a.height)*i+a.x),m=d,g=4*u;!0===a.interlaced&&(g+=4*i*7);for(var b=8,_=0,y=s.length;_<y;++_){var w=s[_];if(0===c&&(c=f,(m+=g)>=p&&(g=4*u+4*i*(b-1),m=d+(f+u)*(b<<1),b>>=1)),w===l)m+=4;else{var v=t[h+3*w],x=t[h+3*w+1],E=t[h+3*w+2];n[m++]=v,n[m++]=x,n[m++]=E,n[m++]=255}--c}}}}catch(t){}},2845:(t,e,r)=>{\"use strict\";var i={};(0,r(9761).assign)(i,r(9880),r(1380),r(1271)),t.exports=i},9880:(t,e,r)=>{\"use strict\";var i=r(5789),n=r(9761),a=r(7944),o=r(2950),s=r(744),h=Object.prototype.toString,l=0,f=-1,u=0,c=8;function d(t){if(!(this instanceof d))return new d(t);this.options=n.assign({level:f,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:u,to:\"\"},t||{});var e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=i.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==l)throw new Error(o[r]);if(e.header&&i.deflateSetHeader(this.strm,e.header),e.dictionary){var p;if(p=\"string\"==typeof e.dictionary?a.string2buf(e.dictionary):\"[object ArrayBuffer]\"===h.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(r=i.deflateSetDictionary(this.strm,p))!==l)throw new Error(o[r]);this._dict_set=!0}}function p(t,e){var r=new d(e);if(r.push(t,!0),r.err)throw r.msg||o[r.err];return r.result}d.prototype.push=function(t,e){var r,o,s=this.strm,f=this.options.chunkSize;if(this.ended)return!1;o=e===~~e?e:!0===e?4:0,\"string\"==typeof t?s.input=a.string2buf(t):\"[object ArrayBuffer]\"===h.call(t)?s.input=new Uint8Array(t):s.input=t,s.next_in=0,s.avail_in=s.input.length;do{if(0===s.avail_out&&(s.output=new n.Buf8(f),s.next_out=0,s.avail_out=f),1!==(r=i.deflate(s,o))&&r!==l)return this.onEnd(r),this.ended=!0,!1;0!==s.avail_out&&(0!==s.avail_in||4!==o&&2!==o)||(\"string\"===this.options.to?this.onData(a.buf2binstring(n.shrinkBuf(s.output,s.next_out))):this.onData(n.shrinkBuf(s.output,s.next_out)))}while((s.avail_in>0||0===s.avail_out)&&1!==r);return 4===o?(r=i.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==o||(this.onEnd(l),s.avail_out=0,!0)},d.prototype.onData=function(t){this.chunks.push(t)},d.prototype.onEnd=function(t){t===l&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=n.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},e.Deflate=d,e.deflate=p,e.deflateRaw=function(t,e){return(e=e||{}).raw=!0,p(t,e)},e.gzip=function(t,e){return(e=e||{}).gzip=!0,p(t,e)}},1380:(t,e,r)=>{\"use strict\";var i=r(5020),n=r(9761),a=r(7944),o=r(1271),s=r(2950),h=r(744),l=r(7357),f=Object.prototype.toString;function u(t){if(!(this instanceof u))return new u(t);this.options=n.assign({chunkSize:16384,windowBits:0,to:\"\"},t||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new h,this.strm.avail_out=0;var r=i.inflateInit2(this.strm,e.windowBits);if(r!==o.Z_OK)throw new Error(s[r]);if(this.header=new l,i.inflateGetHeader(this.strm,this.header),e.dictionary&&(\"string\"==typeof e.dictionary?e.dictionary=a.string2buf(e.dictionary):\"[object ArrayBuffer]\"===f.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(r=i.inflateSetDictionary(this.strm,e.dictionary))!==o.Z_OK))throw new Error(s[r])}function c(t,e){var r=new u(e);if(r.push(t,!0),r.err)throw r.msg||s[r.err];return r.result}u.prototype.push=function(t,e){var r,s,h,l,u,c=this.strm,d=this.options.chunkSize,p=this.options.dictionary,m=!1;if(this.ended)return!1;s=e===~~e?e:!0===e?o.Z_FINISH:o.Z_NO_FLUSH,\"string\"==typeof t?c.input=a.binstring2buf(t):\"[object ArrayBuffer]\"===f.call(t)?c.input=new Uint8Array(t):c.input=t,c.next_in=0,c.avail_in=c.input.length;do{if(0===c.avail_out&&(c.output=new n.Buf8(d),c.next_out=0,c.avail_out=d),(r=i.inflate(c,o.Z_NO_FLUSH))===o.Z_NEED_DICT&&p&&(r=i.inflateSetDictionary(this.strm,p)),r===o.Z_BUF_ERROR&&!0===m&&(r=o.Z_OK,m=!1),r!==o.Z_STREAM_END&&r!==o.Z_OK)return this.onEnd(r),this.ended=!0,!1;c.next_out&&(0!==c.avail_out&&r!==o.Z_STREAM_END&&(0!==c.avail_in||s!==o.Z_FINISH&&s!==o.Z_SYNC_FLUSH)||(\"string\"===this.options.to?(h=a.utf8border(c.output,c.next_out),l=c.next_out-h,u=a.buf2string(c.output,h),c.next_out=l,c.avail_out=d-l,l&&n.arraySet(c.output,c.output,h,l,0),this.onData(u)):this.onData(n.shrinkBuf(c.output,c.next_out)))),0===c.avail_in&&0===c.avail_out&&(m=!0)}while((c.avail_in>0||0===c.avail_out)&&r!==o.Z_STREAM_END);return r===o.Z_STREAM_END&&(s=o.Z_FINISH),s===o.Z_FINISH?(r=i.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===o.Z_OK):s!==o.Z_SYNC_FLUSH||(this.onEnd(o.Z_OK),c.avail_out=0,!0)},u.prototype.onData=function(t){this.chunks.push(t)},u.prototype.onEnd=function(t){t===o.Z_OK&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=n.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},e.Inflate=u,e.inflate=c,e.inflateRaw=function(t,e){return(e=e||{}).raw=!0,c(t,e)},e.ungzip=c},9761:(t,e)=>{\"use strict\";var r=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Int32Array;function i(t,e){return Object.prototype.hasOwnProperty.call(t,e)}e.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if(\"object\"!=typeof r)throw new TypeError(r+\"must be non-object\");for(var n in r)i(r,n)&&(t[n]=r[n])}}return t},e.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var a=0;a<i;a++)t[n+a]=e[r+a]},flattenChunks:function(t){var e,r,i,n,a,o;for(i=0,e=0,r=t.length;e<r;e++)i+=t[e].length;for(o=new Uint8Array(i),n=0,e=0,r=t.length;e<r;e++)a=t[e],o.set(a,n),n+=a.length;return o}},a={arraySet:function(t,e,r,i,n){for(var a=0;a<i;a++)t[n+a]=e[r+a]},flattenChunks:function(t){return[].concat.apply([],t)}};e.setTyped=function(t){t?(e.Buf8=Uint8Array,e.Buf16=Uint16Array,e.Buf32=Int32Array,e.assign(e,n)):(e.Buf8=Array,e.Buf16=Array,e.Buf32=Array,e.assign(e,a))},e.setTyped(r)},7944:(t,e,r)=>{\"use strict\";var i=r(9761),n=!0,a=!0;try{String.fromCharCode.apply(null,[0])}catch(t){n=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){a=!1}for(var o=new i.Buf8(256),s=0;s<256;s++)o[s]=s>=252?6:s>=248?5:s>=240?4:s>=224?3:s>=192?2:1;function h(t,e){if(e<65534&&(t.subarray&&a||!t.subarray&&n))return String.fromCharCode.apply(null,i.shrinkBuf(t,e));for(var r=\"\",o=0;o<e;o++)r+=String.fromCharCode(t[o]);return r}o[254]=o[254]=1,e.string2buf=function(t){var e,r,n,a,o,s=t.length,h=0;for(a=0;a<s;a++)55296==(64512&(r=t.charCodeAt(a)))&&a+1<s&&56320==(64512&(n=t.charCodeAt(a+1)))&&(r=65536+(r-55296<<10)+(n-56320),a++),h+=r<128?1:r<2048?2:r<65536?3:4;for(e=new i.Buf8(h),o=0,a=0;o<h;a++)55296==(64512&(r=t.charCodeAt(a)))&&a+1<s&&56320==(64512&(n=t.charCodeAt(a+1)))&&(r=65536+(r-55296<<10)+(n-56320),a++),r<128?e[o++]=r:r<2048?(e[o++]=192|r>>>6,e[o++]=128|63&r):r<65536?(e[o++]=224|r>>>12,e[o++]=128|r>>>6&63,e[o++]=128|63&r):(e[o++]=240|r>>>18,e[o++]=128|r>>>12&63,e[o++]=128|r>>>6&63,e[o++]=128|63&r);return e},e.buf2binstring=function(t){return h(t,t.length)},e.binstring2buf=function(t){for(var e=new i.Buf8(t.length),r=0,n=e.length;r<n;r++)e[r]=t.charCodeAt(r);return e},e.buf2string=function(t,e){var r,i,n,a,s=e||t.length,l=new Array(2*s);for(i=0,r=0;r<s;)if((n=t[r++])<128)l[i++]=n;else if((a=o[n])>4)l[i++]=65533,r+=a-1;else{for(n&=2===a?31:3===a?15:7;a>1&&r<s;)n=n<<6|63&t[r++],a--;a>1?l[i++]=65533:n<65536?l[i++]=n:(n-=65536,l[i++]=55296|n>>10&1023,l[i++]=56320|1023&n)}return h(l,i)},e.utf8border=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;r>=0&&128==(192&t[r]);)r--;return r<0||0===r?e:r+o[t[r]]>e?r:e}},5562:t=>{\"use strict\";t.exports=function(t,e,r,i){for(var n=65535&t|0,a=t>>>16&65535|0,o=0;0!==r;){r-=o=r>2e3?2e3:r;do{a=a+(n=n+e[i++]|0)|0}while(--o);n%=65521,a%=65521}return n|a<<16|0}},1271:t=>{\"use strict\";t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},4299:t=>{\"use strict\";var e=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();t.exports=function(t,r,i,n){var a=e,o=n+i;t^=-1;for(var s=n;s<o;s++)t=t>>>8^a[255&(t^r[s])];return-1^t}},5789:(t,e,r)=>{\"use strict\";var i,n=r(9761),a=r(9564),o=r(5562),s=r(4299),h=r(2950),l=0,f=4,u=0,c=-2,d=-1,p=1,m=4,g=2,b=8,_=9,y=286,w=30,v=19,x=2*y+1,E=15,k=3,S=258,M=S+k+1,A=42,I=103,B=113,T=666,R=1,P=2,O=3,L=4;function C(t,e){return t.msg=h[e],e}function U(t){return(t<<1)-(t>4?9:0)}function z(t){for(var e=t.length;--e>=0;)t[e]=0}function D(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(n.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function N(t,e){a._tr_flush_block(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,D(t.strm)}function F(t,e){t.pending_buf[t.pending++]=e}function j(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function G(t,e){var r,i,n=t.max_chain_length,a=t.strstart,o=t.prev_length,s=t.nice_match,h=t.strstart>t.w_size-M?t.strstart-(t.w_size-M):0,l=t.window,f=t.w_mask,u=t.prev,c=t.strstart+S,d=l[a+o-1],p=l[a+o];t.prev_length>=t.good_match&&(n>>=2),s>t.lookahead&&(s=t.lookahead);do{if(l[(r=e)+o]===p&&l[r+o-1]===d&&l[r]===l[a]&&l[++r]===l[a+1]){a+=2,r++;do{}while(l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&a<c);if(i=S-(c-a),a=c-S,i>o){if(t.match_start=e,o=i,i>=s)break;d=l[a+o-1],p=l[a+o]}}}while((e=u[e&f])>h&&0!=--n);return o<=t.lookahead?o:t.lookahead}function H(t){var e,r,i,a,h,l,f,u,c,d,p=t.w_size;do{if(a=t.window_size-t.lookahead-t.strstart,t.strstart>=p+(p-M)){n.arraySet(t.window,t.window,p,p,0),t.match_start-=p,t.strstart-=p,t.block_start-=p,e=r=t.hash_size;do{i=t.head[--e],t.head[e]=i>=p?i-p:0}while(--r);e=r=p;do{i=t.prev[--e],t.prev[e]=i>=p?i-p:0}while(--r);a+=p}if(0===t.strm.avail_in)break;if(l=t.strm,f=t.window,u=t.strstart+t.lookahead,c=a,d=void 0,(d=l.avail_in)>c&&(d=c),r=0===d?0:(l.avail_in-=d,n.arraySet(f,l.input,l.next_in,d,u),1===l.state.wrap?l.adler=o(l.adler,f,d,u):2===l.state.wrap&&(l.adler=s(l.adler,f,d,u)),l.next_in+=d,l.total_in+=d,d),t.lookahead+=r,t.lookahead+t.insert>=k)for(h=t.strstart-t.insert,t.ins_h=t.window[h],t.ins_h=(t.ins_h<<t.hash_shift^t.window[h+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[h+k-1])&t.hash_mask,t.prev[h&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=h,h++,t.insert--,!(t.lookahead+t.insert<k)););}while(t.lookahead<M&&0!==t.strm.avail_in)}function W(t,e){for(var r,i;;){if(t.lookahead<M){if(H(t),t.lookahead<M&&e===l)return R;if(0===t.lookahead)break}if(r=0,t.lookahead>=k&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+k-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-M&&(t.match_length=G(t,r)),t.match_length>=k)if(i=a._tr_tally(t,t.strstart-t.match_start,t.match_length-k),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=k){t.match_length--;do{t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+k-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=a._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(N(t,!1),0===t.strm.avail_out))return R}return t.insert=t.strstart<k-1?t.strstart:k-1,e===f?(N(t,!0),0===t.strm.avail_out?O:L):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?R:P}function q(t,e){for(var r,i,n;;){if(t.lookahead<M){if(H(t),t.lookahead<M&&e===l)return R;if(0===t.lookahead)break}if(r=0,t.lookahead>=k&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+k-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=k-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-M&&(t.match_length=G(t,r),t.match_length<=5&&(t.strategy===p||t.match_length===k&&t.strstart-t.match_start>4096)&&(t.match_length=k-1)),t.prev_length>=k&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-k,i=a._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-k),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+k-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=k-1,t.strstart++,i&&(N(t,!1),0===t.strm.avail_out))return R}else if(t.match_available){if((i=a._tr_tally(t,0,t.window[t.strstart-1]))&&N(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return R}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=a._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<k-1?t.strstart:k-1,e===f?(N(t,!0),0===t.strm.avail_out?O:L):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?R:P}function Z(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function Y(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=b,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new n.Buf16(2*x),this.dyn_dtree=new n.Buf16(2*(2*w+1)),this.bl_tree=new n.Buf16(2*(2*v+1)),z(this.dyn_ltree),z(this.dyn_dtree),z(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new n.Buf16(E+1),this.heap=new n.Buf16(2*y+1),z(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new n.Buf16(2*y+1),z(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function V(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=g,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?A:B,t.adler=2===e.wrap?0:1,e.last_flush=l,a._tr_init(e),u):C(t,c)}function X(t){var e,r=V(t);return r===u&&((e=t.state).window_size=2*e.w_size,z(e.head),e.max_lazy_match=i[e.level].max_lazy,e.good_match=i[e.level].good_length,e.nice_match=i[e.level].nice_length,e.max_chain_length=i[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=k-1,e.match_available=0,e.ins_h=0),r}function J(t,e,r,i,a,o){if(!t)return c;var s=1;if(e===d&&(e=6),i<0?(s=0,i=-i):i>15&&(s=2,i-=16),a<1||a>_||r!==b||i<8||i>15||e<0||e>9||o<0||o>m)return C(t,c);8===i&&(i=9);var h=new Y;return t.state=h,h.strm=t,h.wrap=s,h.gzhead=null,h.w_bits=i,h.w_size=1<<h.w_bits,h.w_mask=h.w_size-1,h.hash_bits=a+7,h.hash_size=1<<h.hash_bits,h.hash_mask=h.hash_size-1,h.hash_shift=~~((h.hash_bits+k-1)/k),h.window=new n.Buf8(2*h.w_size),h.head=new n.Buf16(h.hash_size),h.prev=new n.Buf16(h.w_size),h.lit_bufsize=1<<a+6,h.pending_buf_size=4*h.lit_bufsize,h.pending_buf=new n.Buf8(h.pending_buf_size),h.d_buf=1*h.lit_bufsize,h.l_buf=3*h.lit_bufsize,h.level=e,h.strategy=o,h.method=r,X(t)}i=[new Z(0,0,0,0,(function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(H(t),0===t.lookahead&&e===l)return R;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,N(t,!1),0===t.strm.avail_out))return R;if(t.strstart-t.block_start>=t.w_size-M&&(N(t,!1),0===t.strm.avail_out))return R}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:L):(t.strstart>t.block_start&&(N(t,!1),t.strm.avail_out),R)})),new Z(4,4,8,4,W),new Z(4,5,16,8,W),new Z(4,6,32,32,W),new Z(4,4,16,16,q),new Z(8,16,32,32,q),new Z(8,16,128,128,q),new Z(8,32,128,256,q),new Z(32,128,258,1024,q),new Z(32,258,258,4096,q)],e.deflateInit=function(t,e){return J(t,e,b,15,8,0)},e.deflateInit2=J,e.deflateReset=X,e.deflateResetKeep=V,e.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?c:(t.state.gzhead=e,u):c},e.deflate=function(t,e){var r,n,o,h;if(!t||!t.state||e>5||e<0)return t?C(t,c):c;if(n=t.state,!t.output||!t.input&&0!==t.avail_in||n.status===T&&e!==f)return C(t,0===t.avail_out?-5:c);if(n.strm=t,r=n.last_flush,n.last_flush=e,n.status===A)if(2===n.wrap)t.adler=0,F(n,31),F(n,139),F(n,8),n.gzhead?(F(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),F(n,255&n.gzhead.time),F(n,n.gzhead.time>>8&255),F(n,n.gzhead.time>>16&255),F(n,n.gzhead.time>>24&255),F(n,9===n.level?2:n.strategy>=2||n.level<2?4:0),F(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(F(n,255&n.gzhead.extra.length),F(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(t.adler=s(t.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69):(F(n,0),F(n,0),F(n,0),F(n,0),F(n,0),F(n,9===n.level?2:n.strategy>=2||n.level<2?4:0),F(n,3),n.status=B);else{var d=b+(n.w_bits-8<<4)<<8;d|=(n.strategy>=2||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(d|=32),d+=31-d%31,n.status=B,j(n,d),0!==n.strstart&&(j(n,t.adler>>>16),j(n,65535&t.adler)),t.adler=1}if(69===n.status)if(n.gzhead.extra){for(o=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),D(t),o=n.pending,n.pending!==n.pending_buf_size));)F(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=73)}else n.status=73;if(73===n.status)if(n.gzhead.name){o=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),D(t),o=n.pending,n.pending===n.pending_buf_size)){h=1;break}h=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,F(n,h)}while(0!==h);n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),0===h&&(n.gzindex=0,n.status=91)}else n.status=91;if(91===n.status)if(n.gzhead.comment){o=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),D(t),o=n.pending,n.pending===n.pending_buf_size)){h=1;break}h=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,F(n,h)}while(0!==h);n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),0===h&&(n.status=I)}else n.status=I;if(n.status===I&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&D(t),n.pending+2<=n.pending_buf_size&&(F(n,255&t.adler),F(n,t.adler>>8&255),t.adler=0,n.status=B)):n.status=B),0!==n.pending){if(D(t),0===t.avail_out)return n.last_flush=-1,u}else if(0===t.avail_in&&U(e)<=U(r)&&e!==f)return C(t,-5);if(n.status===T&&0!==t.avail_in)return C(t,-5);if(0!==t.avail_in||0!==n.lookahead||e!==l&&n.status!==T){var p=2===n.strategy?function(t,e){for(var r;;){if(0===t.lookahead&&(H(t),0===t.lookahead)){if(e===l)return R;break}if(t.match_length=0,r=a._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(N(t,!1),0===t.strm.avail_out))return R}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:L):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?R:P}(n,e):3===n.strategy?function(t,e){for(var r,i,n,o,s=t.window;;){if(t.lookahead<=S){if(H(t),t.lookahead<=S&&e===l)return R;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=k&&t.strstart>0&&(i=s[n=t.strstart-1])===s[++n]&&i===s[++n]&&i===s[++n]){o=t.strstart+S;do{}while(i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&n<o);t.match_length=S-(o-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=k?(r=a._tr_tally(t,1,t.match_length-k),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=a._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(N(t,!1),0===t.strm.avail_out))return R}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:L):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?R:P}(n,e):i[n.level].func(n,e);if(p!==O&&p!==L||(n.status=T),p===R||p===O)return 0===t.avail_out&&(n.last_flush=-1),u;if(p===P&&(1===e?a._tr_align(n):5!==e&&(a._tr_stored_block(n,0,0,!1),3===e&&(z(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),D(t),0===t.avail_out))return n.last_flush=-1,u}return e!==f?u:n.wrap<=0?1:(2===n.wrap?(F(n,255&t.adler),F(n,t.adler>>8&255),F(n,t.adler>>16&255),F(n,t.adler>>24&255),F(n,255&t.total_in),F(n,t.total_in>>8&255),F(n,t.total_in>>16&255),F(n,t.total_in>>24&255)):(j(n,t.adler>>>16),j(n,65535&t.adler)),D(t),n.wrap>0&&(n.wrap=-n.wrap),0!==n.pending?u:1)},e.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==A&&69!==e&&73!==e&&91!==e&&e!==I&&e!==B&&e!==T?C(t,c):(t.state=null,e===B?C(t,-3):u):c},e.deflateSetDictionary=function(t,e){var r,i,a,s,h,l,f,d,p=e.length;if(!t||!t.state)return c;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==A||r.lookahead)return c;for(1===s&&(t.adler=o(t.adler,e,p,0)),r.wrap=0,p>=r.w_size&&(0===s&&(z(r.head),r.strstart=0,r.block_start=0,r.insert=0),d=new n.Buf8(r.w_size),n.arraySet(d,e,p-r.w_size,r.w_size,0),e=d,p=r.w_size),h=t.avail_in,l=t.next_in,f=t.input,t.avail_in=p,t.next_in=0,t.input=e,H(r);r.lookahead>=k;){i=r.strstart,a=r.lookahead-(k-1);do{r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+k-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++}while(--a);r.strstart=i,r.lookahead=k-1,H(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=k-1,r.match_available=0,t.next_in=l,t.input=f,t.avail_in=h,r.wrap=s,u},e.deflateInfo=\"pako deflate (from Nodeca project)\"},7357:t=>{\"use strict\";t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\"\",this.comment=\"\",this.hcrc=0,this.done=!1}},4980:t=>{\"use strict\";t.exports=function(t,e){var r,i,n,a,o,s,h,l,f,u,c,d,p,m,g,b,_,y,w,v,x,E,k,S,M;r=t.state,i=t.next_in,S=t.input,n=i+(t.avail_in-5),a=t.next_out,M=t.output,o=a-(e-t.avail_out),s=a+(t.avail_out-257),h=r.dmax,l=r.wsize,f=r.whave,u=r.wnext,c=r.window,d=r.hold,p=r.bits,m=r.lencode,g=r.distcode,b=(1<<r.lenbits)-1,_=(1<<r.distbits)-1;t:do{p<15&&(d+=S[i++]<<p,p+=8,d+=S[i++]<<p,p+=8),y=m[d&b];e:for(;;){if(d>>>=w=y>>>24,p-=w,0==(w=y>>>16&255))M[a++]=65535&y;else{if(!(16&w)){if(0==(64&w)){y=m[(65535&y)+(d&(1<<w)-1)];continue e}if(32&w){r.mode=12;break t}t.msg=\"invalid literal/length code\",r.mode=30;break t}v=65535&y,(w&=15)&&(p<w&&(d+=S[i++]<<p,p+=8),v+=d&(1<<w)-1,d>>>=w,p-=w),p<15&&(d+=S[i++]<<p,p+=8,d+=S[i++]<<p,p+=8),y=g[d&_];r:for(;;){if(d>>>=w=y>>>24,p-=w,!(16&(w=y>>>16&255))){if(0==(64&w)){y=g[(65535&y)+(d&(1<<w)-1)];continue r}t.msg=\"invalid distance code\",r.mode=30;break t}if(x=65535&y,p<(w&=15)&&(d+=S[i++]<<p,(p+=8)<w&&(d+=S[i++]<<p,p+=8)),(x+=d&(1<<w)-1)>h){t.msg=\"invalid distance too far back\",r.mode=30;break t}if(d>>>=w,p-=w,x>(w=a-o)){if((w=x-w)>f&&r.sane){t.msg=\"invalid distance too far back\",r.mode=30;break t}if(E=0,k=c,0===u){if(E+=l-w,w<v){v-=w;do{M[a++]=c[E++]}while(--w);E=a-x,k=M}}else if(u<w){if(E+=l+u-w,(w-=u)<v){v-=w;do{M[a++]=c[E++]}while(--w);if(E=0,u<v){v-=w=u;do{M[a++]=c[E++]}while(--w);E=a-x,k=M}}}else if(E+=u-w,w<v){v-=w;do{M[a++]=c[E++]}while(--w);E=a-x,k=M}for(;v>2;)M[a++]=k[E++],M[a++]=k[E++],M[a++]=k[E++],v-=3;v&&(M[a++]=k[E++],v>1&&(M[a++]=k[E++]))}else{E=a-x;do{M[a++]=M[E++],M[a++]=M[E++],M[a++]=M[E++],v-=3}while(v>2);v&&(M[a++]=M[E++],v>1&&(M[a++]=M[E++]))}break}}break}}while(i<n&&a<s);i-=v=p>>3,d&=(1<<(p-=v<<3))-1,t.next_in=i,t.next_out=a,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=a<s?s-a+257:257-(a-s),r.hold=d,r.bits=p}},5020:(t,e,r)=>{\"use strict\";var i=r(9761),n=r(5562),a=r(4299),o=r(4980),s=r(881),h=1,l=2,f=0,u=-2,c=1,d=12,p=30,m=852,g=592;function b(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function _(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new i.Buf16(320),this.work=new i.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function y(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg=\"\",e.wrap&&(t.adler=1&e.wrap),e.mode=c,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new i.Buf32(m),e.distcode=e.distdyn=new i.Buf32(g),e.sane=1,e.back=-1,f):u}function w(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,y(t)):u}function v(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?u:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,w(t))):u}function x(t,e){var r,i;return t?(i=new _,t.state=i,i.window=null,(r=v(t,e))!==f&&(t.state=null),r):u}var E,k,S=!0;function M(t){if(S){var e;for(E=new i.Buf32(512),k=new i.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(s(h,t.lens,0,288,E,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;s(l,t.lens,0,32,k,0,t.work,{bits:5}),S=!1}t.lencode=E,t.lenbits=9,t.distcode=k,t.distbits=5}function A(t,e,r,n){var a,o=t.state;return null===o.window&&(o.wsize=1<<o.wbits,o.wnext=0,o.whave=0,o.window=new i.Buf8(o.wsize)),n>=o.wsize?(i.arraySet(o.window,e,r-o.wsize,o.wsize,0),o.wnext=0,o.whave=o.wsize):((a=o.wsize-o.wnext)>n&&(a=n),i.arraySet(o.window,e,r-n,a,o.wnext),(n-=a)?(i.arraySet(o.window,e,r-n,n,0),o.wnext=n,o.whave=o.wsize):(o.wnext+=a,o.wnext===o.wsize&&(o.wnext=0),o.whave<o.wsize&&(o.whave+=a))),0}e.inflateReset=w,e.inflateReset2=v,e.inflateResetKeep=y,e.inflateInit=function(t){return x(t,15)},e.inflateInit2=x,e.inflate=function(t,e){var r,m,g,_,y,w,v,x,E,k,S,I,B,T,R,P,O,L,C,U,z,D,N,F,j=0,G=new i.Buf8(4),H=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return u;(r=t.state).mode===d&&(r.mode=13),y=t.next_out,g=t.output,v=t.avail_out,_=t.next_in,m=t.input,w=t.avail_in,x=r.hold,E=r.bits,k=w,S=v,D=f;t:for(;;)switch(r.mode){case c:if(0===r.wrap){r.mode=13;break}for(;E<16;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}if(2&r.wrap&&35615===x){r.check=0,G[0]=255&x,G[1]=x>>>8&255,r.check=a(r.check,G,2,0),x=0,E=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&x)<<8)+(x>>8))%31){t.msg=\"incorrect header check\",r.mode=p;break}if(8!=(15&x)){t.msg=\"unknown compression method\",r.mode=p;break}if(E-=4,z=8+(15&(x>>>=4)),0===r.wbits)r.wbits=z;else if(z>r.wbits){t.msg=\"invalid window size\",r.mode=p;break}r.dmax=1<<z,t.adler=r.check=1,r.mode=512&x?10:d,x=0,E=0;break;case 2:for(;E<16;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}if(r.flags=x,8!=(255&r.flags)){t.msg=\"unknown compression method\",r.mode=p;break}if(57344&r.flags){t.msg=\"unknown header flags set\",r.mode=p;break}r.head&&(r.head.text=x>>8&1),512&r.flags&&(G[0]=255&x,G[1]=x>>>8&255,r.check=a(r.check,G,2,0)),x=0,E=0,r.mode=3;case 3:for(;E<32;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}r.head&&(r.head.time=x),512&r.flags&&(G[0]=255&x,G[1]=x>>>8&255,G[2]=x>>>16&255,G[3]=x>>>24&255,r.check=a(r.check,G,4,0)),x=0,E=0,r.mode=4;case 4:for(;E<16;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}r.head&&(r.head.xflags=255&x,r.head.os=x>>8),512&r.flags&&(G[0]=255&x,G[1]=x>>>8&255,r.check=a(r.check,G,2,0)),x=0,E=0,r.mode=5;case 5:if(1024&r.flags){for(;E<16;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}r.length=x,r.head&&(r.head.extra_len=x),512&r.flags&&(G[0]=255&x,G[1]=x>>>8&255,r.check=a(r.check,G,2,0)),x=0,E=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&((I=r.length)>w&&(I=w),I&&(r.head&&(z=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),i.arraySet(r.head.extra,m,_,I,z)),512&r.flags&&(r.check=a(r.check,m,I,_)),w-=I,_+=I,r.length-=I),r.length))break t;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===w)break t;I=0;do{z=m[_+I++],r.head&&z&&r.length<65536&&(r.head.name+=String.fromCharCode(z))}while(z&&I<w);if(512&r.flags&&(r.check=a(r.check,m,I,_)),w-=I,_+=I,z)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===w)break t;I=0;do{z=m[_+I++],r.head&&z&&r.length<65536&&(r.head.comment+=String.fromCharCode(z))}while(z&&I<w);if(512&r.flags&&(r.check=a(r.check,m,I,_)),w-=I,_+=I,z)break t}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;E<16;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}if(x!==(65535&r.check)){t.msg=\"header crc mismatch\",r.mode=p;break}x=0,E=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=d;break;case 10:for(;E<32;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}t.adler=r.check=b(x),x=0,E=0,r.mode=11;case 11:if(0===r.havedict)return t.next_out=y,t.avail_out=v,t.next_in=_,t.avail_in=w,r.hold=x,r.bits=E,2;t.adler=r.check=1,r.mode=d;case d:if(5===e||6===e)break t;case 13:if(r.last){x>>>=7&E,E-=7&E,r.mode=27;break}for(;E<3;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}switch(r.last=1&x,E-=1,3&(x>>>=1)){case 0:r.mode=14;break;case 1:if(M(r),r.mode=20,6===e){x>>>=2,E-=2;break t}break;case 2:r.mode=17;break;case 3:t.msg=\"invalid block type\",r.mode=p}x>>>=2,E-=2;break;case 14:for(x>>>=7&E,E-=7&E;E<32;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}if((65535&x)!=(x>>>16^65535)){t.msg=\"invalid stored block lengths\",r.mode=p;break}if(r.length=65535&x,x=0,E=0,r.mode=15,6===e)break t;case 15:r.mode=16;case 16:if(I=r.length){if(I>w&&(I=w),I>v&&(I=v),0===I)break t;i.arraySet(g,m,_,I,y),w-=I,_+=I,v-=I,y+=I,r.length-=I;break}r.mode=d;break;case 17:for(;E<14;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}if(r.nlen=257+(31&x),x>>>=5,E-=5,r.ndist=1+(31&x),x>>>=5,E-=5,r.ncode=4+(15&x),x>>>=4,E-=4,r.nlen>286||r.ndist>30){t.msg=\"too many length or distance symbols\",r.mode=p;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;E<3;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}r.lens[H[r.have++]]=7&x,x>>>=3,E-=3}for(;r.have<19;)r.lens[H[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,N={bits:r.lenbits},D=s(0,r.lens,0,19,r.lencode,0,r.work,N),r.lenbits=N.bits,D){t.msg=\"invalid code lengths set\",r.mode=p;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;P=(j=r.lencode[x&(1<<r.lenbits)-1])>>>16&255,O=65535&j,!((R=j>>>24)<=E);){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}if(O<16)x>>>=R,E-=R,r.lens[r.have++]=O;else{if(16===O){for(F=R+2;E<F;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}if(x>>>=R,E-=R,0===r.have){t.msg=\"invalid bit length repeat\",r.mode=p;break}z=r.lens[r.have-1],I=3+(3&x),x>>>=2,E-=2}else if(17===O){for(F=R+3;E<F;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}E-=R,z=0,I=3+(7&(x>>>=R)),x>>>=3,E-=3}else{for(F=R+7;E<F;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}E-=R,z=0,I=11+(127&(x>>>=R)),x>>>=7,E-=7}if(r.have+I>r.nlen+r.ndist){t.msg=\"invalid bit length repeat\",r.mode=p;break}for(;I--;)r.lens[r.have++]=z}}if(r.mode===p)break;if(0===r.lens[256]){t.msg=\"invalid code -- missing end-of-block\",r.mode=p;break}if(r.lenbits=9,N={bits:r.lenbits},D=s(h,r.lens,0,r.nlen,r.lencode,0,r.work,N),r.lenbits=N.bits,D){t.msg=\"invalid literal/lengths set\",r.mode=p;break}if(r.distbits=6,r.distcode=r.distdyn,N={bits:r.distbits},D=s(l,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,N),r.distbits=N.bits,D){t.msg=\"invalid distances set\",r.mode=p;break}if(r.mode=20,6===e)break t;case 20:r.mode=21;case 21:if(w>=6&&v>=258){t.next_out=y,t.avail_out=v,t.next_in=_,t.avail_in=w,r.hold=x,r.bits=E,o(t,S),y=t.next_out,g=t.output,v=t.avail_out,_=t.next_in,m=t.input,w=t.avail_in,x=r.hold,E=r.bits,r.mode===d&&(r.back=-1);break}for(r.back=0;P=(j=r.lencode[x&(1<<r.lenbits)-1])>>>16&255,O=65535&j,!((R=j>>>24)<=E);){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}if(P&&0==(240&P)){for(L=R,C=P,U=O;P=(j=r.lencode[U+((x&(1<<L+C)-1)>>L)])>>>16&255,O=65535&j,!(L+(R=j>>>24)<=E);){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}x>>>=L,E-=L,r.back+=L}if(x>>>=R,E-=R,r.back+=R,r.length=O,0===P){r.mode=26;break}if(32&P){r.back=-1,r.mode=d;break}if(64&P){t.msg=\"invalid literal/length code\",r.mode=p;break}r.extra=15&P,r.mode=22;case 22:if(r.extra){for(F=r.extra;E<F;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}r.length+=x&(1<<r.extra)-1,x>>>=r.extra,E-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;P=(j=r.distcode[x&(1<<r.distbits)-1])>>>16&255,O=65535&j,!((R=j>>>24)<=E);){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}if(0==(240&P)){for(L=R,C=P,U=O;P=(j=r.distcode[U+((x&(1<<L+C)-1)>>L)])>>>16&255,O=65535&j,!(L+(R=j>>>24)<=E);){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}x>>>=L,E-=L,r.back+=L}if(x>>>=R,E-=R,r.back+=R,64&P){t.msg=\"invalid distance code\",r.mode=p;break}r.offset=O,r.extra=15&P,r.mode=24;case 24:if(r.extra){for(F=r.extra;E<F;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}r.offset+=x&(1<<r.extra)-1,x>>>=r.extra,E-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg=\"invalid distance too far back\",r.mode=p;break}r.mode=25;case 25:if(0===v)break t;if(I=S-v,r.offset>I){if((I=r.offset-I)>r.whave&&r.sane){t.msg=\"invalid distance too far back\",r.mode=p;break}I>r.wnext?(I-=r.wnext,B=r.wsize-I):B=r.wnext-I,I>r.length&&(I=r.length),T=r.window}else T=g,B=y-r.offset,I=r.length;I>v&&(I=v),v-=I,r.length-=I;do{g[y++]=T[B++]}while(--I);0===r.length&&(r.mode=21);break;case 26:if(0===v)break t;g[y++]=r.length,v--,r.mode=21;break;case 27:if(r.wrap){for(;E<32;){if(0===w)break t;w--,x|=m[_++]<<E,E+=8}if(S-=v,t.total_out+=S,r.total+=S,S&&(t.adler=r.check=r.flags?a(r.check,g,S,y-S):n(r.check,g,S,y-S)),S=v,(r.flags?x:b(x))!==r.check){t.msg=\"incorrect data check\",r.mode=p;break}x=0,E=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;E<32;){if(0===w)break t;w--,x+=m[_++]<<E,E+=8}if(x!==(4294967295&r.total)){t.msg=\"incorrect length check\",r.mode=p;break}x=0,E=0}r.mode=29;case 29:D=1;break t;case p:D=-3;break t;case 31:return-4;default:return u}return t.next_out=y,t.avail_out=v,t.next_in=_,t.avail_in=w,r.hold=x,r.bits=E,(r.wsize||S!==t.avail_out&&r.mode<p&&(r.mode<27||4!==e))&&A(t,t.output,t.next_out,S-t.avail_out)?(r.mode=31,-4):(k-=t.avail_in,S-=t.avail_out,t.total_in+=k,t.total_out+=S,r.total+=S,r.wrap&&S&&(t.adler=r.check=r.flags?a(r.check,g,S,t.next_out-S):n(r.check,g,S,t.next_out-S)),t.data_type=r.bits+(r.last?64:0)+(r.mode===d?128:0)+(20===r.mode||15===r.mode?256:0),(0===k&&0===S||4===e)&&D===f&&(D=-5),D)},e.inflateEnd=function(t){if(!t||!t.state)return u;var e=t.state;return e.window&&(e.window=null),t.state=null,f},e.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?u:(r.head=e,e.done=!1,f):u},e.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&11!==r.mode?u:11===r.mode&&n(1,e,i,0)!==r.check?-3:A(t,e,i,i)?(r.mode=31,-4):(r.havedict=1,f):u},e.inflateInfo=\"pako inflate (from Nodeca project)\"},881:(t,e,r)=>{\"use strict\";var i=r(9761),n=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],a=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],o=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],s=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(t,e,r,h,l,f,u,c){var d,p,m,g,b,_,y,w,v,x=c.bits,E=0,k=0,S=0,M=0,A=0,I=0,B=0,T=0,R=0,P=0,O=null,L=0,C=new i.Buf16(16),U=new i.Buf16(16),z=null,D=0;for(E=0;E<=15;E++)C[E]=0;for(k=0;k<h;k++)C[e[r+k]]++;for(A=x,M=15;M>=1&&0===C[M];M--);if(A>M&&(A=M),0===M)return l[f++]=20971520,l[f++]=20971520,c.bits=1,0;for(S=1;S<M&&0===C[S];S++);for(A<S&&(A=S),T=1,E=1;E<=15;E++)if(T<<=1,(T-=C[E])<0)return-1;if(T>0&&(0===t||1!==M))return-1;for(U[1]=0,E=1;E<15;E++)U[E+1]=U[E]+C[E];for(k=0;k<h;k++)0!==e[r+k]&&(u[U[e[r+k]]++]=k);if(0===t?(O=z=u,_=19):1===t?(O=n,L-=257,z=a,D-=257,_=256):(O=o,z=s,_=-1),P=0,k=0,E=S,b=f,I=A,B=0,m=-1,g=(R=1<<A)-1,1===t&&R>852||2===t&&R>592)return 1;for(;;){y=E-B,u[k]<_?(w=0,v=u[k]):u[k]>_?(w=z[D+u[k]],v=O[L+u[k]]):(w=96,v=0),d=1<<E-B,S=p=1<<I;do{l[b+(P>>B)+(p-=d)]=y<<24|w<<16|v|0}while(0!==p);for(d=1<<E-1;P&d;)d>>=1;if(0!==d?(P&=d-1,P+=d):P=0,k++,0==--C[E]){if(E===M)break;E=e[r+u[k]]}if(E>A&&(P&g)!==m){for(0===B&&(B=A),b+=S,T=1<<(I=E-B);I+B<M&&!((T-=C[I+B])<=0);)I++,T<<=1;if(R+=1<<I,1===t&&R>852||2===t&&R>592)return 1;l[m=P&g]=A<<24|I<<16|b-f|0}}return 0!==P&&(l[b+P]=E-B<<24|64<<16|0),c.bits=A,0}},2950:t=>{\"use strict\";t.exports={2:\"need dictionary\",1:\"stream end\",0:\"\",\"-1\":\"file error\",\"-2\":\"stream error\",\"-3\":\"data error\",\"-4\":\"insufficient memory\",\"-5\":\"buffer error\",\"-6\":\"incompatible version\"}},9564:(t,e,r)=>{\"use strict\";var i=r(9761);function n(t){for(var e=t.length;--e>=0;)t[e]=0}var a=0,o=256,s=o+1+29,h=30,l=19,f=2*s+1,u=15,c=16,d=256,p=16,m=17,g=18,b=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],_=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],y=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],w=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],v=new Array(2*(s+2));n(v);var x=new Array(2*h);n(x);var E=new Array(512);n(E);var k=new Array(256);n(k);var S=new Array(29);n(S);var M,A,I,B=new Array(h);function T(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function R(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function P(t){return t<256?E[t]:E[256+(t>>>7)]}function O(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function L(t,e,r){t.bi_valid>c-r?(t.bi_buf|=e<<t.bi_valid&65535,O(t,t.bi_buf),t.bi_buf=e>>c-t.bi_valid,t.bi_valid+=r-c):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function C(t,e,r){L(t,r[2*e],r[2*e+1])}function U(t,e){var r=0;do{r|=1&t,t>>>=1,r<<=1}while(--e>0);return r>>>1}function z(t,e,r){var i,n,a=new Array(u+1),o=0;for(i=1;i<=u;i++)a[i]=o=o+r[i-1]<<1;for(n=0;n<=e;n++){var s=t[2*n+1];0!==s&&(t[2*n]=U(a[s]++,s))}}function D(t){var e;for(e=0;e<s;e++)t.dyn_ltree[2*e]=0;for(e=0;e<h;e++)t.dyn_dtree[2*e]=0;for(e=0;e<l;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*d]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function N(t){t.bi_valid>8?O(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function F(t,e,r,i){var n=2*e,a=2*r;return t[n]<t[a]||t[n]===t[a]&&i[e]<=i[r]}function j(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&F(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!F(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function G(t,e,r){var i,n,a,s,h=0;if(0!==t.last_lit)do{i=t.pending_buf[t.d_buf+2*h]<<8|t.pending_buf[t.d_buf+2*h+1],n=t.pending_buf[t.l_buf+h],h++,0===i?C(t,n,e):(C(t,(a=k[n])+o+1,e),0!==(s=b[a])&&L(t,n-=S[a],s),C(t,a=P(--i),r),0!==(s=_[a])&&L(t,i-=B[a],s))}while(h<t.last_lit);C(t,d,e)}function H(t,e){var r,i,n,a=e.dyn_tree,o=e.stat_desc.static_tree,s=e.stat_desc.has_stree,h=e.stat_desc.elems,l=-1;for(t.heap_len=0,t.heap_max=f,r=0;r<h;r++)0!==a[2*r]?(t.heap[++t.heap_len]=l=r,t.depth[r]=0):a[2*r+1]=0;for(;t.heap_len<2;)a[2*(n=t.heap[++t.heap_len]=l<2?++l:0)]=1,t.depth[n]=0,t.opt_len--,s&&(t.static_len-=o[2*n+1]);for(e.max_code=l,r=t.heap_len>>1;r>=1;r--)j(t,a,r);n=h;do{r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],j(t,a,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,a[2*n]=a[2*r]+a[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,a[2*r+1]=a[2*i+1]=n,t.heap[1]=n++,j(t,a,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,a,o,s,h=e.dyn_tree,l=e.max_code,c=e.stat_desc.static_tree,d=e.stat_desc.has_stree,p=e.stat_desc.extra_bits,m=e.stat_desc.extra_base,g=e.stat_desc.max_length,b=0;for(a=0;a<=u;a++)t.bl_count[a]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<f;r++)(a=h[2*h[2*(i=t.heap[r])+1]+1]+1)>g&&(a=g,b++),h[2*i+1]=a,i>l||(t.bl_count[a]++,o=0,i>=m&&(o=p[i-m]),s=h[2*i],t.opt_len+=s*(a+o),d&&(t.static_len+=s*(c[2*i+1]+o)));if(0!==b){do{for(a=g-1;0===t.bl_count[a];)a--;t.bl_count[a]--,t.bl_count[a+1]+=2,t.bl_count[g]--,b-=2}while(b>0);for(a=g;0!==a;a--)for(i=t.bl_count[a];0!==i;)(n=t.heap[--r])>l||(h[2*n+1]!==a&&(t.opt_len+=(a-h[2*n+1])*h[2*n],h[2*n+1]=a),i--)}}(t,e),z(a,l,t.bl_count)}function W(t,e,r){var i,n,a=-1,o=e[1],s=0,h=7,l=4;for(0===o&&(h=138,l=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=o,o=e[2*(i+1)+1],++s<h&&n===o||(s<l?t.bl_tree[2*n]+=s:0!==n?(n!==a&&t.bl_tree[2*n]++,t.bl_tree[2*p]++):s<=10?t.bl_tree[2*m]++:t.bl_tree[2*g]++,s=0,a=n,0===o?(h=138,l=3):n===o?(h=6,l=3):(h=7,l=4))}function q(t,e,r){var i,n,a=-1,o=e[1],s=0,h=7,l=4;for(0===o&&(h=138,l=3),i=0;i<=r;i++)if(n=o,o=e[2*(i+1)+1],!(++s<h&&n===o)){if(s<l)do{C(t,n,t.bl_tree)}while(0!=--s);else 0!==n?(n!==a&&(C(t,n,t.bl_tree),s--),C(t,p,t.bl_tree),L(t,s-3,2)):s<=10?(C(t,m,t.bl_tree),L(t,s-3,3)):(C(t,g,t.bl_tree),L(t,s-11,7));s=0,a=n,0===o?(h=138,l=3):n===o?(h=6,l=3):(h=7,l=4)}}n(B);var Z=!1;function Y(t,e,r,n){L(t,(a<<1)+(n?1:0),3),function(t,e,r,n){N(t),O(t,r),O(t,~r),i.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r)}e._tr_init=function(t){Z||(function(){var t,e,r,i,n,a=new Array(u+1);for(r=0,i=0;i<28;i++)for(S[i]=r,t=0;t<1<<b[i];t++)k[r++]=i;for(k[r-1]=i,n=0,i=0;i<16;i++)for(B[i]=n,t=0;t<1<<_[i];t++)E[n++]=i;for(n>>=7;i<h;i++)for(B[i]=n<<7,t=0;t<1<<_[i]-7;t++)E[256+n++]=i;for(e=0;e<=u;e++)a[e]=0;for(t=0;t<=143;)v[2*t+1]=8,t++,a[8]++;for(;t<=255;)v[2*t+1]=9,t++,a[9]++;for(;t<=279;)v[2*t+1]=7,t++,a[7]++;for(;t<=287;)v[2*t+1]=8,t++,a[8]++;for(z(v,s+1,a),t=0;t<h;t++)x[2*t+1]=5,x[2*t]=U(t,5);M=new T(v,b,o+1,s,u),A=new T(x,_,0,h,u),I=new T(new Array(0),y,0,l,7)}(),Z=!0),t.l_desc=new R(t.dyn_ltree,M),t.d_desc=new R(t.dyn_dtree,A),t.bl_desc=new R(t.bl_tree,I),t.bi_buf=0,t.bi_valid=0,D(t)},e._tr_stored_block=Y,e._tr_flush_block=function(t,e,r,i){var n,a,s=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<o;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0}(t)),H(t,t.l_desc),H(t,t.d_desc),s=function(t){var e;for(W(t,t.dyn_ltree,t.l_desc.max_code),W(t,t.dyn_dtree,t.d_desc.max_code),H(t,t.bl_desc),e=l-1;e>=3&&0===t.bl_tree[2*w[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),n=t.opt_len+3+7>>>3,(a=t.static_len+3+7>>>3)<=n&&(n=a)):n=a=r+5,r+4<=n&&-1!==e?Y(t,e,r,i):4===t.strategy||a===n?(L(t,2+(i?1:0),3),G(t,v,x)):(L(t,4+(i?1:0),3),function(t,e,r,i){var n;for(L(t,e-257,5),L(t,r-1,5),L(t,i-4,4),n=0;n<i;n++)L(t,t.bl_tree[2*w[n]+1],3);q(t,t.dyn_ltree,e-1),q(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,s+1),G(t,t.dyn_ltree,t.dyn_dtree)),D(t),i&&N(t)},e._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(k[r]+o+1)]++,t.dyn_dtree[2*P(e)]++),t.last_lit===t.lit_bufsize-1},e._tr_align=function(t){L(t,2,3),C(t,d,v),function(t){16===t.bi_valid?(O(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},744:t=>{\"use strict\";t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\"\",this.state=null,this.data_type=2,this.adler=0}},4398:t=>{function e(t,e){if(!(t=t.replace(/\\t+/g,\" \").trim()))return null;var i=t.indexOf(\" \");if(-1===i)throw new Error(\"no named row at line \"+e);var n=t.substring(0,i);t=(t=(t=(t=t.substring(i+1)).replace(/letter=[\\'\\\"]\\S+[\\'\\\"]/gi,\"\")).split(\"=\")).map((function(t){return t.trim().match(/(\".*?\"|[^\"\\s]+)+(?=\\s*|\\s*$)/g)}));for(var a=[],o=0;o<t.length;o++){var s=t[o];0===o?a.push({key:s[0],data:\"\"}):o===t.length-1?a[a.length-1].data=r(s[0]):(a[a.length-1].data=r(s[0]),a.push({key:s[1],data:\"\"}))}var h={key:n,data:{}};return a.forEach((function(t){h.data[t.key]=t.data})),h}function r(t){return t&&0!==t.length?0===t.indexOf('\"')||0===t.indexOf(\"'\")?t.substring(1,t.length-1):-1!==t.indexOf(\",\")?function(t){return t.split(\",\").map((function(t){return parseInt(t,10)}))}(t):parseInt(t,10):\"\"}t.exports=function(t){if(!t)throw new Error(\"no data provided\");var r={pages:[],chars:[],kernings:[]},i=(t=t.toString().trim()).split(/\\r\\n?|\\n/g);if(0===i.length)throw new Error(\"no data in BMFont file\");for(var n=0;n<i.length;n++){var a=e(i[n],n);if(a)if(\"page\"===a.key){if(\"number\"!=typeof a.data.id)throw new Error(\"malformed file at line \"+n+\" -- needs page id=N\");if(\"string\"!=typeof a.data.file)throw new Error(\"malformed file at line \"+n+' -- needs page file=\"path\"');r.pages[a.data.id]=a.data.file}else\"chars\"===a.key||\"kernings\"===a.key||(\"char\"===a.key?r.chars.push(a.data):\"kerning\"===a.key?r.kernings.push(a.data):r[a.key]=a.data)}return r}},8438:t=>{var e=[66,77,70];function r(t,e,r){if(r>e.length-1)return 0;var n=e.readUInt8(r++),a=e.readInt32LE(r);switch(r+=4,n){case 1:t.info=function(t,e){var r={};r.size=t.readInt16LE(e);var n=t.readUInt8(e+2);return r.smooth=n>>7&1,r.unicode=n>>6&1,r.italic=n>>5&1,r.bold=n>>4&1,n>>3&1&&(r.fixedHeight=1),r.charset=t.readUInt8(e+3)||\"\",r.stretchH=t.readUInt16LE(e+4),r.aa=t.readUInt8(e+6),r.padding=[t.readInt8(e+7),t.readInt8(e+8),t.readInt8(e+9),t.readInt8(e+10)],r.spacing=[t.readInt8(e+11),t.readInt8(e+12)],r.outline=t.readUInt8(e+13),r.face=function(t,e){return i(t,e).toString(\"utf8\")}(t,e+14),r}(e,r);break;case 2:t.common=function(t,e){var r={};return r.lineHeight=t.readUInt16LE(e),r.base=t.readUInt16LE(e+2),r.scaleW=t.readUInt16LE(e+4),r.scaleH=t.readUInt16LE(e+6),r.pages=t.readUInt16LE(e+8),t.readUInt8(e+10),r.packed=0,r.alphaChnl=t.readUInt8(e+11),r.redChnl=t.readUInt8(e+12),r.greenChnl=t.readUInt8(e+13),r.blueChnl=t.readUInt8(e+14),r}(e,r);break;case 3:t.pages=function(t,e,r){for(var n=[],a=i(t,e),o=a.length+1,s=r/o,h=0;h<s;h++)n[h]=t.slice(e,e+a.length).toString(\"utf8\"),e+=o;return n}(e,r,a);break;case 4:t.chars=function(t,e,r){for(var i=[],n=r/20,a=0;a<n;a++){var o={},s=20*a;o.id=t.readUInt32LE(e+0+s),o.x=t.readUInt16LE(e+4+s),o.y=t.readUInt16LE(e+6+s),o.width=t.readUInt16LE(e+8+s),o.height=t.readUInt16LE(e+10+s),o.xoffset=t.readInt16LE(e+12+s),o.yoffset=t.readInt16LE(e+14+s),o.xadvance=t.readInt16LE(e+16+s),o.page=t.readUInt8(e+18+s),o.chnl=t.readUInt8(e+19+s),i[a]=o}return i}(e,r,a);break;case 5:t.kernings=function(t,e,r){for(var i=[],n=r/10,a=0;a<n;a++){var o={},s=10*a;o.first=t.readUInt32LE(e+0+s),o.second=t.readUInt32LE(e+4+s),o.amount=t.readInt16LE(e+8+s),i[a]=o}return i}(e,r,a)}return 5+a}function i(t,e){for(var r=e;r<t.length&&0!==t[r];r++);return t.slice(e,r)}t.exports=function(t){if(t.length<6)throw new Error(\"invalid buffer length for BMFont\");var i=e.every((function(e,r){return t.readUInt8(r)===e}));if(!i)throw new Error(\"BMFont missing BMF byte header\");var n=3;if(t.readUInt8(n++)>3)throw new Error(\"Only supports BMFont Binary v3 (BMFont App v1.10)\");for(var a={kernings:[],chars:[]},o=0;o<5;o++)n+=r(a,t,n);return a}},5947:(t,e,r)=>{var i=r(403),n=r(1596),a={scaleh:\"scaleH\",scalew:\"scaleW\",stretchh:\"stretchH\",lineheight:\"lineHeight\",alphachnl:\"alphaChnl\",redchnl:\"redChnl\",greenchnl:\"greenChnl\",bluechnl:\"blueChnl\"};function o(t){var e=function(t){for(var e=[],r=0;r<t.attributes.length;r++)e.push(t.attributes[r]);return e}(t);return e.reduce((function(t,e){var r;return t[(r=e.nodeName,a[r.toLowerCase()]||r)]=e.nodeValue,t}),{})}t.exports=function(t){t=t.toString();var e=n(t),r={pages:[],chars:[],kernings:[]};[\"info\",\"common\"].forEach((function(t){var n=e.getElementsByTagName(t)[0];n&&(r[t]=i(o(n)))}));var a=e.getElementsByTagName(\"pages\")[0];if(!a)throw new Error(\"malformed file -- no <pages> element\");for(var s=a.getElementsByTagName(\"page\"),h=0;h<s.length;h++){var l=s[h],f=parseInt(l.getAttribute(\"id\"),10),u=l.getAttribute(\"file\");if(isNaN(f))throw new Error('malformed file -- page \"id\" attribute is NaN');if(!u)throw new Error('malformed file -- needs page \"file\" attribute');r.pages[parseInt(f,10)]=u}return[\"chars\",\"kernings\"].forEach((function(t){var n=e.getElementsByTagName(t)[0];if(n)for(var a=t.substring(0,t.length-1),s=n.getElementsByTagName(a),h=0;h<s.length;h++){var l=s[h];r[t].push(i(o(l)))}})),r}},403:t=>{var e=\"chasrset\";t.exports=function(t){for(var r in e in t&&(t.charset=t[e],delete t[e]),t)\"face\"!==r&&\"charset\"!==r&&(t[r]=\"padding\"===r||\"spacing\"===r?t[r].split(\",\").map((function(t){return parseInt(t,10)})):parseInt(t[r],10));return t}},4655:(t,e,r)=>{var i=r(311),n=r(3243);t.exports=function(t){if(!t)return{};var e={};return n(i(t).split(\"\\n\"),(function(t){var r,n=t.indexOf(\":\"),a=i(t.slice(0,n)).toLowerCase(),o=i(t.slice(n+1));void 0===e[a]?e[a]=o:(r=e[a],\"[object Array]\"===Object.prototype.toString.call(r)?e[a].push(o):e[a]=[e[a],o])})),e}},1023:(t,e,r)=>{\"use strict\";var i=r(4406);function n(t){if(\"string\"!=typeof t)throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(t))}function a(t,e){for(var r,i=\"\",n=0,a=-1,o=0,s=0;s<=t.length;++s){if(s<t.length)r=t.charCodeAt(s);else{if(47===r)break;r=47}if(47===r){if(a===s-1||1===o);else if(a!==s-1&&2===o){if(i.length<2||2!==n||46!==i.charCodeAt(i.length-1)||46!==i.charCodeAt(i.length-2))if(i.length>2){var h=i.lastIndexOf(\"/\");if(h!==i.length-1){-1===h?(i=\"\",n=0):n=(i=i.slice(0,h)).length-1-i.lastIndexOf(\"/\"),a=s,o=0;continue}}else if(2===i.length||1===i.length){i=\"\",n=0,a=s,o=0;continue}e&&(i.length>0?i+=\"/..\":i=\"..\",n=2)}else i.length>0?i+=\"/\"+t.slice(a+1,s):i=t.slice(a+1,s),n=s-a-1;a=s,o=0}else 46===r&&-1!==o?++o:o=-1}return i}var o={resolve:function(){for(var t,e=\"\",r=!1,o=arguments.length-1;o>=-1&&!r;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=i.cwd()),s=t),n(s),0!==s.length&&(e=s+\"/\"+e,r=47===s.charCodeAt(0))}return e=a(e,!r),r?e.length>0?\"/\"+e:\"/\":e.length>0?e:\".\"},normalize:function(t){if(n(t),0===t.length)return\".\";var e=47===t.charCodeAt(0),r=47===t.charCodeAt(t.length-1);return 0!==(t=a(t,!e)).length||e||(t=\".\"),t.length>0&&r&&(t+=\"/\"),e?\"/\"+t:t},isAbsolute:function(t){return n(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return\".\";for(var t,e=0;e<arguments.length;++e){var r=arguments[e];n(r),r.length>0&&(void 0===t?t=r:t+=\"/\"+r)}return void 0===t?\".\":o.normalize(t)},relative:function(t,e){if(n(t),n(e),t===e)return\"\";if((t=o.resolve(t))===(e=o.resolve(e)))return\"\";for(var r=1;r<t.length&&47===t.charCodeAt(r);++r);for(var i=t.length,a=i-r,s=1;s<e.length&&47===e.charCodeAt(s);++s);for(var h=e.length-s,l=a<h?a:h,f=-1,u=0;u<=l;++u){if(u===l){if(h>l){if(47===e.charCodeAt(s+u))return e.slice(s+u+1);if(0===u)return e.slice(s+u)}else a>l&&(47===t.charCodeAt(r+u)?f=u:0===u&&(f=0));break}var c=t.charCodeAt(r+u);if(c!==e.charCodeAt(s+u))break;47===c&&(f=u)}var d=\"\";for(u=r+f+1;u<=i;++u)u!==i&&47!==t.charCodeAt(u)||(0===d.length?d+=\"..\":d+=\"/..\");return d.length>0?d+e.slice(s+f):(s+=f,47===e.charCodeAt(s)&&++s,e.slice(s))},_makeLong:function(t){return t},dirname:function(t){if(n(t),0===t.length)return\".\";for(var e=t.charCodeAt(0),r=47===e,i=-1,a=!0,o=t.length-1;o>=1;--o)if(47===(e=t.charCodeAt(o))){if(!a){i=o;break}}else a=!1;return-1===i?r?\"/\":\".\":r&&1===i?\"//\":t.slice(0,i)},basename:function(t,e){if(void 0!==e&&\"string\"!=typeof e)throw new TypeError('\"ext\" argument must be a string');n(t);var r,i=0,a=-1,o=!0;if(void 0!==e&&e.length>0&&e.length<=t.length){if(e.length===t.length&&e===t)return\"\";var s=e.length-1,h=-1;for(r=t.length-1;r>=0;--r){var l=t.charCodeAt(r);if(47===l){if(!o){i=r+1;break}}else-1===h&&(o=!1,h=r+1),s>=0&&(l===e.charCodeAt(s)?-1==--s&&(a=r):(s=-1,a=h))}return i===a?a=h:-1===a&&(a=t.length),t.slice(i,a)}for(r=t.length-1;r>=0;--r)if(47===t.charCodeAt(r)){if(!o){i=r+1;break}}else-1===a&&(o=!1,a=r+1);return-1===a?\"\":t.slice(i,a)},extname:function(t){n(t);for(var e=-1,r=0,i=-1,a=!0,o=0,s=t.length-1;s>=0;--s){var h=t.charCodeAt(s);if(47!==h)-1===i&&(a=!1,i=s+1),46===h?-1===e?e=s:1!==o&&(o=1):-1!==e&&(o=-1);else if(!a){r=s+1;break}}return-1===e||-1===i||0===o||1===o&&e===i-1&&e===r+1?\"\":t.slice(e,i)},format:function(t){if(null===t||\"object\"!=typeof t)throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,i=e.base||(e.name||\"\")+(e.ext||\"\");return r?r===e.root?r+i:r+\"/\"+i:i}(0,t)},parse:function(t){n(t);var e={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(0===t.length)return e;var r,i=t.charCodeAt(0),a=47===i;a?(e.root=\"/\",r=1):r=0;for(var o=-1,s=0,h=-1,l=!0,f=t.length-1,u=0;f>=r;--f)if(47!==(i=t.charCodeAt(f)))-1===h&&(l=!1,h=f+1),46===i?-1===o?o=f:1!==u&&(u=1):-1!==o&&(u=-1);else if(!l){s=f+1;break}return-1===o||-1===h||0===u||1===u&&o===h-1&&o===s+1?-1!==h&&(e.base=e.name=0===s&&a?t.slice(1,h):t.slice(s,h)):(0===s&&a?(e.name=t.slice(1,o),e.base=t.slice(1,h)):(e.name=t.slice(s,o),e.base=t.slice(s,h)),e.ext=t.slice(o,h)),s>0?e.dir=t.slice(0,s-1):a&&(e.dir=\"/\"),e},sep:\"/\",delimiter:\":\",win32:null,posix:null};o.posix=o,t.exports=o},482:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Deferred=void 0,e.Deferred=class{constructor(){this.resolve=()=>null,this.reject=()=>null,this.promise=new Promise(((t,e)=>{this.reject=e,this.resolve=t}))}}},5567:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.EndOfStreamError=e.defaultMessages=void 0,e.defaultMessages=\"End-Of-Stream\";class r extends Error{constructor(){super(e.defaultMessages)}}e.EndOfStreamError=r},4514:(t,e,r)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.StreamReader=e.EndOfStreamError=void 0;const i=r(5567),n=r(482);var a=r(5567);Object.defineProperty(e,\"EndOfStreamError\",{enumerable:!0,get:function(){return a.EndOfStreamError}}),e.StreamReader=class{constructor(t){if(this.s=t,this.deferred=null,this.endOfStream=!1,this.peekQueue=[],!t.read||!t.once)throw new Error(\"Expected an instance of stream.Readable\");this.s.once(\"end\",(()=>this.reject(new i.EndOfStreamError))),this.s.once(\"error\",(t=>this.reject(t))),this.s.once(\"close\",(()=>this.reject(new Error(\"Stream closed\"))))}async peek(t,e,r){const i=await this.read(t,e,r);return this.peekQueue.push(t.subarray(e,e+i)),i}async read(t,e,r){if(0===r)return 0;if(0===this.peekQueue.length&&this.endOfStream)throw new i.EndOfStreamError;let n=r,a=0;for(;this.peekQueue.length>0&&n>0;){const r=this.peekQueue.pop();if(!r)throw new Error(\"peekData should be defined\");const i=Math.min(r.length,n);t.set(r.subarray(0,i),e+a),a+=i,n-=i,i<r.length&&this.peekQueue.push(r.subarray(i))}for(;n>0&&!this.endOfStream;){const r=Math.min(n,1048576),i=await this.readFromStream(t,e+a,r);if(a+=i,i<r)break;n-=i}return a}async readFromStream(t,e,r){const i=this.s.read(r);if(i)return t.set(i,e),i.length;{const i={buffer:t,offset:e,length:r,deferred:new n.Deferred};return this.deferred=i.deferred,this.s.once(\"readable\",(()=>{this.readDeferred(i)})),i.deferred.promise}}readDeferred(t){const e=this.s.read(t.length);e?(t.buffer.set(e,t.offset),t.deferred.resolve(e.length),this.deferred=null):this.s.once(\"readable\",(()=>{this.readDeferred(t)}))}reject(t){this.endOfStream=!0,this.deferred&&(this.deferred.reject(t),this.deferred=null)}}},4644:(t,e,r)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.StreamReader=e.EndOfStreamError=void 0;var i=r(5567);Object.defineProperty(e,\"EndOfStreamError\",{enumerable:!0,get:function(){return i.EndOfStreamError}});var n=r(4514);Object.defineProperty(e,\"StreamReader\",{enumerable:!0,get:function(){return n.StreamReader}})},1294:t=>{\"use strict\";function e(t,i,n,a,o,s){for(var h,l,f,u,c=Math.max(i-1,0),d=Math.max(n-1,0),p=Math.min(i+1,a-1),m=Math.min(n+1,o-1),g=4*(n*a+i),b=0,_=0,y=0,w=0,v=0,x=c;x<=p;x++)for(var E=d;E<=m;E++)if(x!==i||E!==n){var k=r(t,t,g,4*(E*a+x),!0);if(0===k?b++:k<0?y++:k>0&&_++,b>2)return!1;s&&(k<w&&(w=k,h=x,l=E),k>v&&(v=k,f=x,u=E))}return!s||0!==y&&0!==_&&(!e(t,h,l,a,o)&&!e(s,h,l,a,o)||!e(t,f,u,a,o)&&!e(s,f,u,a,o))}function r(t,e,r,s,h){var l=t[r+3]/255,f=e[s+3]/255,u=o(t[r+0],l),c=o(t[r+1],l),d=o(t[r+2],l),p=o(e[s+0],f),m=o(e[s+1],f),g=o(e[s+2],f),b=i(u,c,d)-i(p,m,g);if(h)return b;var _=n(u,c,d)-n(p,m,g),y=a(u,c,d)-a(p,m,g);return.5053*b*b+.299*_*_+.1957*y*y}function i(t,e,r){return.29889531*t+.58662247*e+.11448223*r}function n(t,e,r){return.59597799*t-.2741761*e-.32180189*r}function a(t,e,r){return.21147017*t-.52261711*e+.31114694*r}function o(t,e){return 255+(t-255)*e}function s(t,e,r,i,n){t[e+0]=r,t[e+1]=i,t[e+2]=n,t[e+3]=255}t.exports=function(t,n,a,h,l,f){f||(f={});for(var u=void 0===f.threshold?.1:f.threshold,c=35215*u*u,d=0,p=0;p<l;p++)for(var m=0;m<h;m++){var g=4*(p*h+m);if(r(t,n,g,g)>c)f.includeAA||!e(t,m,p,h,l,n)&&!e(n,m,p,h,l,t)?(a&&s(a,g,255,0,0),d++):a&&s(a,g,255,255,0);else if(a){var b=o((void 0,void 0,void 0,void 0,w=(_=t)[(y=g)+3]/255,i(o(_[y+0],w),o(_[y+1],w),o(_[y+2],w))),.1);s(a,g,b,b,b)}}var _,y,w;return d}},9902:(t,e,r)=>{t.exports=function t(e,r,i){function n(o,s){if(!r[o]){if(!e[o]){if(a)return a(o,!0);var h=new Error(\"Cannot find module '\"+o+\"'\");throw h.code=\"MODULE_NOT_FOUND\",h}var l=r[o]={exports:{}};e[o][0].call(l.exports,(function(t){return n(e[o][1][t]||t)}),l,l.exports,t,e,r,i)}return r[o].exports}for(var a=void 0,o=0;o<i.length;o++)n(i[o]);return n}({1:[function(t,e,r){(function(e){(function(){\"use strict\";let i=t(\"./interlace\"),n=[function(){},function(t,e,r,i){if(i===e.length)throw new Error(\"Ran out of data\");let n=e[i];t[r]=n,t[r+1]=n,t[r+2]=n,t[r+3]=255},function(t,e,r,i){if(i+1>=e.length)throw new Error(\"Ran out of data\");let n=e[i];t[r]=n,t[r+1]=n,t[r+2]=n,t[r+3]=e[i+1]},function(t,e,r,i){if(i+2>=e.length)throw new Error(\"Ran out of data\");t[r]=e[i],t[r+1]=e[i+1],t[r+2]=e[i+2],t[r+3]=255},function(t,e,r,i){if(i+3>=e.length)throw new Error(\"Ran out of data\");t[r]=e[i],t[r+1]=e[i+1],t[r+2]=e[i+2],t[r+3]=e[i+3]}],a=[function(){},function(t,e,r,i){let n=e[0];t[r]=n,t[r+1]=n,t[r+2]=n,t[r+3]=i},function(t,e,r){let i=e[0];t[r]=i,t[r+1]=i,t[r+2]=i,t[r+3]=e[1]},function(t,e,r,i){t[r]=e[0],t[r+1]=e[1],t[r+2]=e[2],t[r+3]=i},function(t,e,r){t[r]=e[0],t[r+1]=e[1],t[r+2]=e[2],t[r+3]=e[3]}];function o(t,e,r,i,a,o){let s=t.width,h=t.height,l=t.index;for(let t=0;t<h;t++)for(let h=0;h<s;h++){let s=r(h,t,l);n[i](e,a,s,o),o+=i}return o}function s(t,e,r,i,n,o){let s=t.width,h=t.height,l=t.index;for(let t=0;t<h;t++){for(let h=0;h<s;h++){let s=n.get(i),f=r(h,t,l);a[i](e,s,f,o)}n.resetAfterLine()}}r.dataToBitMap=function(t,r){let n,a,h=r.width,l=r.height,f=r.depth,u=r.bpp,c=r.interlace;8!==f&&(n=function(t,e){let r=[],i=0;function n(){if(i===t.length)throw new Error(\"Ran out of data\");let n,a,o,s,h,l,f,u,c=t[i];switch(i++,e){default:throw new Error(\"unrecognised depth\");case 16:f=t[i],i++,r.push((c<<8)+f);break;case 4:f=15&c,u=c>>4,r.push(u,f);break;case 2:h=3&c,l=c>>2&3,f=c>>4&3,u=c>>6&3,r.push(u,f,l,h);break;case 1:n=1&c,a=c>>1&1,o=c>>2&1,s=c>>3&1,h=c>>4&1,l=c>>5&1,f=c>>6&1,u=c>>7&1,r.push(u,f,l,h,s,o,a,n)}}return{get:function(t){for(;r.length<t;)n();let e=r.slice(0,t);return r=r.slice(t),e},resetAfterLine:function(){r.length=0},end:function(){if(i!==t.length)throw new Error(\"extra data found\")}}}(t,f)),a=f<=8?e.alloc(h*l*4):new Uint16Array(h*l*4);let d,p,m=Math.pow(2,f)-1,g=0;if(c)d=i.getImagePasses(h,l),p=i.getInterlaceIterator(h,l);else{let t=0;p=function(){let e=t;return t+=4,e},d=[{width:h,height:l}]}for(let e=0;e<d.length;e++)8===f?g=o(d[e],a,p,u,t,g):s(d[e],a,p,u,n,m);if(8===f){if(g!==t.length)throw new Error(\"extra data found\")}else n.end();return a}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./interlace\":11,buffer:33}],2:[function(t,e,r){(function(r){(function(){\"use strict\";let i=t(\"./constants\");e.exports=function(t,e,n,a){let o=-1!==[i.COLORTYPE_COLOR_ALPHA,i.COLORTYPE_ALPHA].indexOf(a.colorType);if(a.colorType===a.inputColorType){let e=function(){let t=new ArrayBuffer(2);return new DataView(t).setInt16(0,256,!0),256!==new Int16Array(t)[0]}();if(8===a.bitDepth||16===a.bitDepth&&e)return t}let s=16!==a.bitDepth?t:new Uint16Array(t.buffer),h=255,l=i.COLORTYPE_TO_BPP_MAP[a.inputColorType];4!==l||a.inputHasAlpha||(l=3);let f=i.COLORTYPE_TO_BPP_MAP[a.colorType];16===a.bitDepth&&(h=65535,f*=2);let u=r.alloc(e*n*f),c=0,d=0,p=a.bgColor||{};function m(){let t,e,r,n=h;switch(a.inputColorType){case i.COLORTYPE_COLOR_ALPHA:n=s[c+3],t=s[c],e=s[c+1],r=s[c+2];break;case i.COLORTYPE_COLOR:t=s[c],e=s[c+1],r=s[c+2];break;case i.COLORTYPE_ALPHA:n=s[c+1],t=s[c],e=t,r=t;break;case i.COLORTYPE_GRAYSCALE:t=s[c],e=t,r=t;break;default:throw new Error(\"input color type:\"+a.inputColorType+\" is not supported at present\")}return a.inputHasAlpha&&(o||(n/=h,t=Math.min(Math.max(Math.round((1-n)*p.red+n*t),0),h),e=Math.min(Math.max(Math.round((1-n)*p.green+n*e),0),h),r=Math.min(Math.max(Math.round((1-n)*p.blue+n*r),0),h))),{red:t,green:e,blue:r,alpha:n}}void 0===p.red&&(p.red=h),void 0===p.green&&(p.green=h),void 0===p.blue&&(p.blue=h);for(let t=0;t<n;t++)for(let t=0;t<e;t++){let t=m();switch(a.colorType){case i.COLORTYPE_COLOR_ALPHA:case i.COLORTYPE_COLOR:8===a.bitDepth?(u[d]=t.red,u[d+1]=t.green,u[d+2]=t.blue,o&&(u[d+3]=t.alpha)):(u.writeUInt16BE(t.red,d),u.writeUInt16BE(t.green,d+2),u.writeUInt16BE(t.blue,d+4),o&&u.writeUInt16BE(t.alpha,d+6));break;case i.COLORTYPE_ALPHA:case i.COLORTYPE_GRAYSCALE:{let e=(t.red+t.green+t.blue)/3;8===a.bitDepth?(u[d]=e,o&&(u[d+1]=t.alpha)):(u.writeUInt16BE(e,d),o&&u.writeUInt16BE(t.alpha,d+2));break}default:throw new Error(\"unrecognised color Type \"+a.colorType)}c+=l,d+=f}return u}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./constants\":4,buffer:33}],3:[function(t,e,r){(function(r,i){(function(){\"use strict\";let n=t(\"util\"),a=t(\"stream\"),o=e.exports=function(){a.call(this),this._buffers=[],this._buffered=0,this._reads=[],this._paused=!1,this._encoding=\"utf8\",this.writable=!0};n.inherits(o,a),o.prototype.read=function(t,e){this._reads.push({length:Math.abs(t),allowLess:t<0,func:e}),r.nextTick(function(){this._process(),this._paused&&this._reads&&this._reads.length>0&&(this._paused=!1,this.emit(\"drain\"))}.bind(this))},o.prototype.write=function(t,e){if(!this.writable)return this.emit(\"error\",new Error(\"Stream not writable\")),!1;let r;return r=i.isBuffer(t)?t:i.from(t,e||this._encoding),this._buffers.push(r),this._buffered+=r.length,this._process(),this._reads&&0===this._reads.length&&(this._paused=!0),this.writable&&!this._paused},o.prototype.end=function(t,e){t&&this.write(t,e),this.writable=!1,this._buffers&&(0===this._buffers.length?this._end():(this._buffers.push(null),this._process()))},o.prototype.destroySoon=o.prototype.end,o.prototype._end=function(){this._reads.length>0&&this.emit(\"error\",new Error(\"Unexpected end of input\")),this.destroy()},o.prototype.destroy=function(){this._buffers&&(this.writable=!1,this._reads=null,this._buffers=null,this.emit(\"close\"))},o.prototype._processReadAllowingLess=function(t){this._reads.shift();let e=this._buffers[0];e.length>t.length?(this._buffered-=t.length,this._buffers[0]=e.slice(t.length),t.func.call(this,e.slice(0,t.length))):(this._buffered-=e.length,this._buffers.shift(),t.func.call(this,e))},o.prototype._processRead=function(t){this._reads.shift();let e=0,r=0,n=i.alloc(t.length);for(;e<t.length;){let i=this._buffers[r++],a=Math.min(i.length,t.length-e);i.copy(n,e,0,a),e+=a,a!==i.length&&(this._buffers[--r]=i.slice(a))}r>0&&this._buffers.splice(0,r),this._buffered-=t.length,t.func.call(this,n)},o.prototype._process=function(){try{for(;this._buffered>0&&this._reads&&this._reads.length>0;){let t=this._reads[0];if(t.allowLess)this._processReadAllowingLess(t);else{if(!(this._buffered>=t.length))break;this._processRead(t)}}this._buffers&&!this.writable&&this._end()}catch(t){this.emit(\"error\",t)}}}).call(this)}).call(this,t(\"_process\"),t(\"buffer\").Buffer)},{_process:60,buffer:33,stream:61,util:81}],4:[function(t,e,r){\"use strict\";e.exports={PNG_SIGNATURE:[137,80,78,71,13,10,26,10],TYPE_IHDR:1229472850,TYPE_IEND:1229278788,TYPE_IDAT:1229209940,TYPE_PLTE:1347179589,TYPE_tRNS:1951551059,TYPE_gAMA:1732332865,COLORTYPE_GRAYSCALE:0,COLORTYPE_PALETTE:1,COLORTYPE_COLOR:2,COLORTYPE_ALPHA:4,COLORTYPE_PALETTE_COLOR:3,COLORTYPE_COLOR_ALPHA:6,COLORTYPE_TO_BPP_MAP:{0:1,2:3,3:1,4:2,6:4},GAMMA_DIVISION:1e5}},{}],5:[function(t,e,r){\"use strict\";let i=[];!function(){for(let t=0;t<256;t++){let e=t;for(let t=0;t<8;t++)1&e?e=3988292384^e>>>1:e>>>=1;i[t]=e}}();let n=e.exports=function(){this._crc=-1};n.prototype.write=function(t){for(let e=0;e<t.length;e++)this._crc=i[255&(this._crc^t[e])]^this._crc>>>8;return!0},n.prototype.crc32=function(){return-1^this._crc},n.crc32=function(t){let e=-1;for(let r=0;r<t.length;r++)e=i[255&(e^t[r])]^e>>>8;return-1^e}},{}],6:[function(t,e,r){(function(r){(function(){\"use strict\";let i=t(\"./paeth-predictor\");let n={0:function(t,e,r,i,n){for(let a=0;a<r;a++)i[n+a]=t[e+a]},1:function(t,e,r,i,n,a){for(let o=0;o<r;o++){let r=o>=a?t[e+o-a]:0,s=t[e+o]-r;i[n+o]=s}},2:function(t,e,r,i,n){for(let a=0;a<r;a++){let o=e>0?t[e+a-r]:0,s=t[e+a]-o;i[n+a]=s}},3:function(t,e,r,i,n,a){for(let o=0;o<r;o++){let s=o>=a?t[e+o-a]:0,h=e>0?t[e+o-r]:0,l=t[e+o]-(s+h>>1);i[n+o]=l}},4:function(t,e,r,n,a,o){for(let s=0;s<r;s++){let h=s>=o?t[e+s-o]:0,l=e>0?t[e+s-r]:0,f=e>0&&s>=o?t[e+s-(r+o)]:0,u=t[e+s]-i(h,l,f);n[a+s]=u}}},a={0:function(t,e,r){let i=0,n=e+r;for(let r=e;r<n;r++)i+=Math.abs(t[r]);return i},1:function(t,e,r,i){let n=0;for(let a=0;a<r;a++){let r=a>=i?t[e+a-i]:0,o=t[e+a]-r;n+=Math.abs(o)}return n},2:function(t,e,r){let i=0,n=e+r;for(let a=e;a<n;a++){let n=e>0?t[a-r]:0,o=t[a]-n;i+=Math.abs(o)}return i},3:function(t,e,r,i){let n=0;for(let a=0;a<r;a++){let o=a>=i?t[e+a-i]:0,s=e>0?t[e+a-r]:0,h=t[e+a]-(o+s>>1);n+=Math.abs(h)}return n},4:function(t,e,r,n){let a=0;for(let o=0;o<r;o++){let s=o>=n?t[e+o-n]:0,h=e>0?t[e+o-r]:0,l=e>0&&o>=n?t[e+o-(r+n)]:0,f=t[e+o]-i(s,h,l);a+=Math.abs(f)}return a}};e.exports=function(t,e,i,o,s){let h;if(\"filterType\"in o&&-1!==o.filterType){if(\"number\"!=typeof o.filterType)throw new Error(\"unrecognised filter types\");h=[o.filterType]}else h=[0,1,2,3,4];16===o.bitDepth&&(s*=2);let l=e*s,f=0,u=0,c=r.alloc((l+1)*i),d=h[0];for(let e=0;e<i;e++){if(h.length>1){let e=1/0;for(let r=0;r<h.length;r++){let i=a[h[r]](t,u,l,s);i<e&&(d=h[r],e=i)}}c[f]=d,f++,n[d](t,u,l,c,f,s),f+=l,u+=l}return c}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./paeth-predictor\":15,buffer:33}],7:[function(t,e,r){(function(r){(function(){\"use strict\";let i=t(\"util\"),n=t(\"./chunkstream\"),a=t(\"./filter-parse\"),o=e.exports=function(t){n.call(this);let e=[],i=this;this._filter=new a(t,{read:this.read.bind(this),write:function(t){e.push(t)},complete:function(){i.emit(\"complete\",r.concat(e))}}),this._filter.start()};i.inherits(o,n)}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./chunkstream\":3,\"./filter-parse\":9,buffer:33,util:81}],8:[function(t,e,r){(function(e){(function(){\"use strict\";let i=t(\"./sync-reader\"),n=t(\"./filter-parse\");r.process=function(t,r){let a=[],o=new i(t);return new n(r,{read:o.read.bind(o),write:function(t){a.push(t)},complete:function(){}}).start(),o.process(),e.concat(a)}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./filter-parse\":9,\"./sync-reader\":22,buffer:33}],9:[function(t,e,r){(function(r){(function(){\"use strict\";let i=t(\"./interlace\"),n=t(\"./paeth-predictor\");function a(t,e,r){let i=t*e;return 8!==r&&(i=Math.ceil(i/(8/r))),i}let o=e.exports=function(t,e){let r=t.width,n=t.height,o=t.interlace,s=t.bpp,h=t.depth;if(this.read=e.read,this.write=e.write,this.complete=e.complete,this._imageIndex=0,this._images=[],o){let t=i.getImagePasses(r,n);for(let e=0;e<t.length;e++)this._images.push({byteWidth:a(t[e].width,s,h),height:t[e].height,lineIndex:0})}else this._images.push({byteWidth:a(r,s,h),height:n,lineIndex:0});this._xComparison=8===h?s:16===h?2*s:1};o.prototype.start=function(){this.read(this._images[this._imageIndex].byteWidth+1,this._reverseFilterLine.bind(this))},o.prototype._unFilterType1=function(t,e,r){let i=this._xComparison,n=i-1;for(let a=0;a<r;a++){let r=t[1+a],o=a>n?e[a-i]:0;e[a]=r+o}},o.prototype._unFilterType2=function(t,e,r){let i=this._lastLine;for(let n=0;n<r;n++){let r=t[1+n],a=i?i[n]:0;e[n]=r+a}},o.prototype._unFilterType3=function(t,e,r){let i=this._xComparison,n=i-1,a=this._lastLine;for(let o=0;o<r;o++){let r=t[1+o],s=a?a[o]:0,h=o>n?e[o-i]:0,l=Math.floor((h+s)/2);e[o]=r+l}},o.prototype._unFilterType4=function(t,e,r){let i=this._xComparison,a=i-1,o=this._lastLine;for(let s=0;s<r;s++){let r=t[1+s],h=o?o[s]:0,l=s>a?e[s-i]:0,f=s>a&&o?o[s-i]:0,u=n(l,h,f);e[s]=r+u}},o.prototype._reverseFilterLine=function(t){let e,i=t[0],n=this._images[this._imageIndex],a=n.byteWidth;if(0===i)e=t.slice(1,a+1);else switch(e=r.alloc(a),i){case 1:this._unFilterType1(t,e,a);break;case 2:this._unFilterType2(t,e,a);break;case 3:this._unFilterType3(t,e,a);break;case 4:this._unFilterType4(t,e,a);break;default:throw new Error(\"Unrecognised filter type - \"+i)}this.write(e),n.lineIndex++,n.lineIndex>=n.height?(this._lastLine=null,this._imageIndex++,n=this._images[this._imageIndex]):this._lastLine=e,n?this.read(n.byteWidth+1,this._reverseFilterLine.bind(this)):(this._lastLine=null,this.complete())}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./interlace\":11,\"./paeth-predictor\":15,buffer:33}],10:[function(t,e,r){(function(t){(function(){\"use strict\";e.exports=function(e,r,i=!1){let n=r.depth,a=r.width,o=r.height,s=r.colorType,h=r.transColor,l=r.palette,f=e;return 3===s?function(t,e,r,i,n){let a=0;for(let o=0;o<i;o++)for(let i=0;i<r;i++){let r=n[t[a]];if(!r)throw new Error(\"index \"+t[a]+\" not in palette\");for(let t=0;t<4;t++)e[a+t]=r[t];a+=4}}(e,f,a,o,l):(h&&function(t,e,r,i,n){let a=0;for(let o=0;o<i;o++)for(let i=0;i<r;i++){let r=!1;if(1===n.length?n[0]===t[a]&&(r=!0):n[0]===t[a]&&n[1]===t[a+1]&&n[2]===t[a+2]&&(r=!0),r)for(let t=0;t<4;t++)e[a+t]=0;a+=4}}(e,f,a,o,h),8===n||i||(16===n&&(f=t.alloc(a*o*4)),function(t,e,r,i,n){let a=Math.pow(2,n)-1,o=0;for(let n=0;n<i;n++)for(let i=0;i<r;i++){for(let r=0;r<4;r++)e[o+r]=Math.floor(255*t[o+r]/a+.5);o+=4}}(e,f,a,o,n))),f}}).call(this)}).call(this,t(\"buffer\").Buffer)},{buffer:33}],11:[function(t,e,r){\"use strict\";let i=[{x:[0],y:[0]},{x:[4],y:[0]},{x:[0,4],y:[4]},{x:[2,6],y:[0,4]},{x:[0,2,4,6],y:[2,6]},{x:[1,3,5,7],y:[0,2,4,6]},{x:[0,1,2,3,4,5,6,7],y:[1,3,5,7]}];r.getImagePasses=function(t,e){let r=[],n=t%8,a=e%8,o=(t-n)/8,s=(e-a)/8;for(let t=0;t<i.length;t++){let e=i[t],h=o*e.x.length,l=s*e.y.length;for(let t=0;t<e.x.length&&e.x[t]<n;t++)h++;for(let t=0;t<e.y.length&&e.y[t]<a;t++)l++;h>0&&l>0&&r.push({width:h,height:l,index:t})}return r},r.getInterlaceIterator=function(t){return function(e,r,n){let a=e%i[n].x.length,o=(e-a)/i[n].x.length*8+i[n].x[a],s=r%i[n].y.length;return 4*o+((r-s)/i[n].y.length*8+i[n].y[s])*t*4}}},{}],12:[function(t,e,r){(function(r){(function(){\"use strict\";let i=t(\"util\"),n=t(\"stream\"),a=t(\"./constants\"),o=t(\"./packer\"),s=e.exports=function(t){n.call(this);let e=t||{};this._packer=new o(e),this._deflate=this._packer.createDeflate(),this.readable=!0};i.inherits(s,n),s.prototype.pack=function(t,e,i,n){this.emit(\"data\",r.from(a.PNG_SIGNATURE)),this.emit(\"data\",this._packer.packIHDR(e,i)),n&&this.emit(\"data\",this._packer.packGAMA(n));let o=this._packer.filterData(t,e,i);this._deflate.on(\"error\",this.emit.bind(this,\"error\")),this._deflate.on(\"data\",function(t){this.emit(\"data\",this._packer.packIDAT(t))}.bind(this)),this._deflate.on(\"end\",function(){this.emit(\"data\",this._packer.packIEND()),this.emit(\"end\")}.bind(this)),this._deflate.end(o)}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./constants\":4,\"./packer\":14,buffer:33,stream:61,util:81}],13:[function(t,e,r){(function(r){(function(){\"use strict\";let i=!0,n=t(\"zlib\");n.deflateSync||(i=!1);let a=t(\"./constants\"),o=t(\"./packer\");e.exports=function(t,e){if(!i)throw new Error(\"To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0\");let s=new o(e||{}),h=[];h.push(r.from(a.PNG_SIGNATURE)),h.push(s.packIHDR(t.width,t.height)),t.gamma&&h.push(s.packGAMA(t.gamma));let l=s.filterData(t.data,t.width,t.height),f=n.deflateSync(l,s.getDeflateOptions());if(l=null,!f||!f.length)throw new Error(\"bad png - invalid compressed data response\");return h.push(s.packIDAT(f)),h.push(s.packIEND()),r.concat(h)}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./constants\":4,\"./packer\":14,buffer:33,zlib:32}],14:[function(t,e,r){(function(r){(function(){\"use strict\";let i=t(\"./constants\"),n=t(\"./crc\"),a=t(\"./bitpacker\"),o=t(\"./filter-pack\"),s=t(\"zlib\"),h=e.exports=function(t){if(this._options=t,t.deflateChunkSize=t.deflateChunkSize||32768,t.deflateLevel=null!=t.deflateLevel?t.deflateLevel:9,t.deflateStrategy=null!=t.deflateStrategy?t.deflateStrategy:3,t.inputHasAlpha=null==t.inputHasAlpha||t.inputHasAlpha,t.deflateFactory=t.deflateFactory||s.createDeflate,t.bitDepth=t.bitDepth||8,t.colorType=\"number\"==typeof t.colorType?t.colorType:i.COLORTYPE_COLOR_ALPHA,t.inputColorType=\"number\"==typeof t.inputColorType?t.inputColorType:i.COLORTYPE_COLOR_ALPHA,-1===[i.COLORTYPE_GRAYSCALE,i.COLORTYPE_COLOR,i.COLORTYPE_COLOR_ALPHA,i.COLORTYPE_ALPHA].indexOf(t.colorType))throw new Error(\"option color type:\"+t.colorType+\" is not supported at present\");if(-1===[i.COLORTYPE_GRAYSCALE,i.COLORTYPE_COLOR,i.COLORTYPE_COLOR_ALPHA,i.COLORTYPE_ALPHA].indexOf(t.inputColorType))throw new Error(\"option input color type:\"+t.inputColorType+\" is not supported at present\");if(8!==t.bitDepth&&16!==t.bitDepth)throw new Error(\"option bit depth:\"+t.bitDepth+\" is not supported at present\")};h.prototype.getDeflateOptions=function(){return{chunkSize:this._options.deflateChunkSize,level:this._options.deflateLevel,strategy:this._options.deflateStrategy}},h.prototype.createDeflate=function(){return this._options.deflateFactory(this.getDeflateOptions())},h.prototype.filterData=function(t,e,r){let n=a(t,e,r,this._options),s=i.COLORTYPE_TO_BPP_MAP[this._options.colorType];return o(n,e,r,this._options,s)},h.prototype._packChunk=function(t,e){let i=e?e.length:0,a=r.alloc(i+12);return a.writeUInt32BE(i,0),a.writeUInt32BE(t,4),e&&e.copy(a,8),a.writeInt32BE(n.crc32(a.slice(4,a.length-4)),a.length-4),a},h.prototype.packGAMA=function(t){let e=r.alloc(4);return e.writeUInt32BE(Math.floor(t*i.GAMMA_DIVISION),0),this._packChunk(i.TYPE_gAMA,e)},h.prototype.packIHDR=function(t,e){let n=r.alloc(13);return n.writeUInt32BE(t,0),n.writeUInt32BE(e,4),n[8]=this._options.bitDepth,n[9]=this._options.colorType,n[10]=0,n[11]=0,n[12]=0,this._packChunk(i.TYPE_IHDR,n)},h.prototype.packIDAT=function(t){return this._packChunk(i.TYPE_IDAT,t)},h.prototype.packIEND=function(){return this._packChunk(i.TYPE_IEND,null)}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./bitpacker\":2,\"./constants\":4,\"./crc\":5,\"./filter-pack\":6,buffer:33,zlib:32}],15:[function(t,e,r){\"use strict\";e.exports=function(t,e,r){let i=t+e-r,n=Math.abs(i-t),a=Math.abs(i-e),o=Math.abs(i-r);return n<=a&&n<=o?t:a<=o?e:r}},{}],16:[function(t,e,r){\"use strict\";let i=t(\"util\"),n=t(\"zlib\"),a=t(\"./chunkstream\"),o=t(\"./filter-parse-async\"),s=t(\"./parser\"),h=t(\"./bitmapper\"),l=t(\"./format-normaliser\"),f=e.exports=function(t){a.call(this),this._parser=new s(t,{read:this.read.bind(this),error:this._handleError.bind(this),metadata:this._handleMetaData.bind(this),gamma:this.emit.bind(this,\"gamma\"),palette:this._handlePalette.bind(this),transColor:this._handleTransColor.bind(this),finished:this._finished.bind(this),inflateData:this._inflateData.bind(this),simpleTransparency:this._simpleTransparency.bind(this),headersFinished:this._headersFinished.bind(this)}),this._options=t,this.writable=!0,this._parser.start()};i.inherits(f,a),f.prototype._handleError=function(t){this.emit(\"error\",t),this.writable=!1,this.destroy(),this._inflate&&this._inflate.destroy&&this._inflate.destroy(),this._filter&&(this._filter.destroy(),this._filter.on(\"error\",(function(){}))),this.errord=!0},f.prototype._inflateData=function(t){if(!this._inflate)if(this._bitmapInfo.interlace)this._inflate=n.createInflate(),this._inflate.on(\"error\",this.emit.bind(this,\"error\")),this._filter.on(\"complete\",this._complete.bind(this)),this._inflate.pipe(this._filter);else{let t=(1+(this._bitmapInfo.width*this._bitmapInfo.bpp*this._bitmapInfo.depth+7>>3))*this._bitmapInfo.height,e=Math.max(t,n.Z_MIN_CHUNK);this._inflate=n.createInflate({chunkSize:e});let r=t,i=this.emit.bind(this,\"error\");this._inflate.on(\"error\",(function(t){r&&i(t)})),this._filter.on(\"complete\",this._complete.bind(this));let a=this._filter.write.bind(this._filter);this._inflate.on(\"data\",(function(t){r&&(t.length>r&&(t=t.slice(0,r)),r-=t.length,a(t))})),this._inflate.on(\"end\",this._filter.end.bind(this._filter))}this._inflate.write(t)},f.prototype._handleMetaData=function(t){this._metaData=t,this._bitmapInfo=Object.create(t),this._filter=new o(this._bitmapInfo)},f.prototype._handleTransColor=function(t){this._bitmapInfo.transColor=t},f.prototype._handlePalette=function(t){this._bitmapInfo.palette=t},f.prototype._simpleTransparency=function(){this._metaData.alpha=!0},f.prototype._headersFinished=function(){this.emit(\"metadata\",this._metaData)},f.prototype._finished=function(){this.errord||(this._inflate?this._inflate.end():this.emit(\"error\",\"No Inflate block\"))},f.prototype._complete=function(t){if(this.errord)return;let e;try{let r=h.dataToBitMap(t,this._bitmapInfo);e=l(r,this._bitmapInfo,this._options.skipRescale),r=null}catch(t){return void this._handleError(t)}this.emit(\"parsed\",e)}},{\"./bitmapper\":1,\"./chunkstream\":3,\"./filter-parse-async\":7,\"./format-normaliser\":10,\"./parser\":18,util:81,zlib:32}],17:[function(t,e,r){(function(r){(function(){\"use strict\";let i=!0,n=t(\"zlib\"),a=t(\"./sync-inflate\");n.deflateSync||(i=!1);let o=t(\"./sync-reader\"),s=t(\"./filter-parse-sync\"),h=t(\"./parser\"),l=t(\"./bitmapper\"),f=t(\"./format-normaliser\");e.exports=function(t,e){if(!i)throw new Error(\"To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0\");let u,c,d;let p=[];let m=new o(t);if(new h(e,{read:m.read.bind(m),error:function(t){u=t},metadata:function(t){c=t},gamma:function(t){d=t},palette:function(t){c.palette=t},transColor:function(t){c.transColor=t},inflateData:function(t){p.push(t)},simpleTransparency:function(){c.alpha=!0}}).start(),m.process(),u)throw u;let g,b=r.concat(p);if(p.length=0,c.interlace)g=n.inflateSync(b);else{let t=(1+(c.width*c.bpp*c.depth+7>>3))*c.height;g=a(b,{chunkSize:t,maxLength:t})}if(b=null,!g||!g.length)throw new Error(\"bad png - invalid inflate data response\");let _=s.process(g,c);b=null;let y=l.dataToBitMap(_,c);_=null;let w=f(y,c,e.skipRescale);return c.data=w,c.gamma=d||0,c}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./bitmapper\":1,\"./filter-parse-sync\":8,\"./format-normaliser\":10,\"./parser\":18,\"./sync-inflate\":21,\"./sync-reader\":22,buffer:33,zlib:32}],18:[function(t,e,r){(function(r){(function(){\"use strict\";let i=t(\"./constants\"),n=t(\"./crc\"),a=e.exports=function(t,e){this._options=t,t.checkCRC=!1!==t.checkCRC,this._hasIHDR=!1,this._hasIEND=!1,this._emittedHeadersFinished=!1,this._palette=[],this._colorType=0,this._chunks={},this._chunks[i.TYPE_IHDR]=this._handleIHDR.bind(this),this._chunks[i.TYPE_IEND]=this._handleIEND.bind(this),this._chunks[i.TYPE_IDAT]=this._handleIDAT.bind(this),this._chunks[i.TYPE_PLTE]=this._handlePLTE.bind(this),this._chunks[i.TYPE_tRNS]=this._handleTRNS.bind(this),this._chunks[i.TYPE_gAMA]=this._handleGAMA.bind(this),this.read=e.read,this.error=e.error,this.metadata=e.metadata,this.gamma=e.gamma,this.transColor=e.transColor,this.palette=e.palette,this.parsed=e.parsed,this.inflateData=e.inflateData,this.finished=e.finished,this.simpleTransparency=e.simpleTransparency,this.headersFinished=e.headersFinished||function(){}};a.prototype.start=function(){this.read(i.PNG_SIGNATURE.length,this._parseSignature.bind(this))},a.prototype._parseSignature=function(t){let e=i.PNG_SIGNATURE;for(let r=0;r<e.length;r++)if(t[r]!==e[r])return void this.error(new Error(\"Invalid file signature\"));this.read(8,this._parseChunkBegin.bind(this))},a.prototype._parseChunkBegin=function(t){let e=t.readUInt32BE(0),a=t.readUInt32BE(4),o=\"\";for(let e=4;e<8;e++)o+=String.fromCharCode(t[e]);let s=Boolean(32&t[4]);if(this._hasIHDR||a===i.TYPE_IHDR){if(this._crc=new n,this._crc.write(r.from(o)),this._chunks[a])return this._chunks[a](e);s?this.read(e+4,this._skipChunk.bind(this)):this.error(new Error(\"Unsupported critical chunk type \"+o))}else this.error(new Error(\"Expected IHDR on beggining\"))},a.prototype._skipChunk=function(){this.read(8,this._parseChunkBegin.bind(this))},a.prototype._handleChunkEnd=function(){this.read(4,this._parseChunkEnd.bind(this))},a.prototype._parseChunkEnd=function(t){let e=t.readInt32BE(0),r=this._crc.crc32();this._options.checkCRC&&r!==e?this.error(new Error(\"Crc error - \"+e+\" - \"+r)):this._hasIEND||this.read(8,this._parseChunkBegin.bind(this))},a.prototype._handleIHDR=function(t){this.read(t,this._parseIHDR.bind(this))},a.prototype._parseIHDR=function(t){this._crc.write(t);let e=t.readUInt32BE(0),r=t.readUInt32BE(4),n=t[8],a=t[9],o=t[10],s=t[11],h=t[12];if(8!==n&&4!==n&&2!==n&&1!==n&&16!==n)return void this.error(new Error(\"Unsupported bit depth \"+n));if(!(a in i.COLORTYPE_TO_BPP_MAP))return void this.error(new Error(\"Unsupported color type\"));if(0!==o)return void this.error(new Error(\"Unsupported compression method\"));if(0!==s)return void this.error(new Error(\"Unsupported filter method\"));if(0!==h&&1!==h)return void this.error(new Error(\"Unsupported interlace method\"));this._colorType=a;let l=i.COLORTYPE_TO_BPP_MAP[this._colorType];this._hasIHDR=!0,this.metadata({width:e,height:r,depth:n,interlace:Boolean(h),palette:Boolean(a&i.COLORTYPE_PALETTE),color:Boolean(a&i.COLORTYPE_COLOR),alpha:Boolean(a&i.COLORTYPE_ALPHA),bpp:l,colorType:a}),this._handleChunkEnd()},a.prototype._handlePLTE=function(t){this.read(t,this._parsePLTE.bind(this))},a.prototype._parsePLTE=function(t){this._crc.write(t);let e=Math.floor(t.length/3);for(let r=0;r<e;r++)this._palette.push([t[3*r],t[3*r+1],t[3*r+2],255]);this.palette(this._palette),this._handleChunkEnd()},a.prototype._handleTRNS=function(t){this.simpleTransparency(),this.read(t,this._parseTRNS.bind(this))},a.prototype._parseTRNS=function(t){if(this._crc.write(t),this._colorType===i.COLORTYPE_PALETTE_COLOR){if(0===this._palette.length)return void this.error(new Error(\"Transparency chunk must be after palette\"));if(t.length>this._palette.length)return void this.error(new Error(\"More transparent colors than palette size\"));for(let e=0;e<t.length;e++)this._palette[e][3]=t[e];this.palette(this._palette)}this._colorType===i.COLORTYPE_GRAYSCALE&&this.transColor([t.readUInt16BE(0)]),this._colorType===i.COLORTYPE_COLOR&&this.transColor([t.readUInt16BE(0),t.readUInt16BE(2),t.readUInt16BE(4)]),this._handleChunkEnd()},a.prototype._handleGAMA=function(t){this.read(t,this._parseGAMA.bind(this))},a.prototype._parseGAMA=function(t){this._crc.write(t),this.gamma(t.readUInt32BE(0)/i.GAMMA_DIVISION),this._handleChunkEnd()},a.prototype._handleIDAT=function(t){this._emittedHeadersFinished||(this._emittedHeadersFinished=!0,this.headersFinished()),this.read(-t,this._parseIDAT.bind(this,t))},a.prototype._parseIDAT=function(t,e){if(this._crc.write(e),this._colorType===i.COLORTYPE_PALETTE_COLOR&&0===this._palette.length)throw new Error(\"Expected palette not found\");this.inflateData(e);let r=t-e.length;r>0?this._handleIDAT(r):this._handleChunkEnd()},a.prototype._handleIEND=function(t){this.read(t,this._parseIEND.bind(this))},a.prototype._parseIEND=function(t){this._crc.write(t),this._hasIEND=!0,this._handleChunkEnd(),this.finished&&this.finished()}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"./constants\":4,\"./crc\":5,buffer:33}],19:[function(t,e,r){\"use strict\";let i=t(\"./parser-sync\"),n=t(\"./packer-sync\");r.read=function(t,e){return i(t,e||{})},r.write=function(t,e){return n(t,e)}},{\"./packer-sync\":13,\"./parser-sync\":17}],20:[function(t,e,r){(function(e,i){(function(){\"use strict\";let n=t(\"util\"),a=t(\"stream\"),o=t(\"./parser-async\"),s=t(\"./packer-async\"),h=t(\"./png-sync\"),l=r.PNG=function(t){a.call(this),t=t||{},this.width=0|t.width,this.height=0|t.height,this.data=this.width>0&&this.height>0?i.alloc(4*this.width*this.height):null,t.fill&&this.data&&this.data.fill(0),this.gamma=0,this.readable=this.writable=!0,this._parser=new o(t),this._parser.on(\"error\",this.emit.bind(this,\"error\")),this._parser.on(\"close\",this._handleClose.bind(this)),this._parser.on(\"metadata\",this._metadata.bind(this)),this._parser.on(\"gamma\",this._gamma.bind(this)),this._parser.on(\"parsed\",function(t){this.data=t,this.emit(\"parsed\",t)}.bind(this)),this._packer=new s(t),this._packer.on(\"data\",this.emit.bind(this,\"data\")),this._packer.on(\"end\",this.emit.bind(this,\"end\")),this._parser.on(\"close\",this._handleClose.bind(this)),this._packer.on(\"error\",this.emit.bind(this,\"error\"))};n.inherits(l,a),l.sync=h,l.prototype.pack=function(){return this.data&&this.data.length?(e.nextTick(function(){this._packer.pack(this.data,this.width,this.height,this.gamma)}.bind(this)),this):(this.emit(\"error\",\"No data provided\"),this)},l.prototype.parse=function(t,e){if(e){let t,r;t=function(t){this.removeListener(\"error\",r),this.data=t,e(null,this)}.bind(this),r=function(r){this.removeListener(\"parsed\",t),e(r,null)}.bind(this),this.once(\"parsed\",t),this.once(\"error\",r)}return this.end(t),this},l.prototype.write=function(t){return this._parser.write(t),!0},l.prototype.end=function(t){this._parser.end(t)},l.prototype._metadata=function(t){this.width=t.width,this.height=t.height,this.emit(\"metadata\",t)},l.prototype._gamma=function(t){this.gamma=t},l.prototype._handleClose=function(){this._parser.writable||this._packer.readable||this.emit(\"close\")},l.bitblt=function(t,e,r,i,n,a,o,s){if(i|=0,n|=0,a|=0,o|=0,s|=0,(r|=0)>t.width||i>t.height||r+n>t.width||i+a>t.height)throw new Error(\"bitblt reading outside image\");if(o>e.width||s>e.height||o+n>e.width||s+a>e.height)throw new Error(\"bitblt writing outside image\");for(let h=0;h<a;h++)t.data.copy(e.data,(s+h)*e.width+o<<2,(i+h)*t.width+r<<2,(i+h)*t.width+r+n<<2)},l.prototype.bitblt=function(t,e,r,i,n,a,o){return l.bitblt(this,t,e,r,i,n,a,o),this},l.adjustGamma=function(t){if(t.gamma){for(let e=0;e<t.height;e++)for(let r=0;r<t.width;r++){let i=t.width*e+r<<2;for(let e=0;e<3;e++){let r=t.data[i+e]/255;r=Math.pow(r,1/2.2/t.gamma),t.data[i+e]=Math.round(255*r)}}t.gamma=0}},l.prototype.adjustGamma=function(){l.adjustGamma(this)}}).call(this)}).call(this,t(\"_process\"),t(\"buffer\").Buffer)},{\"./packer-async\":12,\"./parser-async\":16,\"./png-sync\":19,_process:60,buffer:33,stream:61,util:81}],21:[function(t,e,r){(function(i,n){(function(){\"use strict\";let a=t(\"assert\").ok,o=t(\"zlib\"),s=t(\"util\"),h=t(\"buffer\").kMaxLength;function l(t){if(!(this instanceof l))return new l(t);t&&t.chunkSize<o.Z_MIN_CHUNK&&(t.chunkSize=o.Z_MIN_CHUNK),o.Inflate.call(this,t),this._offset=void 0===this._offset?this._outOffset:this._offset,this._buffer=this._buffer||this._outBuffer,t&&null!=t.maxLength&&(this._maxLength=t.maxLength)}function f(t,e){e&&i.nextTick(e),t._handle&&(t._handle.close(),t._handle=null)}function u(t,e){return function(t,e){if(\"string\"==typeof e&&(e=n.from(e)),!(e instanceof n))throw new TypeError(\"Not a string or buffer\");let r=t._finishFlushFlag;return null==r&&(r=o.Z_FINISH),t._processChunk(e,r)}(new l(e),t)}l.prototype._processChunk=function(t,e,r){if(\"function\"==typeof r)return o.Inflate._processChunk.call(this,t,e,r);let i,s,l=this,u=t&&t.length,c=this._chunkSize-this._offset,d=this._maxLength,p=0,m=[],g=0;function b(t,e){if(l._hadError)return;let r=c-e;if(a(r>=0,\"have should not go down\"),r>0){let t=l._buffer.slice(l._offset,l._offset+r);if(l._offset+=r,t.length>d&&(t=t.slice(0,d)),m.push(t),g+=t.length,d-=t.length,0===d)return!1}return(0===e||l._offset>=l._chunkSize)&&(c=l._chunkSize,l._offset=0,l._buffer=n.allocUnsafe(l._chunkSize)),0===e&&(p+=u-t,u=t,!0)}this.on(\"error\",(function(t){i=t})),a(this._handle,\"zlib binding closed\");do{s=this._handle.writeSync(e,t,p,u,this._buffer,this._offset,c),s=s||this._writeState}while(!this._hadError&&b(s[0],s[1]));if(this._hadError)throw i;if(g>=h)throw f(this),new RangeError(\"Cannot create final Buffer. It would be larger than 0x\"+h.toString(16)+\" bytes\");let _=n.concat(m,g);return f(this),_},s.inherits(l,o.Inflate),e.exports=r=u,r.Inflate=l,r.createInflate=function(t){return new l(t)},r.inflateSync=u}).call(this)}).call(this,t(\"_process\"),t(\"buffer\").Buffer)},{_process:60,assert:23,buffer:33,util:81,zlib:32}],22:[function(t,e,r){\"use strict\";let i=e.exports=function(t){this._buffer=t,this._reads=[]};i.prototype.read=function(t,e){this._reads.push({length:Math.abs(t),allowLess:t<0,func:e})},i.prototype.process=function(){for(;this._reads.length>0&&this._buffer.length;){let t=this._reads[0];if(!this._buffer.length||!(this._buffer.length>=t.length||t.allowLess))break;{this._reads.shift();let e=this._buffer;this._buffer=e.slice(t.length),t.func.call(this,e.slice(0,t.length))}}if(this._reads.length>0)throw new Error(\"There are some read requests waitng on finished stream\");if(this._buffer.length>0)throw new Error(\"unrecognised content at end of stream\")}},{}],23:[function(t,e,i){(function(r){(function(){\"use strict\";function i(t,e){if(t===e)return 0;for(var r=t.length,i=e.length,n=0,a=Math.min(r,i);n<a;++n)if(t[n]!==e[n]){r=t[n],i=e[n];break}return r<i?-1:i<r?1:0}function n(t){return r.Buffer&&\"function\"==typeof r.Buffer.isBuffer?r.Buffer.isBuffer(t):!(null==t||!t._isBuffer)}var a=t(\"util/\"),o=Object.prototype.hasOwnProperty,s=Array.prototype.slice,h=\"foo\"===function(){}.name;function l(t){return Object.prototype.toString.call(t)}function f(t){return!n(t)&&\"function\"==typeof r.ArrayBuffer&&(\"function\"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):!!t&&(t instanceof DataView||!!(t.buffer&&t.buffer instanceof ArrayBuffer)))}var u=e.exports=b,c=/\\s*function\\s+([^\\(\\s]*)\\s*/;function d(t){if(a.isFunction(t)){if(h)return t.name;var e=t.toString().match(c);return e&&e[1]}}function p(t,e){return\"string\"==typeof t?t.length<e?t:t.slice(0,e):t}function m(t){if(h||!a.isFunction(t))return a.inspect(t);var e=d(t);return\"[Function\"+(e?\": \"+e:\"\")+\"]\"}function g(t,e,r,i,n){throw new u.AssertionError({message:r,actual:t,expected:e,operator:i,stackStartFunction:n})}function b(t,e){t||g(t,!0,e,\"==\",u.ok)}function _(t,e,r,o){if(t===e)return!0;if(n(t)&&n(e))return 0===i(t,e);if(a.isDate(t)&&a.isDate(e))return t.getTime()===e.getTime();if(a.isRegExp(t)&&a.isRegExp(e))return t.source===e.source&&t.global===e.global&&t.multiline===e.multiline&&t.lastIndex===e.lastIndex&&t.ignoreCase===e.ignoreCase;if(null!==t&&\"object\"==typeof t||null!==e&&\"object\"==typeof e){if(f(t)&&f(e)&&l(t)===l(e)&&!(t instanceof Float32Array||t instanceof Float64Array))return 0===i(new Uint8Array(t.buffer),new Uint8Array(e.buffer));if(n(t)!==n(e))return!1;var h=(o=o||{actual:[],expected:[]}).actual.indexOf(t);return-1!==h&&h===o.expected.indexOf(e)||(o.actual.push(t),o.expected.push(e),function(t,e,r,i){if(null==t||null==e)return!1;if(a.isPrimitive(t)||a.isPrimitive(e))return t===e;if(r&&Object.getPrototypeOf(t)!==Object.getPrototypeOf(e))return!1;var n=y(t),o=y(e);if(n&&!o||!n&&o)return!1;if(n)return _(t=s.call(t),e=s.call(e),r);var h,l,f=x(t),u=x(e);if(f.length!==u.length)return!1;for(f.sort(),u.sort(),l=f.length-1;l>=0;l--)if(f[l]!==u[l])return!1;for(l=f.length-1;l>=0;l--)if(!_(t[h=f[l]],e[h],r,i))return!1;return!0}(t,e,r,o))}return r?t===e:t==e}function y(t){return\"[object Arguments]\"==Object.prototype.toString.call(t)}function w(t,e){if(!t||!e)return!1;if(\"[object RegExp]\"==Object.prototype.toString.call(e))return e.test(t);try{if(t instanceof e)return!0}catch(t){}return!Error.isPrototypeOf(e)&&!0===e.call({},t)}function v(t,e,r,i){var n;if(\"function\"!=typeof e)throw new TypeError('\"block\" argument must be a function');\"string\"==typeof r&&(i=r,r=null),n=function(t){var e;try{t()}catch(t){e=t}return e}(e),i=(r&&r.name?\" (\"+r.name+\").\":\".\")+(i?\" \"+i:\".\"),t&&!n&&g(n,r,\"Missing expected exception\"+i);var o=\"string\"==typeof i,s=!t&&n&&!r;if((!t&&a.isError(n)&&o&&w(n,r)||s)&&g(n,r,\"Got unwanted exception\"+i),t&&n&&r&&!w(n,r)||!t&&n)throw n}u.AssertionError=function(t){this.name=\"AssertionError\",this.actual=t.actual,this.expected=t.expected,this.operator=t.operator,t.message?(this.message=t.message,this.generatedMessage=!1):(this.message=function(t){return p(m(t.actual),128)+\" \"+t.operator+\" \"+p(m(t.expected),128)}(this),this.generatedMessage=!0);var e=t.stackStartFunction||g;if(Error.captureStackTrace)Error.captureStackTrace(this,e);else{var r=new Error;if(r.stack){var i=r.stack,n=d(e),a=i.indexOf(\"\\n\"+n);if(a>=0){var o=i.indexOf(\"\\n\",a+1);i=i.substring(o+1)}this.stack=i}}},a.inherits(u.AssertionError,Error),u.fail=g,u.ok=b,u.equal=function(t,e,r){t!=e&&g(t,e,r,\"==\",u.equal)},u.notEqual=function(t,e,r){t==e&&g(t,e,r,\"!=\",u.notEqual)},u.deepEqual=function(t,e,r){_(t,e,!1)||g(t,e,r,\"deepEqual\",u.deepEqual)},u.deepStrictEqual=function(t,e,r){_(t,e,!0)||g(t,e,r,\"deepStrictEqual\",u.deepStrictEqual)},u.notDeepEqual=function(t,e,r){_(t,e,!1)&&g(t,e,r,\"notDeepEqual\",u.notDeepEqual)},u.notDeepStrictEqual=function t(e,r,i){_(e,r,!0)&&g(e,r,i,\"notDeepStrictEqual\",t)},u.strictEqual=function(t,e,r){t!==e&&g(t,e,r,\"===\",u.strictEqual)},u.notStrictEqual=function(t,e,r){t===e&&g(t,e,r,\"!==\",u.notStrictEqual)},u.throws=function(t,e,r){v(!0,t,e,r)},u.doesNotThrow=function(t,e,r){v(!1,t,e,r)},u.ifError=function(t){if(t)throw t};var x=Object.keys||function(t){var e=[];for(var r in t)o.call(t,r)&&e.push(r);return e}}).call(this)}).call(this,void 0!==r.g?r.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"util/\":26}],24:[function(t,e,r){\"function\"==typeof Object.create?e.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(t,e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},{}],25:[function(t,e,r){e.exports=function(t){return t&&\"object\"==typeof t&&\"function\"==typeof t.copy&&\"function\"==typeof t.fill&&\"function\"==typeof t.readUInt8}},{}],26:[function(t,e,i){(function(e,r){(function(){var n=/%[sdj%]/g;i.format=function(t){if(!b(t)){for(var e=[],r=0;r<arguments.length;r++)e.push(s(arguments[r]));return e.join(\" \")}r=1;for(var i=arguments,a=i.length,o=String(t).replace(n,(function(t){if(\"%%\"===t)return\"%\";if(r>=a)return t;switch(t){case\"%s\":return String(i[r++]);case\"%d\":return Number(i[r++]);case\"%j\":try{return JSON.stringify(i[r++])}catch(t){return\"[Circular]\"}default:return t}})),h=i[r];r<a;h=i[++r])m(h)||!w(h)?o+=\" \"+h:o+=\" \"+s(h);return o},i.deprecate=function(t,n){if(_(r.process))return function(){return i.deprecate(t,n).apply(this,arguments)};if(!0===e.noDeprecation)return t;var a=!1;return function(){if(!a){if(e.throwDeprecation)throw new Error(n);e.traceDeprecation?console.trace(n):console.error(n),a=!0}return t.apply(this,arguments)}};var a,o={};function s(t,e){var r={seen:[],stylize:l};return arguments.length>=3&&(r.depth=arguments[2]),arguments.length>=4&&(r.colors=arguments[3]),p(e)?r.showHidden=e:e&&i._extend(r,e),_(r.showHidden)&&(r.showHidden=!1),_(r.depth)&&(r.depth=2),_(r.colors)&&(r.colors=!1),_(r.customInspect)&&(r.customInspect=!0),r.colors&&(r.stylize=h),f(r,t,r.depth)}function h(t,e){var r=s.styles[e];return r?\"\u001b[\"+s.colors[r][0]+\"m\"+t+\"\u001b[\"+s.colors[r][1]+\"m\":t}function l(t,e){return t}function f(t,e,r){if(t.customInspect&&e&&E(e.inspect)&&e.inspect!==i.inspect&&(!e.constructor||e.constructor.prototype!==e)){var n=e.inspect(r,t);return b(n)||(n=f(t,n,r)),n}var a=function(t,e){if(_(e))return t.stylize(\"undefined\",\"undefined\");if(b(e)){var r=\"'\"+JSON.stringify(e).replace(/^\"|\"$/g,\"\").replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"')+\"'\";return t.stylize(r,\"string\")}return g(e)?t.stylize(\"\"+e,\"number\"):p(e)?t.stylize(\"\"+e,\"boolean\"):m(e)?t.stylize(\"null\",\"null\"):void 0}(t,e);if(a)return a;var o=Object.keys(e),s=function(t){var e={};return t.forEach((function(t,r){e[t]=!0})),e}(o);if(t.showHidden&&(o=Object.getOwnPropertyNames(e)),x(e)&&(o.indexOf(\"message\")>=0||o.indexOf(\"description\")>=0))return u(e);if(0===o.length){if(E(e)){var h=e.name?\": \"+e.name:\"\";return t.stylize(\"[Function\"+h+\"]\",\"special\")}if(y(e))return t.stylize(RegExp.prototype.toString.call(e),\"regexp\");if(v(e))return t.stylize(Date.prototype.toString.call(e),\"date\");if(x(e))return u(e)}var l,w=\"\",k=!1,S=[\"{\",\"}\"];return d(e)&&(k=!0,S=[\"[\",\"]\"]),E(e)&&(w=\" [Function\"+(e.name?\": \"+e.name:\"\")+\"]\"),y(e)&&(w=\" \"+RegExp.prototype.toString.call(e)),v(e)&&(w=\" \"+Date.prototype.toUTCString.call(e)),x(e)&&(w=\" \"+u(e)),0!==o.length||k&&0!=e.length?r<0?y(e)?t.stylize(RegExp.prototype.toString.call(e),\"regexp\"):t.stylize(\"[Object]\",\"special\"):(t.seen.push(e),l=k?function(t,e,r,i,n){for(var a=[],o=0,s=e.length;o<s;++o)A(e,String(o))?a.push(c(t,e,r,i,String(o),!0)):a.push(\"\");return n.forEach((function(n){n.match(/^\\d+$/)||a.push(c(t,e,r,i,n,!0))})),a}(t,e,r,s,o):o.map((function(i){return c(t,e,r,s,i,k)})),t.seen.pop(),function(t,e,r){return t.reduce((function(t,e){return e.indexOf(\"\\n\"),t+e.replace(/\\u001b\\[\\d\\d?m/g,\"\").length+1}),0)>60?r[0]+(\"\"===e?\"\":e+\"\\n \")+\" \"+t.join(\",\\n  \")+\" \"+r[1]:r[0]+e+\" \"+t.join(\", \")+\" \"+r[1]}(l,w,S)):S[0]+w+S[1]}function u(t){return\"[\"+Error.prototype.toString.call(t)+\"]\"}function c(t,e,r,i,n,a){var o,s,h;if((h=Object.getOwnPropertyDescriptor(e,n)||{value:e[n]}).get?s=h.set?t.stylize(\"[Getter/Setter]\",\"special\"):t.stylize(\"[Getter]\",\"special\"):h.set&&(s=t.stylize(\"[Setter]\",\"special\")),A(i,n)||(o=\"[\"+n+\"]\"),s||(t.seen.indexOf(h.value)<0?(s=m(r)?f(t,h.value,null):f(t,h.value,r-1)).indexOf(\"\\n\")>-1&&(s=a?s.split(\"\\n\").map((function(t){return\"  \"+t})).join(\"\\n\").substr(2):\"\\n\"+s.split(\"\\n\").map((function(t){return\"   \"+t})).join(\"\\n\")):s=t.stylize(\"[Circular]\",\"special\")),_(o)){if(a&&n.match(/^\\d+$/))return s;(o=JSON.stringify(\"\"+n)).match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)?(o=o.substr(1,o.length-2),o=t.stylize(o,\"name\")):(o=o.replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"').replace(/(^\"|\"$)/g,\"'\"),o=t.stylize(o,\"string\"))}return o+\": \"+s}function d(t){return Array.isArray(t)}function p(t){return\"boolean\"==typeof t}function m(t){return null===t}function g(t){return\"number\"==typeof t}function b(t){return\"string\"==typeof t}function _(t){return void 0===t}function y(t){return w(t)&&\"[object RegExp]\"===k(t)}function w(t){return\"object\"==typeof t&&null!==t}function v(t){return w(t)&&\"[object Date]\"===k(t)}function x(t){return w(t)&&(\"[object Error]\"===k(t)||t instanceof Error)}function E(t){return\"function\"==typeof t}function k(t){return Object.prototype.toString.call(t)}function S(t){return t<10?\"0\"+t.toString(10):t.toString(10)}i.debuglog=function(t){if(_(a)&&(a=e.env.NODE_DEBUG||\"\"),t=t.toUpperCase(),!o[t])if(new RegExp(\"\\\\b\"+t+\"\\\\b\",\"i\").test(a)){var r=e.pid;o[t]=function(){var e=i.format.apply(i,arguments);console.error(\"%s %d: %s\",t,r,e)}}else o[t]=function(){};return o[t]},i.inspect=s,s.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},s.styles={special:\"cyan\",number:\"yellow\",boolean:\"yellow\",undefined:\"grey\",null:\"bold\",string:\"green\",date:\"magenta\",regexp:\"red\"},i.isArray=d,i.isBoolean=p,i.isNull=m,i.isNullOrUndefined=function(t){return null==t},i.isNumber=g,i.isString=b,i.isSymbol=function(t){return\"symbol\"==typeof t},i.isUndefined=_,i.isRegExp=y,i.isObject=w,i.isDate=v,i.isError=x,i.isFunction=E,i.isPrimitive=function(t){return null===t||\"boolean\"==typeof t||\"number\"==typeof t||\"string\"==typeof t||\"symbol\"==typeof t||void 0===t},i.isBuffer=t(\"./support/isBuffer\");var M=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"];function A(t,e){return Object.prototype.hasOwnProperty.call(t,e)}i.log=function(){var t,e;console.log(\"%s - %s\",(t=new Date,e=[S(t.getHours()),S(t.getMinutes()),S(t.getSeconds())].join(\":\"),[t.getDate(),M[t.getMonth()],e].join(\" \")),i.format.apply(i,arguments))},i.inherits=t(\"inherits\"),i._extend=function(t,e){if(!e||!w(e))return t;for(var r=Object.keys(e),i=r.length;i--;)t[r[i]]=e[r[i]];return t}}).call(this)}).call(this,t(\"_process\"),void 0!==r.g?r.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"./support/isBuffer\":25,_process:60,inherits:24}],27:[function(t,e,i){(function(r){(function(){\"use strict\";var i=t(\"array-filter\");e.exports=function(){return i([\"BigInt64Array\",\"BigUint64Array\",\"Float32Array\",\"Float64Array\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\"],(function(t){return\"function\"==typeof r[t]}))}}).call(this)}).call(this,void 0!==r.g?r.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"array-filter\":28}],28:[function(t,e,r){e.exports=function(t,e,r){if(t.filter)return t.filter(e,r);if(null==t)throw new TypeError;if(\"function\"!=typeof e)throw new TypeError;for(var n=[],a=0;a<t.length;a++)if(i.call(t,a)){var o=t[a];e.call(r,o,a,t)&&n.push(o)}return n};var i=Object.prototype.hasOwnProperty},{}],29:[function(t,e,r){\"use strict\";r.byteLength=function(t){var e=l(t),r=e[0],i=e[1];return 3*(r+i)/4-i},r.toByteArray=function(t){var e,r,i=l(t),o=i[0],s=i[1],h=new a(function(t,e,r){return 3*(e+r)/4-r}(0,o,s)),f=0,u=s>0?o-4:o;for(r=0;r<u;r+=4)e=n[t.charCodeAt(r)]<<18|n[t.charCodeAt(r+1)]<<12|n[t.charCodeAt(r+2)]<<6|n[t.charCodeAt(r+3)],h[f++]=e>>16&255,h[f++]=e>>8&255,h[f++]=255&e;return 2===s&&(e=n[t.charCodeAt(r)]<<2|n[t.charCodeAt(r+1)]>>4,h[f++]=255&e),1===s&&(e=n[t.charCodeAt(r)]<<10|n[t.charCodeAt(r+1)]<<4|n[t.charCodeAt(r+2)]>>2,h[f++]=e>>8&255,h[f++]=255&e),h},r.fromByteArray=function(t){for(var e,r=t.length,n=r%3,a=[],o=16383,s=0,h=r-n;s<h;s+=o)a.push(f(t,s,s+o>h?h:s+o));return 1===n?(e=t[r-1],a.push(i[e>>2]+i[e<<4&63]+\"==\")):2===n&&(e=(t[r-2]<<8)+t[r-1],a.push(i[e>>10]+i[e>>4&63]+i[e<<2&63]+\"=\")),a.join(\"\")};for(var i=[],n=[],a=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",s=0,h=o.length;s<h;++s)i[s]=o[s],n[o.charCodeAt(s)]=s;function l(t){var e=t.length;if(e%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");var r=t.indexOf(\"=\");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function f(t,e,r){for(var n,a=[],o=e;o<r;o+=3)n=(t[o]<<16&16711680)+(t[o+1]<<8&65280)+(255&t[o+2]),a.push(i[(s=n)>>18&63]+i[s>>12&63]+i[s>>6&63]+i[63&s]);var s;return a.join(\"\")}n[\"-\".charCodeAt(0)]=62,n[\"_\".charCodeAt(0)]=63},{}],30:[function(t,e,r){},{}],31:[function(t,e,r){(function(e,i){(function(){\"use strict\";var n=t(\"assert\"),a=t(\"pako/lib/zlib/zstream\"),o=t(\"pako/lib/zlib/deflate.js\"),s=t(\"pako/lib/zlib/inflate.js\"),h=t(\"pako/lib/zlib/constants\");for(var l in h)r[l]=h[l];r.NONE=0,r.DEFLATE=1,r.INFLATE=2,r.GZIP=3,r.GUNZIP=4,r.DEFLATERAW=5,r.INFLATERAW=6,r.UNZIP=7;function f(t){if(\"number\"!=typeof t||t<r.DEFLATE||t>r.UNZIP)throw new TypeError(\"Bad argument\");this.dictionary=null,this.err=0,this.flush=0,this.init_done=!1,this.level=0,this.memLevel=0,this.mode=t,this.strategy=0,this.windowBits=0,this.write_in_progress=!1,this.pending_close=!1,this.gzip_id_bytes_read=0}f.prototype.close=function(){this.write_in_progress?this.pending_close=!0:(this.pending_close=!1,n(this.init_done,\"close before init\"),n(this.mode<=r.UNZIP),this.mode===r.DEFLATE||this.mode===r.GZIP||this.mode===r.DEFLATERAW?o.deflateEnd(this.strm):this.mode!==r.INFLATE&&this.mode!==r.GUNZIP&&this.mode!==r.INFLATERAW&&this.mode!==r.UNZIP||s.inflateEnd(this.strm),this.mode=r.NONE,this.dictionary=null)},f.prototype.write=function(t,e,r,i,n,a,o){return this._write(!0,t,e,r,i,n,a,o)},f.prototype.writeSync=function(t,e,r,i,n,a,o){return this._write(!1,t,e,r,i,n,a,o)},f.prototype._write=function(t,a,o,s,h,l,f,u){if(n.equal(arguments.length,8),n(this.init_done,\"write before init\"),n(this.mode!==r.NONE,\"already finalized\"),n.equal(!1,this.write_in_progress,\"write already in progress\"),n.equal(!1,this.pending_close,\"close is pending\"),this.write_in_progress=!0,n.equal(!1,void 0===a,\"must provide flush value\"),this.write_in_progress=!0,a!==r.Z_NO_FLUSH&&a!==r.Z_PARTIAL_FLUSH&&a!==r.Z_SYNC_FLUSH&&a!==r.Z_FULL_FLUSH&&a!==r.Z_FINISH&&a!==r.Z_BLOCK)throw new Error(\"Invalid flush value\");if(null==o&&(o=i.alloc(0),h=0,s=0),this.strm.avail_in=h,this.strm.input=o,this.strm.next_in=s,this.strm.avail_out=u,this.strm.output=l,this.strm.next_out=f,this.flush=a,!t)return this._process(),this._checkError()?this._afterSync():void 0;var c=this;return e.nextTick((function(){c._process(),c._after()})),this},f.prototype._afterSync=function(){var t=this.strm.avail_out,e=this.strm.avail_in;return this.write_in_progress=!1,[e,t]},f.prototype._process=function(){var t=null;switch(this.mode){case r.DEFLATE:case r.GZIP:case r.DEFLATERAW:this.err=o.deflate(this.strm,this.flush);break;case r.UNZIP:switch(this.strm.avail_in>0&&(t=this.strm.next_in),this.gzip_id_bytes_read){case 0:if(null===t)break;if(31!==this.strm.input[t]){this.mode=r.INFLATE;break}if(this.gzip_id_bytes_read=1,t++,1===this.strm.avail_in)break;case 1:if(null===t)break;139===this.strm.input[t]?(this.gzip_id_bytes_read=2,this.mode=r.GUNZIP):this.mode=r.INFLATE;break;default:throw new Error(\"invalid number of gzip magic number bytes read\")}case r.INFLATE:case r.GUNZIP:case r.INFLATERAW:for(this.err=s.inflate(this.strm,this.flush),this.err===r.Z_NEED_DICT&&this.dictionary&&(this.err=s.inflateSetDictionary(this.strm,this.dictionary),this.err===r.Z_OK?this.err=s.inflate(this.strm,this.flush):this.err===r.Z_DATA_ERROR&&(this.err=r.Z_NEED_DICT));this.strm.avail_in>0&&this.mode===r.GUNZIP&&this.err===r.Z_STREAM_END&&0!==this.strm.next_in[0];)this.reset(),this.err=s.inflate(this.strm,this.flush);break;default:throw new Error(\"Unknown mode \"+this.mode)}},f.prototype._checkError=function(){switch(this.err){case r.Z_OK:case r.Z_BUF_ERROR:if(0!==this.strm.avail_out&&this.flush===r.Z_FINISH)return this._error(\"unexpected end of file\"),!1;break;case r.Z_STREAM_END:break;case r.Z_NEED_DICT:return null==this.dictionary?this._error(\"Missing dictionary\"):this._error(\"Bad dictionary\"),!1;default:return this._error(\"Zlib error\"),!1}return!0},f.prototype._after=function(){if(this._checkError()){var t=this.strm.avail_out,e=this.strm.avail_in;this.write_in_progress=!1,this.callback(e,t),this.pending_close&&this.close()}},f.prototype._error=function(t){this.strm.msg&&(t=this.strm.msg),this.onerror(t,this.err),this.write_in_progress=!1,this.pending_close&&this.close()},f.prototype.init=function(t,e,i,a,o){n(4===arguments.length||5===arguments.length,\"init(windowBits, level, memLevel, strategy, [dictionary])\"),n(t>=8&&t<=15,\"invalid windowBits\"),n(e>=-1&&e<=9,\"invalid compression level\"),n(i>=1&&i<=9,\"invalid memlevel\"),n(a===r.Z_FILTERED||a===r.Z_HUFFMAN_ONLY||a===r.Z_RLE||a===r.Z_FIXED||a===r.Z_DEFAULT_STRATEGY,\"invalid strategy\"),this._init(e,t,i,a,o),this._setDictionary()},f.prototype.params=function(){throw new Error(\"deflateParams Not supported\")},f.prototype.reset=function(){this._reset(),this._setDictionary()},f.prototype._init=function(t,e,i,n,h){switch(this.level=t,this.windowBits=e,this.memLevel=i,this.strategy=n,this.flush=r.Z_NO_FLUSH,this.err=r.Z_OK,this.mode!==r.GZIP&&this.mode!==r.GUNZIP||(this.windowBits+=16),this.mode===r.UNZIP&&(this.windowBits+=32),this.mode!==r.DEFLATERAW&&this.mode!==r.INFLATERAW||(this.windowBits=-1*this.windowBits),this.strm=new a,this.mode){case r.DEFLATE:case r.GZIP:case r.DEFLATERAW:this.err=o.deflateInit2(this.strm,this.level,r.Z_DEFLATED,this.windowBits,this.memLevel,this.strategy);break;case r.INFLATE:case r.GUNZIP:case r.INFLATERAW:case r.UNZIP:this.err=s.inflateInit2(this.strm,this.windowBits);break;default:throw new Error(\"Unknown mode \"+this.mode)}this.err!==r.Z_OK&&this._error(\"Init error\"),this.dictionary=h,this.write_in_progress=!1,this.init_done=!0},f.prototype._setDictionary=function(){if(null!=this.dictionary){switch(this.err=r.Z_OK,this.mode){case r.DEFLATE:case r.DEFLATERAW:this.err=o.deflateSetDictionary(this.strm,this.dictionary)}this.err!==r.Z_OK&&this._error(\"Failed to set dictionary\")}},f.prototype._reset=function(){switch(this.err=r.Z_OK,this.mode){case r.DEFLATE:case r.DEFLATERAW:case r.GZIP:this.err=o.deflateReset(this.strm);break;case r.INFLATE:case r.INFLATERAW:case r.GUNZIP:this.err=s.inflateReset(this.strm)}this.err!==r.Z_OK&&this._error(\"Failed to reset stream\")},r.Zlib=f}).call(this)}).call(this,t(\"_process\"),t(\"buffer\").Buffer)},{_process:60,assert:23,buffer:33,\"pako/lib/zlib/constants\":51,\"pako/lib/zlib/deflate.js\":53,\"pako/lib/zlib/inflate.js\":55,\"pako/lib/zlib/zstream\":59}],32:[function(t,e,r){(function(e){(function(){\"use strict\";var i=t(\"buffer\").Buffer,n=t(\"stream\").Transform,a=t(\"./binding\"),o=t(\"util\"),s=t(\"assert\").ok,h=t(\"buffer\").kMaxLength,l=\"Cannot create final Buffer. It would be larger than 0x\"+h.toString(16)+\" bytes\";a.Z_MIN_WINDOWBITS=8,a.Z_MAX_WINDOWBITS=15,a.Z_DEFAULT_WINDOWBITS=15,a.Z_MIN_CHUNK=64,a.Z_MAX_CHUNK=1/0,a.Z_DEFAULT_CHUNK=16384,a.Z_MIN_MEMLEVEL=1,a.Z_MAX_MEMLEVEL=9,a.Z_DEFAULT_MEMLEVEL=8,a.Z_MIN_LEVEL=-1,a.Z_MAX_LEVEL=9,a.Z_DEFAULT_LEVEL=a.Z_DEFAULT_COMPRESSION;for(var f=Object.keys(a),u=0;u<f.length;u++){var c=f[u];c.match(/^Z/)&&Object.defineProperty(r,c,{enumerable:!0,value:a[c],writable:!1})}for(var d={Z_OK:a.Z_OK,Z_STREAM_END:a.Z_STREAM_END,Z_NEED_DICT:a.Z_NEED_DICT,Z_ERRNO:a.Z_ERRNO,Z_STREAM_ERROR:a.Z_STREAM_ERROR,Z_DATA_ERROR:a.Z_DATA_ERROR,Z_MEM_ERROR:a.Z_MEM_ERROR,Z_BUF_ERROR:a.Z_BUF_ERROR,Z_VERSION_ERROR:a.Z_VERSION_ERROR},p=Object.keys(d),m=0;m<p.length;m++){var g=p[m];d[d[g]]=g}function b(t,e,r){var n=[],a=0;function o(){for(var e;null!==(e=t.read());)n.push(e),a+=e.length;t.once(\"readable\",o)}function s(){var e,o=null;a>=h?o=new RangeError(l):e=i.concat(n,a),n=[],t.close(),r(o,e)}t.on(\"error\",(function(e){t.removeListener(\"end\",s),t.removeListener(\"readable\",o),r(e)})),t.on(\"end\",s),t.end(e),o()}function _(t,e){if(\"string\"==typeof e&&(e=i.from(e)),!i.isBuffer(e))throw new TypeError(\"Not a string or buffer\");var r=t._finishFlushFlag;return t._processChunk(e,r)}function y(t){if(!(this instanceof y))return new y(t);A.call(this,t,a.DEFLATE)}function w(t){if(!(this instanceof w))return new w(t);A.call(this,t,a.INFLATE)}function v(t){if(!(this instanceof v))return new v(t);A.call(this,t,a.GZIP)}function x(t){if(!(this instanceof x))return new x(t);A.call(this,t,a.GUNZIP)}function E(t){if(!(this instanceof E))return new E(t);A.call(this,t,a.DEFLATERAW)}function k(t){if(!(this instanceof k))return new k(t);A.call(this,t,a.INFLATERAW)}function S(t){if(!(this instanceof S))return new S(t);A.call(this,t,a.UNZIP)}function M(t){return t===a.Z_NO_FLUSH||t===a.Z_PARTIAL_FLUSH||t===a.Z_SYNC_FLUSH||t===a.Z_FULL_FLUSH||t===a.Z_FINISH||t===a.Z_BLOCK}function A(t,e){var o=this;if(this._opts=t=t||{},this._chunkSize=t.chunkSize||r.Z_DEFAULT_CHUNK,n.call(this,t),t.flush&&!M(t.flush))throw new Error(\"Invalid flush flag: \"+t.flush);if(t.finishFlush&&!M(t.finishFlush))throw new Error(\"Invalid flush flag: \"+t.finishFlush);if(this._flushFlag=t.flush||a.Z_NO_FLUSH,this._finishFlushFlag=void 0!==t.finishFlush?t.finishFlush:a.Z_FINISH,t.chunkSize&&(t.chunkSize<r.Z_MIN_CHUNK||t.chunkSize>r.Z_MAX_CHUNK))throw new Error(\"Invalid chunk size: \"+t.chunkSize);if(t.windowBits&&(t.windowBits<r.Z_MIN_WINDOWBITS||t.windowBits>r.Z_MAX_WINDOWBITS))throw new Error(\"Invalid windowBits: \"+t.windowBits);if(t.level&&(t.level<r.Z_MIN_LEVEL||t.level>r.Z_MAX_LEVEL))throw new Error(\"Invalid compression level: \"+t.level);if(t.memLevel&&(t.memLevel<r.Z_MIN_MEMLEVEL||t.memLevel>r.Z_MAX_MEMLEVEL))throw new Error(\"Invalid memLevel: \"+t.memLevel);if(t.strategy&&t.strategy!=r.Z_FILTERED&&t.strategy!=r.Z_HUFFMAN_ONLY&&t.strategy!=r.Z_RLE&&t.strategy!=r.Z_FIXED&&t.strategy!=r.Z_DEFAULT_STRATEGY)throw new Error(\"Invalid strategy: \"+t.strategy);if(t.dictionary&&!i.isBuffer(t.dictionary))throw new Error(\"Invalid dictionary: it should be a Buffer instance\");this._handle=new a.Zlib(e);var s=this;this._hadError=!1,this._handle.onerror=function(t,e){I(s),s._hadError=!0;var i=new Error(t);i.errno=e,i.code=r.codes[e],s.emit(\"error\",i)};var h=r.Z_DEFAULT_COMPRESSION;\"number\"==typeof t.level&&(h=t.level);var l=r.Z_DEFAULT_STRATEGY;\"number\"==typeof t.strategy&&(l=t.strategy),this._handle.init(t.windowBits||r.Z_DEFAULT_WINDOWBITS,h,t.memLevel||r.Z_DEFAULT_MEMLEVEL,l,t.dictionary),this._buffer=i.allocUnsafe(this._chunkSize),this._offset=0,this._level=h,this._strategy=l,this.once(\"end\",this.close),Object.defineProperty(this,\"_closed\",{get:function(){return!o._handle},configurable:!0,enumerable:!0})}function I(t,r){r&&e.nextTick(r),t._handle&&(t._handle.close(),t._handle=null)}function B(t){t.emit(\"close\")}Object.defineProperty(r,\"codes\",{enumerable:!0,value:Object.freeze(d),writable:!1}),r.Deflate=y,r.Inflate=w,r.Gzip=v,r.Gunzip=x,r.DeflateRaw=E,r.InflateRaw=k,r.Unzip=S,r.createDeflate=function(t){return new y(t)},r.createInflate=function(t){return new w(t)},r.createDeflateRaw=function(t){return new E(t)},r.createInflateRaw=function(t){return new k(t)},r.createGzip=function(t){return new v(t)},r.createGunzip=function(t){return new x(t)},r.createUnzip=function(t){return new S(t)},r.deflate=function(t,e,r){return\"function\"==typeof e&&(r=e,e={}),b(new y(e),t,r)},r.deflateSync=function(t,e){return _(new y(e),t)},r.gzip=function(t,e,r){return\"function\"==typeof e&&(r=e,e={}),b(new v(e),t,r)},r.gzipSync=function(t,e){return _(new v(e),t)},r.deflateRaw=function(t,e,r){return\"function\"==typeof e&&(r=e,e={}),b(new E(e),t,r)},r.deflateRawSync=function(t,e){return _(new E(e),t)},r.unzip=function(t,e,r){return\"function\"==typeof e&&(r=e,e={}),b(new S(e),t,r)},r.unzipSync=function(t,e){return _(new S(e),t)},r.inflate=function(t,e,r){return\"function\"==typeof e&&(r=e,e={}),b(new w(e),t,r)},r.inflateSync=function(t,e){return _(new w(e),t)},r.gunzip=function(t,e,r){return\"function\"==typeof e&&(r=e,e={}),b(new x(e),t,r)},r.gunzipSync=function(t,e){return _(new x(e),t)},r.inflateRaw=function(t,e,r){return\"function\"==typeof e&&(r=e,e={}),b(new k(e),t,r)},r.inflateRawSync=function(t,e){return _(new k(e),t)},o.inherits(A,n),A.prototype.params=function(t,i,n){if(t<r.Z_MIN_LEVEL||t>r.Z_MAX_LEVEL)throw new RangeError(\"Invalid compression level: \"+t);if(i!=r.Z_FILTERED&&i!=r.Z_HUFFMAN_ONLY&&i!=r.Z_RLE&&i!=r.Z_FIXED&&i!=r.Z_DEFAULT_STRATEGY)throw new TypeError(\"Invalid strategy: \"+i);if(this._level!==t||this._strategy!==i){var o=this;this.flush(a.Z_SYNC_FLUSH,(function(){s(o._handle,\"zlib binding closed\"),o._handle.params(t,i),o._hadError||(o._level=t,o._strategy=i,n&&n())}))}else e.nextTick(n)},A.prototype.reset=function(){return s(this._handle,\"zlib binding closed\"),this._handle.reset()},A.prototype._flush=function(t){this._transform(i.alloc(0),\"\",t)},A.prototype.flush=function(t,r){var n=this,o=this._writableState;(\"function\"==typeof t||void 0===t&&!r)&&(r=t,t=a.Z_FULL_FLUSH),o.ended?r&&e.nextTick(r):o.ending?r&&this.once(\"end\",r):o.needDrain?r&&this.once(\"drain\",(function(){return n.flush(t,r)})):(this._flushFlag=t,this.write(i.alloc(0),\"\",r))},A.prototype.close=function(t){I(this,t),e.nextTick(B,this)},A.prototype._transform=function(t,e,r){var n,o=this._writableState,s=(o.ending||o.ended)&&(!t||o.length===t.length);return null===t||i.isBuffer(t)?this._handle?(s?n=this._finishFlushFlag:(n=this._flushFlag,t.length>=o.length&&(this._flushFlag=this._opts.flush||a.Z_NO_FLUSH)),void this._processChunk(t,n,r)):r(new Error(\"zlib binding closed\")):r(new Error(\"invalid input\"))},A.prototype._processChunk=function(t,e,r){var n=t&&t.length,a=this._chunkSize-this._offset,o=0,f=this,u=\"function\"==typeof r;if(!u){var c,d=[],p=0;this.on(\"error\",(function(t){c=t})),s(this._handle,\"zlib binding closed\");do{var m=this._handle.writeSync(e,t,o,n,this._buffer,this._offset,a)}while(!this._hadError&&_(m[0],m[1]));if(this._hadError)throw c;if(p>=h)throw I(this),new RangeError(l);var g=i.concat(d,p);return I(this),g}s(this._handle,\"zlib binding closed\");var b=this._handle.write(e,t,o,n,this._buffer,this._offset,a);function _(h,l){if(this&&(this.buffer=null,this.callback=null),!f._hadError){var c=a-l;if(s(c>=0,\"have should not go down\"),c>0){var m=f._buffer.slice(f._offset,f._offset+c);f._offset+=c,u?f.push(m):(d.push(m),p+=m.length)}if((0===l||f._offset>=f._chunkSize)&&(a=f._chunkSize,f._offset=0,f._buffer=i.allocUnsafe(f._chunkSize)),0===l){if(o+=n-h,n=h,!u)return!0;var g=f._handle.write(e,t,o,n,f._buffer,f._offset,f._chunkSize);return g.callback=_,void(g.buffer=t)}if(!u)return!1;r()}}b.buffer=t,b.callback=_},o.inherits(y,A),o.inherits(w,A),o.inherits(v,A),o.inherits(x,A),o.inherits(E,A),o.inherits(k,A),o.inherits(S,A)}).call(this)}).call(this,t(\"_process\"))},{\"./binding\":31,_process:60,assert:23,buffer:33,stream:61,util:81}],33:[function(t,e,r){(function(e){(function(){\"use strict\";var e=t(\"base64-js\"),i=t(\"ieee754\");r.Buffer=o,r.SlowBuffer=function(t){return+t!=t&&(t=0),o.alloc(+t)},r.INSPECT_MAX_BYTES=50;var n=2147483647;function a(t){if(t>n)throw new RangeError('The value \"'+t+'\" is invalid for option \"size\"');var e=new Uint8Array(t);return e.__proto__=o.prototype,e}function o(t,e,r){if(\"number\"==typeof t){if(\"string\"==typeof e)throw new TypeError('The \"string\" argument must be of type string. Received type number');return l(t)}return s(t,e,r)}function s(t,e,r){if(\"string\"==typeof t)return function(t,e){if(\"string\"==typeof e&&\"\"!==e||(e=\"utf8\"),!o.isEncoding(e))throw new TypeError(\"Unknown encoding: \"+e);var r=0|c(t,e),i=a(r),n=i.write(t,e);return n!==r&&(i=i.slice(0,n)),i}(t,e);if(ArrayBuffer.isView(t))return f(t);if(null==t)throw TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof t);if(N(t,ArrayBuffer)||t&&N(t.buffer,ArrayBuffer))return function(t,e,r){if(e<0||t.byteLength<e)throw new RangeError('\"offset\" is outside of buffer bounds');if(t.byteLength<e+(r||0))throw new RangeError('\"length\" is outside of buffer bounds');var i;return(i=void 0===e&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,e):new Uint8Array(t,e,r)).__proto__=o.prototype,i}(t,e,r);if(\"number\"==typeof t)throw new TypeError('The \"value\" argument must not be of type number. Received type number');var i=t.valueOf&&t.valueOf();if(null!=i&&i!==t)return o.from(i,e,r);var n=function(t){if(o.isBuffer(t)){var e=0|u(t.length),r=a(e);return 0===r.length||t.copy(r,0,0,e),r}return void 0!==t.length?\"number\"!=typeof t.length||F(t.length)?a(0):f(t):\"Buffer\"===t.type&&Array.isArray(t.data)?f(t.data):void 0}(t);if(n)return n;if(\"undefined\"!=typeof Symbol&&null!=Symbol.toPrimitive&&\"function\"==typeof t[Symbol.toPrimitive])return o.from(t[Symbol.toPrimitive](\"string\"),e,r);throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof t)}function h(t){if(\"number\"!=typeof t)throw new TypeError('\"size\" argument must be of type number');if(t<0)throw new RangeError('The value \"'+t+'\" is invalid for option \"size\"')}function l(t){return h(t),a(t<0?0:0|u(t))}function f(t){for(var e=t.length<0?0:0|u(t.length),r=a(e),i=0;i<e;i+=1)r[i]=255&t[i];return r}function u(t){if(t>=n)throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+n.toString(16)+\" bytes\");return 0|t}function c(t,e){if(o.isBuffer(t))return t.length;if(ArrayBuffer.isView(t)||N(t,ArrayBuffer))return t.byteLength;if(\"string\"!=typeof t)throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof t);var r=t.length,i=arguments.length>2&&!0===arguments[2];if(!i&&0===r)return 0;for(var n=!1;;)switch(e){case\"ascii\":case\"latin1\":case\"binary\":return r;case\"utf8\":case\"utf-8\":return U(t).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return 2*r;case\"hex\":return r>>>1;case\"base64\":return z(t).length;default:if(n)return i?-1:U(t).length;e=(\"\"+e).toLowerCase(),n=!0}}function d(t,e,r){var i=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return\"\";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return\"\";if((r>>>=0)<=(e>>>=0))return\"\";for(t||(t=\"utf8\");;)switch(t){case\"hex\":return I(this,e,r);case\"utf8\":case\"utf-8\":return k(this,e,r);case\"ascii\":return M(this,e,r);case\"latin1\":case\"binary\":return A(this,e,r);case\"base64\":return E(this,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return B(this,e,r);default:if(i)throw new TypeError(\"Unknown encoding: \"+t);t=(t+\"\").toLowerCase(),i=!0}}function p(t,e,r){var i=t[e];t[e]=t[r],t[r]=i}function m(t,e,r,i,n){if(0===t.length)return-1;if(\"string\"==typeof r?(i=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),F(r=+r)&&(r=n?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(n)return-1;r=t.length-1}else if(r<0){if(!n)return-1;r=0}if(\"string\"==typeof e&&(e=o.from(e,i)),o.isBuffer(e))return 0===e.length?-1:g(t,e,r,i,n);if(\"number\"==typeof e)return e&=255,\"function\"==typeof Uint8Array.prototype.indexOf?n?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):g(t,[e],r,i,n);throw new TypeError(\"val must be string, number or Buffer\")}function g(t,e,r,i,n){var a,o=1,s=t.length,h=e.length;if(void 0!==i&&(\"ucs2\"===(i=String(i).toLowerCase())||\"ucs-2\"===i||\"utf16le\"===i||\"utf-16le\"===i)){if(t.length<2||e.length<2)return-1;o=2,s/=2,h/=2,r/=2}function l(t,e){return 1===o?t[e]:t.readUInt16BE(e*o)}if(n){var f=-1;for(a=r;a<s;a++)if(l(t,a)===l(e,-1===f?0:a-f)){if(-1===f&&(f=a),a-f+1===h)return f*o}else-1!==f&&(a-=a-f),f=-1}else for(r+h>s&&(r=s-h),a=r;a>=0;a--){for(var u=!0,c=0;c<h;c++)if(l(t,a+c)!==l(e,c)){u=!1;break}if(u)return a}return-1}function b(t,e,r,i){r=Number(r)||0;var n=t.length-r;i?(i=Number(i))>n&&(i=n):i=n;var a=e.length;i>a/2&&(i=a/2);for(var o=0;o<i;++o){var s=parseInt(e.substr(2*o,2),16);if(F(s))return o;t[r+o]=s}return o}function _(t,e,r,i){return D(U(e,t.length-r),t,r,i)}function y(t,e,r,i){return D(function(t){for(var e=[],r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,i)}function w(t,e,r,i){return y(t,e,r,i)}function v(t,e,r,i){return D(z(e),t,r,i)}function x(t,e,r,i){return D(function(t,e){for(var r,i,n,a=[],o=0;o<t.length&&!((e-=2)<0);++o)i=(r=t.charCodeAt(o))>>8,n=r%256,a.push(n),a.push(i);return a}(e,t.length-r),t,r,i)}function E(t,r,i){return 0===r&&i===t.length?e.fromByteArray(t):e.fromByteArray(t.slice(r,i))}function k(t,e,r){r=Math.min(t.length,r);for(var i=[],n=e;n<r;){var a,o,s,h,l=t[n],f=null,u=l>239?4:l>223?3:l>191?2:1;if(n+u<=r)switch(u){case 1:l<128&&(f=l);break;case 2:128==(192&(a=t[n+1]))&&(h=(31&l)<<6|63&a)>127&&(f=h);break;case 3:a=t[n+1],o=t[n+2],128==(192&a)&&128==(192&o)&&(h=(15&l)<<12|(63&a)<<6|63&o)>2047&&(h<55296||h>57343)&&(f=h);break;case 4:a=t[n+1],o=t[n+2],s=t[n+3],128==(192&a)&&128==(192&o)&&128==(192&s)&&(h=(15&l)<<18|(63&a)<<12|(63&o)<<6|63&s)>65535&&h<1114112&&(f=h)}null===f?(f=65533,u=1):f>65535&&(f-=65536,i.push(f>>>10&1023|55296),f=56320|1023&f),i.push(f),n+=u}return function(t){var e=t.length;if(e<=S)return String.fromCharCode.apply(String,t);for(var r=\"\",i=0;i<e;)r+=String.fromCharCode.apply(String,t.slice(i,i+=S));return r}(i)}r.kMaxLength=n,o.TYPED_ARRAY_SUPPORT=function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()}catch(t){return!1}}(),o.TYPED_ARRAY_SUPPORT||\"undefined\"==typeof console||\"function\"!=typeof console.error||console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"),Object.defineProperty(o.prototype,\"parent\",{enumerable:!0,get:function(){if(o.isBuffer(this))return this.buffer}}),Object.defineProperty(o.prototype,\"offset\",{enumerable:!0,get:function(){if(o.isBuffer(this))return this.byteOffset}}),\"undefined\"!=typeof Symbol&&null!=Symbol.species&&o[Symbol.species]===o&&Object.defineProperty(o,Symbol.species,{value:null,configurable:!0,enumerable:!1,writable:!1}),o.poolSize=8192,o.from=function(t,e,r){return s(t,e,r)},o.prototype.__proto__=Uint8Array.prototype,o.__proto__=Uint8Array,o.alloc=function(t,e,r){return function(t,e,r){return h(t),t<=0?a(t):void 0!==e?\"string\"==typeof r?a(t).fill(e,r):a(t).fill(e):a(t)}(t,e,r)},o.allocUnsafe=function(t){return l(t)},o.allocUnsafeSlow=function(t){return l(t)},o.isBuffer=function(t){return null!=t&&!0===t._isBuffer&&t!==o.prototype},o.compare=function(t,e){if(N(t,Uint8Array)&&(t=o.from(t,t.offset,t.byteLength)),N(e,Uint8Array)&&(e=o.from(e,e.offset,e.byteLength)),!o.isBuffer(t)||!o.isBuffer(e))throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');if(t===e)return 0;for(var r=t.length,i=e.length,n=0,a=Math.min(r,i);n<a;++n)if(t[n]!==e[n]){r=t[n],i=e[n];break}return r<i?-1:i<r?1:0},o.isEncoding=function(t){switch(String(t).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},o.concat=function(t,e){if(!Array.isArray(t))throw new TypeError('\"list\" argument must be an Array of Buffers');if(0===t.length)return o.alloc(0);var r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;var i=o.allocUnsafe(e),n=0;for(r=0;r<t.length;++r){var a=t[r];if(N(a,Uint8Array)&&(a=o.from(a)),!o.isBuffer(a))throw new TypeError('\"list\" argument must be an Array of Buffers');a.copy(i,n),n+=a.length}return i},o.byteLength=c,o.prototype._isBuffer=!0,o.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(var e=0;e<t;e+=2)p(this,e,e+1);return this},o.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(var e=0;e<t;e+=4)p(this,e,e+3),p(this,e+1,e+2);return this},o.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(var e=0;e<t;e+=8)p(this,e,e+7),p(this,e+1,e+6),p(this,e+2,e+5),p(this,e+3,e+4);return this},o.prototype.toString=function(){var t=this.length;return 0===t?\"\":0===arguments.length?k(this,0,t):d.apply(this,arguments)},o.prototype.toLocaleString=o.prototype.toString,o.prototype.equals=function(t){if(!o.isBuffer(t))throw new TypeError(\"Argument must be a Buffer\");return this===t||0===o.compare(this,t)},o.prototype.inspect=function(){var t=\"\",e=r.INSPECT_MAX_BYTES;return t=this.toString(\"hex\",0,e).replace(/(.{2})/g,\"$1 \").trim(),this.length>e&&(t+=\" ... \"),\"<Buffer \"+t+\">\"},o.prototype.compare=function(t,e,r,i,n){if(N(t,Uint8Array)&&(t=o.from(t,t.offset,t.byteLength)),!o.isBuffer(t))throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type '+typeof t);if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===i&&(i=0),void 0===n&&(n=this.length),e<0||r>t.length||i<0||n>this.length)throw new RangeError(\"out of range index\");if(i>=n&&e>=r)return 0;if(i>=n)return-1;if(e>=r)return 1;if(this===t)return 0;for(var a=(n>>>=0)-(i>>>=0),s=(r>>>=0)-(e>>>=0),h=Math.min(a,s),l=this.slice(i,n),f=t.slice(e,r),u=0;u<h;++u)if(l[u]!==f[u]){a=l[u],s=f[u];break}return a<s?-1:s<a?1:0},o.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},o.prototype.indexOf=function(t,e,r){return m(this,t,e,r,!0)},o.prototype.lastIndexOf=function(t,e,r){return m(this,t,e,r,!1)},o.prototype.write=function(t,e,r,i){if(void 0===e)i=\"utf8\",r=this.length,e=0;else if(void 0===r&&\"string\"==typeof e)i=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");e>>>=0,isFinite(r)?(r>>>=0,void 0===i&&(i=\"utf8\")):(i=r,r=void 0)}var n=this.length-e;if((void 0===r||r>n)&&(r=n),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");i||(i=\"utf8\");for(var a=!1;;)switch(i){case\"hex\":return b(this,t,e,r);case\"utf8\":case\"utf-8\":return _(this,t,e,r);case\"ascii\":return y(this,t,e,r);case\"latin1\":case\"binary\":return w(this,t,e,r);case\"base64\":return v(this,t,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return x(this,t,e,r);default:if(a)throw new TypeError(\"Unknown encoding: \"+i);i=(\"\"+i).toLowerCase(),a=!0}},o.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};var S=4096;function M(t,e,r){var i=\"\";r=Math.min(t.length,r);for(var n=e;n<r;++n)i+=String.fromCharCode(127&t[n]);return i}function A(t,e,r){var i=\"\";r=Math.min(t.length,r);for(var n=e;n<r;++n)i+=String.fromCharCode(t[n]);return i}function I(t,e,r){var i,n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);for(var a=\"\",o=e;o<r;++o)a+=(i=t[o])<16?\"0\"+i.toString(16):i.toString(16);return a}function B(t,e,r){for(var i=t.slice(e,r),n=\"\",a=0;a<i.length;a+=2)n+=String.fromCharCode(i[a]+256*i[a+1]);return n}function T(t,e,r){if(t%1!=0||t<0)throw new RangeError(\"offset is not uint\");if(t+e>r)throw new RangeError(\"Trying to access beyond buffer length\")}function R(t,e,r,i,n,a){if(!o.isBuffer(t))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(e>n||e<a)throw new RangeError('\"value\" argument is out of bounds');if(r+i>t.length)throw new RangeError(\"Index out of range\")}function P(t,e,r,i,n,a){if(r+i>t.length)throw new RangeError(\"Index out of range\");if(r<0)throw new RangeError(\"Index out of range\")}function O(t,e,r,n,a){return e=+e,r>>>=0,a||P(t,0,r,4),i.write(t,e,r,n,23,4),r+4}function L(t,e,r,n,a){return e=+e,r>>>=0,a||P(t,0,r,8),i.write(t,e,r,n,52,8),r+8}o.prototype.slice=function(t,e){var r=this.length;(t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=void 0===e?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t);var i=this.subarray(t,e);return i.__proto__=o.prototype,i},o.prototype.readUIntLE=function(t,e,r){t>>>=0,e>>>=0,r||T(t,e,this.length);for(var i=this[t],n=1,a=0;++a<e&&(n*=256);)i+=this[t+a]*n;return i},o.prototype.readUIntBE=function(t,e,r){t>>>=0,e>>>=0,r||T(t,e,this.length);for(var i=this[t+--e],n=1;e>0&&(n*=256);)i+=this[t+--e]*n;return i},o.prototype.readUInt8=function(t,e){return t>>>=0,e||T(t,1,this.length),this[t]},o.prototype.readUInt16LE=function(t,e){return t>>>=0,e||T(t,2,this.length),this[t]|this[t+1]<<8},o.prototype.readUInt16BE=function(t,e){return t>>>=0,e||T(t,2,this.length),this[t]<<8|this[t+1]},o.prototype.readUInt32LE=function(t,e){return t>>>=0,e||T(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},o.prototype.readUInt32BE=function(t,e){return t>>>=0,e||T(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},o.prototype.readIntLE=function(t,e,r){t>>>=0,e>>>=0,r||T(t,e,this.length);for(var i=this[t],n=1,a=0;++a<e&&(n*=256);)i+=this[t+a]*n;return i>=(n*=128)&&(i-=Math.pow(2,8*e)),i},o.prototype.readIntBE=function(t,e,r){t>>>=0,e>>>=0,r||T(t,e,this.length);for(var i=e,n=1,a=this[t+--i];i>0&&(n*=256);)a+=this[t+--i]*n;return a>=(n*=128)&&(a-=Math.pow(2,8*e)),a},o.prototype.readInt8=function(t,e){return t>>>=0,e||T(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},o.prototype.readInt16LE=function(t,e){t>>>=0,e||T(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},o.prototype.readInt16BE=function(t,e){t>>>=0,e||T(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},o.prototype.readInt32LE=function(t,e){return t>>>=0,e||T(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},o.prototype.readInt32BE=function(t,e){return t>>>=0,e||T(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},o.prototype.readFloatLE=function(t,e){return t>>>=0,e||T(t,4,this.length),i.read(this,t,!0,23,4)},o.prototype.readFloatBE=function(t,e){return t>>>=0,e||T(t,4,this.length),i.read(this,t,!1,23,4)},o.prototype.readDoubleLE=function(t,e){return t>>>=0,e||T(t,8,this.length),i.read(this,t,!0,52,8)},o.prototype.readDoubleBE=function(t,e){return t>>>=0,e||T(t,8,this.length),i.read(this,t,!1,52,8)},o.prototype.writeUIntLE=function(t,e,r,i){t=+t,e>>>=0,r>>>=0,i||R(this,t,e,r,Math.pow(2,8*r)-1,0);var n=1,a=0;for(this[e]=255&t;++a<r&&(n*=256);)this[e+a]=t/n&255;return e+r},o.prototype.writeUIntBE=function(t,e,r,i){t=+t,e>>>=0,r>>>=0,i||R(this,t,e,r,Math.pow(2,8*r)-1,0);var n=r-1,a=1;for(this[e+n]=255&t;--n>=0&&(a*=256);)this[e+n]=t/a&255;return e+r},o.prototype.writeUInt8=function(t,e,r){return t=+t,e>>>=0,r||R(this,t,e,1,255,0),this[e]=255&t,e+1},o.prototype.writeUInt16LE=function(t,e,r){return t=+t,e>>>=0,r||R(this,t,e,2,65535,0),this[e]=255&t,this[e+1]=t>>>8,e+2},o.prototype.writeUInt16BE=function(t,e,r){return t=+t,e>>>=0,r||R(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=255&t,e+2},o.prototype.writeUInt32LE=function(t,e,r){return t=+t,e>>>=0,r||R(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t,e+4},o.prototype.writeUInt32BE=function(t,e,r){return t=+t,e>>>=0,r||R(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},o.prototype.writeIntLE=function(t,e,r,i){if(t=+t,e>>>=0,!i){var n=Math.pow(2,8*r-1);R(this,t,e,r,n-1,-n)}var a=0,o=1,s=0;for(this[e]=255&t;++a<r&&(o*=256);)t<0&&0===s&&0!==this[e+a-1]&&(s=1),this[e+a]=(t/o>>0)-s&255;return e+r},o.prototype.writeIntBE=function(t,e,r,i){if(t=+t,e>>>=0,!i){var n=Math.pow(2,8*r-1);R(this,t,e,r,n-1,-n)}var a=r-1,o=1,s=0;for(this[e+a]=255&t;--a>=0&&(o*=256);)t<0&&0===s&&0!==this[e+a+1]&&(s=1),this[e+a]=(t/o>>0)-s&255;return e+r},o.prototype.writeInt8=function(t,e,r){return t=+t,e>>>=0,r||R(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=255&t,e+1},o.prototype.writeInt16LE=function(t,e,r){return t=+t,e>>>=0,r||R(this,t,e,2,32767,-32768),this[e]=255&t,this[e+1]=t>>>8,e+2},o.prototype.writeInt16BE=function(t,e,r){return t=+t,e>>>=0,r||R(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=255&t,e+2},o.prototype.writeInt32LE=function(t,e,r){return t=+t,e>>>=0,r||R(this,t,e,4,2147483647,-2147483648),this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},o.prototype.writeInt32BE=function(t,e,r){return t=+t,e>>>=0,r||R(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},o.prototype.writeFloatLE=function(t,e,r){return O(this,t,e,!0,r)},o.prototype.writeFloatBE=function(t,e,r){return O(this,t,e,!1,r)},o.prototype.writeDoubleLE=function(t,e,r){return L(this,t,e,!0,r)},o.prototype.writeDoubleBE=function(t,e,r){return L(this,t,e,!1,r)},o.prototype.copy=function(t,e,r,i){if(!o.isBuffer(t))throw new TypeError(\"argument should be a Buffer\");if(r||(r=0),i||0===i||(i=this.length),e>=t.length&&(e=t.length),e||(e=0),i>0&&i<r&&(i=r),i===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError(\"targetStart out of bounds\");if(r<0||r>=this.length)throw new RangeError(\"Index out of range\");if(i<0)throw new RangeError(\"sourceEnd out of bounds\");i>this.length&&(i=this.length),t.length-e<i-r&&(i=t.length-e+r);var n=i-r;if(this===t&&\"function\"==typeof Uint8Array.prototype.copyWithin)this.copyWithin(e,r,i);else if(this===t&&r<e&&e<i)for(var a=n-1;a>=0;--a)t[a+e]=this[a+r];else Uint8Array.prototype.set.call(t,this.subarray(r,i),e);return n},o.prototype.fill=function(t,e,r,i){if(\"string\"==typeof t){if(\"string\"==typeof e?(i=e,e=0,r=this.length):\"string\"==typeof r&&(i=r,r=this.length),void 0!==i&&\"string\"!=typeof i)throw new TypeError(\"encoding must be a string\");if(\"string\"==typeof i&&!o.isEncoding(i))throw new TypeError(\"Unknown encoding: \"+i);if(1===t.length){var n=t.charCodeAt(0);(\"utf8\"===i&&n<128||\"latin1\"===i)&&(t=n)}}else\"number\"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<r)throw new RangeError(\"Out of range index\");if(r<=e)return this;var a;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),\"number\"==typeof t)for(a=e;a<r;++a)this[a]=t;else{var s=o.isBuffer(t)?t:o.from(t,i),h=s.length;if(0===h)throw new TypeError('The value \"'+t+'\" is invalid for argument \"value\"');for(a=0;a<r-e;++a)this[a+e]=s[a%h]}return this};var C=/[^+/0-9A-Za-z-_]/g;function U(t,e){var r;e=e||1/0;for(var i=t.length,n=null,a=[],o=0;o<i;++o){if((r=t.charCodeAt(o))>55295&&r<57344){if(!n){if(r>56319){(e-=3)>-1&&a.push(239,191,189);continue}if(o+1===i){(e-=3)>-1&&a.push(239,191,189);continue}n=r;continue}if(r<56320){(e-=3)>-1&&a.push(239,191,189),n=r;continue}r=65536+(n-55296<<10|r-56320)}else n&&(e-=3)>-1&&a.push(239,191,189);if(n=null,r<128){if((e-=1)<0)break;a.push(r)}else if(r<2048){if((e-=2)<0)break;a.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;a.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error(\"Invalid code point\");if((e-=4)<0)break;a.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return a}function z(t){return e.toByteArray(function(t){if((t=(t=t.split(\"=\")[0]).trim().replace(C,\"\")).length<2)return\"\";for(;t.length%4!=0;)t+=\"=\";return t}(t))}function D(t,e,r,i){for(var n=0;n<i&&!(n+r>=e.length||n>=t.length);++n)e[n+r]=t[n];return n}function N(t,e){return t instanceof e||null!=t&&null!=t.constructor&&null!=t.constructor.name&&t.constructor.name===e.name}function F(t){return t!=t}}).call(this)}).call(this,t(\"buffer\").Buffer)},{\"base64-js\":29,buffer:33,ieee754:44}],34:[function(t,e,r){\"use strict\";var i,n=TypeError,a=Object.getOwnPropertyDescriptor;if(a)try{a({},\"\")}catch(t){a=null}var o=function(){throw new n},s=a?function(){try{return o}catch(t){try{return a(arguments,\"callee\").get}catch(t){return o}}}():o,h=t(\"has-symbols\")(),l=Object.getPrototypeOf||function(t){return t.__proto__},f=i,u=i,c=i,d=i,p=\"undefined\"==typeof Uint8Array?i:l(Uint8Array),m={\"%Array%\":Array,\"%ArrayBuffer%\":\"undefined\"==typeof ArrayBuffer?i:ArrayBuffer,\"%ArrayBufferPrototype%\":\"undefined\"==typeof ArrayBuffer?i:ArrayBuffer.prototype,\"%ArrayIteratorPrototype%\":h?l([][Symbol.iterator]()):i,\"%ArrayPrototype%\":Array.prototype,\"%ArrayProto_entries%\":Array.prototype.entries,\"%ArrayProto_forEach%\":Array.prototype.forEach,\"%ArrayProto_keys%\":Array.prototype.keys,\"%ArrayProto_values%\":Array.prototype.values,\"%AsyncFromSyncIteratorPrototype%\":i,\"%AsyncFunction%\":u,\"%AsyncFunctionPrototype%\":i,\"%AsyncGenerator%\":i,\"%AsyncGeneratorFunction%\":c,\"%AsyncGeneratorPrototype%\":i,\"%AsyncIteratorPrototype%\":d&&h&&Symbol.asyncIterator?d[Symbol.asyncIterator]():i,\"%Atomics%\":\"undefined\"==typeof Atomics?i:Atomics,\"%Boolean%\":Boolean,\"%BooleanPrototype%\":Boolean.prototype,\"%DataView%\":\"undefined\"==typeof DataView?i:DataView,\"%DataViewPrototype%\":\"undefined\"==typeof DataView?i:DataView.prototype,\"%Date%\":Date,\"%DatePrototype%\":Date.prototype,\"%decodeURI%\":decodeURI,\"%decodeURIComponent%\":decodeURIComponent,\"%encodeURI%\":encodeURI,\"%encodeURIComponent%\":encodeURIComponent,\"%Error%\":Error,\"%ErrorPrototype%\":Error.prototype,\"%eval%\":eval,\"%EvalError%\":EvalError,\"%EvalErrorPrototype%\":EvalError.prototype,\"%Float32Array%\":\"undefined\"==typeof Float32Array?i:Float32Array,\"%Float32ArrayPrototype%\":\"undefined\"==typeof Float32Array?i:Float32Array.prototype,\"%Float64Array%\":\"undefined\"==typeof Float64Array?i:Float64Array,\"%Float64ArrayPrototype%\":\"undefined\"==typeof Float64Array?i:Float64Array.prototype,\"%Function%\":Function,\"%FunctionPrototype%\":Function.prototype,\"%Generator%\":i,\"%GeneratorFunction%\":f,\"%GeneratorPrototype%\":i,\"%Int8Array%\":\"undefined\"==typeof Int8Array?i:Int8Array,\"%Int8ArrayPrototype%\":\"undefined\"==typeof Int8Array?i:Int8Array.prototype,\"%Int16Array%\":\"undefined\"==typeof Int16Array?i:Int16Array,\"%Int16ArrayPrototype%\":\"undefined\"==typeof Int16Array?i:Int8Array.prototype,\"%Int32Array%\":\"undefined\"==typeof Int32Array?i:Int32Array,\"%Int32ArrayPrototype%\":\"undefined\"==typeof Int32Array?i:Int32Array.prototype,\"%isFinite%\":isFinite,\"%isNaN%\":isNaN,\"%IteratorPrototype%\":h?l(l([][Symbol.iterator]())):i,\"%JSON%\":\"object\"==typeof JSON?JSON:i,\"%JSONParse%\":\"object\"==typeof JSON?JSON.parse:i,\"%Map%\":\"undefined\"==typeof Map?i:Map,\"%MapIteratorPrototype%\":\"undefined\"!=typeof Map&&h?l((new Map)[Symbol.iterator]()):i,\"%MapPrototype%\":\"undefined\"==typeof Map?i:Map.prototype,\"%Math%\":Math,\"%Number%\":Number,\"%NumberPrototype%\":Number.prototype,\"%Object%\":Object,\"%ObjectPrototype%\":Object.prototype,\"%ObjProto_toString%\":Object.prototype.toString,\"%ObjProto_valueOf%\":Object.prototype.valueOf,\"%parseFloat%\":parseFloat,\"%parseInt%\":parseInt,\"%Promise%\":\"undefined\"==typeof Promise?i:Promise,\"%PromisePrototype%\":\"undefined\"==typeof Promise?i:Promise.prototype,\"%PromiseProto_then%\":\"undefined\"==typeof Promise?i:Promise.prototype.then,\"%Promise_all%\":\"undefined\"==typeof Promise?i:Promise.all,\"%Promise_reject%\":\"undefined\"==typeof Promise?i:Promise.reject,\"%Promise_resolve%\":\"undefined\"==typeof Promise?i:Promise.resolve,\"%Proxy%\":\"undefined\"==typeof Proxy?i:Proxy,\"%RangeError%\":RangeError,\"%RangeErrorPrototype%\":RangeError.prototype,\"%ReferenceError%\":ReferenceError,\"%ReferenceErrorPrototype%\":ReferenceError.prototype,\"%Reflect%\":\"undefined\"==typeof Reflect?i:Reflect,\"%RegExp%\":RegExp,\"%RegExpPrototype%\":RegExp.prototype,\"%Set%\":\"undefined\"==typeof Set?i:Set,\"%SetIteratorPrototype%\":\"undefined\"!=typeof Set&&h?l((new Set)[Symbol.iterator]()):i,\"%SetPrototype%\":\"undefined\"==typeof Set?i:Set.prototype,\"%SharedArrayBuffer%\":\"undefined\"==typeof SharedArrayBuffer?i:SharedArrayBuffer,\"%SharedArrayBufferPrototype%\":\"undefined\"==typeof SharedArrayBuffer?i:SharedArrayBuffer.prototype,\"%String%\":String,\"%StringIteratorPrototype%\":h?l(\"\"[Symbol.iterator]()):i,\"%StringPrototype%\":String.prototype,\"%Symbol%\":h?Symbol:i,\"%SymbolPrototype%\":h?Symbol.prototype:i,\"%SyntaxError%\":SyntaxError,\"%SyntaxErrorPrototype%\":SyntaxError.prototype,\"%ThrowTypeError%\":s,\"%TypedArray%\":p,\"%TypedArrayPrototype%\":p?p.prototype:i,\"%TypeError%\":n,\"%TypeErrorPrototype%\":n.prototype,\"%Uint8Array%\":\"undefined\"==typeof Uint8Array?i:Uint8Array,\"%Uint8ArrayPrototype%\":\"undefined\"==typeof Uint8Array?i:Uint8Array.prototype,\"%Uint8ClampedArray%\":\"undefined\"==typeof Uint8ClampedArray?i:Uint8ClampedArray,\"%Uint8ClampedArrayPrototype%\":\"undefined\"==typeof Uint8ClampedArray?i:Uint8ClampedArray.prototype,\"%Uint16Array%\":\"undefined\"==typeof Uint16Array?i:Uint16Array,\"%Uint16ArrayPrototype%\":\"undefined\"==typeof Uint16Array?i:Uint16Array.prototype,\"%Uint32Array%\":\"undefined\"==typeof Uint32Array?i:Uint32Array,\"%Uint32ArrayPrototype%\":\"undefined\"==typeof Uint32Array?i:Uint32Array.prototype,\"%URIError%\":URIError,\"%URIErrorPrototype%\":URIError.prototype,\"%WeakMap%\":\"undefined\"==typeof WeakMap?i:WeakMap,\"%WeakMapPrototype%\":\"undefined\"==typeof WeakMap?i:WeakMap.prototype,\"%WeakSet%\":\"undefined\"==typeof WeakSet?i:WeakSet,\"%WeakSetPrototype%\":\"undefined\"==typeof WeakSet?i:WeakSet.prototype},g=t(\"function-bind\").call(Function.call,String.prototype.replace),b=/[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g,_=/\\\\(\\\\)?/g,y=function(t){var e=[];return g(t,b,(function(t,r,i,n){e[e.length]=i?g(n,_,\"$1\"):r||t})),e},w=function(t,e){if(!(t in m))throw new SyntaxError(\"intrinsic \"+t+\" does not exist!\");if(void 0===m[t]&&!e)throw new n(\"intrinsic \"+t+\" exists, but is not available. Please file an issue!\");return m[t]};e.exports=function(t,e){if(\"string\"!=typeof t||0===t.length)throw new TypeError(\"intrinsic name must be a non-empty string\");if(arguments.length>1&&\"boolean\"!=typeof e)throw new TypeError('\"allowMissing\" argument must be a boolean');for(var r=y(t),i=w(\"%\"+(r.length>0?r[0]:\"\")+\"%\",e),o=1;o<r.length;o+=1)if(null!=i)if(a&&o+1>=r.length){var s=a(i,r[o]);if(!e&&!(r[o]in i))throw new n(\"base intrinsic for \"+t+\" exists, but the property is not available.\");i=s?s.get||s.value:i[r[o]]}else i=i[r[o]];return i}},{\"function-bind\":41,\"has-symbols\":42}],35:[function(t,e,r){\"use strict\";var i=t(\"function-bind\"),n=t(\"../GetIntrinsic\")(\"%Function%\"),a=n.apply,o=n.call;e.exports=function(){return i.apply(o,arguments)},e.exports.apply=function(){return i.apply(a,arguments)}},{\"../GetIntrinsic\":34,\"function-bind\":41}],36:[function(t,e,r){\"use strict\";var i=t(\"../GetIntrinsic\"),n=t(\"./callBind\"),a=n(i(\"String.prototype.indexOf\"));e.exports=function(t,e){var r=i(t,!!e);return\"function\"==typeof r&&a(t,\".prototype.\")?n(r):r}},{\"../GetIntrinsic\":34,\"./callBind\":35}],37:[function(t,e,r){\"use strict\";var i=t(\"../GetIntrinsic\")(\"%Object.getOwnPropertyDescriptor%\");if(i)try{i([],\"length\")}catch(t){i=null}e.exports=i},{\"../GetIntrinsic\":34}],38:[function(t,e,r){\"use strict\";var i,n=\"object\"==typeof Reflect?Reflect:null,a=n&&\"function\"==typeof n.apply?n.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};i=n&&\"function\"==typeof n.ownKeys?n.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var o=Number.isNaN||function(t){return t!=t};function s(){s.init.call(this)}e.exports=s,e.exports.once=function(t,e){return new Promise((function(r,i){function n(){void 0!==a&&t.removeListener(\"error\",a),r([].slice.call(arguments))}var a;\"error\"!==e&&(a=function(r){t.removeListener(e,n),i(r)},t.once(\"error\",a)),t.once(e,n)}))},s.EventEmitter=s,s.prototype._events=void 0,s.prototype._eventsCount=0,s.prototype._maxListeners=void 0;var h=10;function l(t){if(\"function\"!=typeof t)throw new TypeError('The \"listener\" argument must be of type Function. Received type '+typeof t)}function f(t){return void 0===t._maxListeners?s.defaultMaxListeners:t._maxListeners}function u(t,e,r,i){var n,a,o,s;if(l(r),void 0===(a=t._events)?(a=t._events=Object.create(null),t._eventsCount=0):(void 0!==a.newListener&&(t.emit(\"newListener\",e,r.listener?r.listener:r),a=t._events),o=a[e]),void 0===o)o=a[e]=r,++t._eventsCount;else if(\"function\"==typeof o?o=a[e]=i?[r,o]:[o,r]:i?o.unshift(r):o.push(r),(n=f(t))>0&&o.length>n&&!o.warned){o.warned=!0;var h=new Error(\"Possible EventEmitter memory leak detected. \"+o.length+\" \"+String(e)+\" listeners added. Use emitter.setMaxListeners() to increase limit\");h.name=\"MaxListenersExceededWarning\",h.emitter=t,h.type=e,h.count=o.length,s=h,console&&console.warn&&console.warn(s)}return t}function c(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function d(t,e,r){var i={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},n=c.bind(i);return n.listener=r,i.wrapFn=n,n}function p(t,e,r){var i=t._events;if(void 0===i)return[];var n=i[e];return void 0===n?[]:\"function\"==typeof n?r?[n.listener||n]:[n]:r?function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(n):g(n,n.length)}function m(t){var e=this._events;if(void 0!==e){var r=e[t];if(\"function\"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function g(t,e){for(var r=new Array(e),i=0;i<e;++i)r[i]=t[i];return r}Object.defineProperty(s,\"defaultMaxListeners\",{enumerable:!0,get:function(){return h},set:function(t){if(\"number\"!=typeof t||t<0||o(t))throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received '+t+\".\");h=t}}),s.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},s.prototype.setMaxListeners=function(t){if(\"number\"!=typeof t||t<0||o(t))throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received '+t+\".\");return this._maxListeners=t,this},s.prototype.getMaxListeners=function(){return f(this)},s.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var i=\"error\"===t,n=this._events;if(void 0!==n)i=i&&void 0===n.error;else if(!i)return!1;if(i){var o;if(e.length>0&&(o=e[0]),o instanceof Error)throw o;var s=new Error(\"Unhandled error.\"+(o?\" (\"+o.message+\")\":\"\"));throw s.context=o,s}var h=n[t];if(void 0===h)return!1;if(\"function\"==typeof h)a(h,this,e);else{var l=h.length,f=g(h,l);for(r=0;r<l;++r)a(f[r],this,e)}return!0},s.prototype.addListener=function(t,e){return u(this,t,e,!1)},s.prototype.on=s.prototype.addListener,s.prototype.prependListener=function(t,e){return u(this,t,e,!0)},s.prototype.once=function(t,e){return l(e),this.on(t,d(this,t,e)),this},s.prototype.prependOnceListener=function(t,e){return l(e),this.prependListener(t,d(this,t,e)),this},s.prototype.removeListener=function(t,e){var r,i,n,a,o;if(l(e),void 0===(i=this._events))return this;if(void 0===(r=i[t]))return this;if(r===e||r.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete i[t],i.removeListener&&this.emit(\"removeListener\",t,r.listener||e));else if(\"function\"!=typeof r){for(n=-1,a=r.length-1;a>=0;a--)if(r[a]===e||r[a].listener===e){o=r[a].listener,n=a;break}if(n<0)return this;0===n?r.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(r,n),1===r.length&&(i[t]=r[0]),void 0!==i.removeListener&&this.emit(\"removeListener\",t,o||e)}return this},s.prototype.off=s.prototype.removeListener,s.prototype.removeAllListeners=function(t){var e,r,i;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[t]),this;if(0===arguments.length){var n,a=Object.keys(r);for(i=0;i<a.length;++i)\"removeListener\"!==(n=a[i])&&this.removeAllListeners(n);return this.removeAllListeners(\"removeListener\"),this._events=Object.create(null),this._eventsCount=0,this}if(\"function\"==typeof(e=r[t]))this.removeListener(t,e);else if(void 0!==e)for(i=e.length-1;i>=0;i--)this.removeListener(t,e[i]);return this},s.prototype.listeners=function(t){return p(this,t,!0)},s.prototype.rawListeners=function(t){return p(this,t,!1)},s.listenerCount=function(t,e){return\"function\"==typeof t.listenerCount?t.listenerCount(e):m.call(t,e)},s.prototype.listenerCount=m,s.prototype.eventNames=function(){return this._eventsCount>0?i(this._events):[]}},{}],39:[function(t,e,r){var i=Object.prototype.hasOwnProperty,n=Object.prototype.toString;e.exports=function(t,e,r){if(\"[object Function]\"!==n.call(e))throw new TypeError(\"iterator must be a function\");var a=t.length;if(a===+a)for(var o=0;o<a;o++)e.call(r,t[o],o,t);else for(var s in t)i.call(t,s)&&e.call(r,t[s],s,t)}},{}],40:[function(t,e,r){\"use strict\";var i=\"Function.prototype.bind called on incompatible \",n=Array.prototype.slice,a=Object.prototype.toString,o=\"[object Function]\";e.exports=function(t){var e=this;if(\"function\"!=typeof e||a.call(e)!==o)throw new TypeError(i+e);for(var r,s=n.call(arguments,1),h=Math.max(0,e.length-s.length),l=[],f=0;f<h;f++)l.push(\"$\"+f);if(r=Function(\"binder\",\"return function (\"+l.join(\",\")+\"){ return binder.apply(this,arguments); }\")((function(){if(this instanceof r){var i=e.apply(this,s.concat(n.call(arguments)));return Object(i)===i?i:this}return e.apply(t,s.concat(n.call(arguments)))})),e.prototype){var u=function(){};u.prototype=e.prototype,r.prototype=new u,u.prototype=null}return r}},{}],41:[function(t,e,r){\"use strict\";var i=t(\"./implementation\");e.exports=Function.prototype.bind||i},{\"./implementation\":40}],42:[function(t,e,i){(function(r){(function(){\"use strict\";var i=r.Symbol,n=t(\"./shams\");e.exports=function(){return\"function\"==typeof i&&\"function\"==typeof Symbol&&\"symbol\"==typeof i(\"foo\")&&\"symbol\"==typeof Symbol(\"bar\")&&n()}}).call(this)}).call(this,void 0!==r.g?r.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"./shams\":43}],43:[function(t,e,r){\"use strict\";e.exports=function(){if(\"function\"!=typeof Symbol||\"function\"!=typeof Object.getOwnPropertySymbols)return!1;if(\"symbol\"==typeof Symbol.iterator)return!0;var t={},e=Symbol(\"test\"),r=Object(e);if(\"string\"==typeof e)return!1;if(\"[object Symbol]\"!==Object.prototype.toString.call(e))return!1;if(\"[object Symbol]\"!==Object.prototype.toString.call(r))return!1;for(e in t[e]=42,t)return!1;if(\"function\"==typeof Object.keys&&0!==Object.keys(t).length)return!1;if(\"function\"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(t).length)return!1;var i=Object.getOwnPropertySymbols(t);if(1!==i.length||i[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(t,e))return!1;if(\"function\"==typeof Object.getOwnPropertyDescriptor){var n=Object.getOwnPropertyDescriptor(t,e);if(42!==n.value||!0!==n.enumerable)return!1}return!0}},{}],44:[function(t,e,r){r.read=function(t,e,r,i,n){var a,o,s=8*n-i-1,h=(1<<s)-1,l=h>>1,f=-7,u=r?n-1:0,c=r?-1:1,d=t[e+u];for(u+=c,a=d&(1<<-f)-1,d>>=-f,f+=s;f>0;a=256*a+t[e+u],u+=c,f-=8);for(o=a&(1<<-f)-1,a>>=-f,f+=i;f>0;o=256*o+t[e+u],u+=c,f-=8);if(0===a)a=1-l;else{if(a===h)return o?NaN:1/0*(d?-1:1);o+=Math.pow(2,i),a-=l}return(d?-1:1)*o*Math.pow(2,a-i)},r.write=function(t,e,r,i,n,a){var o,s,h,l=8*a-n-1,f=(1<<l)-1,u=f>>1,c=23===n?Math.pow(2,-24)-Math.pow(2,-77):0,d=i?0:a-1,p=i?1:-1,m=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,o=f):(o=Math.floor(Math.log(e)/Math.LN2),e*(h=Math.pow(2,-o))<1&&(o--,h*=2),(e+=o+u>=1?c/h:c*Math.pow(2,1-u))*h>=2&&(o++,h/=2),o+u>=f?(s=0,o=f):o+u>=1?(s=(e*h-1)*Math.pow(2,n),o+=u):(s=e*Math.pow(2,u-1)*Math.pow(2,n),o=0));n>=8;t[r+d]=255&s,d+=p,s/=256,n-=8);for(o=o<<n|s,l+=n;l>0;t[r+d]=255&o,d+=p,o/=256,l-=8);t[r+d-p]|=128*m}},{}],45:[function(t,e,r){\"function\"==typeof Object.create?e.exports=function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:e.exports=function(t,e){if(e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}}},{}],46:[function(t,e,r){\"use strict\";var i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.toStringTag,n=Object.prototype.toString,a=function(t){return!(i&&t&&\"object\"==typeof t&&Symbol.toStringTag in t)&&\"[object Arguments]\"===n.call(t)},o=function(t){return!!a(t)||null!==t&&\"object\"==typeof t&&\"number\"==typeof t.length&&t.length>=0&&\"[object Array]\"!==n.call(t)&&\"[object Function]\"===n.call(t.callee)},s=function(){return a(arguments)}();a.isLegacyArguments=o,e.exports=s?a:o},{}],47:[function(t,e,r){\"use strict\";var i=Object.prototype.toString,n=Function.prototype.toString,a=/^\\s*(?:function)?\\*/,o=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.toStringTag,s=Object.getPrototypeOf,h=function(){if(!o)return!1;try{return Function(\"return function*() {}\")()}catch(t){}}(),l=h?s(h):{};e.exports=function(t){return\"function\"==typeof t&&(!!a.test(n.call(t))||(o?s(t)===l:\"[object GeneratorFunction]\"===i.call(t)))}},{}],48:[function(t,e,i){(function(r){(function(){\"use strict\";var i=t(\"foreach\"),n=t(\"available-typed-arrays\"),a=t(\"es-abstract/helpers/callBound\"),o=a(\"Object.prototype.toString\"),s=t(\"has-symbols\")()&&\"symbol\"==typeof Symbol.toStringTag,h=n(),l=a(\"Array.prototype.indexOf\",!0)||function(t,e){for(var r=0;r<t.length;r+=1)if(t[r]===e)return r;return-1},f=a(\"String.prototype.slice\"),u={},c=t(\"es-abstract/helpers/getOwnPropertyDescriptor\"),d=Object.getPrototypeOf;s&&c&&d&&i(h,(function(t){var e=new r[t];if(!(Symbol.toStringTag in e))throw new EvalError(\"this engine has support for Symbol.toStringTag, but \"+t+\" does not have the property! Please report this.\");var i=d(e),n=c(i,Symbol.toStringTag);if(!n){var a=d(i);n=c(a,Symbol.toStringTag)}u[t]=n.get}));e.exports=function(t){if(!t||\"object\"!=typeof t)return!1;if(!s){var e=f(o(t),8,-1);return l(h,e)>-1}return!!c&&function(t){var e=!1;return i(u,(function(r,i){if(!e)try{e=r.call(t)===i}catch(t){}})),e}(t)}}).call(this)}).call(this,void 0!==r.g?r.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"available-typed-arrays\":27,\"es-abstract/helpers/callBound\":36,\"es-abstract/helpers/getOwnPropertyDescriptor\":37,foreach:39,\"has-symbols\":42}],49:[function(t,e,r){\"use strict\";var i=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Int32Array;function n(t,e){return Object.prototype.hasOwnProperty.call(t,e)}r.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if(\"object\"!=typeof r)throw new TypeError(r+\"must be non-object\");for(var i in r)n(r,i)&&(t[i]=r[i])}}return t},r.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var a={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var a=0;a<i;a++)t[n+a]=e[r+a]},flattenChunks:function(t){var e,r,i,n,a,o;for(i=0,e=0,r=t.length;e<r;e++)i+=t[e].length;for(o=new Uint8Array(i),n=0,e=0,r=t.length;e<r;e++)a=t[e],o.set(a,n),n+=a.length;return o}},o={arraySet:function(t,e,r,i,n){for(var a=0;a<i;a++)t[n+a]=e[r+a]},flattenChunks:function(t){return[].concat.apply([],t)}};r.setTyped=function(t){t?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,a)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,o))},r.setTyped(i)},{}],50:[function(t,e,r){\"use strict\";e.exports=function(t,e,r,i){for(var n=65535&t|0,a=t>>>16&65535|0,o=0;0!==r;){r-=o=r>2e3?2e3:r;do{a=a+(n=n+e[i++]|0)|0}while(--o);n%=65521,a%=65521}return n|a<<16|0}},{}],51:[function(t,e,r){\"use strict\";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],52:[function(t,e,r){\"use strict\";var i=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e,r,n){var a=i,o=n+r;t^=-1;for(var s=n;s<o;s++)t=t>>>8^a[255&(t^e[s])];return-1^t}},{}],53:[function(t,e,r){\"use strict\";var i,n=t(\"../utils/common\"),a=t(\"./trees\"),o=t(\"./adler32\"),s=t(\"./crc32\"),h=t(\"./messages\"),l=0,f=1,u=3,c=4,d=5,p=0,m=1,g=-2,b=-3,_=-5,y=-1,w=1,v=2,x=3,E=4,k=0,S=2,M=8,A=9,I=15,B=8,T=286,R=30,P=19,O=2*T+1,L=15,C=3,U=258,z=U+C+1,D=32,N=42,F=69,j=73,G=91,H=103,W=113,q=666,Z=1,Y=2,V=3,X=4,J=3;function Q(t,e){return t.msg=h[e],e}function K(t){return(t<<1)-(t>4?9:0)}function $(t){for(var e=t.length;--e>=0;)t[e]=0}function tt(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(n.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function et(t,e){a._tr_flush_block(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,tt(t.strm)}function rt(t,e){t.pending_buf[t.pending++]=e}function it(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function nt(t,e){var r,i,n=t.max_chain_length,a=t.strstart,o=t.prev_length,s=t.nice_match,h=t.strstart>t.w_size-z?t.strstart-(t.w_size-z):0,l=t.window,f=t.w_mask,u=t.prev,c=t.strstart+U,d=l[a+o-1],p=l[a+o];t.prev_length>=t.good_match&&(n>>=2),s>t.lookahead&&(s=t.lookahead);do{if(l[(r=e)+o]===p&&l[r+o-1]===d&&l[r]===l[a]&&l[++r]===l[a+1]){a+=2,r++;do{}while(l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&l[++a]===l[++r]&&a<c);if(i=U-(c-a),a=c-U,i>o){if(t.match_start=e,o=i,i>=s)break;d=l[a+o-1],p=l[a+o]}}}while((e=u[e&f])>h&&0!=--n);return o<=t.lookahead?o:t.lookahead}function at(t){var e,r,i,a,h,l,f,u,c,d,p=t.w_size;do{if(a=t.window_size-t.lookahead-t.strstart,t.strstart>=p+(p-z)){n.arraySet(t.window,t.window,p,p,0),t.match_start-=p,t.strstart-=p,t.block_start-=p,e=r=t.hash_size;do{i=t.head[--e],t.head[e]=i>=p?i-p:0}while(--r);e=r=p;do{i=t.prev[--e],t.prev[e]=i>=p?i-p:0}while(--r);a+=p}if(0===t.strm.avail_in)break;if(l=t.strm,f=t.window,u=t.strstart+t.lookahead,c=a,d=void 0,(d=l.avail_in)>c&&(d=c),r=0===d?0:(l.avail_in-=d,n.arraySet(f,l.input,l.next_in,d,u),1===l.state.wrap?l.adler=o(l.adler,f,d,u):2===l.state.wrap&&(l.adler=s(l.adler,f,d,u)),l.next_in+=d,l.total_in+=d,d),t.lookahead+=r,t.lookahead+t.insert>=C)for(h=t.strstart-t.insert,t.ins_h=t.window[h],t.ins_h=(t.ins_h<<t.hash_shift^t.window[h+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[h+C-1])&t.hash_mask,t.prev[h&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=h,h++,t.insert--,!(t.lookahead+t.insert<C)););}while(t.lookahead<z&&0!==t.strm.avail_in)}function ot(t,e){for(var r,i;;){if(t.lookahead<z){if(at(t),t.lookahead<z&&e===l)return Z;if(0===t.lookahead)break}if(r=0,t.lookahead>=C&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+C-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-z&&(t.match_length=nt(t,r)),t.match_length>=C)if(i=a._tr_tally(t,t.strstart-t.match_start,t.match_length-C),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=C){t.match_length--;do{t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+C-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=a._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(et(t,!1),0===t.strm.avail_out))return Z}return t.insert=t.strstart<C-1?t.strstart:C-1,e===c?(et(t,!0),0===t.strm.avail_out?V:X):t.last_lit&&(et(t,!1),0===t.strm.avail_out)?Z:Y}function st(t,e){for(var r,i,n;;){if(t.lookahead<z){if(at(t),t.lookahead<z&&e===l)return Z;if(0===t.lookahead)break}if(r=0,t.lookahead>=C&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+C-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=C-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-z&&(t.match_length=nt(t,r),t.match_length<=5&&(t.strategy===w||t.match_length===C&&t.strstart-t.match_start>4096)&&(t.match_length=C-1)),t.prev_length>=C&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-C,i=a._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-C),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+C-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=C-1,t.strstart++,i&&(et(t,!1),0===t.strm.avail_out))return Z}else if(t.match_available){if((i=a._tr_tally(t,0,t.window[t.strstart-1]))&&et(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return Z}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=a._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<C-1?t.strstart:C-1,e===c?(et(t,!0),0===t.strm.avail_out?V:X):t.last_lit&&(et(t,!1),0===t.strm.avail_out)?Z:Y}function ht(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function lt(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=M,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new n.Buf16(2*O),this.dyn_dtree=new n.Buf16(2*(2*R+1)),this.bl_tree=new n.Buf16(2*(2*P+1)),$(this.dyn_ltree),$(this.dyn_dtree),$(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new n.Buf16(L+1),this.heap=new n.Buf16(2*T+1),$(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new n.Buf16(2*T+1),$(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function ft(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=S,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?N:W,t.adler=2===e.wrap?0:1,e.last_flush=l,a._tr_init(e),p):Q(t,g)}function ut(t){var e,r=ft(t);return r===p&&((e=t.state).window_size=2*e.w_size,$(e.head),e.max_lazy_match=i[e.level].max_lazy,e.good_match=i[e.level].good_length,e.nice_match=i[e.level].nice_length,e.max_chain_length=i[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=C-1,e.match_available=0,e.ins_h=0),r}function ct(t,e,r,i,a,o){if(!t)return g;var s=1;if(e===y&&(e=6),i<0?(s=0,i=-i):i>15&&(s=2,i-=16),a<1||a>A||r!==M||i<8||i>15||e<0||e>9||o<0||o>E)return Q(t,g);8===i&&(i=9);var h=new lt;return t.state=h,h.strm=t,h.wrap=s,h.gzhead=null,h.w_bits=i,h.w_size=1<<h.w_bits,h.w_mask=h.w_size-1,h.hash_bits=a+7,h.hash_size=1<<h.hash_bits,h.hash_mask=h.hash_size-1,h.hash_shift=~~((h.hash_bits+C-1)/C),h.window=new n.Buf8(2*h.w_size),h.head=new n.Buf16(h.hash_size),h.prev=new n.Buf16(h.w_size),h.lit_bufsize=1<<a+6,h.pending_buf_size=4*h.lit_bufsize,h.pending_buf=new n.Buf8(h.pending_buf_size),h.d_buf=1*h.lit_bufsize,h.l_buf=3*h.lit_bufsize,h.level=e,h.strategy=o,h.method=r,ut(t)}i=[new ht(0,0,0,0,(function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(at(t),0===t.lookahead&&e===l)return Z;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,et(t,!1),0===t.strm.avail_out))return Z;if(t.strstart-t.block_start>=t.w_size-z&&(et(t,!1),0===t.strm.avail_out))return Z}return t.insert=0,e===c?(et(t,!0),0===t.strm.avail_out?V:X):(t.strstart>t.block_start&&(et(t,!1),t.strm.avail_out),Z)})),new ht(4,4,8,4,ot),new ht(4,5,16,8,ot),new ht(4,6,32,32,ot),new ht(4,4,16,16,st),new ht(8,16,32,32,st),new ht(8,16,128,128,st),new ht(8,32,128,256,st),new ht(32,128,258,1024,st),new ht(32,258,258,4096,st)],r.deflateInit=function(t,e){return ct(t,e,M,I,B,k)},r.deflateInit2=ct,r.deflateReset=ut,r.deflateResetKeep=ft,r.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?g:(t.state.gzhead=e,p):g},r.deflate=function(t,e){var r,n,o,h;if(!t||!t.state||e>d||e<0)return t?Q(t,g):g;if(n=t.state,!t.output||!t.input&&0!==t.avail_in||n.status===q&&e!==c)return Q(t,0===t.avail_out?_:g);if(n.strm=t,r=n.last_flush,n.last_flush=e,n.status===N)if(2===n.wrap)t.adler=0,rt(n,31),rt(n,139),rt(n,8),n.gzhead?(rt(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),rt(n,255&n.gzhead.time),rt(n,n.gzhead.time>>8&255),rt(n,n.gzhead.time>>16&255),rt(n,n.gzhead.time>>24&255),rt(n,9===n.level?2:n.strategy>=v||n.level<2?4:0),rt(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(rt(n,255&n.gzhead.extra.length),rt(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(t.adler=s(t.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=F):(rt(n,0),rt(n,0),rt(n,0),rt(n,0),rt(n,0),rt(n,9===n.level?2:n.strategy>=v||n.level<2?4:0),rt(n,J),n.status=W);else{var b=M+(n.w_bits-8<<4)<<8;b|=(n.strategy>=v||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(b|=D),b+=31-b%31,n.status=W,it(n,b),0!==n.strstart&&(it(n,t.adler>>>16),it(n,65535&t.adler)),t.adler=1}if(n.status===F)if(n.gzhead.extra){for(o=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),tt(t),o=n.pending,n.pending!==n.pending_buf_size));)rt(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=j)}else n.status=j;if(n.status===j)if(n.gzhead.name){o=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),tt(t),o=n.pending,n.pending===n.pending_buf_size)){h=1;break}h=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,rt(n,h)}while(0!==h);n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),0===h&&(n.gzindex=0,n.status=G)}else n.status=G;if(n.status===G)if(n.gzhead.comment){o=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),tt(t),o=n.pending,n.pending===n.pending_buf_size)){h=1;break}h=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,rt(n,h)}while(0!==h);n.gzhead.hcrc&&n.pending>o&&(t.adler=s(t.adler,n.pending_buf,n.pending-o,o)),0===h&&(n.status=H)}else n.status=H;if(n.status===H&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&tt(t),n.pending+2<=n.pending_buf_size&&(rt(n,255&t.adler),rt(n,t.adler>>8&255),t.adler=0,n.status=W)):n.status=W),0!==n.pending){if(tt(t),0===t.avail_out)return n.last_flush=-1,p}else if(0===t.avail_in&&K(e)<=K(r)&&e!==c)return Q(t,_);if(n.status===q&&0!==t.avail_in)return Q(t,_);if(0!==t.avail_in||0!==n.lookahead||e!==l&&n.status!==q){var y=n.strategy===v?function(t,e){for(var r;;){if(0===t.lookahead&&(at(t),0===t.lookahead)){if(e===l)return Z;break}if(t.match_length=0,r=a._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(et(t,!1),0===t.strm.avail_out))return Z}return t.insert=0,e===c?(et(t,!0),0===t.strm.avail_out?V:X):t.last_lit&&(et(t,!1),0===t.strm.avail_out)?Z:Y}(n,e):n.strategy===x?function(t,e){for(var r,i,n,o,s=t.window;;){if(t.lookahead<=U){if(at(t),t.lookahead<=U&&e===l)return Z;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=C&&t.strstart>0&&(i=s[n=t.strstart-1])===s[++n]&&i===s[++n]&&i===s[++n]){o=t.strstart+U;do{}while(i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&n<o);t.match_length=U-(o-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=C?(r=a._tr_tally(t,1,t.match_length-C),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=a._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(et(t,!1),0===t.strm.avail_out))return Z}return t.insert=0,e===c?(et(t,!0),0===t.strm.avail_out?V:X):t.last_lit&&(et(t,!1),0===t.strm.avail_out)?Z:Y}(n,e):i[n.level].func(n,e);if(y!==V&&y!==X||(n.status=q),y===Z||y===V)return 0===t.avail_out&&(n.last_flush=-1),p;if(y===Y&&(e===f?a._tr_align(n):e!==d&&(a._tr_stored_block(n,0,0,!1),e===u&&($(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),tt(t),0===t.avail_out))return n.last_flush=-1,p}return e!==c?p:n.wrap<=0?m:(2===n.wrap?(rt(n,255&t.adler),rt(n,t.adler>>8&255),rt(n,t.adler>>16&255),rt(n,t.adler>>24&255),rt(n,255&t.total_in),rt(n,t.total_in>>8&255),rt(n,t.total_in>>16&255),rt(n,t.total_in>>24&255)):(it(n,t.adler>>>16),it(n,65535&t.adler)),tt(t),n.wrap>0&&(n.wrap=-n.wrap),0!==n.pending?p:m)},r.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==N&&e!==F&&e!==j&&e!==G&&e!==H&&e!==W&&e!==q?Q(t,g):(t.state=null,e===W?Q(t,b):p):g},r.deflateSetDictionary=function(t,e){var r,i,a,s,h,l,f,u,c=e.length;if(!t||!t.state)return g;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==N||r.lookahead)return g;for(1===s&&(t.adler=o(t.adler,e,c,0)),r.wrap=0,c>=r.w_size&&(0===s&&($(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new n.Buf8(r.w_size),n.arraySet(u,e,c-r.w_size,r.w_size,0),e=u,c=r.w_size),h=t.avail_in,l=t.next_in,f=t.input,t.avail_in=c,t.next_in=0,t.input=e,at(r);r.lookahead>=C;){i=r.strstart,a=r.lookahead-(C-1);do{r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+C-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++}while(--a);r.strstart=i,r.lookahead=C-1,at(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=C-1,r.match_available=0,t.next_in=l,t.input=f,t.avail_in=h,r.wrap=s,p},r.deflateInfo=\"pako deflate (from Nodeca project)\"},{\"../utils/common\":49,\"./adler32\":50,\"./crc32\":52,\"./messages\":57,\"./trees\":58}],54:[function(t,e,r){\"use strict\";e.exports=function(t,e){var r,i,n,a,o,s,h,l,f,u,c,d,p,m,g,b,_,y,w,v,x,E,k,S,M;r=t.state,i=t.next_in,S=t.input,n=i+(t.avail_in-5),a=t.next_out,M=t.output,o=a-(e-t.avail_out),s=a+(t.avail_out-257),h=r.dmax,l=r.wsize,f=r.whave,u=r.wnext,c=r.window,d=r.hold,p=r.bits,m=r.lencode,g=r.distcode,b=(1<<r.lenbits)-1,_=(1<<r.distbits)-1;t:do{p<15&&(d+=S[i++]<<p,p+=8,d+=S[i++]<<p,p+=8),y=m[d&b];e:for(;;){if(d>>>=w=y>>>24,p-=w,0==(w=y>>>16&255))M[a++]=65535&y;else{if(!(16&w)){if(0==(64&w)){y=m[(65535&y)+(d&(1<<w)-1)];continue e}if(32&w){r.mode=12;break t}t.msg=\"invalid literal/length code\",r.mode=30;break t}v=65535&y,(w&=15)&&(p<w&&(d+=S[i++]<<p,p+=8),v+=d&(1<<w)-1,d>>>=w,p-=w),p<15&&(d+=S[i++]<<p,p+=8,d+=S[i++]<<p,p+=8),y=g[d&_];r:for(;;){if(d>>>=w=y>>>24,p-=w,!(16&(w=y>>>16&255))){if(0==(64&w)){y=g[(65535&y)+(d&(1<<w)-1)];continue r}t.msg=\"invalid distance code\",r.mode=30;break t}if(x=65535&y,p<(w&=15)&&(d+=S[i++]<<p,(p+=8)<w&&(d+=S[i++]<<p,p+=8)),(x+=d&(1<<w)-1)>h){t.msg=\"invalid distance too far back\",r.mode=30;break t}if(d>>>=w,p-=w,x>(w=a-o)){if((w=x-w)>f&&r.sane){t.msg=\"invalid distance too far back\",r.mode=30;break t}if(E=0,k=c,0===u){if(E+=l-w,w<v){v-=w;do{M[a++]=c[E++]}while(--w);E=a-x,k=M}}else if(u<w){if(E+=l+u-w,(w-=u)<v){v-=w;do{M[a++]=c[E++]}while(--w);if(E=0,u<v){v-=w=u;do{M[a++]=c[E++]}while(--w);E=a-x,k=M}}}else if(E+=u-w,w<v){v-=w;do{M[a++]=c[E++]}while(--w);E=a-x,k=M}for(;v>2;)M[a++]=k[E++],M[a++]=k[E++],M[a++]=k[E++],v-=3;v&&(M[a++]=k[E++],v>1&&(M[a++]=k[E++]))}else{E=a-x;do{M[a++]=M[E++],M[a++]=M[E++],M[a++]=M[E++],v-=3}while(v>2);v&&(M[a++]=M[E++],v>1&&(M[a++]=M[E++]))}break}}break}}while(i<n&&a<s);i-=v=p>>3,d&=(1<<(p-=v<<3))-1,t.next_in=i,t.next_out=a,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=a<s?s-a+257:257-(a-s),r.hold=d,r.bits=p}},{}],55:[function(t,e,r){\"use strict\";var i=t(\"../utils/common\"),n=t(\"./adler32\"),a=t(\"./crc32\"),o=t(\"./inffast\"),s=t(\"./inftrees\"),h=0,l=1,f=2,u=4,c=5,d=6,p=0,m=1,g=2,b=-2,_=-3,y=-4,w=-5,v=8,x=1,E=2,k=3,S=4,M=5,A=6,I=7,B=8,T=9,R=10,P=11,O=12,L=13,C=14,U=15,z=16,D=17,N=18,F=19,j=20,G=21,H=22,W=23,q=24,Z=25,Y=26,V=27,X=28,J=29,Q=30,K=31,$=852,tt=592,et=15;function rt(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function it(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new i.Buf16(320),this.work=new i.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function nt(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg=\"\",e.wrap&&(t.adler=1&e.wrap),e.mode=x,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new i.Buf32($),e.distcode=e.distdyn=new i.Buf32(tt),e.sane=1,e.back=-1,p):b}function at(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,nt(t)):b}function ot(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?b:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,at(t))):b}function st(t,e){var r,i;return t?(i=new it,t.state=i,i.window=null,(r=ot(t,e))!==p&&(t.state=null),r):b}var ht,lt,ft=!0;function ut(t){if(ft){var e;for(ht=new i.Buf32(512),lt=new i.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(s(l,t.lens,0,288,ht,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;s(f,t.lens,0,32,lt,0,t.work,{bits:5}),ft=!1}t.lencode=ht,t.lenbits=9,t.distcode=lt,t.distbits=5}function ct(t,e,r,n){var a,o=t.state;return null===o.window&&(o.wsize=1<<o.wbits,o.wnext=0,o.whave=0,o.window=new i.Buf8(o.wsize)),n>=o.wsize?(i.arraySet(o.window,e,r-o.wsize,o.wsize,0),o.wnext=0,o.whave=o.wsize):((a=o.wsize-o.wnext)>n&&(a=n),i.arraySet(o.window,e,r-n,a,o.wnext),(n-=a)?(i.arraySet(o.window,e,r-n,n,0),o.wnext=n,o.whave=o.wsize):(o.wnext+=a,o.wnext===o.wsize&&(o.wnext=0),o.whave<o.wsize&&(o.whave+=a))),0}r.inflateReset=at,r.inflateReset2=ot,r.inflateResetKeep=nt,r.inflateInit=function(t){return st(t,et)},r.inflateInit2=st,r.inflate=function(t,e){var r,$,tt,et,it,nt,at,ot,st,ht,lt,ft,dt,pt,mt,gt,bt,_t,yt,wt,vt,xt,Et,kt,St=0,Mt=new i.Buf8(4),At=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return b;(r=t.state).mode===O&&(r.mode=L),it=t.next_out,tt=t.output,at=t.avail_out,et=t.next_in,$=t.input,nt=t.avail_in,ot=r.hold,st=r.bits,ht=nt,lt=at,xt=p;t:for(;;)switch(r.mode){case x:if(0===r.wrap){r.mode=L;break}for(;st<16;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}if(2&r.wrap&&35615===ot){r.check=0,Mt[0]=255&ot,Mt[1]=ot>>>8&255,r.check=a(r.check,Mt,2,0),ot=0,st=0,r.mode=E;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&ot)<<8)+(ot>>8))%31){t.msg=\"incorrect header check\",r.mode=Q;break}if((15&ot)!==v){t.msg=\"unknown compression method\",r.mode=Q;break}if(st-=4,vt=8+(15&(ot>>>=4)),0===r.wbits)r.wbits=vt;else if(vt>r.wbits){t.msg=\"invalid window size\",r.mode=Q;break}r.dmax=1<<vt,t.adler=r.check=1,r.mode=512&ot?R:O,ot=0,st=0;break;case E:for(;st<16;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}if(r.flags=ot,(255&r.flags)!==v){t.msg=\"unknown compression method\",r.mode=Q;break}if(57344&r.flags){t.msg=\"unknown header flags set\",r.mode=Q;break}r.head&&(r.head.text=ot>>8&1),512&r.flags&&(Mt[0]=255&ot,Mt[1]=ot>>>8&255,r.check=a(r.check,Mt,2,0)),ot=0,st=0,r.mode=k;case k:for(;st<32;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}r.head&&(r.head.time=ot),512&r.flags&&(Mt[0]=255&ot,Mt[1]=ot>>>8&255,Mt[2]=ot>>>16&255,Mt[3]=ot>>>24&255,r.check=a(r.check,Mt,4,0)),ot=0,st=0,r.mode=S;case S:for(;st<16;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}r.head&&(r.head.xflags=255&ot,r.head.os=ot>>8),512&r.flags&&(Mt[0]=255&ot,Mt[1]=ot>>>8&255,r.check=a(r.check,Mt,2,0)),ot=0,st=0,r.mode=M;case M:if(1024&r.flags){for(;st<16;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}r.length=ot,r.head&&(r.head.extra_len=ot),512&r.flags&&(Mt[0]=255&ot,Mt[1]=ot>>>8&255,r.check=a(r.check,Mt,2,0)),ot=0,st=0}else r.head&&(r.head.extra=null);r.mode=A;case A:if(1024&r.flags&&((ft=r.length)>nt&&(ft=nt),ft&&(r.head&&(vt=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),i.arraySet(r.head.extra,$,et,ft,vt)),512&r.flags&&(r.check=a(r.check,$,ft,et)),nt-=ft,et+=ft,r.length-=ft),r.length))break t;r.length=0,r.mode=I;case I:if(2048&r.flags){if(0===nt)break t;ft=0;do{vt=$[et+ft++],r.head&&vt&&r.length<65536&&(r.head.name+=String.fromCharCode(vt))}while(vt&&ft<nt);if(512&r.flags&&(r.check=a(r.check,$,ft,et)),nt-=ft,et+=ft,vt)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=B;case B:if(4096&r.flags){if(0===nt)break t;ft=0;do{vt=$[et+ft++],r.head&&vt&&r.length<65536&&(r.head.comment+=String.fromCharCode(vt))}while(vt&&ft<nt);if(512&r.flags&&(r.check=a(r.check,$,ft,et)),nt-=ft,et+=ft,vt)break t}else r.head&&(r.head.comment=null);r.mode=T;case T:if(512&r.flags){for(;st<16;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}if(ot!==(65535&r.check)){t.msg=\"header crc mismatch\",r.mode=Q;break}ot=0,st=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=O;break;case R:for(;st<32;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}t.adler=r.check=rt(ot),ot=0,st=0,r.mode=P;case P:if(0===r.havedict)return t.next_out=it,t.avail_out=at,t.next_in=et,t.avail_in=nt,r.hold=ot,r.bits=st,g;t.adler=r.check=1,r.mode=O;case O:if(e===c||e===d)break t;case L:if(r.last){ot>>>=7&st,st-=7&st,r.mode=V;break}for(;st<3;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}switch(r.last=1&ot,st-=1,3&(ot>>>=1)){case 0:r.mode=C;break;case 1:if(ut(r),r.mode=j,e===d){ot>>>=2,st-=2;break t}break;case 2:r.mode=D;break;case 3:t.msg=\"invalid block type\",r.mode=Q}ot>>>=2,st-=2;break;case C:for(ot>>>=7&st,st-=7&st;st<32;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}if((65535&ot)!=(ot>>>16^65535)){t.msg=\"invalid stored block lengths\",r.mode=Q;break}if(r.length=65535&ot,ot=0,st=0,r.mode=U,e===d)break t;case U:r.mode=z;case z:if(ft=r.length){if(ft>nt&&(ft=nt),ft>at&&(ft=at),0===ft)break t;i.arraySet(tt,$,et,ft,it),nt-=ft,et+=ft,at-=ft,it+=ft,r.length-=ft;break}r.mode=O;break;case D:for(;st<14;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}if(r.nlen=257+(31&ot),ot>>>=5,st-=5,r.ndist=1+(31&ot),ot>>>=5,st-=5,r.ncode=4+(15&ot),ot>>>=4,st-=4,r.nlen>286||r.ndist>30){t.msg=\"too many length or distance symbols\",r.mode=Q;break}r.have=0,r.mode=N;case N:for(;r.have<r.ncode;){for(;st<3;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}r.lens[At[r.have++]]=7&ot,ot>>>=3,st-=3}for(;r.have<19;)r.lens[At[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,Et={bits:r.lenbits},xt=s(h,r.lens,0,19,r.lencode,0,r.work,Et),r.lenbits=Et.bits,xt){t.msg=\"invalid code lengths set\",r.mode=Q;break}r.have=0,r.mode=F;case F:for(;r.have<r.nlen+r.ndist;){for(;gt=(St=r.lencode[ot&(1<<r.lenbits)-1])>>>16&255,bt=65535&St,!((mt=St>>>24)<=st);){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}if(bt<16)ot>>>=mt,st-=mt,r.lens[r.have++]=bt;else{if(16===bt){for(kt=mt+2;st<kt;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}if(ot>>>=mt,st-=mt,0===r.have){t.msg=\"invalid bit length repeat\",r.mode=Q;break}vt=r.lens[r.have-1],ft=3+(3&ot),ot>>>=2,st-=2}else if(17===bt){for(kt=mt+3;st<kt;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}st-=mt,vt=0,ft=3+(7&(ot>>>=mt)),ot>>>=3,st-=3}else{for(kt=mt+7;st<kt;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}st-=mt,vt=0,ft=11+(127&(ot>>>=mt)),ot>>>=7,st-=7}if(r.have+ft>r.nlen+r.ndist){t.msg=\"invalid bit length repeat\",r.mode=Q;break}for(;ft--;)r.lens[r.have++]=vt}}if(r.mode===Q)break;if(0===r.lens[256]){t.msg=\"invalid code -- missing end-of-block\",r.mode=Q;break}if(r.lenbits=9,Et={bits:r.lenbits},xt=s(l,r.lens,0,r.nlen,r.lencode,0,r.work,Et),r.lenbits=Et.bits,xt){t.msg=\"invalid literal/lengths set\",r.mode=Q;break}if(r.distbits=6,r.distcode=r.distdyn,Et={bits:r.distbits},xt=s(f,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,Et),r.distbits=Et.bits,xt){t.msg=\"invalid distances set\",r.mode=Q;break}if(r.mode=j,e===d)break t;case j:r.mode=G;case G:if(nt>=6&&at>=258){t.next_out=it,t.avail_out=at,t.next_in=et,t.avail_in=nt,r.hold=ot,r.bits=st,o(t,lt),it=t.next_out,tt=t.output,at=t.avail_out,et=t.next_in,$=t.input,nt=t.avail_in,ot=r.hold,st=r.bits,r.mode===O&&(r.back=-1);break}for(r.back=0;gt=(St=r.lencode[ot&(1<<r.lenbits)-1])>>>16&255,bt=65535&St,!((mt=St>>>24)<=st);){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}if(gt&&0==(240&gt)){for(_t=mt,yt=gt,wt=bt;gt=(St=r.lencode[wt+((ot&(1<<_t+yt)-1)>>_t)])>>>16&255,bt=65535&St,!(_t+(mt=St>>>24)<=st);){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}ot>>>=_t,st-=_t,r.back+=_t}if(ot>>>=mt,st-=mt,r.back+=mt,r.length=bt,0===gt){r.mode=Y;break}if(32&gt){r.back=-1,r.mode=O;break}if(64&gt){t.msg=\"invalid literal/length code\",r.mode=Q;break}r.extra=15&gt,r.mode=H;case H:if(r.extra){for(kt=r.extra;st<kt;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}r.length+=ot&(1<<r.extra)-1,ot>>>=r.extra,st-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=W;case W:for(;gt=(St=r.distcode[ot&(1<<r.distbits)-1])>>>16&255,bt=65535&St,!((mt=St>>>24)<=st);){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}if(0==(240&gt)){for(_t=mt,yt=gt,wt=bt;gt=(St=r.distcode[wt+((ot&(1<<_t+yt)-1)>>_t)])>>>16&255,bt=65535&St,!(_t+(mt=St>>>24)<=st);){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}ot>>>=_t,st-=_t,r.back+=_t}if(ot>>>=mt,st-=mt,r.back+=mt,64&gt){t.msg=\"invalid distance code\",r.mode=Q;break}r.offset=bt,r.extra=15&gt,r.mode=q;case q:if(r.extra){for(kt=r.extra;st<kt;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}r.offset+=ot&(1<<r.extra)-1,ot>>>=r.extra,st-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg=\"invalid distance too far back\",r.mode=Q;break}r.mode=Z;case Z:if(0===at)break t;if(ft=lt-at,r.offset>ft){if((ft=r.offset-ft)>r.whave&&r.sane){t.msg=\"invalid distance too far back\",r.mode=Q;break}ft>r.wnext?(ft-=r.wnext,dt=r.wsize-ft):dt=r.wnext-ft,ft>r.length&&(ft=r.length),pt=r.window}else pt=tt,dt=it-r.offset,ft=r.length;ft>at&&(ft=at),at-=ft,r.length-=ft;do{tt[it++]=pt[dt++]}while(--ft);0===r.length&&(r.mode=G);break;case Y:if(0===at)break t;tt[it++]=r.length,at--,r.mode=G;break;case V:if(r.wrap){for(;st<32;){if(0===nt)break t;nt--,ot|=$[et++]<<st,st+=8}if(lt-=at,t.total_out+=lt,r.total+=lt,lt&&(t.adler=r.check=r.flags?a(r.check,tt,lt,it-lt):n(r.check,tt,lt,it-lt)),lt=at,(r.flags?ot:rt(ot))!==r.check){t.msg=\"incorrect data check\",r.mode=Q;break}ot=0,st=0}r.mode=X;case X:if(r.wrap&&r.flags){for(;st<32;){if(0===nt)break t;nt--,ot+=$[et++]<<st,st+=8}if(ot!==(4294967295&r.total)){t.msg=\"incorrect length check\",r.mode=Q;break}ot=0,st=0}r.mode=J;case J:xt=m;break t;case Q:xt=_;break t;case K:return y;default:return b}return t.next_out=it,t.avail_out=at,t.next_in=et,t.avail_in=nt,r.hold=ot,r.bits=st,(r.wsize||lt!==t.avail_out&&r.mode<Q&&(r.mode<V||e!==u))&&ct(t,t.output,t.next_out,lt-t.avail_out)?(r.mode=K,y):(ht-=t.avail_in,lt-=t.avail_out,t.total_in+=ht,t.total_out+=lt,r.total+=lt,r.wrap&&lt&&(t.adler=r.check=r.flags?a(r.check,tt,lt,t.next_out-lt):n(r.check,tt,lt,t.next_out-lt)),t.data_type=r.bits+(r.last?64:0)+(r.mode===O?128:0)+(r.mode===j||r.mode===U?256:0),(0===ht&&0===lt||e===u)&&xt===p&&(xt=w),xt)},r.inflateEnd=function(t){if(!t||!t.state)return b;var e=t.state;return e.window&&(e.window=null),t.state=null,p},r.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?b:(r.head=e,e.done=!1,p):b},r.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&r.mode!==P?b:r.mode===P&&n(1,e,i,0)!==r.check?_:ct(t,e,i,i)?(r.mode=K,y):(r.havedict=1,p):b},r.inflateInfo=\"pako inflate (from Nodeca project)\"},{\"../utils/common\":49,\"./adler32\":50,\"./crc32\":52,\"./inffast\":54,\"./inftrees\":56}],56:[function(t,e,r){\"use strict\";var i=t(\"../utils/common\"),n=15,a=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],o=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],s=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],h=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,r,l,f,u,c,d){var p,m,g,b,_,y,w,v,x,E=d.bits,k=0,S=0,M=0,A=0,I=0,B=0,T=0,R=0,P=0,O=0,L=null,C=0,U=new i.Buf16(16),z=new i.Buf16(16),D=null,N=0;for(k=0;k<=n;k++)U[k]=0;for(S=0;S<l;S++)U[e[r+S]]++;for(I=E,A=n;A>=1&&0===U[A];A--);if(I>A&&(I=A),0===A)return f[u++]=20971520,f[u++]=20971520,d.bits=1,0;for(M=1;M<A&&0===U[M];M++);for(I<M&&(I=M),R=1,k=1;k<=n;k++)if(R<<=1,(R-=U[k])<0)return-1;if(R>0&&(0===t||1!==A))return-1;for(z[1]=0,k=1;k<n;k++)z[k+1]=z[k]+U[k];for(S=0;S<l;S++)0!==e[r+S]&&(c[z[e[r+S]]++]=S);if(0===t?(L=D=c,y=19):1===t?(L=a,C-=257,D=o,N-=257,y=256):(L=s,D=h,y=-1),O=0,S=0,k=M,_=u,B=I,T=0,g=-1,b=(P=1<<I)-1,1===t&&P>852||2===t&&P>592)return 1;for(;;){w=k-T,c[S]<y?(v=0,x=c[S]):c[S]>y?(v=D[N+c[S]],x=L[C+c[S]]):(v=96,x=0),p=1<<k-T,M=m=1<<B;do{f[_+(O>>T)+(m-=p)]=w<<24|v<<16|x|0}while(0!==m);for(p=1<<k-1;O&p;)p>>=1;if(0!==p?(O&=p-1,O+=p):O=0,S++,0==--U[k]){if(k===A)break;k=e[r+c[S]]}if(k>I&&(O&b)!==g){for(0===T&&(T=I),_+=M,R=1<<(B=k-T);B+T<A&&!((R-=U[B+T])<=0);)B++,R<<=1;if(P+=1<<B,1===t&&P>852||2===t&&P>592)return 1;f[g=O&b]=I<<24|B<<16|_-u|0}}return 0!==O&&(f[_+O]=k-T<<24|64<<16|0),d.bits=I,0}},{\"../utils/common\":49}],57:[function(t,e,r){\"use strict\";e.exports={2:\"need dictionary\",1:\"stream end\",0:\"\",\"-1\":\"file error\",\"-2\":\"stream error\",\"-3\":\"data error\",\"-4\":\"insufficient memory\",\"-5\":\"buffer error\",\"-6\":\"incompatible version\"}},{}],58:[function(t,e,r){\"use strict\";var i=t(\"../utils/common\"),n=4,a=0,o=1,s=2;function h(t){for(var e=t.length;--e>=0;)t[e]=0}var l=0,f=1,u=2,c=29,d=256,p=d+1+c,m=30,g=19,b=2*p+1,_=15,y=16,w=7,v=256,x=16,E=17,k=18,S=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],M=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],A=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],I=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],B=new Array(2*(p+2));h(B);var T=new Array(2*m);h(T);var R=new Array(512);h(R);var P=new Array(256);h(P);var O=new Array(c);h(O);var L,C,U,z=new Array(m);function D(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function N(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function F(t){return t<256?R[t]:R[256+(t>>>7)]}function j(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function G(t,e,r){t.bi_valid>y-r?(t.bi_buf|=e<<t.bi_valid&65535,j(t,t.bi_buf),t.bi_buf=e>>y-t.bi_valid,t.bi_valid+=r-y):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function H(t,e,r){G(t,r[2*e],r[2*e+1])}function W(t,e){var r=0;do{r|=1&t,t>>>=1,r<<=1}while(--e>0);return r>>>1}function q(t,e,r){var i,n,a=new Array(_+1),o=0;for(i=1;i<=_;i++)a[i]=o=o+r[i-1]<<1;for(n=0;n<=e;n++){var s=t[2*n+1];0!==s&&(t[2*n]=W(a[s]++,s))}}function Z(t){var e;for(e=0;e<p;e++)t.dyn_ltree[2*e]=0;for(e=0;e<m;e++)t.dyn_dtree[2*e]=0;for(e=0;e<g;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*v]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function Y(t){t.bi_valid>8?j(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function V(t,e,r,i){var n=2*e,a=2*r;return t[n]<t[a]||t[n]===t[a]&&i[e]<=i[r]}function X(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&V(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!V(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function J(t,e,r){var i,n,a,o,s=0;if(0!==t.last_lit)do{i=t.pending_buf[t.d_buf+2*s]<<8|t.pending_buf[t.d_buf+2*s+1],n=t.pending_buf[t.l_buf+s],s++,0===i?H(t,n,e):(H(t,(a=P[n])+d+1,e),0!==(o=S[a])&&G(t,n-=O[a],o),H(t,a=F(--i),r),0!==(o=M[a])&&G(t,i-=z[a],o))}while(s<t.last_lit);H(t,v,e)}function Q(t,e){var r,i,n,a=e.dyn_tree,o=e.stat_desc.static_tree,s=e.stat_desc.has_stree,h=e.stat_desc.elems,l=-1;for(t.heap_len=0,t.heap_max=b,r=0;r<h;r++)0!==a[2*r]?(t.heap[++t.heap_len]=l=r,t.depth[r]=0):a[2*r+1]=0;for(;t.heap_len<2;)a[2*(n=t.heap[++t.heap_len]=l<2?++l:0)]=1,t.depth[n]=0,t.opt_len--,s&&(t.static_len-=o[2*n+1]);for(e.max_code=l,r=t.heap_len>>1;r>=1;r--)X(t,a,r);n=h;do{r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],X(t,a,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,a[2*n]=a[2*r]+a[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,a[2*r+1]=a[2*i+1]=n,t.heap[1]=n++,X(t,a,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,a,o,s,h=e.dyn_tree,l=e.max_code,f=e.stat_desc.static_tree,u=e.stat_desc.has_stree,c=e.stat_desc.extra_bits,d=e.stat_desc.extra_base,p=e.stat_desc.max_length,m=0;for(a=0;a<=_;a++)t.bl_count[a]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<b;r++)(a=h[2*h[2*(i=t.heap[r])+1]+1]+1)>p&&(a=p,m++),h[2*i+1]=a,i>l||(t.bl_count[a]++,o=0,i>=d&&(o=c[i-d]),s=h[2*i],t.opt_len+=s*(a+o),u&&(t.static_len+=s*(f[2*i+1]+o)));if(0!==m){do{for(a=p-1;0===t.bl_count[a];)a--;t.bl_count[a]--,t.bl_count[a+1]+=2,t.bl_count[p]--,m-=2}while(m>0);for(a=p;0!==a;a--)for(i=t.bl_count[a];0!==i;)(n=t.heap[--r])>l||(h[2*n+1]!==a&&(t.opt_len+=(a-h[2*n+1])*h[2*n],h[2*n+1]=a),i--)}}(t,e),q(a,l,t.bl_count)}function K(t,e,r){var i,n,a=-1,o=e[1],s=0,h=7,l=4;for(0===o&&(h=138,l=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=o,o=e[2*(i+1)+1],++s<h&&n===o||(s<l?t.bl_tree[2*n]+=s:0!==n?(n!==a&&t.bl_tree[2*n]++,t.bl_tree[2*x]++):s<=10?t.bl_tree[2*E]++:t.bl_tree[2*k]++,s=0,a=n,0===o?(h=138,l=3):n===o?(h=6,l=3):(h=7,l=4))}function $(t,e,r){var i,n,a=-1,o=e[1],s=0,h=7,l=4;for(0===o&&(h=138,l=3),i=0;i<=r;i++)if(n=o,o=e[2*(i+1)+1],!(++s<h&&n===o)){if(s<l)do{H(t,n,t.bl_tree)}while(0!=--s);else 0!==n?(n!==a&&(H(t,n,t.bl_tree),s--),H(t,x,t.bl_tree),G(t,s-3,2)):s<=10?(H(t,E,t.bl_tree),G(t,s-3,3)):(H(t,k,t.bl_tree),G(t,s-11,7));s=0,a=n,0===o?(h=138,l=3):n===o?(h=6,l=3):(h=7,l=4)}}h(z);var tt=!1;function et(t,e,r,n){G(t,(l<<1)+(n?1:0),3),function(t,e,r,n){Y(t),n&&(j(t,r),j(t,~r)),i.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r,!0)}r._tr_init=function(t){tt||(function(){var t,e,r,i,n,a=new Array(_+1);for(r=0,i=0;i<c-1;i++)for(O[i]=r,t=0;t<1<<S[i];t++)P[r++]=i;for(P[r-1]=i,n=0,i=0;i<16;i++)for(z[i]=n,t=0;t<1<<M[i];t++)R[n++]=i;for(n>>=7;i<m;i++)for(z[i]=n<<7,t=0;t<1<<M[i]-7;t++)R[256+n++]=i;for(e=0;e<=_;e++)a[e]=0;for(t=0;t<=143;)B[2*t+1]=8,t++,a[8]++;for(;t<=255;)B[2*t+1]=9,t++,a[9]++;for(;t<=279;)B[2*t+1]=7,t++,a[7]++;for(;t<=287;)B[2*t+1]=8,t++,a[8]++;for(q(B,p+1,a),t=0;t<m;t++)T[2*t+1]=5,T[2*t]=W(t,5);L=new D(B,S,d+1,p,_),C=new D(T,M,0,m,_),U=new D(new Array(0),A,0,g,w)}(),tt=!0),t.l_desc=new N(t.dyn_ltree,L),t.d_desc=new N(t.dyn_dtree,C),t.bl_desc=new N(t.bl_tree,U),t.bi_buf=0,t.bi_valid=0,Z(t)},r._tr_stored_block=et,r._tr_flush_block=function(t,e,r,i){var h,l,c=0;t.level>0?(t.strm.data_type===s&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return a;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return o;for(e=32;e<d;e++)if(0!==t.dyn_ltree[2*e])return o;return a}(t)),Q(t,t.l_desc),Q(t,t.d_desc),c=function(t){var e;for(K(t,t.dyn_ltree,t.l_desc.max_code),K(t,t.dyn_dtree,t.d_desc.max_code),Q(t,t.bl_desc),e=g-1;e>=3&&0===t.bl_tree[2*I[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),h=t.opt_len+3+7>>>3,(l=t.static_len+3+7>>>3)<=h&&(h=l)):h=l=r+5,r+4<=h&&-1!==e?et(t,e,r,i):t.strategy===n||l===h?(G(t,(f<<1)+(i?1:0),3),J(t,B,T)):(G(t,(u<<1)+(i?1:0),3),function(t,e,r,i){var n;for(G(t,e-257,5),G(t,r-1,5),G(t,i-4,4),n=0;n<i;n++)G(t,t.bl_tree[2*I[n]+1],3);$(t,t.dyn_ltree,e-1),$(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,c+1),J(t,t.dyn_ltree,t.dyn_dtree)),Z(t),i&&Y(t)},r._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(P[r]+d+1)]++,t.dyn_dtree[2*F(e)]++),t.last_lit===t.lit_bufsize-1},r._tr_align=function(t){G(t,f<<1,3),H(t,v,B),function(t){16===t.bi_valid?(j(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},{\"../utils/common\":49}],59:[function(t,e,r){\"use strict\";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\"\",this.state=null,this.data_type=2,this.adler=0}},{}],60:[function(t,e,r){var i,n,a=e.exports={};function o(){throw new Error(\"setTimeout has not been defined\")}function s(){throw new Error(\"clearTimeout has not been defined\")}function h(t){if(i===setTimeout)return setTimeout(t,0);if((i===o||!i)&&setTimeout)return i=setTimeout,setTimeout(t,0);try{return i(t,0)}catch(e){try{return i.call(null,t,0)}catch(e){return i.call(this,t,0)}}}!function(){try{i=\"function\"==typeof setTimeout?setTimeout:o}catch(t){i=o}try{n=\"function\"==typeof clearTimeout?clearTimeout:s}catch(t){n=s}}();var l,f=[],u=!1,c=-1;function d(){u&&l&&(u=!1,l.length?f=l.concat(f):c=-1,f.length&&p())}function p(){if(!u){var t=h(d);u=!0;for(var e=f.length;e;){for(l=f,f=[];++c<e;)l&&l[c].run();c=-1,e=f.length}l=null,u=!1,function(t){if(n===clearTimeout)return clearTimeout(t);if((n===s||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t)}}function m(t,e){this.fun=t,this.array=e}function g(){}a.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];f.push(new m(t,e)),1!==f.length||u||h(p)},m.prototype.run=function(){this.fun.apply(null,this.array)},a.title=\"browser\",a.browser=!0,a.env={},a.argv=[],a.version=\"\",a.versions={},a.on=g,a.addListener=g,a.once=g,a.off=g,a.removeListener=g,a.removeAllListeners=g,a.emit=g,a.prependListener=g,a.prependOnceListener=g,a.listeners=function(t){return[]},a.binding=function(t){throw new Error(\"process.binding is not supported\")},a.cwd=function(){return\"/\"},a.chdir=function(t){throw new Error(\"process.chdir is not supported\")},a.umask=function(){return 0}},{}],61:[function(t,e,r){e.exports=n;var i=t(\"events\").EventEmitter;function n(){i.call(this)}t(\"inherits\")(n,i),n.Readable=t(\"readable-stream/lib/_stream_readable.js\"),n.Writable=t(\"readable-stream/lib/_stream_writable.js\"),n.Duplex=t(\"readable-stream/lib/_stream_duplex.js\"),n.Transform=t(\"readable-stream/lib/_stream_transform.js\"),n.PassThrough=t(\"readable-stream/lib/_stream_passthrough.js\"),n.finished=t(\"readable-stream/lib/internal/streams/end-of-stream.js\"),n.pipeline=t(\"readable-stream/lib/internal/streams/pipeline.js\"),n.Stream=n,n.prototype.pipe=function(t,e){var r=this;function n(e){t.writable&&!1===t.write(e)&&r.pause&&r.pause()}function a(){r.readable&&r.resume&&r.resume()}r.on(\"data\",n),t.on(\"drain\",a),t._isStdio||e&&!1===e.end||(r.on(\"end\",s),r.on(\"close\",h));var o=!1;function s(){o||(o=!0,t.end())}function h(){o||(o=!0,\"function\"==typeof t.destroy&&t.destroy())}function l(t){if(f(),0===i.listenerCount(this,\"error\"))throw t}function f(){r.removeListener(\"data\",n),t.removeListener(\"drain\",a),r.removeListener(\"end\",s),r.removeListener(\"close\",h),r.removeListener(\"error\",l),t.removeListener(\"error\",l),r.removeListener(\"end\",f),r.removeListener(\"close\",f),t.removeListener(\"close\",f)}return r.on(\"error\",l),t.on(\"error\",l),r.on(\"end\",f),r.on(\"close\",f),t.on(\"close\",f),t.emit(\"pipe\",r),t}},{events:38,inherits:45,\"readable-stream/lib/_stream_duplex.js\":63,\"readable-stream/lib/_stream_passthrough.js\":64,\"readable-stream/lib/_stream_readable.js\":65,\"readable-stream/lib/_stream_transform.js\":66,\"readable-stream/lib/_stream_writable.js\":67,\"readable-stream/lib/internal/streams/end-of-stream.js\":71,\"readable-stream/lib/internal/streams/pipeline.js\":73}],62:[function(t,e,r){\"use strict\";var i={};function n(t,e,r){r||(r=Error);var n=function(t){function r(r,i,n){return t.call(this,function(t,r,i){return\"string\"==typeof e?e:e(t,r,i)}(r,i,n))||this}return n=t,(i=r).prototype=Object.create(n.prototype),i.prototype.constructor=i,i.__proto__=n,r;var i,n}(r);n.prototype.name=r.name,n.prototype.code=t,i[t]=n}function a(t,e){if(Array.isArray(t)){var r=t.length;return t=t.map((function(t){return String(t)})),r>2?\"one of \".concat(e,\" \").concat(t.slice(0,r-1).join(\", \"),\", or \")+t[r-1]:2===r?\"one of \".concat(e,\" \").concat(t[0],\" or \").concat(t[1]):\"of \".concat(e,\" \").concat(t[0])}return\"of \".concat(e,\" \").concat(String(t))}n(\"ERR_INVALID_OPT_VALUE\",(function(t,e){return'The value \"'+e+'\" is invalid for option \"'+t+'\"'}),TypeError),n(\"ERR_INVALID_ARG_TYPE\",(function(t,e,r){var i,n,o,s;if(\"string\"==typeof e&&(o=\"not \",e.substr(!s||s<0?0:+s,o.length)===o)?(i=\"must not be\",e=e.replace(/^not /,\"\")):i=\"must be\",function(t,e,r){return(void 0===r||r>t.length)&&(r=t.length),t.substring(r-e.length,r)===e}(t,\" argument\"))n=\"The \".concat(t,\" \").concat(i,\" \").concat(a(e,\"type\"));else{var h=function(t,e,r){return\"number\"!=typeof r&&(r=0),!(r+e.length>t.length)&&-1!==t.indexOf(e,r)}(t,\".\")?\"property\":\"argument\";n='The \"'.concat(t,'\" ').concat(h,\" \").concat(i,\" \").concat(a(e,\"type\"))}return n+\". Received type \".concat(typeof r)}),TypeError),n(\"ERR_STREAM_PUSH_AFTER_EOF\",\"stream.push() after EOF\"),n(\"ERR_METHOD_NOT_IMPLEMENTED\",(function(t){return\"The \"+t+\" method is not implemented\"})),n(\"ERR_STREAM_PREMATURE_CLOSE\",\"Premature close\"),n(\"ERR_STREAM_DESTROYED\",(function(t){return\"Cannot call \"+t+\" after a stream was destroyed\"})),n(\"ERR_MULTIPLE_CALLBACK\",\"Callback called multiple times\"),n(\"ERR_STREAM_CANNOT_PIPE\",\"Cannot pipe, not readable\"),n(\"ERR_STREAM_WRITE_AFTER_END\",\"write after end\"),n(\"ERR_STREAM_NULL_VALUES\",\"May not write null values to stream\",TypeError),n(\"ERR_UNKNOWN_ENCODING\",(function(t){return\"Unknown encoding: \"+t}),TypeError),n(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\",\"stream.unshift() after end event\"),e.exports.codes=i},{}],63:[function(t,e,r){(function(r){(function(){\"use strict\";var i=Object.keys||function(t){var e=[];for(var r in t)e.push(r);return e};e.exports=l;var n=t(\"./_stream_readable\"),a=t(\"./_stream_writable\");t(\"inherits\")(l,n);for(var o=i(a.prototype),s=0;s<o.length;s++){var h=o[s];l.prototype[h]||(l.prototype[h]=a.prototype[h])}function l(t){if(!(this instanceof l))return new l(t);n.call(this,t),a.call(this,t),this.allowHalfOpen=!0,t&&(!1===t.readable&&(this.readable=!1),!1===t.writable&&(this.writable=!1),!1===t.allowHalfOpen&&(this.allowHalfOpen=!1,this.once(\"end\",f)))}function f(){this._writableState.ended||r.nextTick(u,this)}function u(t){t.end()}Object.defineProperty(l.prototype,\"writableHighWaterMark\",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(l.prototype,\"writableBuffer\",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(l.prototype,\"writableLength\",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(l.prototype,\"destroyed\",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&this._readableState.destroyed&&this._writableState.destroyed},set:function(t){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=t,this._writableState.destroyed=t)}})}).call(this)}).call(this,t(\"_process\"))},{\"./_stream_readable\":65,\"./_stream_writable\":67,_process:60,inherits:45}],64:[function(t,e,r){\"use strict\";e.exports=n;var i=t(\"./_stream_transform\");function n(t){if(!(this instanceof n))return new n(t);i.call(this,t)}t(\"inherits\")(n,i),n.prototype._transform=function(t,e,r){r(null,t)}},{\"./_stream_transform\":66,inherits:45}],65:[function(t,e,i){(function(r,i){(function(){\"use strict\";var n;e.exports=S,S.ReadableState=k,t(\"events\").EventEmitter;var a=function(t,e){return t.listeners(e).length},o=t(\"./internal/streams/stream\"),s=t(\"buffer\").Buffer,h=i.Uint8Array||function(){};var l,f=t(\"util\");l=f&&f.debuglog?f.debuglog(\"stream\"):function(){};var u,c,d,p=t(\"./internal/streams/buffer_list\"),m=t(\"./internal/streams/destroy\"),g=t(\"./internal/streams/state\").getHighWaterMark,b=t(\"../errors\").codes,_=b.ERR_INVALID_ARG_TYPE,y=b.ERR_STREAM_PUSH_AFTER_EOF,w=b.ERR_METHOD_NOT_IMPLEMENTED,v=b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;t(\"inherits\")(S,o);var x=m.errorOrDestroy,E=[\"error\",\"close\",\"destroy\",\"pause\",\"resume\"];function k(e,r,i){n=n||t(\"./_stream_duplex\"),e=e||{},\"boolean\"!=typeof i&&(i=r instanceof n),this.objectMode=!!e.objectMode,i&&(this.objectMode=this.objectMode||!!e.readableObjectMode),this.highWaterMark=g(this,e,\"readableHighWaterMark\",i),this.buffer=new p,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==e.emitClose,this.autoDestroy=!!e.autoDestroy,this.destroyed=!1,this.defaultEncoding=e.defaultEncoding||\"utf8\",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(u||(u=t(\"string_decoder/\").StringDecoder),this.decoder=new u(e.encoding),this.encoding=e.encoding)}function S(e){if(n=n||t(\"./_stream_duplex\"),!(this instanceof S))return new S(e);var r=this instanceof n;this._readableState=new k(e,this,r),this.readable=!0,e&&(\"function\"==typeof e.read&&(this._read=e.read),\"function\"==typeof e.destroy&&(this._destroy=e.destroy)),o.call(this)}function M(t,e,r,i,n){l(\"readableAddChunk\",e);var a,o=t._readableState;if(null===e)o.reading=!1,function(t,e){if(l(\"onEofChunk\"),!e.ended){if(e.decoder){var r=e.decoder.end();r&&r.length&&(e.buffer.push(r),e.length+=e.objectMode?1:r.length)}e.ended=!0,e.sync?T(t):(e.needReadable=!1,e.emittedReadable||(e.emittedReadable=!0,R(t)))}}(t,o);else if(n||(a=function(t,e){var r;return i=e,s.isBuffer(i)||i instanceof h||\"string\"==typeof e||void 0===e||t.objectMode||(r=new _(\"chunk\",[\"string\",\"Buffer\",\"Uint8Array\"],e)),r;var i}(o,e)),a)x(t,a);else if(o.objectMode||e&&e.length>0)if(\"string\"==typeof e||o.objectMode||Object.getPrototypeOf(e)===s.prototype||(e=function(t){return s.from(t)}(e)),i)o.endEmitted?x(t,new v):A(t,o,e,!0);else if(o.ended)x(t,new y);else{if(o.destroyed)return!1;o.reading=!1,o.decoder&&!r?(e=o.decoder.write(e),o.objectMode||0!==e.length?A(t,o,e,!1):P(t,o)):A(t,o,e,!1)}else i||(o.reading=!1,P(t,o));return!o.ended&&(o.length<o.highWaterMark||0===o.length)}function A(t,e,r,i){e.flowing&&0===e.length&&!e.sync?(e.awaitDrain=0,t.emit(\"data\",r)):(e.length+=e.objectMode?1:r.length,i?e.buffer.unshift(r):e.buffer.push(r),e.needReadable&&T(t)),P(t,e)}Object.defineProperty(S.prototype,\"destroyed\",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(t){this._readableState&&(this._readableState.destroyed=t)}}),S.prototype.destroy=m.destroy,S.prototype._undestroy=m.undestroy,S.prototype._destroy=function(t,e){e(t)},S.prototype.push=function(t,e){var r,i=this._readableState;return i.objectMode?r=!0:\"string\"==typeof t&&((e=e||i.defaultEncoding)!==i.encoding&&(t=s.from(t,e),e=\"\"),r=!0),M(this,t,e,!1,r)},S.prototype.unshift=function(t){return M(this,t,null,!0,!1)},S.prototype.isPaused=function(){return!1===this._readableState.flowing},S.prototype.setEncoding=function(e){u||(u=t(\"string_decoder/\").StringDecoder);var r=new u(e);this._readableState.decoder=r,this._readableState.encoding=this._readableState.decoder.encoding;for(var i=this._readableState.buffer.head,n=\"\";null!==i;)n+=r.write(i.data),i=i.next;return this._readableState.buffer.clear(),\"\"!==n&&this._readableState.buffer.push(n),this._readableState.length=n.length,this};var I=1073741824;function B(t,e){return t<=0||0===e.length&&e.ended?0:e.objectMode?1:t!=t?e.flowing&&e.length?e.buffer.head.data.length:e.length:(t>e.highWaterMark&&(e.highWaterMark=function(t){return t>=I?t=I:(t--,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t++),t}(t)),t<=e.length?t:e.ended?e.length:(e.needReadable=!0,0))}function T(t){var e=t._readableState;l(\"emitReadable\",e.needReadable,e.emittedReadable),e.needReadable=!1,e.emittedReadable||(l(\"emitReadable\",e.flowing),e.emittedReadable=!0,r.nextTick(R,t))}function R(t){var e=t._readableState;l(\"emitReadable_\",e.destroyed,e.length,e.ended),e.destroyed||!e.length&&!e.ended||(t.emit(\"readable\"),e.emittedReadable=!1),e.needReadable=!e.flowing&&!e.ended&&e.length<=e.highWaterMark,z(t)}function P(t,e){e.readingMore||(e.readingMore=!0,r.nextTick(O,t,e))}function O(t,e){for(;!e.reading&&!e.ended&&(e.length<e.highWaterMark||e.flowing&&0===e.length);){var r=e.length;if(l(\"maybeReadMore read 0\"),t.read(0),r===e.length)break}e.readingMore=!1}function L(t){var e=t._readableState;e.readableListening=t.listenerCount(\"readable\")>0,e.resumeScheduled&&!e.paused?e.flowing=!0:t.listenerCount(\"data\")>0&&t.resume()}function C(t){l(\"readable nexttick read 0\"),t.read(0)}function U(t,e){l(\"resume\",e.reading),e.reading||t.read(0),e.resumeScheduled=!1,t.emit(\"resume\"),z(t),e.flowing&&!e.reading&&t.read(0)}function z(t){var e=t._readableState;for(l(\"flow\",e.flowing);e.flowing&&null!==t.read(););}function D(t,e){return 0===e.length?null:(e.objectMode?r=e.buffer.shift():!t||t>=e.length?(r=e.decoder?e.buffer.join(\"\"):1===e.buffer.length?e.buffer.first():e.buffer.concat(e.length),e.buffer.clear()):r=e.buffer.consume(t,e.decoder),r);var r}function N(t){var e=t._readableState;l(\"endReadable\",e.endEmitted),e.endEmitted||(e.ended=!0,r.nextTick(F,e,t))}function F(t,e){if(l(\"endReadableNT\",t.endEmitted,t.length),!t.endEmitted&&0===t.length&&(t.endEmitted=!0,e.readable=!1,e.emit(\"end\"),t.autoDestroy)){var r=e._writableState;(!r||r.autoDestroy&&r.finished)&&e.destroy()}}function j(t,e){for(var r=0,i=t.length;r<i;r++)if(t[r]===e)return r;return-1}S.prototype.read=function(t){l(\"read\",t),t=parseInt(t,10);var e=this._readableState,r=t;if(0!==t&&(e.emittedReadable=!1),0===t&&e.needReadable&&((0!==e.highWaterMark?e.length>=e.highWaterMark:e.length>0)||e.ended))return l(\"read: emitReadable\",e.length,e.ended),0===e.length&&e.ended?N(this):T(this),null;if(0===(t=B(t,e))&&e.ended)return 0===e.length&&N(this),null;var i,n=e.needReadable;return l(\"need readable\",n),(0===e.length||e.length-t<e.highWaterMark)&&l(\"length less than watermark\",n=!0),e.ended||e.reading?l(\"reading or ended\",n=!1):n&&(l(\"do read\"),e.reading=!0,e.sync=!0,0===e.length&&(e.needReadable=!0),this._read(e.highWaterMark),e.sync=!1,e.reading||(t=B(r,e))),null===(i=t>0?D(t,e):null)?(e.needReadable=e.length<=e.highWaterMark,t=0):(e.length-=t,e.awaitDrain=0),0===e.length&&(e.ended||(e.needReadable=!0),r!==t&&e.ended&&N(this)),null!==i&&this.emit(\"data\",i),i},S.prototype._read=function(t){x(this,new w(\"_read()\"))},S.prototype.pipe=function(t,e){var i=this,n=this._readableState;switch(n.pipesCount){case 0:n.pipes=t;break;case 1:n.pipes=[n.pipes,t];break;default:n.pipes.push(t)}n.pipesCount+=1,l(\"pipe count=%d opts=%j\",n.pipesCount,e);var o=e&&!1===e.end||t===r.stdout||t===r.stderr?g:h;function s(e,r){l(\"onunpipe\"),e===i&&r&&!1===r.hasUnpiped&&(r.hasUnpiped=!0,l(\"cleanup\"),t.removeListener(\"close\",p),t.removeListener(\"finish\",m),t.removeListener(\"drain\",f),t.removeListener(\"error\",d),t.removeListener(\"unpipe\",s),i.removeListener(\"end\",h),i.removeListener(\"end\",g),i.removeListener(\"data\",c),u=!0,!n.awaitDrain||t._writableState&&!t._writableState.needDrain||f())}function h(){l(\"onend\"),t.end()}n.endEmitted?r.nextTick(o):i.once(\"end\",o),t.on(\"unpipe\",s);var f=function(t){return function(){var e=t._readableState;l(\"pipeOnDrain\",e.awaitDrain),e.awaitDrain&&e.awaitDrain--,0===e.awaitDrain&&a(t,\"data\")&&(e.flowing=!0,z(t))}}(i);t.on(\"drain\",f);var u=!1;function c(e){l(\"ondata\");var r=t.write(e);l(\"dest.write\",r),!1===r&&((1===n.pipesCount&&n.pipes===t||n.pipesCount>1&&-1!==j(n.pipes,t))&&!u&&(l(\"false write response, pause\",n.awaitDrain),n.awaitDrain++),i.pause())}function d(e){l(\"onerror\",e),g(),t.removeListener(\"error\",d),0===a(t,\"error\")&&x(t,e)}function p(){t.removeListener(\"finish\",m),g()}function m(){l(\"onfinish\"),t.removeListener(\"close\",p),g()}function g(){l(\"unpipe\"),i.unpipe(t)}return i.on(\"data\",c),function(t,e,r){if(\"function\"==typeof t.prependListener)return t.prependListener(e,r);t._events&&t._events[e]?Array.isArray(t._events[e])?t._events[e].unshift(r):t._events[e]=[r,t._events[e]]:t.on(e,r)}(t,\"error\",d),t.once(\"close\",p),t.once(\"finish\",m),t.emit(\"pipe\",i),n.flowing||(l(\"pipe resume\"),i.resume()),t},S.prototype.unpipe=function(t){var e=this._readableState,r={hasUnpiped:!1};if(0===e.pipesCount)return this;if(1===e.pipesCount)return t&&t!==e.pipes||(t||(t=e.pipes),e.pipes=null,e.pipesCount=0,e.flowing=!1,t&&t.emit(\"unpipe\",this,r)),this;if(!t){var i=e.pipes,n=e.pipesCount;e.pipes=null,e.pipesCount=0,e.flowing=!1;for(var a=0;a<n;a++)i[a].emit(\"unpipe\",this,{hasUnpiped:!1});return this}var o=j(e.pipes,t);return-1===o||(e.pipes.splice(o,1),e.pipesCount-=1,1===e.pipesCount&&(e.pipes=e.pipes[0]),t.emit(\"unpipe\",this,r)),this},S.prototype.on=function(t,e){var i=o.prototype.on.call(this,t,e),n=this._readableState;return\"data\"===t?(n.readableListening=this.listenerCount(\"readable\")>0,!1!==n.flowing&&this.resume()):\"readable\"===t&&(n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.flowing=!1,n.emittedReadable=!1,l(\"on readable\",n.length,n.reading),n.length?T(this):n.reading||r.nextTick(C,this))),i},S.prototype.addListener=S.prototype.on,S.prototype.removeListener=function(t,e){var i=o.prototype.removeListener.call(this,t,e);return\"readable\"===t&&r.nextTick(L,this),i},S.prototype.removeAllListeners=function(t){var e=o.prototype.removeAllListeners.apply(this,arguments);return\"readable\"!==t&&void 0!==t||r.nextTick(L,this),e},S.prototype.resume=function(){var t=this._readableState;return t.flowing||(l(\"resume\"),t.flowing=!t.readableListening,function(t,e){e.resumeScheduled||(e.resumeScheduled=!0,r.nextTick(U,t,e))}(this,t)),t.paused=!1,this},S.prototype.pause=function(){return l(\"call pause flowing=%j\",this._readableState.flowing),!1!==this._readableState.flowing&&(l(\"pause\"),this._readableState.flowing=!1,this.emit(\"pause\")),this._readableState.paused=!0,this},S.prototype.wrap=function(t){var e=this,r=this._readableState,i=!1;for(var n in t.on(\"end\",(function(){if(l(\"wrapped end\"),r.decoder&&!r.ended){var t=r.decoder.end();t&&t.length&&e.push(t)}e.push(null)})),t.on(\"data\",(function(n){l(\"wrapped data\"),r.decoder&&(n=r.decoder.write(n)),r.objectMode&&null==n||(r.objectMode||n&&n.length)&&(e.push(n)||(i=!0,t.pause()))})),t)void 0===this[n]&&\"function\"==typeof t[n]&&(this[n]=function(e){return function(){return t[e].apply(t,arguments)}}(n));for(var a=0;a<E.length;a++)t.on(E[a],this.emit.bind(this,E[a]));return this._read=function(e){l(\"wrapped _read\",e),i&&(i=!1,t.resume())},this},\"function\"==typeof Symbol&&(S.prototype[Symbol.asyncIterator]=function(){return void 0===c&&(c=t(\"./internal/streams/async_iterator\")),c(this)}),Object.defineProperty(S.prototype,\"readableHighWaterMark\",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(S.prototype,\"readableBuffer\",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(S.prototype,\"readableFlowing\",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(t){this._readableState&&(this._readableState.flowing=t)}}),S._fromList=D,Object.defineProperty(S.prototype,\"readableLength\",{enumerable:!1,get:function(){return this._readableState.length}}),\"function\"==typeof Symbol&&(S.from=function(e,r){return void 0===d&&(d=t(\"./internal/streams/from\")),d(S,e,r)})}).call(this)}).call(this,t(\"_process\"),void 0!==r.g?r.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"../errors\":62,\"./_stream_duplex\":63,\"./internal/streams/async_iterator\":68,\"./internal/streams/buffer_list\":69,\"./internal/streams/destroy\":70,\"./internal/streams/from\":72,\"./internal/streams/state\":74,\"./internal/streams/stream\":75,_process:60,buffer:33,events:38,inherits:45,\"string_decoder/\":76,util:30}],66:[function(t,e,r){\"use strict\";e.exports=f;var i=t(\"../errors\").codes,n=i.ERR_METHOD_NOT_IMPLEMENTED,a=i.ERR_MULTIPLE_CALLBACK,o=i.ERR_TRANSFORM_ALREADY_TRANSFORMING,s=i.ERR_TRANSFORM_WITH_LENGTH_0,h=t(\"./_stream_duplex\");function l(t,e){var r=this._transformState;r.transforming=!1;var i=r.writecb;if(null===i)return this.emit(\"error\",new a);r.writechunk=null,r.writecb=null,null!=e&&this.push(e),i(t);var n=this._readableState;n.reading=!1,(n.needReadable||n.length<n.highWaterMark)&&this._read(n.highWaterMark)}function f(t){if(!(this instanceof f))return new f(t);h.call(this,t),this._transformState={afterTransform:l.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,t&&(\"function\"==typeof t.transform&&(this._transform=t.transform),\"function\"==typeof t.flush&&(this._flush=t.flush)),this.on(\"prefinish\",u)}function u(){var t=this;\"function\"!=typeof this._flush||this._readableState.destroyed?c(this,null,null):this._flush((function(e,r){c(t,e,r)}))}function c(t,e,r){if(e)return t.emit(\"error\",e);if(null!=r&&t.push(r),t._writableState.length)throw new s;if(t._transformState.transforming)throw new o;return t.push(null)}t(\"inherits\")(f,h),f.prototype.push=function(t,e){return this._transformState.needTransform=!1,h.prototype.push.call(this,t,e)},f.prototype._transform=function(t,e,r){r(new n(\"_transform()\"))},f.prototype._write=function(t,e,r){var i=this._transformState;if(i.writecb=r,i.writechunk=t,i.writeencoding=e,!i.transforming){var n=this._readableState;(i.needTransform||n.needReadable||n.length<n.highWaterMark)&&this._read(n.highWaterMark)}},f.prototype._read=function(t){var e=this._transformState;null===e.writechunk||e.transforming?e.needTransform=!0:(e.transforming=!0,this._transform(e.writechunk,e.writeencoding,e.afterTransform))},f.prototype._destroy=function(t,e){h.prototype._destroy.call(this,t,(function(t){e(t)}))}},{\"../errors\":62,\"./_stream_duplex\":63,inherits:45}],67:[function(t,e,i){(function(r,i){(function(){\"use strict\";function n(t){var e=this;this.next=null,this.entry=null,this.finish=function(){!function(t,e,r){var i=t.entry;for(t.entry=null;i;){var n=i.callback;e.pendingcb--,n(r),i=i.next}e.corkedRequestsFree.next=t}(e,t)}}var a;e.exports=S,S.WritableState=k;var o={deprecate:t(\"util-deprecate\")},s=t(\"./internal/streams/stream\"),h=t(\"buffer\").Buffer,l=i.Uint8Array||function(){};var f,u=t(\"./internal/streams/destroy\"),c=t(\"./internal/streams/state\").getHighWaterMark,d=t(\"../errors\").codes,p=d.ERR_INVALID_ARG_TYPE,m=d.ERR_METHOD_NOT_IMPLEMENTED,g=d.ERR_MULTIPLE_CALLBACK,b=d.ERR_STREAM_CANNOT_PIPE,_=d.ERR_STREAM_DESTROYED,y=d.ERR_STREAM_NULL_VALUES,w=d.ERR_STREAM_WRITE_AFTER_END,v=d.ERR_UNKNOWN_ENCODING,x=u.errorOrDestroy;function E(){}function k(e,i,o){a=a||t(\"./_stream_duplex\"),e=e||{},\"boolean\"!=typeof o&&(o=i instanceof a),this.objectMode=!!e.objectMode,o&&(this.objectMode=this.objectMode||!!e.writableObjectMode),this.highWaterMark=c(this,e,\"writableHighWaterMark\",o),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var s=!1===e.decodeStrings;this.decodeStrings=!s,this.defaultEncoding=e.defaultEncoding||\"utf8\",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(t){!function(t,e){var i=t._writableState,n=i.sync,a=i.writecb;if(\"function\"!=typeof a)throw new g;if(function(t){t.writing=!1,t.writecb=null,t.length-=t.writelen,t.writelen=0}(i),e)!function(t,e,i,n,a){--e.pendingcb,i?(r.nextTick(a,n),r.nextTick(P,t,e),t._writableState.errorEmitted=!0,x(t,n)):(a(n),t._writableState.errorEmitted=!0,x(t,n),P(t,e))}(t,i,n,e,a);else{var o=T(i)||t.destroyed;o||i.corked||i.bufferProcessing||!i.bufferedRequest||B(t,i),n?r.nextTick(I,t,i,o,a):I(t,i,o,a)}}(i,t)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==e.emitClose,this.autoDestroy=!!e.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new n(this)}function S(e){var r=this instanceof(a=a||t(\"./_stream_duplex\"));if(!r&&!f.call(S,this))return new S(e);this._writableState=new k(e,this,r),this.writable=!0,e&&(\"function\"==typeof e.write&&(this._write=e.write),\"function\"==typeof e.writev&&(this._writev=e.writev),\"function\"==typeof e.destroy&&(this._destroy=e.destroy),\"function\"==typeof e.final&&(this._final=e.final)),s.call(this)}function M(t,e,r,i,n,a){if(!r){var o=function(t,e,r){return t.objectMode||!1===t.decodeStrings||\"string\"!=typeof e||(e=h.from(e,r)),e}(e,i,n);i!==o&&(r=!0,n=\"buffer\",i=o)}var s=e.objectMode?1:i.length;e.length+=s;var l=e.length<e.highWaterMark;if(l||(e.needDrain=!0),e.writing||e.corked){var f=e.lastBufferedRequest;e.lastBufferedRequest={chunk:i,encoding:n,isBuf:r,callback:a,next:null},f?f.next=e.lastBufferedRequest:e.bufferedRequest=e.lastBufferedRequest,e.bufferedRequestCount+=1}else A(t,e,!1,s,i,n,a);return l}function A(t,e,r,i,n,a,o){e.writelen=i,e.writecb=o,e.writing=!0,e.sync=!0,e.destroyed?e.onwrite(new _(\"write\")):r?t._writev(n,e.onwrite):t._write(n,a,e.onwrite),e.sync=!1}function I(t,e,r,i){r||function(t,e){0===e.length&&e.needDrain&&(e.needDrain=!1,t.emit(\"drain\"))}(t,e),e.pendingcb--,i(),P(t,e)}function B(t,e){e.bufferProcessing=!0;var r=e.bufferedRequest;if(t._writev&&r&&r.next){var i=e.bufferedRequestCount,a=new Array(i),o=e.corkedRequestsFree;o.entry=r;for(var s=0,h=!0;r;)a[s]=r,r.isBuf||(h=!1),r=r.next,s+=1;a.allBuffers=h,A(t,e,!0,e.length,a,\"\",o.finish),e.pendingcb++,e.lastBufferedRequest=null,o.next?(e.corkedRequestsFree=o.next,o.next=null):e.corkedRequestsFree=new n(e),e.bufferedRequestCount=0}else{for(;r;){var l=r.chunk,f=r.encoding,u=r.callback;if(A(t,e,!1,e.objectMode?1:l.length,l,f,u),r=r.next,e.bufferedRequestCount--,e.writing)break}null===r&&(e.lastBufferedRequest=null)}e.bufferedRequest=r,e.bufferProcessing=!1}function T(t){return t.ending&&0===t.length&&null===t.bufferedRequest&&!t.finished&&!t.writing}function R(t,e){t._final((function(r){e.pendingcb--,r&&x(t,r),e.prefinished=!0,t.emit(\"prefinish\"),P(t,e)}))}function P(t,e){var i=T(e);if(i&&(function(t,e){e.prefinished||e.finalCalled||(\"function\"!=typeof t._final||e.destroyed?(e.prefinished=!0,t.emit(\"prefinish\")):(e.pendingcb++,e.finalCalled=!0,r.nextTick(R,t,e)))}(t,e),0===e.pendingcb&&(e.finished=!0,t.emit(\"finish\"),e.autoDestroy))){var n=t._readableState;(!n||n.autoDestroy&&n.endEmitted)&&t.destroy()}return i}t(\"inherits\")(S,s),k.prototype.getBuffer=function(){for(var t=this.bufferedRequest,e=[];t;)e.push(t),t=t.next;return e},function(){try{Object.defineProperty(k.prototype,\"buffer\",{get:o.deprecate((function(){return this.getBuffer()}),\"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.\",\"DEP0003\")})}catch(t){}}(),\"function\"==typeof Symbol&&Symbol.hasInstance&&\"function\"==typeof Function.prototype[Symbol.hasInstance]?(f=Function.prototype[Symbol.hasInstance],Object.defineProperty(S,Symbol.hasInstance,{value:function(t){return!!f.call(this,t)||this===S&&t&&t._writableState instanceof k}})):f=function(t){return t instanceof this},S.prototype.pipe=function(){x(this,new b)},S.prototype.write=function(t,e,i){var n,a=this._writableState,o=!1,s=!a.objectMode&&(n=t,h.isBuffer(n)||n instanceof l);return s&&!h.isBuffer(t)&&(t=function(t){return h.from(t)}(t)),\"function\"==typeof e&&(i=e,e=null),s?e=\"buffer\":e||(e=a.defaultEncoding),\"function\"!=typeof i&&(i=E),a.ending?function(t,e){var i=new w;x(t,i),r.nextTick(e,i)}(this,i):(s||function(t,e,i,n){var a;return null===i?a=new y:\"string\"==typeof i||e.objectMode||(a=new p(\"chunk\",[\"string\",\"Buffer\"],i)),!a||(x(t,a),r.nextTick(n,a),!1)}(this,a,t,i))&&(a.pendingcb++,o=M(this,a,s,t,e,i)),o},S.prototype.cork=function(){this._writableState.corked++},S.prototype.uncork=function(){var t=this._writableState;t.corked&&(t.corked--,t.writing||t.corked||t.bufferProcessing||!t.bufferedRequest||B(this,t))},S.prototype.setDefaultEncoding=function(t){if(\"string\"==typeof t&&(t=t.toLowerCase()),!([\"hex\",\"utf8\",\"utf-8\",\"ascii\",\"binary\",\"base64\",\"ucs2\",\"ucs-2\",\"utf16le\",\"utf-16le\",\"raw\"].indexOf((t+\"\").toLowerCase())>-1))throw new v(t);return this._writableState.defaultEncoding=t,this},Object.defineProperty(S.prototype,\"writableBuffer\",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(S.prototype,\"writableHighWaterMark\",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),S.prototype._write=function(t,e,r){r(new m(\"_write()\"))},S.prototype._writev=null,S.prototype.end=function(t,e,i){var n=this._writableState;return\"function\"==typeof t?(i=t,t=null,e=null):\"function\"==typeof e&&(i=e,e=null),null!=t&&this.write(t,e),n.corked&&(n.corked=1,this.uncork()),n.ending||function(t,e,i){e.ending=!0,P(t,e),i&&(e.finished?r.nextTick(i):t.once(\"finish\",i)),e.ended=!0,t.writable=!1}(this,n,i),this},Object.defineProperty(S.prototype,\"writableLength\",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(S.prototype,\"destroyed\",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(t){this._writableState&&(this._writableState.destroyed=t)}}),S.prototype.destroy=u.destroy,S.prototype._undestroy=u.undestroy,S.prototype._destroy=function(t,e){e(t)}}).call(this)}).call(this,t(\"_process\"),void 0!==r.g?r.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"../errors\":62,\"./_stream_duplex\":63,\"./internal/streams/destroy\":70,\"./internal/streams/state\":74,\"./internal/streams/stream\":75,_process:60,buffer:33,inherits:45,\"util-deprecate\":78}],68:[function(t,e,r){(function(r){(function(){\"use strict\";var i;function n(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var a=t(\"./end-of-stream\"),o=Symbol(\"lastResolve\"),s=Symbol(\"lastReject\"),h=Symbol(\"error\"),l=Symbol(\"ended\"),f=Symbol(\"lastPromise\"),u=Symbol(\"handlePromise\"),c=Symbol(\"stream\");function d(t,e){return{value:t,done:e}}function p(t){var e=t[o];if(null!==e){var r=t[c].read();null!==r&&(t[f]=null,t[o]=null,t[s]=null,e(d(r,!1)))}}function m(t){r.nextTick(p,t)}var g=Object.getPrototypeOf((function(){})),b=Object.setPrototypeOf((n(i={get stream(){return this[c]},next:function(){var t=this,e=this[h];if(null!==e)return Promise.reject(e);if(this[l])return Promise.resolve(d(void 0,!0));if(this[c].destroyed)return new Promise((function(e,i){r.nextTick((function(){t[h]?i(t[h]):e(d(void 0,!0))}))}));var i,n=this[f];if(n)i=new Promise(function(t,e){return function(r,i){t.then((function(){e[l]?r(d(void 0,!0)):e[u](r,i)}),i)}}(n,this));else{var a=this[c].read();if(null!==a)return Promise.resolve(d(a,!1));i=new Promise(this[u])}return this[f]=i,i}},Symbol.asyncIterator,(function(){return this})),n(i,\"return\",(function(){var t=this;return new Promise((function(e,r){t[c].destroy(null,(function(t){t?r(t):e(d(void 0,!0))}))}))})),i),g);e.exports=function(t){var e,r=Object.create(b,(n(e={},c,{value:t,writable:!0}),n(e,o,{value:null,writable:!0}),n(e,s,{value:null,writable:!0}),n(e,h,{value:null,writable:!0}),n(e,l,{value:t._readableState.endEmitted,writable:!0}),n(e,u,{value:function(t,e){var i=r[c].read();i?(r[f]=null,r[o]=null,r[s]=null,t(d(i,!1))):(r[o]=t,r[s]=e)},writable:!0}),e));return r[f]=null,a(t,(function(t){if(t&&\"ERR_STREAM_PREMATURE_CLOSE\"!==t.code){var e=r[s];return null!==e&&(r[f]=null,r[o]=null,r[s]=null,e(t)),void(r[h]=t)}var i=r[o];null!==i&&(r[f]=null,r[o]=null,r[s]=null,i(d(void 0,!0))),r[l]=!0})),t.on(\"readable\",m.bind(null,r)),r}}).call(this)}).call(this,t(\"_process\"))},{\"./end-of-stream\":71,_process:60}],69:[function(t,e,r){\"use strict\";function i(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,i)}return r}function n(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function a(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}var o=t(\"buffer\").Buffer,s=t(\"util\").inspect,h=s&&s.custom||\"inspect\";e.exports=function(){function t(){(function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")})(this,t),this.head=null,this.tail=null,this.length=0}return e=t,r=[{key:\"push\",value:function(t){var e={data:t,next:null};this.length>0?this.tail.next=e:this.head=e,this.tail=e,++this.length}},{key:\"unshift\",value:function(t){var e={data:t,next:this.head};0===this.length&&(this.tail=e),this.head=e,++this.length}},{key:\"shift\",value:function(){if(0!==this.length){var t=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,t}}},{key:\"clear\",value:function(){this.head=this.tail=null,this.length=0}},{key:\"join\",value:function(t){if(0===this.length)return\"\";for(var e=this.head,r=\"\"+e.data;e=e.next;)r+=t+e.data;return r}},{key:\"concat\",value:function(t){if(0===this.length)return o.alloc(0);for(var e=o.allocUnsafe(t>>>0),r=this.head,i=0;r;)n=r.data,a=e,s=i,o.prototype.copy.call(n,a,s),i+=r.data.length,r=r.next;var n,a,s;return e}},{key:\"consume\",value:function(t,e){var r;return t<this.head.data.length?(r=this.head.data.slice(0,t),this.head.data=this.head.data.slice(t)):r=t===this.head.data.length?this.shift():e?this._getString(t):this._getBuffer(t),r}},{key:\"first\",value:function(){return this.head.data}},{key:\"_getString\",value:function(t){var e=this.head,r=1,i=e.data;for(t-=i.length;e=e.next;){var n=e.data,a=t>n.length?n.length:t;if(a===n.length?i+=n:i+=n.slice(0,t),0==(t-=a)){a===n.length?(++r,e.next?this.head=e.next:this.head=this.tail=null):(this.head=e,e.data=n.slice(a));break}++r}return this.length-=r,i}},{key:\"_getBuffer\",value:function(t){var e=o.allocUnsafe(t),r=this.head,i=1;for(r.data.copy(e),t-=r.data.length;r=r.next;){var n=r.data,a=t>n.length?n.length:t;if(n.copy(e,e.length-t,0,a),0==(t-=a)){a===n.length?(++i,r.next?this.head=r.next:this.head=this.tail=null):(this.head=r,r.data=n.slice(a));break}++i}return this.length-=i,e}},{key:h,value:function(t,e){return s(this,function(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?i(Object(r),!0).forEach((function(e){n(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}({},e,{depth:0,customInspect:!1}))}}],r&&a(e.prototype,r),l&&a(e,l),t;var e,r,l}()},{buffer:33,util:30}],70:[function(t,e,r){(function(t){(function(){\"use strict\";function r(t,e){n(t,e),i(t)}function i(t){t._writableState&&!t._writableState.emitClose||t._readableState&&!t._readableState.emitClose||t.emit(\"close\")}function n(t,e){t.emit(\"error\",e)}e.exports={destroy:function(e,a){var o=this,s=this._readableState&&this._readableState.destroyed,h=this._writableState&&this._writableState.destroyed;return s||h?(a?a(e):e&&(this._writableState?this._writableState.errorEmitted||(this._writableState.errorEmitted=!0,t.nextTick(n,this,e)):t.nextTick(n,this,e)),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,(function(e){!a&&e?o._writableState?o._writableState.errorEmitted?t.nextTick(i,o):(o._writableState.errorEmitted=!0,t.nextTick(r,o,e)):t.nextTick(r,o,e):a?(t.nextTick(i,o),a(e)):t.nextTick(i,o)})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)},errorOrDestroy:function(t,e){var r=t._readableState,i=t._writableState;r&&r.autoDestroy||i&&i.autoDestroy?t.destroy(e):t.emit(\"error\",e)}}}).call(this)}).call(this,t(\"_process\"))},{_process:60}],71:[function(t,e,r){\"use strict\";var i=t(\"../../../errors\").codes.ERR_STREAM_PREMATURE_CLOSE;function n(){}e.exports=function t(e,r,a){if(\"function\"==typeof r)return t(e,null,r);r||(r={}),a=function(t){var e=!1;return function(){if(!e){e=!0;for(var r=arguments.length,i=new Array(r),n=0;n<r;n++)i[n]=arguments[n];t.apply(this,i)}}}(a||n);var o=r.readable||!1!==r.readable&&e.readable,s=r.writable||!1!==r.writable&&e.writable,h=function(){e.writable||f()},l=e._writableState&&e._writableState.finished,f=function(){s=!1,l=!0,o||a.call(e)},u=e._readableState&&e._readableState.endEmitted,c=function(){o=!1,u=!0,s||a.call(e)},d=function(t){a.call(e,t)},p=function(){var t;return o&&!u?(e._readableState&&e._readableState.ended||(t=new i),a.call(e,t)):s&&!l?(e._writableState&&e._writableState.ended||(t=new i),a.call(e,t)):void 0},m=function(){e.req.on(\"finish\",f)};return function(t){return t.setHeader&&\"function\"==typeof t.abort}(e)?(e.on(\"complete\",f),e.on(\"abort\",p),e.req?m():e.on(\"request\",m)):s&&!e._writableState&&(e.on(\"end\",h),e.on(\"close\",h)),e.on(\"end\",c),e.on(\"finish\",f),!1!==r.error&&e.on(\"error\",d),e.on(\"close\",p),function(){e.removeListener(\"complete\",f),e.removeListener(\"abort\",p),e.removeListener(\"request\",m),e.req&&e.req.removeListener(\"finish\",f),e.removeListener(\"end\",h),e.removeListener(\"close\",h),e.removeListener(\"finish\",f),e.removeListener(\"end\",c),e.removeListener(\"error\",d),e.removeListener(\"close\",p)}}},{\"../../../errors\":62}],72:[function(t,e,r){e.exports=function(){throw new Error(\"Readable.from is not available in the browser\")}},{}],73:[function(t,e,r){\"use strict\";var i;var n=t(\"../../../errors\").codes,a=n.ERR_MISSING_ARGS,o=n.ERR_STREAM_DESTROYED;function s(t){if(t)throw t}function h(t){t()}function l(t,e){return t.pipe(e)}e.exports=function(){for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];var f,u=function(t){return t.length?\"function\"!=typeof t[t.length-1]?s:t.pop():s}(r);if(Array.isArray(r[0])&&(r=r[0]),r.length<2)throw new a(\"streams\");var c=r.map((function(e,n){var a=n<r.length-1;return function(e,r,n,a){a=function(t){var e=!1;return function(){e||(e=!0,t.apply(void 0,arguments))}}(a);var s=!1;e.on(\"close\",(function(){s=!0})),void 0===i&&(i=t(\"./end-of-stream\")),i(e,{readable:r,writable:n},(function(t){if(t)return a(t);s=!0,a()}));var h=!1;return function(t){if(!s&&!h)return h=!0,function(t){return t.setHeader&&\"function\"==typeof t.abort}(e)?e.abort():\"function\"==typeof e.destroy?e.destroy():void a(t||new o(\"pipe\"))}}(e,a,n>0,(function(t){f||(f=t),t&&c.forEach(h),a||(c.forEach(h),u(f))}))}));return r.reduce(l)}},{\"../../../errors\":62,\"./end-of-stream\":71}],74:[function(t,e,r){\"use strict\";var i=t(\"../../../errors\").codes.ERR_INVALID_OPT_VALUE;e.exports={getHighWaterMark:function(t,e,r,n){var a=function(t,e,r){return null!=t.highWaterMark?t.highWaterMark:e?t[r]:null}(e,n,r);if(null!=a){if(!isFinite(a)||Math.floor(a)!==a||a<0)throw new i(n?r:\"highWaterMark\",a);return Math.floor(a)}return t.objectMode?16:16384}}},{\"../../../errors\":62}],75:[function(t,e,r){e.exports=t(\"events\").EventEmitter},{events:38}],76:[function(t,e,r){\"use strict\";var i=t(\"safe-buffer\").Buffer,n=i.isEncoding||function(t){switch((t=\"\"+t)&&t.toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":case\"raw\":return!0;default:return!1}};function a(t){var e;switch(this.encoding=function(t){var e=function(t){if(!t)return\"utf8\";for(var e;;)switch(t){case\"utf8\":case\"utf-8\":return\"utf8\";case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return\"utf16le\";case\"latin1\":case\"binary\":return\"latin1\";case\"base64\":case\"ascii\":case\"hex\":return t;default:if(e)return;t=(\"\"+t).toLowerCase(),e=!0}}(t);if(\"string\"!=typeof e&&(i.isEncoding===n||!n(t)))throw new Error(\"Unknown encoding: \"+t);return e||t}(t),this.encoding){case\"utf16le\":this.text=h,this.end=l,e=4;break;case\"utf8\":this.fillLast=s,e=4;break;case\"base64\":this.text=f,this.end=u,e=3;break;default:return this.write=c,void(this.end=d)}this.lastNeed=0,this.lastTotal=0,this.lastChar=i.allocUnsafe(e)}function o(t){return t<=127?0:t>>5==6?2:t>>4==14?3:t>>3==30?4:t>>6==2?-1:-2}function s(t){var e=this.lastTotal-this.lastNeed,r=function(t,e,r){if(128!=(192&e[0]))return t.lastNeed=0,\"\";if(t.lastNeed>1&&e.length>1){if(128!=(192&e[1]))return t.lastNeed=1,\"\";if(t.lastNeed>2&&e.length>2&&128!=(192&e[2]))return t.lastNeed=2,\"\"}}(this,t);return void 0!==r?r:this.lastNeed<=t.length?(t.copy(this.lastChar,e,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(t.copy(this.lastChar,e,0,t.length),void(this.lastNeed-=t.length))}function h(t,e){if((t.length-e)%2==0){var r=t.toString(\"utf16le\",e);if(r){var i=r.charCodeAt(r.length-1);if(i>=55296&&i<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=t[t.length-1],t.toString(\"utf16le\",e,t.length-1)}function l(t){var e=t&&t.length?this.write(t):\"\";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return e+this.lastChar.toString(\"utf16le\",0,r)}return e}function f(t,e){var r=(t.length-e)%3;return 0===r?t.toString(\"base64\",e):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=t[t.length-1]:(this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1]),t.toString(\"base64\",e,t.length-r))}function u(t){var e=t&&t.length?this.write(t):\"\";return this.lastNeed?e+this.lastChar.toString(\"base64\",0,3-this.lastNeed):e}function c(t){return t.toString(this.encoding)}function d(t){return t&&t.length?this.write(t):\"\"}r.StringDecoder=a,a.prototype.write=function(t){if(0===t.length)return\"\";var e,r;if(this.lastNeed){if(void 0===(e=this.fillLast(t)))return\"\";r=this.lastNeed,this.lastNeed=0}else r=0;return r<t.length?e?e+this.text(t,r):this.text(t,r):e||\"\"},a.prototype.end=function(t){var e=t&&t.length?this.write(t):\"\";return this.lastNeed?e+\"\":e},a.prototype.text=function(t,e){var r=function(t,e,r){var i=e.length-1;if(i<r)return 0;var n=o(e[i]);return n>=0?(n>0&&(t.lastNeed=n-1),n):--i<r||-2===n?0:(n=o(e[i]))>=0?(n>0&&(t.lastNeed=n-2),n):--i<r||-2===n?0:(n=o(e[i]))>=0?(n>0&&(2===n?n=0:t.lastNeed=n-3),n):0}(this,t,e);if(!this.lastNeed)return t.toString(\"utf8\",e);this.lastTotal=r;var i=t.length-(r-this.lastNeed);return t.copy(this.lastChar,0,i),t.toString(\"utf8\",e,i)},a.prototype.fillLast=function(t){if(this.lastNeed<=t.length)return t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,t.length),this.lastNeed-=t.length}},{\"safe-buffer\":77}],77:[function(t,e,r){var i=t(\"buffer\"),n=i.Buffer;function a(t,e){for(var r in t)e[r]=t[r]}function o(t,e,r){return n(t,e,r)}n.from&&n.alloc&&n.allocUnsafe&&n.allocUnsafeSlow?e.exports=i:(a(i,r),r.Buffer=o),o.prototype=Object.create(n.prototype),a(n,o),o.from=function(t,e,r){if(\"number\"==typeof t)throw new TypeError(\"Argument must not be a number\");return n(t,e,r)},o.alloc=function(t,e,r){if(\"number\"!=typeof t)throw new TypeError(\"Argument must be a number\");var i=n(t);return void 0!==e?\"string\"==typeof r?i.fill(e,r):i.fill(e):i.fill(0),i},o.allocUnsafe=function(t){if(\"number\"!=typeof t)throw new TypeError(\"Argument must be a number\");return n(t)},o.allocUnsafeSlow=function(t){if(\"number\"!=typeof t)throw new TypeError(\"Argument must be a number\");return i.SlowBuffer(t)}},{buffer:33}],78:[function(t,e,i){(function(t){(function(){function r(e){try{if(!t.localStorage)return!1}catch(t){return!1}var r=t.localStorage[e];return null!=r&&\"true\"===String(r).toLowerCase()}e.exports=function(t,e){if(r(\"noDeprecation\"))return t;var i=!1;return function(){if(!i){if(r(\"throwDeprecation\"))throw new Error(e);r(\"traceDeprecation\")?console.trace(e):console.warn(e),i=!0}return t.apply(this,arguments)}}}).call(this)}).call(this,void 0!==r.g?r.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],79:[function(t,e,r){arguments[4][25][0].apply(r,arguments)},{dup:25}],80:[function(t,e,r){\"use strict\";var i=t(\"is-arguments\"),n=t(\"is-generator-function\"),a=t(\"which-typed-array\"),o=t(\"is-typed-array\");function s(t){return t.call.bind(t)}var h=\"undefined\"!=typeof BigInt,l=\"undefined\"!=typeof Symbol,f=s(Object.prototype.toString),u=s(Number.prototype.valueOf),c=s(String.prototype.valueOf),d=s(Boolean.prototype.valueOf);if(h)var p=s(BigInt.prototype.valueOf);if(l)var m=s(Symbol.prototype.valueOf);function g(t,e){if(\"object\"!=typeof t)return!1;try{return e(t),!0}catch(t){return!1}}function b(t){return\"[object Map]\"===f(t)}function _(t){return\"[object Set]\"===f(t)}function y(t){return\"[object WeakMap]\"===f(t)}function w(t){return\"[object WeakSet]\"===f(t)}function v(t){return\"[object ArrayBuffer]\"===f(t)}function x(t){return\"undefined\"!=typeof ArrayBuffer&&(v.working?v(t):t instanceof ArrayBuffer)}function E(t){return\"[object DataView]\"===f(t)}function k(t){return\"undefined\"!=typeof DataView&&(E.working?E(t):t instanceof DataView)}function S(t){return\"[object SharedArrayBuffer]\"===f(t)}function M(t){return\"undefined\"!=typeof SharedArrayBuffer&&(S.working?S(t):t instanceof SharedArrayBuffer)}function A(t){return g(t,u)}function I(t){return g(t,c)}function B(t){return g(t,d)}function T(t){return h&&g(t,p)}function R(t){return l&&g(t,m)}r.isArgumentsObject=i,r.isGeneratorFunction=n,r.isTypedArray=o,r.isPromise=function(t){return\"undefined\"!=typeof Promise&&t instanceof Promise||null!==t&&\"object\"==typeof t&&\"function\"==typeof t.then&&\"function\"==typeof t.catch},r.isArrayBufferView=function(t){return\"undefined\"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(t):o(t)||k(t)},r.isUint8Array=function(t){return\"Uint8Array\"===a(t)},r.isUint8ClampedArray=function(t){return\"Uint8ClampedArray\"===a(t)},r.isUint16Array=function(t){return\"Uint16Array\"===a(t)},r.isUint32Array=function(t){return\"Uint32Array\"===a(t)},r.isInt8Array=function(t){return\"Int8Array\"===a(t)},r.isInt16Array=function(t){return\"Int16Array\"===a(t)},r.isInt32Array=function(t){return\"Int32Array\"===a(t)},r.isFloat32Array=function(t){return\"Float32Array\"===a(t)},r.isFloat64Array=function(t){return\"Float64Array\"===a(t)},r.isBigInt64Array=function(t){return\"BigInt64Array\"===a(t)},r.isBigUint64Array=function(t){return\"BigUint64Array\"===a(t)},b.working=\"undefined\"!=typeof Map&&b(new Map),r.isMap=function(t){return\"undefined\"!=typeof Map&&(b.working?b(t):t instanceof Map)},_.working=\"undefined\"!=typeof Set&&_(new Set),r.isSet=function(t){return\"undefined\"!=typeof Set&&(_.working?_(t):t instanceof Set)},y.working=\"undefined\"!=typeof WeakMap&&y(new WeakMap),r.isWeakMap=function(t){return\"undefined\"!=typeof WeakMap&&(y.working?y(t):t instanceof WeakMap)},w.working=\"undefined\"!=typeof WeakSet&&w(new WeakSet),r.isWeakSet=function(t){return w(t)},v.working=\"undefined\"!=typeof ArrayBuffer&&v(new ArrayBuffer),r.isArrayBuffer=x,E.working=\"undefined\"!=typeof ArrayBuffer&&\"undefined\"!=typeof DataView&&E(new DataView(new ArrayBuffer(1),0,1)),r.isDataView=k,S.working=\"undefined\"!=typeof SharedArrayBuffer&&S(new SharedArrayBuffer),r.isSharedArrayBuffer=M,r.isAsyncFunction=function(t){return\"[object AsyncFunction]\"===f(t)},r.isMapIterator=function(t){return\"[object Map Iterator]\"===f(t)},r.isSetIterator=function(t){return\"[object Set Iterator]\"===f(t)},r.isGeneratorObject=function(t){return\"[object Generator]\"===f(t)},r.isWebAssemblyCompiledModule=function(t){return\"[object WebAssembly.Module]\"===f(t)},r.isNumberObject=A,r.isStringObject=I,r.isBooleanObject=B,r.isBigIntObject=T,r.isSymbolObject=R,r.isBoxedPrimitive=function(t){return A(t)||I(t)||B(t)||T(t)||R(t)},r.isAnyArrayBuffer=function(t){return\"undefined\"!=typeof Uint8Array&&(x(t)||M(t))},[\"isProxy\",\"isExternal\",\"isModuleNamespaceObject\"].forEach((function(t){Object.defineProperty(r,t,{enumerable:!1,value:function(){throw new Error(t+\" is not supported in userland\")}})}))},{\"is-arguments\":46,\"is-generator-function\":47,\"is-typed-array\":48,\"which-typed-array\":82}],81:[function(t,e,r){(function(e){(function(){var i=Object.getOwnPropertyDescriptors||function(t){for(var e=Object.keys(t),r={},i=0;i<e.length;i++)r[e[i]]=Object.getOwnPropertyDescriptor(t,e[i]);return r},n=/%[sdj%]/g;r.format=function(t){if(!_(t)){for(var e=[],r=0;r<arguments.length;r++)e.push(h(arguments[r]));return e.join(\" \")}r=1;for(var i=arguments,a=i.length,o=String(t).replace(n,(function(t){if(\"%%\"===t)return\"%\";if(r>=a)return t;switch(t){case\"%s\":return String(i[r++]);case\"%d\":return Number(i[r++]);case\"%j\":try{return JSON.stringify(i[r++])}catch(t){return\"[Circular]\"}default:return t}})),s=i[r];r<a;s=i[++r])g(s)||!v(s)?o+=\" \"+s:o+=\" \"+h(s);return o},r.deprecate=function(t,i){if(void 0!==e&&!0===e.noDeprecation)return t;if(void 0===e)return function(){return r.deprecate(t,i).apply(this,arguments)};var n=!1;return function(){if(!n){if(e.throwDeprecation)throw new Error(i);e.traceDeprecation?console.trace(i):console.error(i),n=!0}return t.apply(this,arguments)}};var a={},o=/^$/;if(e.env.NODE_DEBUG){var s=e.env.NODE_DEBUG;s=s.replace(/[|\\\\{}()[\\]^$+?.]/g,\"\\\\$&\").replace(/\\*/g,\".*\").replace(/,/g,\"$|^\").toUpperCase(),o=new RegExp(\"^\"+s+\"$\",\"i\")}function h(t,e){var i={seen:[],stylize:f};return arguments.length>=3&&(i.depth=arguments[2]),arguments.length>=4&&(i.colors=arguments[3]),m(e)?i.showHidden=e:e&&r._extend(i,e),y(i.showHidden)&&(i.showHidden=!1),y(i.depth)&&(i.depth=2),y(i.colors)&&(i.colors=!1),y(i.customInspect)&&(i.customInspect=!0),i.colors&&(i.stylize=l),u(i,t,i.depth)}function l(t,e){var r=h.styles[e];return r?\"\u001b[\"+h.colors[r][0]+\"m\"+t+\"\u001b[\"+h.colors[r][1]+\"m\":t}function f(t,e){return t}function u(t,e,i){if(t.customInspect&&e&&k(e.inspect)&&e.inspect!==r.inspect&&(!e.constructor||e.constructor.prototype!==e)){var n=e.inspect(i,t);return _(n)||(n=u(t,n,i)),n}var a=function(t,e){if(y(e))return t.stylize(\"undefined\",\"undefined\");if(_(e)){var r=\"'\"+JSON.stringify(e).replace(/^\"|\"$/g,\"\").replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"')+\"'\";return t.stylize(r,\"string\")}return b(e)?t.stylize(\"\"+e,\"number\"):m(e)?t.stylize(\"\"+e,\"boolean\"):g(e)?t.stylize(\"null\",\"null\"):void 0}(t,e);if(a)return a;var o=Object.keys(e),s=function(t){var e={};return t.forEach((function(t,r){e[t]=!0})),e}(o);if(t.showHidden&&(o=Object.getOwnPropertyNames(e)),E(e)&&(o.indexOf(\"message\")>=0||o.indexOf(\"description\")>=0))return c(e);if(0===o.length){if(k(e)){var h=e.name?\": \"+e.name:\"\";return t.stylize(\"[Function\"+h+\"]\",\"special\")}if(w(e))return t.stylize(RegExp.prototype.toString.call(e),\"regexp\");if(x(e))return t.stylize(Date.prototype.toString.call(e),\"date\");if(E(e))return c(e)}var l,f=\"\",v=!1,S=[\"{\",\"}\"];return p(e)&&(v=!0,S=[\"[\",\"]\"]),k(e)&&(f=\" [Function\"+(e.name?\": \"+e.name:\"\")+\"]\"),w(e)&&(f=\" \"+RegExp.prototype.toString.call(e)),x(e)&&(f=\" \"+Date.prototype.toUTCString.call(e)),E(e)&&(f=\" \"+c(e)),0!==o.length||v&&0!=e.length?i<0?w(e)?t.stylize(RegExp.prototype.toString.call(e),\"regexp\"):t.stylize(\"[Object]\",\"special\"):(t.seen.push(e),l=v?function(t,e,r,i,n){for(var a=[],o=0,s=e.length;o<s;++o)I(e,String(o))?a.push(d(t,e,r,i,String(o),!0)):a.push(\"\");return n.forEach((function(n){n.match(/^\\d+$/)||a.push(d(t,e,r,i,n,!0))})),a}(t,e,i,s,o):o.map((function(r){return d(t,e,i,s,r,v)})),t.seen.pop(),function(t,e,r){return t.reduce((function(t,e){return e.indexOf(\"\\n\"),t+e.replace(/\\u001b\\[\\d\\d?m/g,\"\").length+1}),0)>60?r[0]+(\"\"===e?\"\":e+\"\\n \")+\" \"+t.join(\",\\n  \")+\" \"+r[1]:r[0]+e+\" \"+t.join(\", \")+\" \"+r[1]}(l,f,S)):S[0]+f+S[1]}function c(t){return\"[\"+Error.prototype.toString.call(t)+\"]\"}function d(t,e,r,i,n,a){var o,s,h;if((h=Object.getOwnPropertyDescriptor(e,n)||{value:e[n]}).get?s=h.set?t.stylize(\"[Getter/Setter]\",\"special\"):t.stylize(\"[Getter]\",\"special\"):h.set&&(s=t.stylize(\"[Setter]\",\"special\")),I(i,n)||(o=\"[\"+n+\"]\"),s||(t.seen.indexOf(h.value)<0?(s=g(r)?u(t,h.value,null):u(t,h.value,r-1)).indexOf(\"\\n\")>-1&&(s=a?s.split(\"\\n\").map((function(t){return\"  \"+t})).join(\"\\n\").substr(2):\"\\n\"+s.split(\"\\n\").map((function(t){return\"   \"+t})).join(\"\\n\")):s=t.stylize(\"[Circular]\",\"special\")),y(o)){if(a&&n.match(/^\\d+$/))return s;(o=JSON.stringify(\"\"+n)).match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)?(o=o.substr(1,o.length-2),o=t.stylize(o,\"name\")):(o=o.replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"').replace(/(^\"|\"$)/g,\"'\"),o=t.stylize(o,\"string\"))}return o+\": \"+s}function p(t){return Array.isArray(t)}function m(t){return\"boolean\"==typeof t}function g(t){return null===t}function b(t){return\"number\"==typeof t}function _(t){return\"string\"==typeof t}function y(t){return void 0===t}function w(t){return v(t)&&\"[object RegExp]\"===S(t)}function v(t){return\"object\"==typeof t&&null!==t}function x(t){return v(t)&&\"[object Date]\"===S(t)}function E(t){return v(t)&&(\"[object Error]\"===S(t)||t instanceof Error)}function k(t){return\"function\"==typeof t}function S(t){return Object.prototype.toString.call(t)}function M(t){return t<10?\"0\"+t.toString(10):t.toString(10)}r.debuglog=function(t){if(t=t.toUpperCase(),!a[t])if(o.test(t)){var i=e.pid;a[t]=function(){var e=r.format.apply(r,arguments);console.error(\"%s %d: %s\",t,i,e)}}else a[t]=function(){};return a[t]},r.inspect=h,h.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},h.styles={special:\"cyan\",number:\"yellow\",boolean:\"yellow\",undefined:\"grey\",null:\"bold\",string:\"green\",date:\"magenta\",regexp:\"red\"},r.types=t(\"./support/types\"),r.isArray=p,r.isBoolean=m,r.isNull=g,r.isNullOrUndefined=function(t){return null==t},r.isNumber=b,r.isString=_,r.isSymbol=function(t){return\"symbol\"==typeof t},r.isUndefined=y,r.isRegExp=w,r.types.isRegExp=w,r.isObject=v,r.isDate=x,r.types.isDate=x,r.isError=E,r.types.isNativeError=E,r.isFunction=k,r.isPrimitive=function(t){return null===t||\"boolean\"==typeof t||\"number\"==typeof t||\"string\"==typeof t||\"symbol\"==typeof t||void 0===t},r.isBuffer=t(\"./support/isBuffer\");var A=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"];function I(t,e){return Object.prototype.hasOwnProperty.call(t,e)}r.log=function(){var t,e;console.log(\"%s - %s\",(t=new Date,e=[M(t.getHours()),M(t.getMinutes()),M(t.getSeconds())].join(\":\"),[t.getDate(),A[t.getMonth()],e].join(\" \")),r.format.apply(r,arguments))},r.inherits=t(\"inherits\"),r._extend=function(t,e){if(!e||!v(e))return t;for(var r=Object.keys(e),i=r.length;i--;)t[r[i]]=e[r[i]];return t};var B=\"undefined\"!=typeof Symbol?Symbol(\"util.promisify.custom\"):void 0;function T(t,e){if(!t){var r=new Error(\"Promise was rejected with a falsy value\");r.reason=t,t=r}return e(t)}r.promisify=function(t){if(\"function\"!=typeof t)throw new TypeError('The \"original\" argument must be of type Function');if(B&&t[B]){var e;if(\"function\"!=typeof(e=t[B]))throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');return Object.defineProperty(e,B,{value:e,enumerable:!1,writable:!1,configurable:!0}),e}function e(){for(var e,r,i=new Promise((function(t,i){e=t,r=i})),n=[],a=0;a<arguments.length;a++)n.push(arguments[a]);n.push((function(t,i){t?r(t):e(i)}));try{t.apply(this,n)}catch(t){r(t)}return i}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),B&&Object.defineProperty(e,B,{value:e,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(e,i(t))},r.promisify.custom=B,r.callbackify=function(t){if(\"function\"!=typeof t)throw new TypeError('The \"original\" argument must be of type Function');function r(){for(var r=[],i=0;i<arguments.length;i++)r.push(arguments[i]);var n=r.pop();if(\"function\"!=typeof n)throw new TypeError(\"The last argument must be of type Function\");var a=this,o=function(){return n.apply(a,arguments)};t.apply(this,r).then((function(t){e.nextTick(o.bind(null,null,t))}),(function(t){e.nextTick(T.bind(null,t,o))}))}return Object.setPrototypeOf(r,Object.getPrototypeOf(t)),Object.defineProperties(r,i(t)),r}}).call(this)}).call(this,t(\"_process\"))},{\"./support/isBuffer\":79,\"./support/types\":80,_process:60,inherits:45}],82:[function(t,e,i){(function(r){(function(){\"use strict\";var i=t(\"foreach\"),n=t(\"available-typed-arrays\"),a=t(\"es-abstract/helpers/callBound\"),o=a(\"Object.prototype.toString\"),s=t(\"has-symbols\")()&&\"symbol\"==typeof Symbol.toStringTag,h=n(),l=a(\"String.prototype.slice\"),f={},u=t(\"es-abstract/helpers/getOwnPropertyDescriptor\"),c=Object.getPrototypeOf;s&&u&&c&&i(h,(function(t){if(\"function\"==typeof r[t]){var e=new r[t];if(!(Symbol.toStringTag in e))throw new EvalError(\"this engine has support for Symbol.toStringTag, but \"+t+\" does not have the property! Please report this.\");var i=c(e),n=u(i,Symbol.toStringTag);if(!n){var a=c(i);n=u(a,Symbol.toStringTag)}f[t]=n.get}}));var d=t(\"is-typed-array\");e.exports=function(t){return!!d(t)&&(s?function(t){var e=!1;return i(f,(function(r,i){if(!e)try{var n=r.call(t);n===i&&(e=n)}catch(t){}})),e}(t):l(o(t),8,-1))}}).call(this)}).call(this,void 0!==r.g?r.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"available-typed-arrays\":27,\"es-abstract/helpers/callBound\":36,\"es-abstract/helpers/getOwnPropertyDescriptor\":37,foreach:39,\"has-symbols\":42,\"is-typed-array\":48}]},{},[20])(20)},4406:t=>{var e=t.exports={};e.nextTick=function(){var t=\"undefined\"!=typeof window&&window.setImmediate,e=\"undefined\"!=typeof window&&window.postMessage&&window.addEventListener;if(t)return function(t){return window.setImmediate(t)};if(e){var r=[];return window.addEventListener(\"message\",(function(t){var e=t.source;e!==window&&null!==e||\"process-tick\"!==t.data||(t.stopPropagation(),r.length>0&&r.shift()())}),!0),function(t){r.push(t),window.postMessage(\"process-tick\",\"*\")}}return function(t){setTimeout(t,0)}}(),e.title=\"browser\",e.browser=!0,e.env={},e.argv=[],e.binding=function(t){throw new Error(\"process.binding is not supported\")},e.cwd=function(){return\"/\"},e.chdir=function(t){throw new Error(\"process.chdir is not supported\")}},6197:(t,e,r)=>{\"use strict\";var i=r(8834).lW;Object.defineProperty(e,\"__esModule\",{value:!0}),e.AbstractTokenizer=void 0;const n=r(4644);e.AbstractTokenizer=class{constructor(t){this.position=0,this.numBuffer=new Uint8Array(8),this.fileInfo=t||{}}async readToken(t,e=this.position){const r=i.alloc(t.len);if(await this.readBuffer(r,{position:e})<t.len)throw new n.EndOfStreamError;return t.get(r,0)}async peekToken(t,e=this.position){const r=i.alloc(t.len);if(await this.peekBuffer(r,{position:e})<t.len)throw new n.EndOfStreamError;return t.get(r,0)}async readNumber(t){if(await this.readBuffer(this.numBuffer,{length:t.len})<t.len)throw new n.EndOfStreamError;return t.get(this.numBuffer,0)}async peekNumber(t){if(await this.peekBuffer(this.numBuffer,{length:t.len})<t.len)throw new n.EndOfStreamError;return t.get(this.numBuffer,0)}async ignore(t){if(void 0!==this.fileInfo.size){const e=this.fileInfo.size-this.position;if(t>e)return this.position+=e,e}return this.position+=t,t}async close(){}normalizeOptions(t,e){if(e&&void 0!==e.position&&e.position<this.position)throw new Error(\"`options.position` must be equal or greater than `tokenizer.position`\");return e?{mayBeLess:!0===e.mayBeLess,offset:e.offset?e.offset:0,length:e.length?e.length:t.length-(e.offset?e.offset:0),position:e.position?e.position:this.position}:{mayBeLess:!1,offset:0,length:t.length,position:this.position}}}},932:(t,e,r)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.BufferTokenizer=void 0;const i=r(4644),n=r(6197);class a extends n.AbstractTokenizer{constructor(t,e){super(e),this.uint8Array=t,this.fileInfo.size=this.fileInfo.size?this.fileInfo.size:t.length}async readBuffer(t,e){if(e&&e.position){if(e.position<this.position)throw new Error(\"`options.position` must be equal or greater than `tokenizer.position`\");this.position=e.position}const r=await this.peekBuffer(t,e);return this.position+=r,r}async peekBuffer(t,e){const r=this.normalizeOptions(t,e),n=Math.min(this.uint8Array.length-r.position,r.length);if(!r.mayBeLess&&n<r.length)throw new i.EndOfStreamError;return t.set(this.uint8Array.subarray(r.position,r.position+n),r.offset),n}async close(){}}e.BufferTokenizer=a},9425:(t,e,r)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.fromFile=e.FileTokenizer=void 0;const i=r(6197),n=r(4644),a=r(5187);class o extends i.AbstractTokenizer{constructor(t,e){super(e),this.fd=t}async readBuffer(t,e){const r=this.normalizeOptions(t,e);this.position=r.position;const i=await a.read(this.fd,t,r.offset,r.length,r.position);if(this.position+=i.bytesRead,i.bytesRead<r.length&&(!e||!e.mayBeLess))throw new n.EndOfStreamError;return i.bytesRead}async peekBuffer(t,e){const r=this.normalizeOptions(t,e),i=await a.read(this.fd,t,r.offset,r.length,r.position);if(!r.mayBeLess&&i.bytesRead<r.length)throw new n.EndOfStreamError;return i.bytesRead}async close(){return a.close(this.fd)}}e.FileTokenizer=o,e.fromFile=async function(t){const e=await a.stat(t);if(!e.isFile)throw new Error(`File not a file: ${t}`);const r=await a.open(t,\"r\");return new o(r,{path:t,size:e.size})}},5187:(t,e,r)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.readFile=e.writeFileSync=e.writeFile=e.read=e.open=e.close=e.stat=e.createReadStream=e.pathExists=void 0;const i=r(6777);e.pathExists=i.existsSync,e.createReadStream=i.createReadStream,e.stat=async function(t){return new Promise(((e,r)=>{i.stat(t,((t,i)=>{t?r(t):e(i)}))}))},e.close=async function(t){return new Promise(((e,r)=>{i.close(t,(t=>{t?r(t):e()}))}))},e.open=async function(t,e){return new Promise(((r,n)=>{i.open(t,e,((t,e)=>{t?n(t):r(e)}))}))},e.read=async function(t,e,r,n,a){return new Promise(((o,s)=>{i.read(t,e,r,n,a,((t,e,r)=>{t?s(t):o({bytesRead:e,buffer:r})}))}))},e.writeFile=async function(t,e){return new Promise(((r,n)=>{i.writeFile(t,e,(t=>{t?n(t):r()}))}))},e.writeFileSync=function(t,e){i.writeFileSync(t,e)},e.readFile=async function(t){return new Promise(((e,r)=>{i.readFile(t,((t,i)=>{t?r(t):e(i)}))}))}},8286:(t,e,r)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.ReadStreamTokenizer=void 0;const i=r(6197),n=r(4644);class a extends i.AbstractTokenizer{constructor(t,e){super(e),this.streamReader=new n.StreamReader(t)}async getFileInfo(){return this.fileInfo}async readBuffer(t,e){const r=this.normalizeOptions(t,e),i=r.position-this.position;if(i>0)return await this.ignore(i),this.readBuffer(t,e);if(i<0)throw new Error(\"`options.position` must be equal or greater than `tokenizer.position`\");if(0===r.length)return 0;const a=await this.streamReader.read(t,r.offset,r.length);if(this.position+=a,(!e||!e.mayBeLess)&&a<r.length)throw new n.EndOfStreamError;return a}async peekBuffer(t,e){const r=this.normalizeOptions(t,e);let i=0;if(r.position){const e=r.position-this.position;if(e>0){const n=new Uint8Array(r.length+e);return i=await this.peekBuffer(n,{mayBeLess:r.mayBeLess}),t.set(n.subarray(e),r.offset),i-e}if(e<0)throw new Error(\"Cannot peek from a negative offset in a stream\")}if(r.length>0){try{i=await this.streamReader.peek(t,r.offset,r.length)}catch(t){if(e&&e.mayBeLess&&t instanceof n.EndOfStreamError)return 0;throw t}if(!r.mayBeLess&&i<r.length)throw new n.EndOfStreamError}return i}async ignore(t){const e=Math.min(256e3,t),r=new Uint8Array(e);let i=0;for(;i<t;){const n=t-i,a=await this.readBuffer(r,{length:Math.min(e,n)});if(a<0)return a;i+=a}return i}}e.ReadStreamTokenizer=a},7378:(t,e,r)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.fromBuffer=e.fromStream=e.EndOfStreamError=void 0;const i=r(8286),n=r(932);var a=r(4644);Object.defineProperty(e,\"EndOfStreamError\",{enumerable:!0,get:function(){return a.EndOfStreamError}}),e.fromStream=function(t,e){return e=e||{},new i.ReadStreamTokenizer(t,e)},e.fromBuffer=function(t,e){return new n.BufferTokenizer(t,e)}},3569:(t,e,r)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.fromStream=e.fromBuffer=e.EndOfStreamError=e.fromFile=void 0;const i=r(5187),n=r(7378);var a=r(9425);Object.defineProperty(e,\"fromFile\",{enumerable:!0,get:function(){return a.fromFile}});var o=r(7378);Object.defineProperty(e,\"EndOfStreamError\",{enumerable:!0,get:function(){return o.EndOfStreamError}}),Object.defineProperty(e,\"fromBuffer\",{enumerable:!0,get:function(){return o.fromBuffer}}),e.fromStream=async function(t,e){if(e=e||{},t.path){const r=await i.stat(t.path);e.path=t.path,e.size=r.size}return n.fromStream(t,e)}},643:(t,e)=>{\"use strict\";var r=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t};e.Ee=function(t,e,r,i,n,a){for(var o=arguments.length,h=Array(o>6?o-6:0),l=6;l<o;l++)h[l-6]=arguments[l];return h.length?s.call.apply(s,[null,!1,!0,t,e,r,i,n,a].concat(h)):s(!1,!0,t,e,r,i,n,a)};var i=\"INVALID_ARGS\";function n(t){throw new Error(t)}function a(t){var e=Object.keys(t);return Object.getOwnPropertySymbols?e.concat(Object.getOwnPropertySymbols(t)):e}function o(t){if(Array.isArray(t))return t.slice();for(var e=a(t),r={},i=0;i<e.length;i++){var n=e[i];r[n]=t[n]}return r}function s(t,e,r){var l=r;null==l&&n(i);for(var f=!1,u=arguments.length,c=Array(u>3?u-3:0),d=3;d<u;d++)c[d-3]=arguments[d];for(var p=0;p<c.length;p++){var m=c[p];if(null!=m){var g=a(m);if(g.length)for(var b=0;b<=g.length;b++){var _=g[b];if(!t||void 0===l[_]){var y=m[_];e&&h(l[_])&&h(y)&&(y=s(t,e,l[_],y)),void 0!==y&&y!==l[_]&&(f||(f=!0,l=o(l)),l[_]=y)}}}}return l}function h(t){var e=void 0===t?\"undefined\":r(t);return null!=t&&\"object\"===e}},5010:(t,e,r)=>{\"use strict\";var i=r(8834).lW;Object.defineProperty(e,\"__esModule\",{value:!0}),e.AnsiStringType=e.StringType=e.BufferType=e.Uint8ArrayType=e.IgnoreType=e.Float80_LE=e.Float80_BE=e.Float64_LE=e.Float64_BE=e.Float32_LE=e.Float32_BE=e.Float16_LE=e.Float16_BE=e.INT64_BE=e.UINT64_BE=e.INT64_LE=e.UINT64_LE=e.INT32_LE=e.INT32_BE=e.INT24_BE=e.INT24_LE=e.INT16_LE=e.INT16_BE=e.INT8=e.UINT32_BE=e.UINT32_LE=e.UINT24_BE=e.UINT24_LE=e.UINT16_BE=e.UINT16_LE=e.UINT8=void 0;const n=r(2333);function a(t){return new DataView(t.buffer,t.byteOffset)}e.UINT8={len:1,get:(t,e)=>a(t).getUint8(e),put:(t,e,r)=>(a(t).setUint8(e,r),e+1)},e.UINT16_LE={len:2,get:(t,e)=>a(t).getUint16(e,!0),put:(t,e,r)=>(a(t).setUint16(e,r,!0),e+2)},e.UINT16_BE={len:2,get:(t,e)=>a(t).getUint16(e),put:(t,e,r)=>(a(t).setUint16(e,r),e+2)},e.UINT24_LE={len:3,get(t,e){const r=a(t);return r.getUint8(e)+(r.getUint16(e+1,!0)<<8)},put(t,e,r){const i=a(t);return i.setUint8(e,255&r),i.setUint16(e+1,r>>8,!0),e+3}},e.UINT24_BE={len:3,get(t,e){const r=a(t);return(r.getUint16(e)<<8)+r.getUint8(e+2)},put(t,e,r){const i=a(t);return i.setUint16(e,r>>8),i.setUint8(e+2,255&r),e+3}},e.UINT32_LE={len:4,get:(t,e)=>a(t).getUint32(e,!0),put:(t,e,r)=>(a(t).setUint32(e,r,!0),e+4)},e.UINT32_BE={len:4,get:(t,e)=>a(t).getUint32(e),put:(t,e,r)=>(a(t).setUint32(e,r),e+4)},e.INT8={len:1,get:(t,e)=>a(t).getInt8(e),put:(t,e,r)=>(a(t).setInt8(e,r),e+1)},e.INT16_BE={len:2,get:(t,e)=>a(t).getInt16(e),put:(t,e,r)=>(a(t).setInt16(e,r),e+2)},e.INT16_LE={len:2,get:(t,e)=>a(t).getInt16(e,!0),put:(t,e,r)=>(a(t).setInt16(e,r,!0),e+2)},e.INT24_LE={len:3,get(t,r){const i=e.UINT24_LE.get(t,r);return i>8388607?i-16777216:i},put(t,e,r){const i=a(t);return i.setUint8(e,255&r),i.setUint16(e+1,r>>8,!0),e+3}},e.INT24_BE={len:3,get(t,r){const i=e.UINT24_BE.get(t,r);return i>8388607?i-16777216:i},put(t,e,r){const i=a(t);return i.setUint16(e,r>>8),i.setUint8(e+2,255&r),e+3}},e.INT32_BE={len:4,get:(t,e)=>a(t).getInt32(e),put:(t,e,r)=>(a(t).setInt32(e,r),e+4)},e.INT32_LE={len:4,get:(t,e)=>a(t).getInt32(e,!0),put:(t,e,r)=>(a(t).setInt32(e,r,!0),e+4)},e.UINT64_LE={len:8,get:(t,e)=>a(t).getBigUint64(e,!0),put:(t,e,r)=>(a(t).setBigUint64(e,r,!0),e+8)},e.INT64_LE={len:8,get:(t,e)=>a(t).getBigInt64(e,!0),put:(t,e,r)=>(a(t).setBigInt64(e,r,!0),e+8)},e.UINT64_BE={len:8,get:(t,e)=>a(t).getBigUint64(e),put:(t,e,r)=>(a(t).setBigUint64(e,r),e+8)},e.INT64_BE={len:8,get:(t,e)=>a(t).getBigInt64(e),put:(t,e,r)=>(a(t).setBigInt64(e,r),e+8)},e.Float16_BE={len:2,get(t,e){return n.read(t,e,!1,10,this.len)},put(t,e,r){return n.write(t,r,e,!1,10,this.len),e+this.len}},e.Float16_LE={len:2,get(t,e){return n.read(t,e,!0,10,this.len)},put(t,e,r){return n.write(t,r,e,!0,10,this.len),e+this.len}},e.Float32_BE={len:4,get:(t,e)=>a(t).getFloat32(e),put:(t,e,r)=>(a(t).setFloat32(e,r),e+4)},e.Float32_LE={len:4,get:(t,e)=>a(t).getFloat32(e,!0),put:(t,e,r)=>(a(t).setFloat32(e,r,!0),e+4)},e.Float64_BE={len:8,get:(t,e)=>a(t).getFloat64(e),put:(t,e,r)=>(a(t).setFloat64(e,r),e+8)},e.Float64_LE={len:8,get:(t,e)=>a(t).getFloat64(e,!0),put:(t,e,r)=>(a(t).setFloat64(e,r,!0),e+8)},e.Float80_BE={len:10,get(t,e){return n.read(t,e,!1,63,this.len)},put(t,e,r){return n.write(t,r,e,!1,63,this.len),e+this.len}},e.Float80_LE={len:10,get(t,e){return n.read(t,e,!0,63,this.len)},put(t,e,r){return n.write(t,r,e,!0,63,this.len),e+this.len}},e.IgnoreType=class{constructor(t){this.len=t}get(t,e){}},e.Uint8ArrayType=class{constructor(t){this.len=t}get(t,e){return t.subarray(e,e+this.len)}},e.BufferType=class{constructor(t){this.len=t}get(t,e){return i.from(t.subarray(e,e+this.len))}},e.StringType=class{constructor(t,e){this.len=t,this.encoding=e}get(t,e){return i.from(t).toString(this.encoding,e,e+this.len)}};class o{constructor(t){this.len=t}static decode(t,e,r){let i=\"\";for(let n=e;n<r;++n)i+=o.codePointToString(o.singleByteDecoder(t[n]));return i}static inRange(t,e,r){return e<=t&&t<=r}static codePointToString(t){return t<=65535?String.fromCharCode(t):(t-=65536,String.fromCharCode(55296+(t>>10),56320+(1023&t)))}static singleByteDecoder(t){if(o.inRange(t,0,127))return t;const e=o.windows1252[t-128];if(null===e)throw Error(\"invaliding encoding\");return e}get(t,e=0){return o.decode(t,e,e+this.len)}}e.AnsiStringType=o,o.windows1252=[8364,129,8218,402,8222,8230,8224,8225,710,8240,352,8249,338,141,381,143,144,8216,8217,8220,8221,8226,8211,8212,732,8482,353,8250,339,157,382,376,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]},311:(t,e)=>{(e=t.exports=function(t){return t.replace(/^\\s*|\\s*$/g,\"\")}).left=function(t){return t.replace(/^\\s*/,\"\")},e.right=function(t){return t.replace(/\\s*$/,\"\")}},9299:(t,e,r)=>{var i=r(4406);!function(){var e={};function n(){void 0===i&&console.log.apply(console,arguments)}t.exports=e,function(t,e){var r,i,a,o,s,h,l,f,u,c,d,p,m,g,b;!function(){\"use strict\";var e=function(){function t(t){this.message=\"JPEG error: \"+t}return t.prototype=new Error,t.prototype.name=\"JpegError\",t.constructor=t,t}(),r=function(){var t=new Uint8Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),r=4017,n=799,a=3406,o=2276,s=1567,h=3784,l=5793,f=2896;function u(t){null==t&&(t={}),null==t.w&&(t.w=-1),this.V=t.n,this.N=t.w}function c(t,e){for(var r,i,n,a=0,o=[],s=16;s>0&&!t[s-1];)s--;o.push({children:[],index:0});var h=o[0];for(r=0;r<s;r++){for(i=0;i<t[r];i++){for((h=o.pop()).children[h.index]=e[a];h.index>0;)h=o.pop();for(h.index++,o.push(h);o.length<=r;)o.push(n={children:[],index:0}),h.children[h.index]=n.children,h=n;a++}r+1<s&&(o.push(n={children:[],index:0}),h.children[h.index]=n.children,h=n)}return o[0].children}function d(t,e,r){return 64*((t.P+1)*e+r)}function p(r,n,a,o,s,h,l,f,u,c){null==c&&(c=!1);var p,m,g,_,y,w,v,x,E,k,S,M=a.m,A=a.Z,I=n,B=0,T=0,R=0,P=0,O=0,L=0;function C(){if(T>0)return T--,B>>T&1;if(255===(B=r[n++])){var t=r[n++];if(t){if(220===t&&c){var o=i(r,n+=2);if(n+=2,o>0&&o!==a.s)throw new DNLMarkerError(\"Found DNL marker (0xFFDC) while parsing scan data\",o)}else if(217===t){if(c){var s=8*O;if(s>0&&s<a.s/10)throw new DNLMarkerError(\"Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter\",s)}throw new EOIMarkerError(\"Found EOI marker (0xFFD9) while parsing scan data\")}throw new e(\"unexpected marker\")}}return T=7,B>>>7}function U(t){for(var r=t;;){switch(typeof(r=r[C()])){case\"number\":return r;case\"object\":continue}throw new e(\"invalid huffman sequence\")}}function z(t){for(var e=0;t>0;)e=e<<1|C(),t--;return e}function D(t){if(1===t)return 1===C()?1:-1;var e=z(t);return e>=1<<t-1?e:e+(-1<<t)+1}function N(t,e,r,i,n){var a=r%M;O=(r/M|0)*t.A+i;var o=a*t.h+n;e(t,d(t,O,o))}function F(t,e,r){O=r/t.P|0;var i=r%t.P;e(t,d(t,O,i))}var j=o.length;for(v=A?0===h?0===f?function(t,e){var r=U(t.J),i=0===r?0:D(r)<<u;t.D[e]=t.Q+=i}:function(t,e){t.D[e]|=C()<<u}:0===f?function(e,r){if(R>0)R--;else for(var i=h,n=l;i<=n;){var a=U(e.i),o=15&a,s=a>>4;if(0!==o){var f=t[i+=s];e.D[r+f]=D(o)*(1<<u),i++}else{if(s<15){R=z(s)+(1<<s)-1;break}i+=16}}}:function(r,i){for(var n,a,o=h,s=l,f=0;o<=s;){var c=i+t[o],d=r.D[c]<0?-1:1;switch(P){case 0:if(f=(a=U(r.i))>>4,0==(n=15&a))f<15?(R=z(f)+(1<<f),P=4):(f=16,P=1);else{if(1!==n)throw new e(\"invalid ACn encoding\");p=D(n),P=f?2:3}continue;case 1:case 2:r.D[c]?r.D[c]+=d*(C()<<u):0==--f&&(P=2===P?3:0);break;case 3:r.D[c]?r.D[c]+=d*(C()<<u):(r.D[c]=p<<u,P=0);break;case 4:r.D[c]&&(r.D[c]+=d*(C()<<u))}o++}4===P&&0==--R&&(P=0)}:function(e,r){var i=U(e.J),n=0===i?0:D(i),a=1;for(e.D[r]=e.Q+=n;a<64;){var o=U(e.i),s=15&o,h=o>>4;if(0!==s){var l=t[a+=h];e.D[r+l]=D(s),a++}else{if(h<15)break;a+=16}}},E=1===j?o[0].P*o[0].c:M*a.R;L<=E;){var G=s?Math.min(E-L,s):E;if(G>0){for(g=0;g<j;g++)o[g].Q=0;if(R=0,1===j)for(m=o[0],w=0;w<G;w++)F(m,v,L),L++;else for(w=0;w<G;w++){for(g=0;g<j;g++)for(k=(m=o[g]).h,S=m.A,_=0;_<S;_++)for(y=0;y<k;y++)N(m,v,L,_,y);L++}}if(T=0,!(x=b(r,n)))break;if(x.u&&(n=x.offset),!(x.M>=65488&&x.M<=65495))break;n+=2}return n-I}function m(t,i,u){var c,d,p,m,g,b,_,y,w,v,x,E,k,S,M,A,I,B=t.$,T=t.D;if(!B)throw new e(\"missing required Quantization Table.\");for(var R=0;R<64;R+=8)w=T[i+R],v=T[i+R+1],x=T[i+R+2],E=T[i+R+3],k=T[i+R+4],S=T[i+R+5],M=T[i+R+6],A=T[i+R+7],w*=B[R],0!=(v|x|E|k|S|M|A)?(v*=B[R+1],x*=B[R+2],E*=B[R+3],k*=B[R+4],S*=B[R+5],M*=B[R+6],A*=B[R+7],d=(c=(c=l*w+128>>8)+(d=l*k+128>>8)+1>>1)-d,I=(p=x)*h+(m=M)*s+128>>8,p=p*s-m*h+128>>8,_=(g=(g=f*(v-A)+128>>8)+(_=S<<4)+1>>1)-_,b=(y=(y=f*(v+A)+128>>8)+(b=E<<4)+1>>1)-b,m=(c=c+(m=I)+1>>1)-m,p=(d=d+p+1>>1)-p,I=g*o+y*a+2048>>12,g=g*a-y*o+2048>>12,y=I,I=b*n+_*r+2048>>12,b=b*r-_*n+2048>>12,_=I,u[R]=c+y,u[R+7]=c-y,u[R+1]=d+_,u[R+6]=d-_,u[R+2]=p+b,u[R+5]=p-b,u[R+3]=m+g,u[R+4]=m-g):(I=l*w+512>>10,u[R]=I,u[R+1]=I,u[R+2]=I,u[R+3]=I,u[R+4]=I,u[R+5]=I,u[R+6]=I,u[R+7]=I);for(var P=0;P<8;++P)w=u[P],0!=((v=u[P+8])|(x=u[P+16])|(E=u[P+24])|(k=u[P+32])|(S=u[P+40])|(M=u[P+48])|(A=u[P+56]))?(d=(c=4112+((c=l*w+2048>>12)+(d=l*k+2048>>12)+1>>1))-d,I=(p=x)*h+(m=M)*s+2048>>12,p=p*s-m*h+2048>>12,m=I,_=(g=(g=f*(v-A)+2048>>12)+(_=S)+1>>1)-_,b=(y=(y=f*(v+A)+2048>>12)+(b=E)+1>>1)-b,I=g*o+y*a+2048>>12,g=g*a-y*o+2048>>12,y=I,I=b*n+_*r+2048>>12,b=b*r-_*n+2048>>12,(w=(c=c+m+1>>1)+y)<16?w=0:w>=4080?w=255:w>>=4,(v=(d=d+p+1>>1)+(_=I))<16?v=0:v>=4080?v=255:v>>=4,(x=(p=d-p)+b)<16?x=0:x>=4080?x=255:x>>=4,(E=(m=c-m)+g)<16?E=0:E>=4080?E=255:E>>=4,(k=m-g)<16?k=0:k>=4080?k=255:k>>=4,(S=p-b)<16?S=0:S>=4080?S=255:S>>=4,(M=d-_)<16?M=0:M>=4080?M=255:M>>=4,(A=c-y)<16?A=0:A>=4080?A=255:A>>=4,T[i+P]=w,T[i+P+8]=v,T[i+P+16]=x,T[i+P+24]=E,T[i+P+32]=k,T[i+P+40]=S,T[i+P+48]=M,T[i+P+56]=A):(I=(I=l*w+8192>>14)<-2040?0:I>=2024?255:I+2056>>4,T[i+P]=I,T[i+P+8]=I,T[i+P+16]=I,T[i+P+24]=I,T[i+P+32]=I,T[i+P+40]=I,T[i+P+48]=I,T[i+P+56]=I)}function g(t,e){for(var r=e.P,i=e.c,n=new Int16Array(64),a=0;a<i;a++)for(var o=0;o<r;o++)m(e,d(e,a,o),n);return e.D}function b(t,e,r){null==r&&(r=e);var n=t.length-1,a=r<e?r:e;if(e>=n)return null;var o=i(t,e);if(o>=65472&&o<=65534)return{u:null,M:o,offset:e};for(var s=i(t,a);!(s>=65472&&s<=65534);){if(++a>=n)return null;s=i(t,a)}return{u:o.toString(16),M:s,offset:a}}return u.prototype={parse(r,n){null==n&&(n={});var a,o,s=n.F,h=0,l=null,f=null,u=0;function d(){var t=i(r,h),e=(h+=2)+t-2,n=b(r,e,h);n&&n.u&&(e=n.offset);var a=r.subarray(h,e);return h+=a.length,a}function m(t){for(var e=Math.ceil(t.o/8/t.X),r=Math.ceil(t.s/8/t.B),i=0;i<t.W.length;i++){G=t.W[i];var n=Math.ceil(Math.ceil(t.o/8)*G.h/t.X),a=Math.ceil(Math.ceil(t.s/8)*G.A/t.B),o=e*G.h,s=r*G.A*64*(o+1);G.D=new Int16Array(s),G.P=n,G.c=a}t.m=e,t.R=r}var _=[],y=[],w=[],v=i(r,h);if(h+=2,65496!==v)throw new e(\"SOI not found\");v=i(r,h),h+=2;t:for(;65497!==v;){var x,E,k;switch(v){case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var S=d();65504===v&&74===S[0]&&70===S[1]&&73===S[2]&&70===S[3]&&0===S[4]&&(l={version:{d:S[5],T:S[6]},K:S[7],j:S[8]<<8|S[9],H:S[10]<<8|S[11],S:S[12],I:S[13],C:S.subarray(14,14+3*S[12]*S[13])}),65518===v&&65===S[0]&&100===S[1]&&111===S[2]&&98===S[3]&&101===S[4]&&(f={version:S[5]<<8|S[6],k:S[7]<<8|S[8],q:S[9]<<8|S[10],a:S[11]});break;case 65499:for(var M=i(r,h)+(h+=2)-2;h<M;){var A=r[h++],I=new Uint16Array(64);if(A>>4==0)for(E=0;E<64;E++)I[t[E]]=r[h++];else{if(A>>4!=1)throw new e(\"DQT - invalid table spec\");for(E=0;E<64;E++)I[t[E]]=i(r,h),h+=2}_[15&A]=I}break;case 65472:case 65473:case 65474:if(a)throw new e(\"Only single frame JPEGs supported\");h+=2,(a={}).G=65473===v,a.Z=65474===v,a.precision=r[h++];var B,T=i(r,h),R=0,P=0;h+=2,a.s=s||T,a.o=i(r,h),h+=2,a.W=[],a._={};var O=r[h++];for(x=0;x<O;x++){B=r[h];var L=r[h+1]>>4,C=15&r[h+1];R<L&&(R=L),P<C&&(P=C);var U=r[h+2];k=a.W.push({h:L,A:C,L:U,$:null}),a._[B]=k-1,h+=3}a.X=R,a.B=P,m(a);break;case 65476:var z=i(r,h);for(h+=2,x=2;x<z;){var D=r[h++],N=new Uint8Array(16),F=0;for(E=0;E<16;E++,h++)F+=N[E]=r[h];var j=new Uint8Array(F);for(E=0;E<F;E++,h++)j[E]=r[h];x+=17+F,(D>>4==0?w:y)[15&D]=c(N,j)}break;case 65501:o=i(r,h+=2),h+=2;break;case 65498:var G,H=1==++u&&!s;h+=2;var W=r[h++],q=[];for(x=0;x<W;x++){var Z=r[h++],Y=a._[Z];(G=a.W[Y]).index=Z;var V=r[h++];G.J=w[V>>4],G.i=y[15&V],q.push(G)}var X=r[h++],J=r[h++],Q=r[h++];try{var K=p(r,h,a,q,o,X,J,Q>>4,15&Q,H);h+=K}catch(t){if(t instanceof DNLMarkerError)return this.parse(r,{F:t.s});if(t instanceof EOIMarkerError)break t;throw t}break;case 65500:h+=4;break;case 65535:255!==r[h]&&h--;break;default:var $=b(r,h-2,h-3);if($&&$.u){h=$.offset;break}if(h>=r.length-1)break t;throw new e(\"JpegImage.parse - unknown marker: \"+v.toString(16))}v=i(r,h),h+=2}for(this.width=a.o,this.height=a.s,this.g=l,this.b=f,this.W=[],x=0;x<a.W.length;x++){var tt=_[(G=a.W[x]).L];tt&&(G.$=tt),this.W.push({index:G.index,e:g(0,G),l:G.h/a.X,t:G.A/a.B,P:G.P,c:G.c})}this.p=this.W.length},Y(t,e,r){null==r&&(r=!1);var i,n,a,o,s,h,l,f,u,c,d,p,m=this.width/t,g=this.height/e,b=0,_=this.W.length,y=t*e*_,w=new Uint8ClampedArray(y),v=new Uint32Array(t),x=4294967288;for(l=0;l<_;l++){if(n=(i=this.W[l]).l*m,a=i.t*g,b=l,d=i.e,o=i.P+1<<3,n!==p){for(s=0;s<t;s++)f=0|s*n,v[s]=(f&x)<<3|7&f;p=n}for(h=0;h<e;h++)for(c=o*((f=0|h*a)&x)|(7&f)<<3,s=0;s<t;s++)w[b]=d[c+v[s]],b+=_}var E=this.V;if(r||4!==_||E||(E=new Int32Array([-256,255,-256,255,-256,255,-256,255])),E)for(l=0;l<y;)for(f=0,u=0;f<_;f++,l++,u+=2)w[l]=(w[l]*E[u]>>8)+E[u+1];return w},get f(){return this.b?!!this.b.a:3===this.p?0!==this.N&&(82!==this.W[0].index||71!==this.W[1].index||66!==this.W[2].index):1===this.N},z:function(t){for(var e,r,i,n=0,a=t.length;n<a;n+=3)e=t[n],r=t[n+1],i=t[n+2],t[n]=e-179.456+1.402*i,t[n+1]=e+135.459-.344*r-.714*i,t[n+2]=e-226.816+1.772*r;return t},O:function(t){for(var e,r,i,n,a=0,o=0,s=t.length;o<s;o+=4)e=t[o],r=t[o+1],i=t[o+2],n=t[o+3],t[a++]=r*(-660635669420364e-19*r+.000437130475926232*i-54080610064599e-18*e+.00048449797120281*n-.154362151871126)-122.67195406894+i*(-.000957964378445773*i+.000817076911346625*e-.00477271405408747*n+1.53380253221734)+e*(.000961250184130688*e-.00266257332283933*n+.48357088451265)+n*(-.000336197177618394*n+.484791561490776),t[a++]=107.268039397724+r*(219927104525741e-19*r-.000640992018297945*i+.000659397001245577*e+.000426105652938837*n-.176491792462875)+i*(-.000778269941513683*i+.00130872261408275*e+.000770482631801132*n-.151051492775562)+e*(.00126935368114843*e-.00265090189010898*n+.25802910206845)+n*(-.000318913117588328*n-.213742400323665),t[a++]=r*(-.000570115196973677*r-263409051004589e-19*i+.0020741088115012*e-.00288260236853442*n+.814272968359295)-20.810012546947+i*(-153496057440975e-19*i-.000132689043961446*e+.000560833691242812*n-.195152027534049)+e*(.00174418132927582*e-.00255243321439347*n+.116935020465145)+n*(-.000343531996510555*n+.24165260232407);return t.subarray(0,a)},r:function(t){for(var e,r,i,n=0,a=t.length;n<a;n+=4)e=t[n],r=t[n+1],i=t[n+2],t[n]=434.456-e-1.402*i,t[n+1]=119.541-e+.344*r+.714*i,t[n+2]=481.816-e-1.772*r;return t},U:function(t){for(var e,r,i,n,a=0,o=0,s=t.length;o<s;o+=4)e=t[o],r=t[o+1],i=t[o+2],n=t[o+3],t[a++]=255+e*(-6747147073602441e-20*e+.0008379262121013727*r+.0002894718188643294*i+.003264231057537806*n-1.1185611867203937)+r*(26374107616089405e-21*r-8626949158638572e-20*i-.0002748769067499491*n-.02155688794978967)+i*(-3878099212869363e-20*i-.0003267808279485286*n+.0686742238595345)-n*(.0003361971776183937*n+.7430659151342254),t[a++]=255+e*(.00013596372813588848*e+.000924537132573585*r+.00010567359618683593*i+.0004791864687436512*n-.3109689587515875)+r*(-.00023545346108370344*r+.0002702845253534714*i+.0020200308977307156*n-.7488052167015494)+i*(6834815998235662e-20*i+.00015168452363460973*n-.09751927774728933)-n*(.0003189131175883281*n+.7364883807733168),t[a++]=255+e*(13598650411385307e-21*e+.00012423956175490851*r+.0004751985097583589*i-36729317476630422e-22*n-.05562186980264034)+r*(.00016141380598724676*r+.0009692239130725186*i+.0007782692450036253*n-.44015232367526463)+i*(5.068882914068769e-7*i+.0017778369011375071*n-.7591454649749609)-n*(.0003435319965105553*n+.7063770186160144);return t.subarray(0,a)},getData:function(t){var r=t.width,i=t.height,n=t.forceRGB,a=t.isSourcePDF;if(this.p>4)throw new e(\"Unsupported color mode\");var o=this.Y(r,i,a);if(1===this.p&&n){for(var s=o.length,h=new Uint8ClampedArray(3*s),l=0,f=0;f<s;f++){var u=o[f];h[l++]=u,h[l++]=u,h[l++]=u}return h}if(3===this.p&&this.f)return this.z(o);if(4===this.p){if(this.f)return n?this.O(o):this.r(o);if(n)return this.U(o)}return o}},u}();function i(t,e){return t[e]<<8|t[e+1]}t.JpegDecoder=r}(),t.encodeImage=function(e,r,i,n){var a={t256:[r],t257:[i],t258:[8,8,8,8],t259:[1],t262:[2],t273:[1e3],t277:[4],t278:[i],t279:[r*i*4],t282:[[72,1]],t283:[[72,1]],t284:[1],t286:[[0,1]],t287:[[0,1]],t296:[1],t305:[\"Photopea (UTIF.js)\"],t338:[1]};if(n)for(var o in n)a[o]=n[o];var s=new Uint8Array(t.encode([a])),h=new Uint8Array(e),l=new Uint8Array(1e3+r*i*4);for(o=0;o<s.length;o++)l[o]=s[o];for(o=0;o<h.length;o++)l[1e3+o]=h[o];return l.buffer},t.encode=function(e){var r=new Uint8Array(2e4),i=4,n=t._binBE;r[0]=r[1]=77,n.writeUshort(r,2,42);var a=8;n.writeUint(r,i,a),i+=4;for(var o=0;o<e.length;o++){var s=t._writeIFD(n,t._types.basic,r,a,e[o]);a=s[1],o<e.length-1&&(0!=(3&a)&&(a+=4-(3&a)),n.writeUint(r,s[0],a))}return r.slice(0,a).buffer},t.decode=function(e,r){null==r&&(r={parseMN:!0,debug:!1});var i=new Uint8Array(e),a=0,o=t._binBE.readASCII(i,a,2);a+=2;var s=\"II\"==o?t._binLE:t._binBE;s.readUshort(i,a),a+=2;var h=s.readUint(i,a);a+=4;for(var l=[];;){var f=s.readUshort(i,h),u=s.readUshort(i,h+4);if(0!=f&&(u<1||13<u)){n(\"error in TIFF\");break}if(t._readIFD(s,i,h,l,0,r),0==(h=s.readUint(i,h+2+12*f)))break}return l},t.decodeImage=function(e,r,i){if(!r.data){var a=new Uint8Array(e),o=t._binBE.readASCII(a,0,2);if(null!=r.t256){r.isLE=\"II\"==o,r.width=r.t256[0],r.height=r.t257[0];var s,h=r.t259?r.t259[0]:1,l=r.t266?r.t266[0]:1;r.t284&&2==r.t284[0]&&n(\"PlanarConfiguration 2 should not be used!\"),7==h&&r.t258&&r.t258.length>3&&(r.t258=r.t258.slice(0,3)),s=r.t258?Math.min(32,r.t258[0])*r.t258.length:r.t277?r.t277[0]:1,1==h&&null!=r.t279&&r.t278&&32803==r.t262[0]&&(s=Math.round(8*r.t279[0]/(r.width*r.t278[0]))),r.t50885&&4==r.t50885[0]&&(s=3*r.t258[0]);var f=8*Math.ceil(r.width*s/8),u=r.t273;(null==u||r.t322)&&(u=r.t324);var c=r.t279;1==h&&1==u.length&&(c=[r.height*(f>>>3)]),(null==c||r.t322)&&(c=r.t325);var d=new Uint8Array(r.height*(f>>>3)),p=0;if(null!=r.t322){var m=r.t322[0],g=r.t323[0],b=Math.floor((r.width+m-1)/m),_=Math.floor((r.height+g-1)/g),y=new Uint8Array(0|Math.ceil(m*g*s/8));console.log(\"====\",b,_);for(var w=0;w<_;w++)for(var v=0;v<b;v++){var x=w*b+v;y.fill(0),t.decode._decompress(r,i,a,u[x],c[x],h,y,0,l),6==h?d=y:t._copyTile(y,0|Math.ceil(m*s/8),g,d,0|Math.ceil(r.width*s/8),r.height,0|Math.ceil(v*m*s/8),w*g)}p=8*d.length}else{var E=r.t278?r.t278[0]:r.height;for(E=Math.min(E,r.height),console.log(\"====\",r.width,E),x=0;x<u.length;x++)t.decode._decompress(r,i,a,u[x],c[x],h,d,0|Math.ceil(p/8),l),p+=f*E;p=Math.min(p,8*d.length)}r.data=new Uint8Array(d.buffer,0,0|Math.ceil(p/8))}}},t.decode._decompress=function(r,i,a,o,s,h,l,f,u){if(1==h)for(var c=0;c<s;c++)l[f+c]=a[o+c];else if(2==h)t.decode._decodeG2(a,o,s,l,f,r.width,u);else if(3==h)t.decode._decodeG3(a,o,s,l,f,r.width,u,!!r.t292&&1==(1&r.t292[0]));else if(4==h)t.decode._decodeG4(a,o,s,l,f,r.width,u);else if(5==h)t.decode._decodeLZW(a,o,s,l,f,8);else if(6==h)t.decode._decodeOldJPEG(r,a,o,s,l,f);else if(7==h||34892==h)t.decode._decodeNewJPEG(r,a,o,s,l,f);else if(8==h||32946==h)for(var d=new Uint8Array(a.buffer,o,s),p=e.inflate(d),m=0;m<p.length;m++)l[f+m]=p[m];else 9==h?t.decode._decodeVC5(a,o,s,l,f):32767==h?t.decode._decodeARW(r,a,o,s,l,f):32773==h?t.decode._decodePackBits(a,o,s,l,f):32809==h?t.decode._decodeThunder(a,o,s,l,f):34713==h?t.decode._decodeNikon(r,i,a,o,s,l,f):34676==h?t.decode._decodeLogLuv32(r,a,o,s,l,f):n(\"Unknown compression\",h);var g=r.t258?Math.min(32,r.t258[0]):1,b=r.t277?r.t277[0]:1,_=g*b>>>3,y=r.t278?r.t278[0]:r.height,w=Math.ceil(g*b*r.width/8);if(16==g&&!r.isLE&&null==r.t33422)for(var v=0;v<y;v++)for(var x=f+v*w,E=1;E<w;E+=2){var k=l[x+E];l[x+E]=l[x+E-1],l[x+E-1]=k}if(r.t317&&2==r.t317[0])for(v=0;v<y;v++){var S=f+v*w;if(16==g)for(c=_;c<w;c+=2){var M=(l[S+c+1]<<8|l[S+c])+(l[S+c-_+1]<<8|l[S+c-_]);l[S+c]=255&M,l[S+c+1]=M>>>8&255}else if(3==b)for(c=3;c<w;c+=3)l[S+c]=l[S+c]+l[S+c-3]&255,l[S+c+1]=l[S+c+1]+l[S+c-2]&255,l[S+c+2]=l[S+c+2]+l[S+c-1]&255;else for(c=_;c<w;c++)l[S+c]=l[S+c]+l[S+c-_]&255}},t.decode._decodeVC5=t.decode._decodeVC5=function(){var e,r,i,n=[1,0,1,0,2,2,1,1,3,7,1,2,5,25,1,3,6,48,1,4,6,54,1,5,7,111,1,8,7,99,1,6,7,105,12,0,7,107,1,7,8,209,20,0,8,212,1,9,8,220,1,10,9,393,1,11,9,394,32,0,9,416,1,12,9,427,1,13,10,887,1,18,10,784,1,14,10,790,1,15,10,835,60,0,10,852,1,16,10,885,1,17,11,1571,1,19,11,1668,1,20,11,1669,100,0,11,1707,1,21,11,1772,1,22,12,3547,1,29,12,3164,1,24,12,3166,1,25,12,3140,1,23,12,3413,1,26,12,3537,1,27,12,3539,1,28,13,7093,1,35,13,6283,1,30,13,6331,1,31,13,6335,180,0,13,6824,1,32,13,7072,1,33,13,7077,320,0,13,7076,1,34,14,12565,1,36,14,12661,1,37,14,12669,1,38,14,13651,1,39,14,14184,1,40,15,28295,1,46,15,28371,1,47,15,25320,1,42,15,25336,1,43,15,25128,1,41,15,27300,1,44,15,28293,1,45,16,50259,1,48,16,50643,1,49,16,50675,1,50,16,56740,1,53,16,56584,1,51,16,56588,1,52,17,113483,1,61,17,113482,1,60,17,101285,1,55,17,101349,1,56,17,109205,1,57,17,109207,1,58,17,100516,1,54,17,113171,1,59,18,202568,1,62,18,202696,1,63,18,218408,1,64,18,218412,1,65,18,226340,1,66,18,226356,1,67,18,226358,1,68,19,402068,1,69,19,405138,1,70,19,405394,1,71,19,436818,1,72,19,436826,1,73,19,452714,1,75,19,452718,1,76,19,452682,1,74,20,804138,1,77,20,810279,1,78,20,810790,1,79,20,873638,1,80,20,873654,1,81,20,905366,1,82,20,905430,1,83,20,905438,1,84,21,1608278,1,85,21,1620557,1,86,21,1621582,1,87,21,1621583,1,88,21,1747310,1,89,21,1810734,1,90,21,1810735,1,91,21,1810863,1,92,21,1810879,1,93,22,3621725,1,99,22,3621757,1,100,22,3241112,1,94,22,3494556,1,95,22,3494557,1,96,22,3494622,1,97,22,3494623,1,98,23,6482227,1,102,23,6433117,1,101,23,6989117,1,103,23,6989119,1,105,23,6989118,1,104,23,7243449,1,106,23,7243512,1,107,24,13978233,1,111,24,12964453,1,109,24,12866232,1,108,24,14486897,1,113,24,13978232,1,110,24,14486896,1,112,24,14487026,1,114,24,14487027,1,115,25,25732598,1,225,25,25732597,1,189,25,25732596,1,188,25,25732595,1,203,25,25732594,1,202,25,25732593,1,197,25,25732592,1,207,25,25732591,1,169,25,25732590,1,223,25,25732589,1,159,25,25732522,1,235,25,25732579,1,152,25,25732575,1,192,25,25732489,1,179,25,25732573,1,201,25,25732472,1,172,25,25732576,1,149,25,25732488,1,178,25,25732566,1,120,25,25732571,1,219,25,25732577,1,150,25,25732487,1,127,25,25732506,1,211,25,25732548,1,125,25,25732588,1,158,25,25732486,1,247,25,25732467,1,238,25,25732508,1,163,25,25732552,1,228,25,25732603,1,183,25,25732513,1,217,25,25732587,1,168,25,25732520,1,122,25,25732484,1,128,25,25732562,1,249,25,25732505,1,187,25,25732504,1,186,25,25732483,1,136,25,25928905,1,181,25,25732560,1,255,25,25732500,1,230,25,25732482,1,135,25,25732555,1,233,25,25732568,1,222,25,25732583,1,145,25,25732481,1,134,25,25732586,1,167,25,25732521,1,248,25,25732518,1,209,25,25732480,1,243,25,25732512,1,216,25,25732509,1,164,25,25732547,1,140,25,25732479,1,157,25,25732544,1,239,25,25732574,1,191,25,25732564,1,251,25,25732478,1,156,25,25732546,1,139,25,25732498,1,242,25,25732557,1,133,25,25732477,1,162,25,25732515,1,213,25,25732584,1,165,25,25732514,1,212,25,25732476,1,227,25,25732494,1,198,25,25732531,1,236,25,25732530,1,234,25,25732529,1,117,25,25732528,1,215,25,25732527,1,124,25,25732526,1,123,25,25732525,1,254,25,25732524,1,253,25,25732523,1,148,25,25732570,1,218,25,25732580,1,146,25,25732581,1,147,25,25732569,1,224,25,25732533,1,143,25,25732540,1,184,25,25732541,1,185,25,25732585,1,166,25,25732556,1,132,25,25732485,1,129,25,25732563,1,250,25,25732578,1,151,25,25732501,1,119,25,25732502,1,193,25,25732536,1,176,25,25732496,1,245,25,25732553,1,229,25,25732516,1,206,25,25732582,1,144,25,25732517,1,208,25,25732558,1,137,25,25732543,1,241,25,25732466,1,237,25,25732507,1,190,25,25732542,1,240,25,25732551,1,131,25,25732554,1,232,25,25732565,1,252,25,25732475,1,171,25,25732493,1,205,25,25732492,1,204,25,25732491,1,118,25,25732490,1,214,25,25928904,1,180,25,25732549,1,126,25,25732602,1,182,25,25732539,1,175,25,25732545,1,141,25,25732559,1,138,25,25732537,1,177,25,25732534,1,153,25,25732503,1,194,25,25732606,1,160,25,25732567,1,121,25,25732538,1,174,25,25732497,1,246,25,25732550,1,130,25,25732572,1,200,25,25732474,1,170,25,25732511,1,221,25,25732601,1,196,25,25732532,1,142,25,25732519,1,210,25,25732495,1,199,25,25732605,1,155,25,25732535,1,154,25,25732499,1,244,25,25732510,1,220,25,25732600,1,195,25,25732607,1,161,25,25732604,1,231,25,25732473,1,173,25,25732599,1,226,26,51465122,1,116,26,51465123,0,1],a=[3,3,3,3,2,2,2,1,1,1];function o(t){var e=t[1],r=t[0][e>>>3]>>>7-(7&e)&1;return t[1]++,r}function s(t,r){if(null==e){e={};for(var i=0;i<n.length;i+=4)e[n[i+1]]=n.slice(i,i+4)}for(var a=o(t),s=e[a];null==s;)a=a<<1|o(t),s=e[a];var h=s[3];0!=h&&(h=0==o(t)?h:-h),r[0]=s[2],r[1]=h}function h(t,e){for(var r=0;r<e;r++)1==(1&t)&&t++,t>>>=1;return t}function l(t,e){return t>>e}function f(t,e,r,i,n,a){e[r]=l(l(11*t[n]-4*t[n+a]+t[n+a+a]+4,3)+t[i],1),e[r+a]=l(l(5*t[n]+4*t[n+a]-t[n+a+a]+4,3)-t[i],1)}function u(t,e,r,i,n,a){var o=t[n-a]-t[n+a],s=t[n],h=t[i];e[r]=l(l(o+4,3)+s+h,1),e[r+a]=l(l(4-o,3)+s-h,1)}function c(t,e,r,i,n,a){e[r]=l(l(5*t[n]+4*t[n-a]-t[n-a-a]+4,3)+t[i],1),e[r+a]=l(l(11*t[n]-4*t[n-a]+t[n-a-a]+4,3)-t[i],1)}function d(t){return i[t=t<0?0:t>4095?4095:t]>>>2}return function(e,n,o,l,p){l=new Uint16Array(l.buffer);var m,g,b,_,y,w,v,x,E=Date.now(),k=t._binBE,S=n+o;for(n+=4;n<S;){var M=k.readShort(e,n),A=k.readUshort(e,n+2);if(n+=4,12==M)L=A;else if(20==M)m=A;else if(21==M)g=A;else if(48==M)b=A;else if(53==M)_=A;else if(35==M);else if(62==M)y=A;else if(101==M);else if(109==M)w=A;else if(84==M);else if(106==M);else if(107==M);else if(108==M);else if(102==M);else if(104==M)tt=A;else if(105==M);else{var I=M<0?-M:M,B=65280&I,T=0;if(24576&I&&(8192&I?(T=65535&A,T+=(255&I)<<16):T=65535&A),24576==(24576&I)){if(null==v){v=[];for(var R=0;R<4;R++)v[R]=new Int16Array((m>>>1)*(g>>>1));for(x=new Int16Array((m>>>1)*(g>>>1)),r=new Int16Array(1024),R=0;R<1024;R++){var P=R-512,O=Math.abs(P),L=Math.floor(768*O*O*O/16581375)+O;r[R]=Math.sign(P)*L}for(i=new Uint16Array(4096),R=0;R<4096;R++){var C=R,U=65535*(Math.pow(113,C/4095)-1)/112;i[R]=Math.min(U,65535)}}var z=v[y],D=h(m,1+a[b]),N=h(g,1+a[b]);if(0==b)for(var F=0;F<N;F++)for(var j=0;j<D;j++){var G=n+2*(F*D+j);z[F*(m>>>1)+j]=e[G]<<8|e[G+1]}else{var H=[e,8*n],W=[],q=0,Z=D*N,Y=[0,0],V=0;for(A=0;q<Z;)for(s(H,Y),V=Y[0],A=Y[1];V>0;)W[q++]=A,V--;var X=(b-1)%3,J=1!=X?D:0,Q=0!=X?N:0;for(F=0;F<N;F++){var K=(F+Q)*(m>>>1)+J,$=F*D;for(j=0;j<D;j++)z[K+j]=r[W[$+j]+512]*_}if(2==X){var tt=m>>>1,et=2*D,rt=2*N;for(F=0;F<N;F++)for(j=0;j<et;j++){R=2*F*tt+j;var it=N*tt+(at=F*tt+j);0==F?f(z,x,R,it,at,tt):F==N-1?c(z,x,R,it,at,tt):u(z,x,R,it,at,tt)}var nt=z;for(z=x,x=nt,F=0;F<rt;F++)for(j=0;j<D;j++){var at;R=F*tt+2*j,it=D+(at=F*tt+j),0==j?f(z,x,R,it,at,1):j==D-1?c(z,x,R,it,at,1):u(z,x,R,it,at,1)}nt=z,z=x,x=nt;for(var ot=[],st=2-~~((b-1)/3),ht=0;ht<3;ht++)ot[ht]=w>>14-2*ht&3;var lt=ot[st];if(0!=lt)for(F=0;F<rt;F++)for(j=0;j<et;j++)z[R=F*tt+j]=z[R]<<lt}}if(9==b&&3==y){var ft=v[0],ut=v[1],ct=v[2],dt=v[3];for(F=0;F<g;F+=2)for(j=0;j<m;j+=2){var pt=F*m+j,mt=ft[G=(F>>>1)*(m>>>1)+(j>>>1)],gt=ut[G]-2048,bt=ct[G]-2048,_t=dt[G]-2048,yt=(gt<<1)+mt,wt=(bt<<1)+mt,vt=mt+_t,xt=mt-_t;l[pt]=d(yt),l[pt+1]=d(vt),l[pt+m]=d(xt),l[pt+m+1]=d(wt)}}n+=4*T}else if(16388==I)n+=4*T;else if(8192!=B&&8448!=B&&9216!=B)throw I.toString(16)}}console.log(Date.now()-E)}}(),t.decode._decodeLogLuv32=function(t,e,r,i,n,a){for(var o=t.width,s=4*o,h=0,l=new Uint8Array(s);h<i;){for(var f=0;f<s;){var u=e[r+h];if(h++,u<128){for(var c=0;c<u;c++)l[f+c]=e[r+h+c];f+=u,h+=u}else{for(u-=126,c=0;c<u;c++)l[f+c]=e[r+h];f+=u,h++}}for(var d=0;d<o;d++)n[a+0]=l[d],n[a+1]=l[d+o],n[a+2]=l[d+2*o],n[a+4]=l[d+3*o],a+=6}},t.decode._ljpeg_diff=function(e,r,i){var n,a,o=t.decode._getbithuff;return n=o(e,r,i[0],i),0==((a=o(e,r,n,0))&1<<n-1)&&(a-=(1<<n)-1),a},t.decode._decodeARW=function(e,r,i,n,a,o){var s=e.t256[0],h=e.t257[0],l=e.t258[0],f=e.isLE?t._binLE:t._binBE;if(s*h==n||s*h*1.5==n)if(s*h*1.5!=n){var u,c,d,p,m,g,b,_,y=new Uint16Array(16),w=new Uint8Array(s+1);for(I=0;I<h;I++){for(var v=0;v<s;v++)w[v]=r[i++];for(_=0,A=0;A<s-30;_+=16){for(c=2047&(u=f.readUint(w,_)),d=2047&u>>>11,p=15&u>>>22,m=15&u>>>26,g=0;g<4&&128<<g<=c-d;g++);for(b=30,x=0;x<16;x++)x==p?y[x]=c:x==m?y[x]=d:(y[x]=((f.readUshort(w,_+(b>>3))>>>(7&b)&127)<<g)+d,y[x]>2047&&(y[x]=2047),b+=7);for(x=0;x<16;x++,A+=2)U=y[x]<<1,t.decode._putsF(a,(I*s+A)*l,U<<16-l);A-=1&A?1:31}}}else for(var x=0;x<n;x+=3){var E=r[i+x+0],k=r[i+x+1],S=r[i+x+2];a[o+x]=k<<4|E>>>4,a[o+x+1]=E<<4|S>>>4,a[o+x+2]=S<<4|k>>>4}else{h+=8;var M,A,I,B=[i,0,0,0],T=new Uint16Array(32770),R=[3857,3856,3599,3342,3085,2828,2571,2314,2057,1800,1543,1286,1029,772,771,768,514,513],P=0,O=t.decode._ljpeg_diff;for(T[0]=15,M=x=0;x<18;x++)for(var L=32768>>>(R[x]>>>8),C=0;C<L;C++)T[++M]=R[x];for(A=s;A--;)for(I=0;I<h+1;I+=2)if(I==h&&(I=1),P+=O(r,B,T),I<h){var U=4095&P;t.decode._putsF(a,(I*s+A)*l,U<<16-l)}}},t.decode._decodeNikon=function(e,r,i,n,a,o,s){var h=[[0,0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,5,4,3,6,2,7,1,0,8,9,11,10,12],[0,0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,57,90,56,39,22,5,4,3,2,1,0,11,12,12],[0,0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,5,4,6,3,7,2,8,1,9,0,10,11,12],[0,0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,5,6,4,7,8,3,9,2,1,0,10,11,12,13,14],[0,0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,8,92,75,58,41,7,6,5,4,3,2,1,0,13,14],[0,0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,7,6,8,5,9,4,10,3,11,12,2,0,1,13,14]],l=e.t256[0],f=e.t257[0],u=e.t258[0],c=0,d=0,p=t.decode._make_decoder,m=t.decode._getbithuff,g=r[0].exifIFD.makerNote,b=g.t150?g.t150:g.t140,_=0,y=b[_++],w=b[_++];73!=y&&88!=w||(_+=2110),70==y&&(c=2),14==u&&(c+=3);for(var v=[[0,0],[0,0]],x=e.isLE?t._binLE:t._binBE,E=0;E<2;E++)for(var k=0;k<2;k++)v[E][k]=x.readShort(b,_),_+=2;var S,M,A,I,B,T=1<<u&32767,R=0,P=x.readShort(b,_);_+=2,P>1&&(R=Math.floor(T/(P-1))),68==y&&32==w&&R>0&&(d=x.readShort(b,562));var O=[0,0],L=p(h[c]),C=[n,0,0,0];for(S=0;S<f;S++)for(d&&S==d&&(L=p(h[c+1])),M=0;M<l;M++){E=m(i,C,L[0],L),0==((B=1+(m(i,C,(A=15&E)-(I=E>>>4),0)<<1)<<I>>>1)&1<<A-1)&&(B-=(1<<A)-(0==I?1:0)),M<2?O[M]=v[1&S][M]+=B:O[1&M]+=B;var U=Math.min(Math.max(O[1&M],0),(1<<u)-1),z=(S*l+M)*u;t.decode._putsF(o,z,U<<16-u)}},t.decode._putsF=function(t,e,r){r<<=8-(7&e);var i=e>>>3;t[i]|=r>>>16,t[i+1]|=r>>>8,t[i+2]|=r},t.decode._getbithuff=function(e,r,i,n){t.decode._get_byte;var a,o=r[0],s=r[1],h=r[2],l=r[3];if(0==i||h<0)return 0;for(;!l&&h<i&&-1!=(a=e[o++])&&!(l=0);)s=(s<<8)+a,h+=8;if(a=s<<32-h>>>32-i,n?(h-=n[a+1]>>>8,a=255&n[a+1]):h-=i,h<0)throw\"e\";return r[0]=o,r[1]=s,r[2]=h,r[3]=l,a},t.decode._make_decoder=function(t){var e,r,i,n,a,o=[];for(e=16;0!=e&&!t[e];e--);var s=17;for(o[0]=e,i=r=1;r<=e;r++)for(n=0;n<t[r];n++,++s)for(a=0;a<1<<e-r;a++)i<=1<<e&&(o[i++]=r<<8|t[s]);return o},t.decode._decodeNewJPEG=function(e,r,i,n,a,o){n=Math.min(n,r.length-i);var s=e.t347,h=s?s.length:0,l=new Uint8Array(h+n);if(s){for(var f=0,u=0;u<h-1&&(255!=s[u]||217!=s[u+1]);u++)l[f++]=s[u];var c=r[i],d=r[i+1];for(255==c&&216==d||(l[f++]=c,l[f++]=d),u=2;u<n;u++)l[f++]=r[i+u]}else for(u=0;u<n;u++)l[u]=r[i+u];if(32803==e.t262[0]||7==e.t259[0]&&34892==e.t262[0]){var p=e.t258[0],m=t.LosslessJpegDecode(l),g=m.length;if(16==p)if(e.isLE)for(u=0;u<g;u++)a[o+(u<<1)]=255&m[u],a[o+(u<<1)+1]=m[u]>>>8;else for(u=0;u<g;u++)a[o+(u<<1)]=m[u]>>>8,a[o+(u<<1)+1]=255&m[u];else if(14==p||12==p){var b=16-p;for(u=0;u<g;u++)t.decode._putsF(a,u*p,m[u]<<b)}else{if(8!=p)throw new Error(\"unsupported bit depth \"+p);for(u=0;u<g;u++)a[o+u]=m[u]}}else{var _=new t.JpegDecoder;_.parse(l);var y=_.getData({width:_.width,height:_.height,forceRGB:!0,isSourcePDF:!1});for(u=0;u<y.length;u++)a[o+u]=y[u]}6==e.t262[0]&&(e.t262[0]=2)},t.decode._decodeOldJPEGInit=function(t,e,r,i){var a,o,s,h,l,f=216,u=0,c=0,d=!1,p=t.t513,m=p?p[0]:0,g=t.t514,b=g?g[0]:0,_=t.t324||t.t273||p,y=t.t530,w=0,v=0,x=t.t277?t.t277[0]:1,E=t.t515;if(_&&(c=_[0],d=_.length>1),!d){if(255==e[r]&&e[r+1]==f)return{jpegOffset:r};if(null!=p&&(255==e[r+m]&&e[r+m+1]==f?u=r+m:n(\"JPEGInterchangeFormat does not point to SOI\"),null==g?n(\"JPEGInterchangeFormatLength field is missing\"):(m>=c||m+b<=c)&&n(\"JPEGInterchangeFormatLength field value is invalid\"),null!=u))return{jpegOffset:u}}if(null!=y&&(w=y[0],v=y[1]),null!=p&&null!=g)if(b>=2&&m+b<=c){for(a=255==e[r+m+b-2]&&e[r+m+b-1]==f?new Uint8Array(b-2):new Uint8Array(b),s=0;s<a.length;s++)a[s]=e[r+m+s];n(\"Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables\")}else n(\"JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile\");if(null==a){var k=0,S=[];S[k++]=255,S[k++]=f;var M=t.t519;if(null==M)throw new Error(\"JPEGQTables tag is missing\");for(s=0;s<M.length;s++)for(S[k++]=255,S[k++]=219,S[k++]=0,S[k++]=67,S[k++]=s,h=0;h<64;h++)S[k++]=e[r+M[s]+h];for(l=0;l<2;l++){var A=t[0==l?\"t520\":\"t521\"];if(null==A)throw new Error((0==l?\"JPEGDCTables\":\"JPEGACTables\")+\" tag is missing\");for(s=0;s<A.length;s++){S[k++]=255,S[k++]=196;var I=19;for(h=0;h<16;h++)I+=e[r+A[s]+h];for(S[k++]=I>>>8,S[k++]=255&I,S[k++]=s|l<<4,h=0;h<16;h++)S[k++]=e[r+A[s]+h];for(h=0;h<I;h++)S[k++]=e[r+A[s]+16+h]}}if(S[k++]=255,S[k++]=192,S[k++]=0,S[k++]=8+3*x,S[k++]=8,S[k++]=t.height>>>8&255,S[k++]=255&t.height,S[k++]=t.width>>>8&255,S[k++]=255&t.width,S[k++]=x,1==x)S[k++]=1,S[k++]=17,S[k++]=0;else for(s=0;s<3;s++)S[k++]=s+1,S[k++]=0!=s?17:(15&w)<<4|15&v,S[k++]=s;null!=E&&0!=E[0]&&(S[k++]=255,S[k++]=221,S[k++]=0,S[k++]=4,S[k++]=E[0]>>>8&255,S[k++]=255&E[0]),a=new Uint8Array(S)}var B=-1;for(s=0;s<a.length-1;){if(255==a[s]&&192==a[s+1]){B=s;break}s++}if(-1==B){var T=new Uint8Array(a.length+10+3*x);T.set(a);var R=a.length;if(B=a.length,(a=T)[R++]=255,a[R++]=192,a[R++]=0,a[R++]=8+3*x,a[R++]=8,a[R++]=t.height>>>8&255,a[R++]=255&t.height,a[R++]=t.width>>>8&255,a[R++]=255&t.width,a[R++]=x,1==x)a[R++]=1,a[R++]=17,a[R++]=0;else for(s=0;s<3;s++)a[R++]=s+1,a[R++]=0!=s?17:(15&w)<<4|15&v,a[R++]=s}if(255==e[c]&&218==e[c+1]){var P=e[c+2]<<8|e[c+3];for((o=new Uint8Array(P+2))[0]=e[c],o[1]=e[c+1],o[2]=e[c+2],o[3]=e[c+3],s=0;s<P-2;s++)o[s+4]=e[c+s+4]}else{var O=0;if((o=new Uint8Array(8+2*x))[O++]=255,o[O++]=218,o[O++]=0,o[O++]=6+2*x,o[O++]=x,1==x)o[O++]=1,o[O++]=0;else for(s=0;s<3;s++)o[O++]=s+1,o[O++]=s<<4|s;o[O++]=0,o[O++]=63,o[O++]=0}return{jpegOffset:r,tables:a,sosMarker:o,sofPosition:B}},t.decode._decodeOldJPEG=function(e,r,i,n,a,o){var s,h,l,f,u=t.decode._decodeOldJPEGInit(e,r,i,n);if(null!=u.jpegOffset)for(s=i+n-u.jpegOffset,l=new Uint8Array(s),p=0;p<s;p++)l[p]=r[u.jpegOffset+p];else{for(h=u.tables.length,(l=new Uint8Array(h+u.sosMarker.length+n+2)).set(u.tables),f=h,l[u.sofPosition+5]=e.height>>>8&255,l[u.sofPosition+6]=255&e.height,l[u.sofPosition+7]=e.width>>>8&255,l[u.sofPosition+8]=255&e.width,255==r[i]&&r[i+1]==SOS||(l.set(u.sosMarker,f),f+=sosMarker.length),p=0;p<n;p++)l[f++]=r[i+p];l[f++]=255,l[f++]=EOI}var c=new t.JpegDecoder;c.parse(l);for(var d=c.getData({width:c.width,height:c.height,forceRGB:!0,isSourcePDF:!1}),p=0;p<d.length;p++)a[o+p]=d[p];e.t262&&6==e.t262[0]&&(e.t262[0]=2)},t.decode._decodePackBits=function(t,e,r,i,n){for(var a=new Int8Array(t.buffer),o=new Int8Array(i.buffer),s=e+r;e<s;){var h=a[e];if(e++,h>=0&&h<128)for(var l=0;l<h+1;l++)o[n]=a[e],n++,e++;if(h>=-127&&h<0){for(l=0;l<1-h;l++)o[n]=a[e],n++;e++}}return n},t.decode._decodeThunder=function(t,e,r,i,n){for(var a=[0,1,0,-1],o=[0,1,2,3,0,-3,-2,-1],s=e+r,h=2*n,l=0;e<s;){var f=t[e],u=f>>>6,c=63&f;if(e++,3==u&&(l=15&c,i[h>>>1]|=l<<4*(1-h&1),h++),0==u)for(var d=0;d<c;d++)i[h>>>1]|=l<<4*(1-h&1),h++;if(2==u)for(d=0;d<2;d++)4!=(p=c>>>3*(1-d)&7)&&(l+=o[p],i[h>>>1]|=l<<4*(1-h&1),h++);if(1==u)for(d=0;d<3;d++){var p;2!=(p=c>>>2*(2-d)&3)&&(l+=a[p],i[h>>>1]|=l<<4*(1-h&1),h++)}}},t.decode._dmap={1:0,\"011\":1,\"000011\":2,\"0000011\":3,\"010\":-1,\"000010\":-2,\"0000010\":-3},t.decode._lens=function(){var t=function(t,e,r,i){for(var n=0;n<e.length;n++)t[e[n]]=r+n*i},e=\"00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100\",r=\"0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111\",i=\"11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011\",n=\"0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101\",a=\"00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111\";e=e.split(\",\"),r=r.split(\",\"),i=i.split(\",\"),n=n.split(\",\"),a=a.split(\",\");var o={},s={};return t(o,e,0,1),t(o,i,64,64),t(o,a,1792,64),t(s,r,0,1),t(s,n,64,64),t(s,a,1792,64),[o,s]}(),t.decode._decodeG4=function(e,r,i,n,a,o,s){for(var h=t.decode,l=r<<3,f=0,u=\"\",c=[],d=[],p=0;p<o;p++)d.push(0);d=h._makeDiff(d);for(var m=0,g=0,b=0,_=0,y=0,w=0,v=\"\",x=0,E=8*Math.ceil(o/8);l>>>3<r+i;){b=h._findDiff(d,m+(0==m?0:1),1-y),_=h._findDiff(d,b,y);var k=0;if(1==s&&(k=e[l>>>3]>>>7-(7&l)&1),2==s&&(k=e[l>>>3]>>>(7&l)&1),l++,u+=k,\"H\"==v){if(null!=h._lens[y][u]){var S=h._lens[y][u];u=\"\",f+=S,S<64&&(h._addNtimes(c,f,y),m+=f,y=1-y,f=0,0==--x&&(v=\"\"))}}else\"0001\"==u&&(u=\"\",h._addNtimes(c,_-m,y),m=_),\"001\"==u&&(u=\"\",v=\"H\",x=2),null!=h._dmap[u]&&(g=b+h._dmap[u],h._addNtimes(c,g-m,y),m=g,u=\"\",y=1-y);c.length==o&&\"\"==v&&(h._writeBits(c,n,8*a+w*E),y=0,w++,m=0,d=h._makeDiff(c),c=[])}},t.decode._findDiff=function(t,e,r){for(var i=0;i<t.length;i+=2)if(t[i]>=e&&t[i+1]==r)return t[i]},t.decode._makeDiff=function(t){var e=[];1==t[0]&&e.push(0,1);for(var r=1;r<t.length;r++)t[r-1]!=t[r]&&e.push(r,t[r]);return e.push(t.length,0,t.length,1),e},t.decode._decodeG2=function(e,r,i,n,a,o,s){for(var h=t.decode,l=r<<3,f=0,u=\"\",c=[],d=0,p=0,m=8*Math.ceil(o/8);l>>>3<r+i;){var g=0;1==s&&(g=e[l>>>3]>>>7-(7&l)&1),2==s&&(g=e[l>>>3]>>>(7&l)&1),l++,u+=g,null!=(f=h._lens[d][u])&&(h._addNtimes(c,f,d),u=\"\",f<64&&(d=1-d),c.length==o&&(h._writeBits(c,n,8*a+p*m),c=[],p++,d=0,0!=(7&l)&&(l+=8-(7&l)),f>=64&&(l+=8)))}},t.decode._decodeG3=function(e,r,i,n,a,o,s,h){for(var l=t.decode,f=r<<3,u=0,c=\"\",d=[],p=[],m=0;m<o;m++)d.push(0);for(var g=0,b=0,_=0,y=0,w=0,v=-1,x=\"\",E=0,k=!0,S=8*Math.ceil(o/8);f>>>3<r+i;){_=l._findDiff(p,g+(0==g?0:1),1-w),y=l._findDiff(p,_,w);var M=0;if(1==s&&(M=e[f>>>3]>>>7-(7&f)&1),2==s&&(M=e[f>>>3]>>>(7&f)&1),f++,c+=M,k){if(null!=l._lens[w][c]){var A=l._lens[w][c];c=\"\",u+=A,A<64&&(l._addNtimes(d,u,w),w=1-w,u=0)}}else\"H\"==x?null!=l._lens[w][c]&&(A=l._lens[w][c],c=\"\",u+=A,A<64&&(l._addNtimes(d,u,w),g+=u,w=1-w,u=0,0==--E&&(x=\"\"))):(\"0001\"==c&&(c=\"\",l._addNtimes(d,y-g,w),g=y),\"001\"==c&&(c=\"\",x=\"H\",E=2),null!=l._dmap[c]&&(b=_+l._dmap[c],l._addNtimes(d,b-g,w),g=b,c=\"\",w=1-w));c.endsWith(\"000000000001\")&&(v>=0&&l._writeBits(d,n,8*a+v*S),h&&(1==s&&(k=1==(e[f>>>3]>>>7-(7&f)&1)),2==s&&(k=1==(e[f>>>3]>>>(7&f)&1)),f++),c=\"\",w=0,v++,g=0,p=l._makeDiff(d),d=[])}d.length==o&&l._writeBits(d,n,8*a+v*S)},t.decode._addNtimes=function(t,e,r){for(var i=0;i<e;i++)t.push(r)},t.decode._writeBits=function(t,e,r){for(var i=0;i<t.length;i++)e[r+i>>>3]|=t[i]<<7-(r+i&7)},t.decode._decodeLZW=t.decode._decodeLZW=(s=0,h=0,l=0,f=0,u=function(){var t=r>>>3,e=(i[t]<<16|i[t+1]<<8|i[t+2])>>>24-(7&r)-h&(1<<h)-1;return r+=h,e},c=new Uint32Array(16384),d=0,p=function(t){h=t+1,s=f+1},m=function(t){for(var e=t<<2,r=c[e+2],i=o+r-1;65535!=e;)a[i--]=c[e],e=c[e+1];o+=r},g=function(t,e){var r=s<<2,i=t<<2;c[r]=c[3+(e<<2)],c[r+1]=i,c[r+2]=c[i+2]+1,c[r+3]=c[i+3],1+ ++s==1<<h&&12!=h&&h++},function(t,e,n,h,b,_){r=e<<3,i=t,a=h,o=b;var y=e+n<<3,w=0,v=0;for(function(t){if(t!=d){d=t,f=1+(l=1<<t);for(var e=0;e<f+1;e++)c[4*e]=c[4*e+3]=e,c[4*e+1]=65535,c[4*e+2]=1}}(_),p(_);r<y&&(w=u())!=f;){if(w==l){if(p(_),(w=u())==f)break;m(w)}else w<s?(m(w),g(v,w)):(g(v,v),m(s-1));v=w}return o}),t.tags={},t._types=((b=new Array(250)).fill(0),{basic:{main:b=b.concat([0,0,0,0,4,3,3,3,3,3,0,0,3,0,0,0,3,0,0,2,2,2,2,4,3,0,0,3,4,4,3,3,5,5,3,2,5,5,0,0,0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,2,2,3,5,5,3,0,3,3,4,4,4,3,4,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),rest:{33432:2,33434:5,33437:5,34665:4,34850:3,34853:4,34855:3,34864:3,34866:4,36864:7,36867:2,36868:2,37121:7,37377:10,37378:5,37380:10,37381:5,37383:3,37384:3,37385:3,37386:5,37510:7,37520:2,37521:2,37522:2,40960:7,40961:3,40962:4,40963:4,40965:4,41486:5,41487:5,41488:3,41985:3,41986:3,41987:3,41988:5,41989:3,41990:3,41993:3,41994:3,41995:7,41996:3,42032:2,42033:2,42034:5,42036:2,42037:2,59932:7}},gps:{main:[1,2,5,2,5,1,5,5,0,9],rest:{18:2,29:2}}}),t._readIFD=function(e,r,i,a,o,s){var h=e.readUshort(r,i);i+=2;var l={};s.debug&&n(\"   \".repeat(o),a.length-1,\">>>----------------\");for(var f=0;f<h;f++){var u=e.readUshort(r,i);i+=2;var c=e.readUshort(r,i);i+=2;var d=e.readUint(r,i);i+=4;var p=e.readUint(r,i);i+=4;var m=[];if(1!=c&&7!=c||(m=new Uint8Array(r.buffer,d<5?i-4:p,d)),2==c){var g=d<5?i-4:p,b=r[g],_=Math.max(0,Math.min(d-1,r.length-g));b<128||0==_?m.push(e.readASCII(r,g,_)):m=new Uint8Array(r.buffer,g,_)}if(3==c)for(var y=0;y<d;y++)m.push(e.readUshort(r,(d<3?i-4:p)+2*y));if(4==c||13==c)for(y=0;y<d;y++)m.push(e.readUint(r,(d<2?i-4:p)+4*y));if(5==c||10==c){var w=5==c?e.readUint:e.readInt;for(y=0;y<d;y++)m.push([w(r,p+8*y),w(r,p+8*y+4)])}if(8==c)for(y=0;y<d;y++)m.push(e.readShort(r,(d<3?i-4:p)+2*y));if(9==c)for(y=0;y<d;y++)m.push(e.readInt(r,(d<2?i-4:p)+4*y));if(11==c)for(y=0;y<d;y++)m.push(e.readFloat(r,p+4*y));if(12==c)for(y=0;y<d;y++)m.push(e.readDouble(r,p+8*y));if(0==d||0!=m.length){if(s.debug&&n(\"   \".repeat(o),u,c,t.tags[u],m),l[\"t\"+u]=m,330==u&&l.t272&&\"DSLR-A100\"==l.t272[0]);else if(330==u||34665==u||34853==u||50740==u&&e.readUshort(r,e.readUint(m,0))<300||61440==u){var v=50740==u?[e.readUint(m,0)]:m,x=[];for(y=0;y<v.length;y++)t._readIFD(e,r,v[y],x,o+1,s);330==u&&(l.subIFD=x),34665==u&&(l.exifIFD=x[0]),34853==u&&(l.gpsiIFD=x[0]),50740==u&&(l.dngPrvt=x[0]),61440==u&&(l.fujiIFD=x[0])}if(37500==u&&s.parseMN){var E=m;if(\"Nikon\"==e.readASCII(E,0,5))l.makerNote=t.decode(E.slice(10).buffer)[0];else if(e.readUshort(r,p)<300&&e.readUshort(r,p+4)<=12){var k=[];t._readIFD(e,r,p,k,o+1,s),l.makerNote=k[0]}}}else if(n(u,\"unknown TIFF tag type: \",c,\"num:\",d),0==f)return}return a.push(l),s.debug&&n(\"   \".repeat(o),\"<<<---------------\"),i},t._writeIFD=function(e,r,i,n,a){var o=Object.keys(a),s=o.length;a.exifIFD&&s--,a.gpsiIFD&&s--,e.writeUshort(i,n,s);for(var h=(n+=2)+12*s+4,l=0;l<o.length;l++){var f=o[l];if(\"t34665\"!=f&&\"t34853\"!=f){\"exifIFD\"==f&&(f=\"t34665\"),\"gpsiIFD\"==f&&(f=\"t34853\");var u=parseInt(f.slice(1)),c=r.main[u];if(null==c&&(c=r.rest[u]),null==c||0==c)throw new Error(\"unknown type of tag: \"+u);var d=a[f];34665==u&&(d=[h],h=t._writeIFD(e,r,i,h,a.exifIFD)[1]),34853==u&&(d=[h],h=t._writeIFD(e,t._types.gps,i,h,a.gpsiIFD)[1]),2==c&&(d=d[0]+\"\\0\");var p=d.length;e.writeUshort(i,n,u),n+=2,e.writeUshort(i,n,c),n+=2,e.writeUint(i,n,p);var m=[-1,1,1,2,4,8,0,1,0,4,8,0,8][c]*p,g=n+=4;if(m>4&&(e.writeUint(i,n,h),g=h),1==c||7==c)for(var b=0;b<p;b++)i[g+b]=d[b];else if(2==c)e.writeASCII(i,g,d);else if(3==c)for(b=0;b<p;b++)e.writeUshort(i,g+2*b,d[b]);else if(4==c)for(b=0;b<p;b++)e.writeUint(i,g+4*b,d[b]);else if(5==c||10==c){var _=5==c?e.writeUint:e.writeInt;for(b=0;b<p;b++){var y=d[b],w=y[0],v=y[1];if(null==w)throw\"e\";_(i,g+8*b,w),_(i,g+8*b+4,v)}}else if(9==c)for(b=0;b<p;b++)e.writeInt(i,g+4*b,d[b]);else{if(12!=c)throw c;for(b=0;b<p;b++)e.writeDouble(i,g+8*b,d[b])}m>4&&(h+=m+=1&m),n+=4}}return[n,h]},t.toRGBA8=function(t,e){var r=t.width,i=t.height,a=r*i,o=4*a,s=t.data,h=new Uint8Array(4*a),l=t.t262?t.t262[0]:2,f=t.t258?Math.min(32,t.t258[0]):1;if(null==t.t262&&1==f&&(l=0),0==l)for(var u=Math.ceil(f*r/8),c=0;c<i;c++){var d=c*u,p=c*r;if(1==f)for(var m=0;m<r;m++){var g=p+m<<2,b=s[d+(m>>3)]>>7-(7&m)&1;h[g]=h[g+1]=h[g+2]=255*(1-b),h[g+3]=255}if(4==f)for(m=0;m<r;m++)g=p+m<<2,b=s[d+(m>>1)]>>4-4*(1&m)&15,h[g]=h[g+1]=h[g+2]=17*(15-b),h[g+3]=255;if(8==f)for(m=0;m<r;m++)g=p+m<<2,b=s[d+m],h[g]=h[g+1]=h[g+2]=255-b,h[g+3]=255}else if(1==l){var _=t.t258?t.t258.length:1;for(u=Math.ceil(_*f*r/8),null==e&&(e=1/256),c=0;c<i;c++){if(d=c*u,p=c*r,1==f)for(m=0;m<r;m++)g=p+m<<2,b=s[d+(m>>3)]>>7-(7&m)&1,h[g]=h[g+1]=h[g+2]=255*b,h[g+3]=255;if(2==f)for(m=0;m<r;m++)g=p+m<<2,b=s[d+(m>>2)]>>6-2*(3&m)&3,h[g]=h[g+1]=h[g+2]=85*b,h[g+3]=255;if(8==f)for(m=0;m<r;m++)g=p+m<<2,b=s[d+m*_],h[g]=h[g+1]=h[g+2]=b,h[g+3]=255;if(16==f)for(m=0;m<r;m++){g=p+m<<2;var y=d+2*m;b=s[y+1]<<8|s[y],h[g]=h[g+1]=h[g+2]=Math.min(255,~~(b*e)),h[g+3]=255}}}else if(2==l)if(_=t.t258?t.t258.length:3,8==f){if(4==_)for(m=0;m<o;m++)h[m]=s[m];if(3==_)for(m=0;m<a;m++){var w=3*m;h[g=m<<2]=s[w],h[g+1]=s[w+1],h[g+2]=s[w+2],h[g+3]=255}}else if(16==f){if(4==_)for(m=0;m<a;m++)w=8*m+1,h[g=m<<2]=s[w],h[g+1]=s[w+2],h[g+2]=s[w+4],h[g+3]=s[w+6];if(3==_)for(m=0;m<a;m++)w=6*m+1,h[g=m<<2]=s[w],h[g+1]=s[w+2],h[g+2]=s[w+4],h[g+3]=255}else{if(32!=f)throw f;if(!h.isLE)for(m=0;m<s.length;m+=4){var v=s[m];s[m]=s[m+3],s[m+3]=v,v=s[m+1],s[m+1]=s[m+2],s[m+2]=v}var x=new Float32Array(s.buffer);if(3!=_)throw _;for(m=0;m<a;m++)w=3*m,h[g=m<<2]=~~(.5+255*x[w]),h[g+1]=~~(.5+255*x[w+1]),h[g+2]=~~(.5+255*x[w+2]),h[g+3]=255}else if(3==l){var E=t.t320,k=(_=t.t258?t.t258.length:1,u=Math.ceil(_*f*r/8),1<<f);for(c=0;c<i;c++)for(var S=0;S<r;S++){g=(m=c*r+S)<<2;var M=0,A=c*u;if(1==f)M=s[A+(S>>>3)]>>>7-(7&S)&1;else if(2==f)M=s[A+(S>>>2)]>>>6-2*(3&S)&3;else if(4==f)M=s[A+(S>>>1)]>>>4-4*(1&S)&15;else{if(8!=f)throw f;M=s[A+S*_]}h[g]=E[M]>>8,h[g+1]=E[k+M]>>8,h[g+2]=E[k+k+M]>>8,h[g+3]=255}}else if(5==l){var I=(_=t.t258?t.t258.length:4)>4?1:0;for(m=0;m<a;m++){g=m<<2;var B=m*_;if(UDOC){var T=s[B],R=s[B+1],P=s[B+2],O=s[B+3],L=UDOC.C.cmykToRgb([T*(1/255),R*(1/255),P*(1/255),O*(1/255)]);h[g]=~~(.5+255*L[0]),h[g+1]=~~(.5+255*L[1]),h[g+2]=~~(.5+255*L[2])}else T=255-s[B],R=255-s[B+1],P=255-s[B+2],O=(255-s[B+3])*(1/255),h[g]=~~(T*O+.5),h[g+1]=~~(R*O+.5),h[g+2]=~~(P*O+.5);h[g+3]=255*(1-I)+s[B+4]*I}}else if(6==l&&t.t278){var C=t.t278[0];for(c=0;c<i;c+=C){m=c*r;for(var U=C*r,z=0;z<U;z++){g=4*(m+z),P=s[(B=3*m+4*(z>>>1))+(1&z)];var D=s[B+2]-128,N=s[B+3]-128,F=P+((N>>2)+(N>>3)+(N>>5)),j=P-((D>>2)+(D>>4)+(D>>5))-((N>>1)+(N>>3)+(N>>4)+(N>>5)),G=P+(D+(D>>1)+(D>>2)+(D>>6));h[g]=Math.max(0,Math.min(255,F)),h[g+1]=Math.max(0,Math.min(255,j)),h[g+2]=Math.max(0,Math.min(255,G)),h[g+3]=255}}}else if(32845==l){function H(t){return t<.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055}for(c=0;c<i;c++)for(S=0;S<r;S++){g=4*(c*r+S);var W=s[1+(B=6*(c*r+S))]<<8|s[B],q=(W=Math.pow(2,(W+.5)/256-64),(s[B+3]+.5)/410),Z=(s[B+5]+.5)/410,Y=9*q/(6*q-16*Z+12),V=4*Z/(6*q-16*Z+12),X=Y*W/V,J=(1-Y-V)*W/V;F=2.69*X-1.276*(P=W)-.414*J,j=-1.022*X+1.978*P+.044*J,G=.061*X-.224*P+1.163*J,h[g]=255*H(Math.min(F,1)),h[g+1]=255*H(Math.min(j,1)),h[g+2]=255*H(Math.min(G,1)),h[g+3]=255}}else n(\"Unknown Photometric interpretation: \"+l);return h},t.replaceIMG=function(e){null==e&&(e=document.getElementsByTagName(\"img\"));for(var r=[\"tif\",\"tiff\",\"dng\",\"cr2\",\"nef\"],i=0;i<e.length;i++){var n=e[i],a=n.getAttribute(\"src\");if(null!=a){var o=a.split(\".\").pop().toLowerCase();if(-1!=r.indexOf(o)){var s=new XMLHttpRequest;t._xhrs.push(s),t._imgs.push(n),s.open(\"GET\",a),s.responseType=\"arraybuffer\",s.onload=t._imgLoaded,s.send()}}}},t._xhrs=[],t._imgs=[],t._imgLoaded=function(e){var r=t._xhrs.indexOf(e.target),i=t._imgs[r];t._xhrs.splice(r,1),t._imgs.splice(r,1),i.setAttribute(\"src\",t.bufferToURI(e.target.response))},t.bufferToURI=function(e){var r=t.decode(e),i=r,n=0,a=i[0];r[0].subIFD&&(i=i.concat(r[0].subIFD));for(var o=0;o<i.length;o++){var s=i[o];if(!(null==s.t258||s.t258.length<3)){var h=s.t256*s.t257;h>n&&(n=h,a=s)}}t.decodeImage(e,a,r);var l=t.toRGBA8(a),f=a.width,u=a.height,c=document.createElement(\"canvas\");c.width=f,c.height=u;var d=c.getContext(\"2d\"),p=new ImageData(new Uint8ClampedArray(l.buffer),f,u);return d.putImageData(p,0,0),c.toDataURL()},t._binBE={nextZero:function(t,e){for(;0!=t[e];)e++;return e},readUshort:function(t,e){return t[e]<<8|t[e+1]},readShort:function(e,r){var i=t._binBE.ui8;return i[0]=e[r+1],i[1]=e[r+0],t._binBE.i16[0]},readInt:function(e,r){var i=t._binBE.ui8;return i[0]=e[r+3],i[1]=e[r+2],i[2]=e[r+1],i[3]=e[r+0],t._binBE.i32[0]},readUint:function(e,r){var i=t._binBE.ui8;return i[0]=e[r+3],i[1]=e[r+2],i[2]=e[r+1],i[3]=e[r+0],t._binBE.ui32[0]},readASCII:function(t,e,r){for(var i=\"\",n=0;n<r;n++)i+=String.fromCharCode(t[e+n]);return i},readFloat:function(e,r){for(var i=t._binBE.ui8,n=0;n<4;n++)i[n]=e[r+3-n];return t._binBE.fl32[0]},readDouble:function(e,r){for(var i=t._binBE.ui8,n=0;n<8;n++)i[n]=e[r+7-n];return t._binBE.fl64[0]},writeUshort:function(t,e,r){t[e]=r>>8&255,t[e+1]=255&r},writeInt:function(e,r,i){var n=t._binBE.ui8;t._binBE.i32[0]=i,e[r+3]=n[0],e[r+2]=n[1],e[r+1]=n[2],e[r+0]=n[3]},writeUint:function(t,e,r){t[e]=r>>24&255,t[e+1]=r>>16&255,t[e+2]=r>>8&255,t[e+3]=r>>0&255},writeASCII:function(t,e,r){for(var i=0;i<r.length;i++)t[e+i]=r.charCodeAt(i)},writeDouble:function(e,r,i){t._binBE.fl64[0]=i;for(var n=0;n<8;n++)e[r+n]=t._binBE.ui8[7-n]}},t._binBE.ui8=new Uint8Array(8),t._binBE.i16=new Int16Array(t._binBE.ui8.buffer),t._binBE.i32=new Int32Array(t._binBE.ui8.buffer),t._binBE.ui32=new Uint32Array(t._binBE.ui8.buffer),t._binBE.fl32=new Float32Array(t._binBE.ui8.buffer),t._binBE.fl64=new Float64Array(t._binBE.ui8.buffer),t._binLE={nextZero:t._binBE.nextZero,readUshort:function(t,e){return t[e+1]<<8|t[e]},readShort:function(e,r){var i=t._binBE.ui8;return i[0]=e[r+0],i[1]=e[r+1],t._binBE.i16[0]},readInt:function(e,r){var i=t._binBE.ui8;return i[0]=e[r+0],i[1]=e[r+1],i[2]=e[r+2],i[3]=e[r+3],t._binBE.i32[0]},readUint:function(e,r){var i=t._binBE.ui8;return i[0]=e[r+0],i[1]=e[r+1],i[2]=e[r+2],i[3]=e[r+3],t._binBE.ui32[0]},readASCII:t._binBE.readASCII,readFloat:function(e,r){for(var i=t._binBE.ui8,n=0;n<4;n++)i[n]=e[r+n];return t._binBE.fl32[0]},readDouble:function(e,r){for(var i=t._binBE.ui8,n=0;n<8;n++)i[n]=e[r+n];return t._binBE.fl64[0]},writeUshort:function(t,e,r){t[e]=255&r,t[e+1]=r>>8&255},writeInt:function(e,r,i){var n=t._binBE.ui8;t._binBE.i32[0]=i,e[r+0]=n[0],e[r+1]=n[1],e[r+2]=n[2],e[r+3]=n[3]},writeUint:function(t,e,r){t[e]=r>>>0&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24&255},writeASCII:t._binBE.writeASCII},t._copyTile=function(t,e,r,i,n,a,o,s){for(var h=Math.min(e,n-o),l=Math.min(r,a-s),f=0;f<l;f++)for(var u=(s+f)*n+o,c=f*e,d=0;d<h;d++)i[u+d]=t[c+d]},t.LosslessJpegDecode=function(){var t,e;function r(){return t[e++]}function i(){return t[e++]<<8|t[e++]}function n(t){for(var e=r(),i=[0,0,0,255],n=[],o=0;o<16;o++)n[o]=r();for(o=0;o<16;o++)for(var s=0;s<n[o];s++)i[a(i,0,o+1,1)+3]=r();var h=new Uint8Array(256);for(t[e]=[new Uint8Array(i),h],o=0;o<256;o++){for(var l=8,f=o,u=0;255==i[u+3]&&0!=l;)u=i[u+(f>>--l&1)];h[o]=u}}function a(t,e,r,i){if(255!=t[e+3])return 0;if(0==r)return e;for(var n=0;n<2;n++){0==t[e+n]&&(t[e+n]=t.length,t.push(0,0,i,255));var o=a(t,t[e+n],r-1,i+1);if(0!=o)return o}return 0}function o(t){for(var e=t.b,r=t.a;e<25&&t.e<t.d;){var i=t.data[t.e++];t.c||(t.e+=i+1>>>8),r=r<<8|i,e+=8}if(e<0)throw\"e\";t.b=e,t.a=r}function s(t,e){return e.b<t&&o(e),e.a>>(e.b-=t)&65535>>16-t}function h(t,e){var r=t[0],i=0,n=255;e.b<16&&o(e);var a=e.a>>e.b-8&255;for(n=r[(i=t[1][a])+3],e.b-=r[i+2];255==n;)n=r[(i=r[i+(e.a>>--e.b&1)])+3];return n}function l(t,e){return t<32768>>16-e&&(t+=1-(1<<e)),t}function f(t,e){var r=h(t,e);return 0==r?0:16==r?-32768:l(s(r,e),r)}function u(t,e,r,i,n,a){for(var o=0;o<a;o++)for(var s=o*e,h=0;h<e;h+=n)for(var l=0;l<n;l++)t[s+h+l]=f(i[l],r)}function c(t,e){return l(s(t,e),t)}function d(t,e,r,i,n,a,o,s){for(var h=r*o,l=n;l<a;l++)t[l]+=1<<s-1;for(var f=o;f<h;f+=o)for(l=n;l<a;l++)t[f+l]+=t[f+l-o];for(var u=1;u<i;u++){var c=u*h;for(l=n;l<a;l++)t[c+l]+=t[c+l-h];for(f=o;f<h;f+=o)for(l=n;l<a;l++){var d=c+f+l,p=d-h,m=t[d-o],g=0;if(0==e)g=0;else if(1==e)g=m;else if(2==e)g=t[p];else if(3==e)g=t[p-o];else if(4==e)g=m+(t[p]-t[p-o]);else if(5==e)g=m+(t[p]-t[p-o]>>>1);else if(6==e)g=t[p]+(m-t[p-o]>>>1);else{if(7!=e)throw e;g=m+t[p]>>>1}t[d]+=g}}}return function(a){if(t=a,e=0,65496!=i())throw\"e\";for(var o=[],s=0,l=0,f=[],p=[],m=[],g=0,b=0,_=0;;){var y=i();if(65535!=y){var w=i();if(65475==y){l=r(),b=i(),_=i(),g=r();for(var v=0;v<g;v++){var x=r(),E=r();if(0!=r())throw\"e\";o[x]=[v,E>>4,15&E]}}else if(65476==y)for(var k=e+w-2;e<k;)n(p);else{if(65498==y){for(e++,v=0;v<g;v++){var S=o[r()];m[S[0]]=p[r()>>>4],f[S[0]]=S.slice(1)}s=r(),e+=2;break}e+=w-2}}else e--}var M=new(l>8?Uint16Array:Uint8Array)(b*_*g),A={b:0,a:0,c:8==s,e,data:t,d:t.length};if(A.c)!function(r,i,n,a,o){for(var s=t.length-e,l=0;l<s;l+=4){var f=t[e+l];t[e+l]=t[e+l+3],t[e+l+3]=f,f=t[e+l+1],t[e+l+1]=t[e+l+2],t[e+l+2]=f}for(var u=0;u<o;u++)for(var d=32768,p=32768,m=0;m<i;m+=2){var g=h(a,n),b=h(a,n);0!=g&&(d+=c(g,n)),0!=b&&(p+=c(b,n)),r[u*i+m]=65535&d,r[u*i+m+1]=65535&p}}(M,_*g,A,m[0],b);else{var I=[],B=0,T=0;for(v=0;v<g;v++){var R=f[v];(N=R[0])>B&&(B=N),(D=R[1])>T&&(T=D),I.push(N*D)}if(1!=B||1!=T){var P=[],O=0;for(v=0;v<g;v++){for(var L=0;L<I[v];L++)P.push(m[v]);O+=I[v]}var C=_/B,U=b/T;u(M,C*O,A,P,O,U),d(M,s,C,U,O-2,O,O,l);for(var z=M.slice(0),D=0;D<b;D++)for(var N=0;N<_;N++){var F=(D*_+N)*g,j=~~(D/T)*C+~~(N/B),G=0;for(v=0;v<g;v++){var H=1&N,W=j*O+G+(0==v?1==T?H:2*H+(1&D):0);M[F+v]=z[W],G+=I[v]}}d(M,s,_,b,0,1,g,l)}else u(M,_*g,A,m,g,b),d(M,s,_,b,0,g,g,l)}return M}}(),function(){var e=2,r=3,i=4,n=5,a=6,o=7,s=8,h=9,l=10,f=11,u=12,c=13,d=14,p=15,m=16,g=17;function b(t){for(var e=[[],[],[]],r=Math.max(2,t.w+32>>>6),i=0;i<3;i++)for(var n=0;n<41;n++)e[i][n]=[r,1];return e}function _(t,e){var r=0,i=8-t.a;if(t.j,t.a,e){if(e>=i)do{r<<=i,e-=i,r|=t[t.j]&(1<<i)-1,t.j++,i=8}while(e>=8);e&&(r<<=e,i-=e,r|=t[t.j]>>>i&(1<<e)-1),t.a=8-i}return r}function y(t,e,r,i,n,a,o,s){null==s&&(s=0);var h,l,f,u,c,d,p=a+1,m=p%2,g=0,b=i[n],y=i[n-1],w=i[n-2][p],v=y[p-1],x=y[p],E=y[p+1],k=b[p-1],S=b[p+1],M=Math.abs;if(m&&(f=M(E-x),u=M(w-x),c=M(v-x)),m){if(d=(d=f>c&&u<f?w+v:f<c&&u<c?w+E:E+v)+2*x>>>2,s)return void(b[p]=d);h=e.t*e.c[t.g+x-w]+e.c[t.g+v-x]}else d=x>v&&x>E||x<v&&x<E?S+k+2*x>>>2:k+S>>>1,h=e.t*e.c[t.g+x-v]+e.c[t.g+v-k];l=M(h);var A=function(t){for(var e=-1,r=0;!r;e++)r=t[t.j]>>>7-t.a&1,t.a++,t.a&=7,t.a||t.j++;return e}(r);if(A<t.n-e.v-1){var I=function(t,e){var r=0;if(e<t)for(;r<=14&&e<<++r<t;);return r}(o[l][0],o[l][1]);g=_(r,I)+(A<<I)}else g=_(r,e.v)+1;g=1&g?-1-(g>>>1):g>>>1,o[l][0]+=M(g),o[l][1]==t.f&&(o[l][0]>>>=1,o[l][1]>>>=1),o[l][1]++,d=h<0?d-g:d+g,t.i&&(d<0?d+=e.w:d>t.g&&(d-=e.w)),b[p]=d>=0?Math.min(d,t.g):0}function w(t,e,r){for(var i=t[0].length,n=e;n<=r;n++)t[n][0]=t[n-1][1],t[n][i-1]=t[n-1][i-2]}function v(t){w(t,o,u),w(t,e,i),w(t,p,g)}function x(t,e,r,n,a,o,s,h,l,f,u,d,p){for(var m=0,g=1,b=a<c&&a>i;g<t.m;)m<t.m&&(y(t,e,r,n,a,m,s[l],t.h&&(b&&f||!b&&(u||(m&d)==p))),y(t,e,r,n,o,m,s[l],t.h&&(!b&&f||b&&(u||(m&d)==p))),m+=2),m>8&&(y(t,e,r,n,a,g,h[l]),y(t,e,r,n,o,g,h[l]),g+=2);v(n)}function E(t,n,a,c,d,b){x(t,n,a,c,e,o,d,b,0,0,1,0,8),x(t,n,a,c,s,p,d,b,1,0,1,0,8),x(t,n,a,c,r,h,d,b,2,1,0,3,0),x(t,n,a,c,l,m,d,b,0,0,0,3,2),x(t,n,a,c,i,f,d,b,1,0,0,3,2),x(t,n,a,c,u,g,d,b,2,1,0,3,0)}function k(t,r,i,n,a,s){var h=s.length,l=t.l;a+1==t.s&&(l=t.e-a*t.l);for(var f=6*t.e*n+a*t.l,u=0;u<6;u++){for(var c=0;c<l;c++){var d,m=s[u%h][c%h];d=0==m?e+(u>>>1):2==m?p+(u>>>1):o+u;var g=t.h?(2*c/3&2147483646|c%3&1)+(c%3>>>1):c>>>1;r[f+c]=i[d][g+1]}f+=t.e}}t._decompressRAF=function(o,s){var h=function(e){var r=t._binBE.readUshort,i={b:r(e,0),i:e[2],C:e[3],u:e[4],q:r(e,5),k:r(e,7),e:r(e,9),l:r(e,11),s:e[13],d:r(e,14)};if(18771!=i.b||i.i>1||i.q<6||i.q%6||i.e<768||i.e%24||768!=i.l||i.k<i.l||i.k%i.l||i.k-i.e>=i.l||i.s>16||i.s!=i.k/i.l||i.s!=Math.ceil(i.e/i.l)||i.d!=i.q/6||12!=i.u&&14!=i.u&&16!=i.u||16!=i.C&&0!=i.C)throw\"Invalid data\";if(0==i.i)throw\"Not implemented. We need this file!\";return i.h=16==i.C,i.m=0|(i.h?2*i.l/3:i.l>>>1),i.A=i.m+2,i.f=64,i.g=(1<<i.u)-1,i.n=4*i.u,i}(o),l=function(e,r){var i=new Array(r.s),n=4*r.s,a=16+n;12&n&&(a+=16-(12&n));for(var o=0,s=16;o<r.s;s+=4){var h=t._binBE.readUint(e,s);i[o]=e.slice(a,a+h),i[o].j=0,i[o].a=0,a+=h,o++}if(a!=e.length)throw\"Invalid data\";return i}(o,h),p=function(t){var e={c:new Int8Array(2<<t.u)};return function(t,e,r){var i=[0,18,67,276,r];t.o=0,t.w=(i[4]+0)/1+1|0,t.v=Math.ceil(Math.log2(t.w)),t.t=9,function(t,e){for(var r=-e[4],i=0;r<=e[4];i++,r++)t[i]=r<=-e[3]?-4:r<=-e[2]?-3:r<=-e[1]?-2:r<-e[0]?-1:r<=e[0]?0:r<e[1]?1:r<e[2]?2:r<e[3]?3:4}(t.c,i)}(e,0,t.g),e}(h),_=new Int16Array(h.e*h.q);null==s&&(s=h.h?[[1,1,0,1,1,2],[1,1,2,1,1,0],[2,0,1,0,2,1],[1,1,2,1,1,0],[1,1,0,1,1,2],[0,2,1,2,0,1]]:[[0,1],[3,2]]);for(var y=[[0,r],[1,i],[n,f],[a,u],[c,m],[d,g]],w=[],x=0;x<18;x++)w[x]=new Uint16Array(h.A);for(var S=0;S<h.s;S++){var M=b(p),A=b(p);for(x=0;x<18;x++)for(var I=0;I<h.A;I++)w[x][I]=0;for(var B=0;B<h.d;B++){for(E(h,p,l[S],w,M,A),x=0;x<6;x++)for(I=0;I<h.A;I++)w[y[x][0]][I]=w[y[x][1]][I];for(k(h,_,w,B,S,s),x=e;x<18;x++)if(-1==[n,a,c,d].indexOf(x))for(I=0;I<h.A;I++)w[x][I]=0;v(w)}}return _}}()}(e,r(2845))}()},6168:(t,e,r)=>{\"use strict\";r.r(e),r.d(e,{DOMException:()=>v,Headers:()=>f,Request:()=>b,Response:()=>y,fetch:()=>x});var i=\"undefined\"!=typeof globalThis&&globalThis||\"undefined\"!=typeof self&&self||void 0!==i&&i,n={searchParams:\"URLSearchParams\"in i,iterable:\"Symbol\"in i&&\"iterator\"in Symbol,blob:\"FileReader\"in i&&\"Blob\"in i&&function(){try{return new Blob,!0}catch(t){return!1}}(),formData:\"FormData\"in i,arrayBuffer:\"ArrayBuffer\"in i};if(n.arrayBuffer)var a=[\"[object Int8Array]\",\"[object Uint8Array]\",\"[object Uint8ClampedArray]\",\"[object Int16Array]\",\"[object Uint16Array]\",\"[object Int32Array]\",\"[object Uint32Array]\",\"[object Float32Array]\",\"[object Float64Array]\"],o=ArrayBuffer.isView||function(t){return t&&a.indexOf(Object.prototype.toString.call(t))>-1};function s(t){if(\"string\"!=typeof t&&(t=String(t)),/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(t)||\"\"===t)throw new TypeError('Invalid character in header field name: \"'+t+'\"');return t.toLowerCase()}function h(t){return\"string\"!=typeof t&&(t=String(t)),t}function l(t){var e={next:function(){var e=t.shift();return{done:void 0===e,value:e}}};return n.iterable&&(e[Symbol.iterator]=function(){return e}),e}function f(t){this.map={},t instanceof f?t.forEach((function(t,e){this.append(e,t)}),this):Array.isArray(t)?t.forEach((function(t){this.append(t[0],t[1])}),this):t&&Object.getOwnPropertyNames(t).forEach((function(e){this.append(e,t[e])}),this)}function u(t){if(t.bodyUsed)return Promise.reject(new TypeError(\"Already read\"));t.bodyUsed=!0}function c(t){return new Promise((function(e,r){t.onload=function(){e(t.result)},t.onerror=function(){r(t.error)}}))}function d(t){var e=new FileReader,r=c(e);return e.readAsArrayBuffer(t),r}function p(t){if(t.slice)return t.slice(0);var e=new Uint8Array(t.byteLength);return e.set(new Uint8Array(t)),e.buffer}function m(){return this.bodyUsed=!1,this._initBody=function(t){var e;this.bodyUsed=this.bodyUsed,this._bodyInit=t,t?\"string\"==typeof t?this._bodyText=t:n.blob&&Blob.prototype.isPrototypeOf(t)?this._bodyBlob=t:n.formData&&FormData.prototype.isPrototypeOf(t)?this._bodyFormData=t:n.searchParams&&URLSearchParams.prototype.isPrototypeOf(t)?this._bodyText=t.toString():n.arrayBuffer&&n.blob&&(e=t)&&DataView.prototype.isPrototypeOf(e)?(this._bodyArrayBuffer=p(t.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):n.arrayBuffer&&(ArrayBuffer.prototype.isPrototypeOf(t)||o(t))?this._bodyArrayBuffer=p(t):this._bodyText=t=Object.prototype.toString.call(t):this._bodyText=\"\",this.headers.get(\"content-type\")||(\"string\"==typeof t?this.headers.set(\"content-type\",\"text/plain;charset=UTF-8\"):this._bodyBlob&&this._bodyBlob.type?this.headers.set(\"content-type\",this._bodyBlob.type):n.searchParams&&URLSearchParams.prototype.isPrototypeOf(t)&&this.headers.set(\"content-type\",\"application/x-www-form-urlencoded;charset=UTF-8\"))},n.blob&&(this.blob=function(){var t=u(this);if(t)return t;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error(\"could not read FormData body as blob\");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?u(this)||(ArrayBuffer.isView(this._bodyArrayBuffer)?Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset,this._bodyArrayBuffer.byteOffset+this._bodyArrayBuffer.byteLength)):Promise.resolve(this._bodyArrayBuffer)):this.blob().then(d)}),this.text=function(){var t,e,r,i=u(this);if(i)return i;if(this._bodyBlob)return t=this._bodyBlob,r=c(e=new FileReader),e.readAsText(t),r;if(this._bodyArrayBuffer)return Promise.resolve(function(t){for(var e=new Uint8Array(t),r=new Array(e.length),i=0;i<e.length;i++)r[i]=String.fromCharCode(e[i]);return r.join(\"\")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error(\"could not read FormData body as text\");return Promise.resolve(this._bodyText)},n.formData&&(this.formData=function(){return this.text().then(_)}),this.json=function(){return this.text().then(JSON.parse)},this}f.prototype.append=function(t,e){t=s(t),e=h(e);var r=this.map[t];this.map[t]=r?r+\", \"+e:e},f.prototype.delete=function(t){delete this.map[s(t)]},f.prototype.get=function(t){return t=s(t),this.has(t)?this.map[t]:null},f.prototype.has=function(t){return this.map.hasOwnProperty(s(t))},f.prototype.set=function(t,e){this.map[s(t)]=h(e)},f.prototype.forEach=function(t,e){for(var r in this.map)this.map.hasOwnProperty(r)&&t.call(e,this.map[r],r,this)},f.prototype.keys=function(){var t=[];return this.forEach((function(e,r){t.push(r)})),l(t)},f.prototype.values=function(){var t=[];return this.forEach((function(e){t.push(e)})),l(t)},f.prototype.entries=function(){var t=[];return this.forEach((function(e,r){t.push([r,e])})),l(t)},n.iterable&&(f.prototype[Symbol.iterator]=f.prototype.entries);var g=[\"DELETE\",\"GET\",\"HEAD\",\"OPTIONS\",\"POST\",\"PUT\"];function b(t,e){if(!(this instanceof b))throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');var r,i,n=(e=e||{}).body;if(t instanceof b){if(t.bodyUsed)throw new TypeError(\"Already read\");this.url=t.url,this.credentials=t.credentials,e.headers||(this.headers=new f(t.headers)),this.method=t.method,this.mode=t.mode,this.signal=t.signal,n||null==t._bodyInit||(n=t._bodyInit,t.bodyUsed=!0)}else this.url=String(t);if(this.credentials=e.credentials||this.credentials||\"same-origin\",!e.headers&&this.headers||(this.headers=new f(e.headers)),this.method=(i=(r=e.method||this.method||\"GET\").toUpperCase(),g.indexOf(i)>-1?i:r),this.mode=e.mode||this.mode||null,this.signal=e.signal||this.signal,this.referrer=null,(\"GET\"===this.method||\"HEAD\"===this.method)&&n)throw new TypeError(\"Body not allowed for GET or HEAD requests\");if(this._initBody(n),!(\"GET\"!==this.method&&\"HEAD\"!==this.method||\"no-store\"!==e.cache&&\"no-cache\"!==e.cache)){var a=/([?&])_=[^&]*/;a.test(this.url)?this.url=this.url.replace(a,\"$1_=\"+(new Date).getTime()):this.url+=(/\\?/.test(this.url)?\"&\":\"?\")+\"_=\"+(new Date).getTime()}}function _(t){var e=new FormData;return t.trim().split(\"&\").forEach((function(t){if(t){var r=t.split(\"=\"),i=r.shift().replace(/\\+/g,\" \"),n=r.join(\"=\").replace(/\\+/g,\" \");e.append(decodeURIComponent(i),decodeURIComponent(n))}})),e}function y(t,e){if(!(this instanceof y))throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');e||(e={}),this.type=\"default\",this.status=void 0===e.status?200:e.status,this.ok=this.status>=200&&this.status<300,this.statusText=void 0===e.statusText?\"\":\"\"+e.statusText,this.headers=new f(e.headers),this.url=e.url||\"\",this._initBody(t)}b.prototype.clone=function(){return new b(this,{body:this._bodyInit})},m.call(b.prototype),m.call(y.prototype),y.prototype.clone=function(){return new y(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new f(this.headers),url:this.url})},y.error=function(){var t=new y(null,{status:0,statusText:\"\"});return t.type=\"error\",t};var w=[301,302,303,307,308];y.redirect=function(t,e){if(-1===w.indexOf(e))throw new RangeError(\"Invalid status code\");return new y(null,{status:e,headers:{location:t}})};var v=i.DOMException;try{new v}catch(t){(v=function(t,e){this.message=t,this.name=e;var r=Error(t);this.stack=r.stack}).prototype=Object.create(Error.prototype),v.prototype.constructor=v}function x(t,e){return new Promise((function(r,a){var o=new b(t,e);if(o.signal&&o.signal.aborted)return a(new v(\"Aborted\",\"AbortError\"));var s=new XMLHttpRequest;function l(){s.abort()}s.onload=function(){var t,e,i={status:s.status,statusText:s.statusText,headers:(t=s.getAllResponseHeaders()||\"\",e=new f,t.replace(/\\r?\\n[\\t ]+/g,\" \").split(\"\\r\").map((function(t){return 0===t.indexOf(\"\\n\")?t.substr(1,t.length):t})).forEach((function(t){var r=t.split(\":\"),i=r.shift().trim();if(i){var n=r.join(\":\").trim();e.append(i,n)}})),e)};i.url=\"responseURL\"in s?s.responseURL:i.headers.get(\"X-Request-URL\");var n=\"response\"in s?s.response:s.responseText;setTimeout((function(){r(new y(n,i))}),0)},s.onerror=function(){setTimeout((function(){a(new TypeError(\"Network request failed\"))}),0)},s.ontimeout=function(){setTimeout((function(){a(new TypeError(\"Network request failed\"))}),0)},s.onabort=function(){setTimeout((function(){a(new v(\"Aborted\",\"AbortError\"))}),0)},s.open(o.method,function(t){try{return\"\"===t&&i.location.href?i.location.href:t}catch(e){return t}}(o.url),!0),\"include\"===o.credentials?s.withCredentials=!0:\"omit\"===o.credentials&&(s.withCredentials=!1),\"responseType\"in s&&(n.blob?s.responseType=\"blob\":n.arrayBuffer&&o.headers.get(\"Content-Type\")&&-1!==o.headers.get(\"Content-Type\").indexOf(\"application/octet-stream\")&&(s.responseType=\"arraybuffer\")),!e||\"object\"!=typeof e.headers||e.headers instanceof f?o.headers.forEach((function(t,e){s.setRequestHeader(e,t)})):Object.getOwnPropertyNames(e.headers).forEach((function(t){s.setRequestHeader(t,h(e.headers[t]))})),o.signal&&(o.signal.addEventListener(\"abort\",l),s.onreadystatechange=function(){4===s.readyState&&o.signal.removeEventListener(\"abort\",l)}),s.send(void 0===o._bodyInit?null:o._bodyInit)}))}x.polyfill=!0,i.fetch||(i.fetch=x,i.Headers=f,i.Request=b,i.Response=y)},6290:(t,e,r)=>{\"use strict\";var i=r(5048),n=r(9748),a=r(4655),o=r(1960);function s(t,e,r){var i=t;return n(e)?(r=e,\"string\"==typeof t&&(i={uri:t})):i=o(e,{uri:t}),i.callback=r,i}function h(t,e,r){return l(e=s(t,e,r))}function l(t){if(void 0===t.callback)throw new Error(\"callback argument missing\");var e=!1,r=function(r,i,n){e||(e=!0,t.callback(r,i,n))};function i(){var t=void 0;if(t=f.response?f.response:f.responseText||function(t){try{if(\"document\"===t.responseType)return t.responseXML;var e=t.responseXML&&\"parsererror\"===t.responseXML.documentElement.nodeName;if(\"\"===t.responseType&&!e)return t.responseXML}catch(t){}return null}(f),b)try{t=JSON.parse(t)}catch(t){}return t}function n(t){return clearTimeout(u),t instanceof Error||(t=new Error(\"\"+(t||\"Unknown XMLHttpRequest Error\"))),t.statusCode=0,r(t,_)}function o(){if(!l){var e;clearTimeout(u),e=t.useXDR&&void 0===f.status?200:1223===f.status?204:f.status;var n=_,o=null;return 0!==e?(n={body:i(),statusCode:e,method:d,headers:{},url:c,rawRequest:f},f.getAllResponseHeaders&&(n.headers=a(f.getAllResponseHeaders()))):o=new Error(\"Internal XMLHttpRequest Error\"),r(o,n,n.body)}}var s,l,f=t.xhr||null;f||(f=t.cors||t.useXDR?new h.XDomainRequest:new h.XMLHttpRequest);var u,c=f.url=t.uri||t.url,d=f.method=t.method||\"GET\",p=t.body||t.data,m=f.headers=t.headers||{},g=!!t.sync,b=!1,_={body:void 0,headers:{},statusCode:0,method:d,url:c,rawRequest:f};if(\"json\"in t&&!1!==t.json&&(b=!0,m.accept||m.Accept||(m.Accept=\"application/json\"),\"GET\"!==d&&\"HEAD\"!==d&&(m[\"content-type\"]||m[\"Content-Type\"]||(m[\"Content-Type\"]=\"application/json\"),p=JSON.stringify(!0===t.json?p:t.json))),f.onreadystatechange=function(){4===f.readyState&&setTimeout(o,0)},f.onload=o,f.onerror=n,f.onprogress=function(){},f.onabort=function(){l=!0},f.ontimeout=n,f.open(d,c,!g,t.username,t.password),g||(f.withCredentials=!!t.withCredentials),!g&&t.timeout>0&&(u=setTimeout((function(){if(!l){l=!0,f.abort(\"timeout\");var t=new Error(\"XMLHttpRequest timeout\");t.code=\"ETIMEDOUT\",n(t)}}),t.timeout)),f.setRequestHeader)for(s in m)m.hasOwnProperty(s)&&f.setRequestHeader(s,m[s]);else if(t.headers&&!function(t){for(var e in t)if(t.hasOwnProperty(e))return!1;return!0}(t.headers))throw new Error(\"Headers cannot be set on an XDomainRequest object\");return\"responseType\"in t&&(f.responseType=t.responseType),\"beforeSend\"in t&&\"function\"==typeof t.beforeSend&&t.beforeSend(f),f.send(p||null),f}t.exports=h,t.exports.default=h,h.XMLHttpRequest=i.XMLHttpRequest||function(){},h.XDomainRequest=\"withCredentials\"in new h.XMLHttpRequest?h.XMLHttpRequest:i.XDomainRequest,function(t,e){for(var r=0;r<t.length;r++)e(t[r])}([\"get\",\"put\",\"post\",\"patch\",\"head\",\"delete\"],(function(t){h[\"delete\"===t?\"del\":t]=function(e,r,i){return(r=s(e,r,i)).method=t.toUpperCase(),l(r)}}))},1596:t=>{t.exports=void 0!==self.DOMParser?function(t){return(new self.DOMParser).parseFromString(t,\"application/xml\")}:void 0!==self.ActiveXObject&&new self.ActiveXObject(\"Microsoft.XMLDOM\")?function(t){var e=new self.ActiveXObject(\"Microsoft.XMLDOM\");return e.async=\"false\",e.loadXML(t),e}:function(t){var e=document.createElement(\"div\");return e.innerHTML=t,e}},1960:t=>{t.exports=function(){for(var t={},r=0;r<arguments.length;r++){var i=arguments[r];for(var n in i)e.call(i,n)&&(t[n]=i[n])}return t};var e=Object.prototype.hasOwnProperty},8522:()=>{},6777:()=>{},5546:()=>{},2460:(t,e,r)=>{var i=r(4406),n=Object.defineProperty,a=Object.getOwnPropertyDescriptor,o=Object.getOwnPropertyNames,s=Object.prototype.hasOwnProperty,h=(t,e)=>{for(var r in e)n(t,r,{get:e[r],enumerable:!0})},l=(t=>(e,r)=>t&&t.get(e)||(r=((t,e,r,i)=>{if(e&&\"object\"==typeof e||\"function\"==typeof e)for(let r of o(e))s.call(t,r)||n(t,r,{get:()=>e[r],enumerable:!(i=a(e,r))||i.enumerable});return t})(n({},\"__esModule\",{value:!0}),e),t&&t.set(e,r),r))(\"undefined\"!=typeof WeakMap?new WeakMap:0),f=(t,e,r)=>(((t,e,r)=>{e in t?n(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r})(t,\"symbol\"!=typeof e?e+\"\":e,r),r),u={};h(u,{applyPalette:()=>te,applyPaletteSync:()=>$t,buildPalette:()=>Kt,buildPaletteSync:()=>Qt,constants:()=>c,conversion:()=>b,distance:()=>H,image:()=>Ct,palette:()=>ot,quality:()=>Wt,utils:()=>ct});var c={};h(c,{bt709:()=>d});var d={};h(d,{Y:()=>p,x:()=>m,y:()=>g});var p=(t=>(t[t.RED=.2126]=\"RED\",t[t.GREEN=.7152]=\"GREEN\",t[t.BLUE=.0722]=\"BLUE\",t[t.WHITE=1]=\"WHITE\",t))(p||{}),m=(t=>(t[t.RED=.64]=\"RED\",t[t.GREEN=.3]=\"GREEN\",t[t.BLUE=.15]=\"BLUE\",t[t.WHITE=.3127]=\"WHITE\",t))(m||{}),g=(t=>(t[t.RED=.33]=\"RED\",t[t.GREEN=.6]=\"GREEN\",t[t.BLUE=.06]=\"BLUE\",t[t.WHITE=.329]=\"WHITE\",t))(g||{}),b={};function _(t){return t>.04045?((t+.055)/1.055)**2.4:t/12.92}function y(t,e,r){return{x:.4124*(t=_(t/255))+.3576*(e=_(e/255))+.1805*(r=_(r/255)),y:.2126*t+.7152*e+.0722*r,z:.0193*t+.1192*e+.9505*r}}h(b,{lab2rgb:()=>G,lab2xyz:()=>N,rgb2hsl:()=>I,rgb2lab:()=>L,rgb2xyz:()=>y,xyz2lab:()=>O,xyz2rgb:()=>j});var w={};function v(t){return t*(Math.PI/180)}function x(t,e,r){let i=t;return i<e&&(i=e),i<r&&(i=r),i}function E(t,e,r){let i=t;return i>e&&(i=e),i>r&&(i=r),i}function k(t,e,r){return t>r&&(t=r),t<e&&(t=e),0|t}function S(t){return(t=Math.round(t))>255?t=255:t<0&&(t=0),t}function M(t){return t>255?t=255:t<0&&(t=0),t}function A(t,e){const r=typeof t[0];let i;if(\"number\"===r||\"string\"===r){const r=Object.create(null);for(let e=0,i=t.length;e<i;e++){const i=t[e];r[i]||0===r[i]||(r[i]=e)}i=t.sort(((t,i)=>e(t,i)||r[t]-r[i]))}else{const r=t.slice(0);i=t.sort(((t,i)=>e(t,i)||r.indexOf(t)-r.indexOf(i)))}return i}function I(t,e,r){const i=E(t,e,r),n=x(t,e,r),a=n-i,o=(i+n)/510;let s=0;o>0&&o<1&&(s=a/(o<.5?n+i:510-n-i));let h=0;return a>0&&(h=n===t?(e-r)/a:n===e?2+(r-t)/a:4+(t-e)/a,h*=60,h<0&&(h+=360)),{h,s,l:o}}h(w,{degrees2radians:()=>v,inRange0to255:()=>M,inRange0to255Rounded:()=>S,intInRange:()=>k,max3:()=>x,min3:()=>E,stableSort:()=>A});var B=.95047,T=1,R=1.08883;function P(t){return t>.008856?t**(1/3):7.787*t+16/116}function O(t,e,r){if(t=P(t/B),e=P(e/T),r=P(r/R),116*e-16<0)throw new Error(\"xxx\");return{L:Math.max(0,116*e-16),a:500*(t-e),b:200*(e-r)}}function L(t,e,r){const i=y(t,e,r);return O(i.x,i.y,i.z)}var C=.95047,U=1,z=1.08883;function D(t){return t>.206893034?t**3:(t-16/116)/7.787}function N(t,e,r){const i=(t+16)/116,n=i-r/200;return{x:C*D(e/500+i),y:U*D(i),z:z*D(n)}}function F(t){return t>.0031308?1.055*t**(1/2.4)-.055:12.92*t}function j(t,e,r){const i=F(3.2406*t+-1.5372*e+-.4986*r),n=F(-.9689*t+1.8758*e+.0415*r),a=F(.0557*t+-.204*e+1.057*r);return{r:S(255*i),g:S(255*n),b:S(255*a)}}function G(t,e,r){const i=N(t,e,r);return j(i.x,i.y,i.z)}var H={};h(H,{AbstractDistanceCalculator:()=>W,AbstractEuclidean:()=>Q,AbstractManhattan:()=>et,CIE94GraphicArts:()=>Y,CIE94Textiles:()=>Z,CIEDE2000:()=>X,CMetric:()=>J,Euclidean:()=>K,EuclideanBT709:()=>$,EuclideanBT709NoAlpha:()=>tt,Manhattan:()=>rt,ManhattanBT709:()=>nt,ManhattanNommyde:()=>it,PNGQuant:()=>at});var W=class{constructor(){f(this,\"_maxDistance\"),f(this,\"_whitePoint\"),this._setDefaults(),this.setWhitePoint(255,255,255,255)}setWhitePoint(t,e,r,i){this._whitePoint={r:t>0?255/t:0,g:e>0?255/e:0,b:r>0?255/r:0,a:i>0?255/i:0},this._maxDistance=this.calculateRaw(t,e,r,i,0,0,0,0)}calculateNormalized(t,e){return this.calculateRaw(t.r,t.g,t.b,t.a,e.r,e.g,e.b,e.a)/this._maxDistance}},q=class extends W{calculateRaw(t,e,r,i,n,a,o,s){const h=L(M(t*this._whitePoint.r),M(e*this._whitePoint.g),M(r*this._whitePoint.b)),l=L(M(n*this._whitePoint.r),M(a*this._whitePoint.g),M(o*this._whitePoint.b)),f=h.L-l.L,u=h.a-l.a,c=h.b-l.b,d=Math.sqrt(h.a*h.a+h.b*h.b),p=d-Math.sqrt(l.a*l.a+l.b*l.b);let m=u*u+c*c-p*p;m=m<0?0:Math.sqrt(m);const g=(s-i)*this._whitePoint.a*this._kA;return Math.sqrt((f/this._Kl)**2+(p/(1+this._K1*d))**2+(m/(1+this._K2*d))**2+g**2)}},Z=class extends q{_setDefaults(){this._Kl=2,this._K1=.048,this._K2=.014,this._kA=12.5/255}},Y=class extends q{_setDefaults(){this._Kl=1,this._K1=.045,this._K2=.015,this._kA=25/255}},V=class extends W{_setDefaults(){}static _calculatehp(t,e){const r=Math.atan2(t,e);return r>=0?r:r+V._deg360InRad}static _calculateRT(t,e){const r=e**7,i=2*Math.sqrt(r/(r+V._pow25to7)),n=V._deg30InRad*Math.exp(-(((t-V._deg275InRad)/V._deg25InRad)**2));return-Math.sin(2*n)*i}static _calculateT(t){return 1-.17*Math.cos(t-V._deg30InRad)+.24*Math.cos(2*t)+.32*Math.cos(3*t+V._deg6InRad)-.2*Math.cos(4*t-V._deg63InRad)}static _calculate_ahp(t,e,r,i){const n=r+i;return 0===t?n:e<=V._deg180InRad?n/2:n<V._deg360InRad?(n+V._deg360InRad)/2:(n-V._deg360InRad)/2}static _calculate_dHp(t,e,r,i){let n;return n=0===t?0:e<=V._deg180InRad?r-i:r<=i?r-i+V._deg360InRad:r-i-V._deg360InRad,2*Math.sqrt(t)*Math.sin(n/2)}calculateRaw(t,e,r,i,n,a,o,s){const h=L(M(t*this._whitePoint.r),M(e*this._whitePoint.g),M(r*this._whitePoint.b)),l=L(M(n*this._whitePoint.r),M(a*this._whitePoint.g),M(o*this._whitePoint.b)),f=(s-i)*this._whitePoint.a*V._kA,u=this.calculateRawInLab(h,l);return Math.sqrt(u+f*f)}calculateRawInLab(t,e){const r=t.L,i=t.a,n=t.b,a=e.L,o=e.a,s=e.b,h=((Math.sqrt(i*i+n*n)+Math.sqrt(o*o+s*s))/2)**7,l=.5*(1-Math.sqrt(h/(h+V._pow25to7))),f=(1+l)*i,u=(1+l)*o,c=Math.sqrt(f*f+n*n),d=Math.sqrt(u*u+s*s),p=c*d,m=V._calculatehp(n,f),g=V._calculatehp(s,u),b=Math.abs(m-g),_=a-r,y=d-c,w=V._calculate_dHp(p,b,g,m),v=V._calculate_ahp(p,b,m,g),x=(c+d)/2,E=((r+a)/2-50)**2,k=y/(1+.045*x),S=w/(1+.015*V._calculateT(v)*x);return(_/(1+.015*E/Math.sqrt(20+E)))**2+k**2+S**2+V._calculateRT(v,x)*k*S}},X=V;f(X,\"_kA\",25/255),f(X,\"_pow25to7\",25**7),f(X,\"_deg360InRad\",v(360)),f(X,\"_deg180InRad\",v(180)),f(X,\"_deg30InRad\",v(30)),f(X,\"_deg6InRad\",v(6)),f(X,\"_deg63InRad\",v(63)),f(X,\"_deg275InRad\",v(275)),f(X,\"_deg25InRad\",v(25));var J=class extends W{calculateRaw(t,e,r,i,n,a,o,s){const h=(t+n)/2*this._whitePoint.r,l=(t-n)*this._whitePoint.r,f=(e-a)*this._whitePoint.g,u=(r-o)*this._whitePoint.b,c=((512+h)*l*l>>8)+4*f*f+((767-h)*u*u>>8),d=(s-i)*this._whitePoint.a;return Math.sqrt(c+d*d)}_setDefaults(){}},Q=class extends W{calculateRaw(t,e,r,i,n,a,o,s){const h=n-t,l=a-e,f=o-r,u=s-i;return Math.sqrt(this._kR*h*h+this._kG*l*l+this._kB*f*f+this._kA*u*u)}},K=class extends Q{_setDefaults(){this._kR=1,this._kG=1,this._kB=1,this._kA=1}},$=class extends Q{_setDefaults(){this._kR=.2126,this._kG=.7152,this._kB=.0722,this._kA=1}},tt=class extends Q{_setDefaults(){this._kR=.2126,this._kG=.7152,this._kB=.0722,this._kA=0}},et=class extends W{calculateRaw(t,e,r,i,n,a,o,s){let h=n-t,l=a-e,f=o-r,u=s-i;return h<0&&(h=0-h),l<0&&(l=0-l),f<0&&(f=0-f),u<0&&(u=0-u),this._kR*h+this._kG*l+this._kB*f+this._kA*u}},rt=class extends et{_setDefaults(){this._kR=1,this._kG=1,this._kB=1,this._kA=1}},it=class extends et{_setDefaults(){this._kR=.4984,this._kG=.8625,this._kB=.2979,this._kA=1}},nt=class extends et{_setDefaults(){this._kR=.2126,this._kG=.7152,this._kB=.0722,this._kA=1}},at=class extends W{calculateRaw(t,e,r,i,n,a,o,s){const h=(s-i)*this._whitePoint.a;return this._colordifferenceCh(t*this._whitePoint.r,n*this._whitePoint.r,h)+this._colordifferenceCh(e*this._whitePoint.g,a*this._whitePoint.g,h)+this._colordifferenceCh(r*this._whitePoint.b,o*this._whitePoint.b,h)}_colordifferenceCh(t,e,r){const i=t-e,n=i+r;return i*i+n*n}_setDefaults(){}},ot={};h(ot,{AbstractPaletteQuantizer:()=>st,ColorHistogram:()=>kt,NeuQuant:()=>yt,NeuQuantFloat:()=>xt,RGBQuant:()=>Mt,WuColorCube:()=>Pt,WuQuant:()=>Lt});var st=class{quantizeSync(){for(const t of this.quantize())if(t.palette)return t.palette;throw new Error(\"unreachable\")}},ht=class{constructor(){f(this,\"r\"),f(this,\"g\"),f(this,\"b\"),f(this,\"a\"),f(this,\"uint32\"),f(this,\"rgba\"),this.uint32=-1>>>0,this.r=this.g=this.b=this.a=0,this.rgba=new Array(4),this.rgba[0]=0,this.rgba[1]=0,this.rgba[2]=0,this.rgba[3]=0}static createByQuadruplet(t){const e=new ht;return e.r=0|t[0],e.g=0|t[1],e.b=0|t[2],e.a=0|t[3],e._loadUINT32(),e._loadQuadruplet(),e}static createByRGBA(t,e,r,i){const n=new ht;return n.r=0|t,n.g=0|e,n.b=0|r,n.a=0|i,n._loadUINT32(),n._loadQuadruplet(),n}static createByUint32(t){const e=new ht;return e.uint32=t>>>0,e._loadRGBA(),e._loadQuadruplet(),e}from(t){this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this.uint32=t.uint32,this.rgba[0]=t.r,this.rgba[1]=t.g,this.rgba[2]=t.b,this.rgba[3]=t.a}getLuminosity(t){let e=this.r,r=this.g,i=this.b;return t&&(e=Math.min(255,255-this.a+this.a*e/255),r=Math.min(255,255-this.a+this.a*r/255),i=Math.min(255,255-this.a+this.a*i/255)),.2126*e+.7152*r+.0722*i}_loadUINT32(){this.uint32=(this.a<<24|this.b<<16|this.g<<8|this.r)>>>0}_loadRGBA(){this.r=255&this.uint32,this.g=this.uint32>>>8&255,this.b=this.uint32>>>16&255,this.a=this.uint32>>>24&255}_loadQuadruplet(){this.rgba[0]=this.r,this.rgba[1]=this.g,this.rgba[2]=this.b,this.rgba[3]=this.a}},lt=class{constructor(){f(this,\"_pointArray\"),f(this,\"_width\"),f(this,\"_height\"),this._width=0,this._height=0,this._pointArray=[]}getWidth(){return this._width}getHeight(){return this._height}setWidth(t){this._width=t}setHeight(t){this._height=t}getPointArray(){return this._pointArray}clone(){const t=new lt;t._width=this._width,t._height=this._height;for(let e=0,r=this._pointArray.length;e<r;e++)t._pointArray[e]=ht.createByUint32(0|this._pointArray[e].uint32);return t}toUint32Array(){const t=this._pointArray.length,e=new Uint32Array(t);for(let r=0;r<t;r++)e[r]=this._pointArray[r].uint32;return e}toUint8Array(){return new Uint8Array(this.toUint32Array().buffer)}static fromHTMLImageElement(t){const e=t.naturalWidth,r=t.naturalHeight,i=document.createElement(\"canvas\");return i.width=e,i.height=r,i.getContext(\"2d\").drawImage(t,0,0,e,r,0,0,e,r),lt.fromHTMLCanvasElement(i)}static fromHTMLCanvasElement(t){const e=t.width,r=t.height,i=t.getContext(\"2d\").getImageData(0,0,e,r);return lt.fromImageData(i)}static fromImageData(t){const e=t.width,r=t.height;return lt.fromUint8Array(t.data,e,r)}static fromUint8Array(t,e,r){switch(Object.prototype.toString.call(t)){case\"[object Uint8ClampedArray]\":case\"[object Uint8Array]\":break;default:t=new Uint8Array(t)}const i=new Uint32Array(t.buffer);return lt.fromUint32Array(i,e,r)}static fromUint32Array(t,e,r){const i=new lt;i._width=e,i._height=r;for(let e=0,r=t.length;e<r;e++)i._pointArray[e]=ht.createByUint32(0|t[e]);return i}static fromBuffer(t,e,r){const i=new Uint32Array(t.buffer,t.byteOffset,t.byteLength/Uint32Array.BYTES_PER_ELEMENT);return lt.fromUint32Array(i,e,r)}};function ft(t,e){const r=360/e;for(let i=1,n=r-r/2;i<e;i++,n+=r)if(t>=n&&t<n+r)return i;return 0}var ut=class{constructor(){f(this,\"_pointContainer\"),f(this,\"_pointArray\",[]),f(this,\"_i32idx\",{}),this._pointContainer=new lt,this._pointContainer.setHeight(1),this._pointArray=this._pointContainer.getPointArray()}add(t){this._pointArray.push(t),this._pointContainer.setWidth(this._pointArray.length)}has(t){for(let e=this._pointArray.length-1;e>=0;e--)if(t.uint32===this._pointArray[e].uint32)return!0;return!1}getNearestColor(t,e){return this._pointArray[0|this._getNearestIndex(t,e)]}getPointContainer(){return this._pointContainer}_nearestPointFromCache(t){return\"number\"==typeof this._i32idx[t]?this._i32idx[t]:-1}_getNearestIndex(t,e){let r=this._nearestPointFromCache(\"\"+e.uint32);if(r>=0)return r;let i=Number.MAX_VALUE;r=0;for(let n=0,a=this._pointArray.length;n<a;n++){const a=this._pointArray[n],o=t.calculateRaw(e.r,e.g,e.b,e.a,a.r,a.g,a.b,a.a);o<i&&(i=o,r=n)}return this._i32idx[e.uint32]=r,r}sort(){this._i32idx={},this._pointArray.sort(((t,e)=>{const r=I(t.r,t.g,t.b),i=I(e.r,e.g,e.b),n=t.r===t.g&&t.g===t.b?0:1+ft(r.h,10),a=(e.r===e.g&&e.g===e.b?0:1+ft(i.h,10))-n;if(a)return-a;const o=t.getLuminosity(!0),s=e.getLuminosity(!0);if(s-o!=0)return s-o;const h=(100*i.s|0)-(100*r.s|0);return h?-h:0}))}},ct={};h(ct,{HueStatistics:()=>pt,Palette:()=>ut,Point:()=>ht,PointContainer:()=>lt,ProgressTracker:()=>gt,arithmetic:()=>w});var dt=class{constructor(){f(this,\"num\",0),f(this,\"cols\",[])}},pt=class{constructor(t,e){f(this,\"_numGroups\"),f(this,\"_minCols\"),f(this,\"_stats\"),f(this,\"_groupsFull\"),this._numGroups=t,this._minCols=e,this._stats=[];for(let e=0;e<=t;e++)this._stats[e]=new dt;this._groupsFull=0}check(t){this._groupsFull===this._numGroups+1&&(this.check=()=>{});const e=255&t,r=t>>>8&255,i=t>>>16&255,n=e===r&&r===i?0:1+ft(I(e,r,i).h,this._numGroups),a=this._stats[n],o=this._minCols;a.num++,a.num>o||(a.num===o&&this._groupsFull++,a.num<=o&&this._stats[n].cols.push(t))}injectIntoDictionary(t){for(let e=0;e<=this._numGroups;e++)this._stats[e].num<=this._minCols&&this._stats[e].cols.forEach((e=>{t[e]?t[e]++:t[e]=1}))}injectIntoArray(t){for(let e=0;e<=this._numGroups;e++)this._stats[e].num<=this._minCols&&this._stats[e].cols.forEach((e=>{-1===t.indexOf(e)&&t.push(e)}))}},mt=class{constructor(t,e){f(this,\"progress\"),f(this,\"_step\"),f(this,\"_range\"),f(this,\"_last\"),f(this,\"_progressRange\"),this._range=t,this._progressRange=e,this._step=Math.max(1,this._range/(mt.steps+1)|0),this._last=-this._step,this.progress=0}shouldNotify(t){return t-this._last>=this._step&&(this._last=t,this.progress=Math.min(this._progressRange*this._last/this._range,this._progressRange),!0)}},gt=mt;f(gt,\"steps\",100);var bt=class{constructor(t){f(this,\"r\"),f(this,\"g\"),f(this,\"b\"),f(this,\"a\"),this.r=this.g=this.b=this.a=t}toPoint(){return ht.createByRGBA(this.r>>3,this.g>>3,this.b>>3,this.a>>3)}subtract(t,e,r,i){this.r-=0|t,this.g-=0|e,this.b-=0|r,this.a-=0|i}},_t=class extends st{constructor(t,e=256){super(),f(this,\"_pointArray\"),f(this,\"_networkSize\"),f(this,\"_network\"),f(this,\"_sampleFactor\"),f(this,\"_radPower\"),f(this,\"_freq\"),f(this,\"_bias\"),f(this,\"_distance\"),this._distance=t,this._pointArray=[],this._sampleFactor=1,this._networkSize=e,this._distance.setWhitePoint(2040,2040,2040,2040)}sample(t){this._pointArray=this._pointArray.concat(t.getPointArray())}*quantize(){this._init(),yield*this._learn(),yield{palette:this._buildPalette(),progress:100}}_init(){this._freq=[],this._bias=[],this._radPower=[],this._network=[];for(let t=0;t<this._networkSize;t++)this._network[t]=new bt((t<<11)/this._networkSize|0),this._freq[t]=_t._initialBias/this._networkSize|0,this._bias[t]=0}*_learn(){let t=this._sampleFactor;const e=this._pointArray.length;e<_t._minpicturebytes&&(t=1);const r=30+(t-1)/3|0,i=e/t|0;let n,a=i/_t._nCycles|0,o=_t._initAlpha,s=(this._networkSize>>3)*_t._radiusBias,h=s>>_t._radiusBiasShift;h<=1&&(h=0);for(let t=0;t<h;t++)this._radPower[t]=o*((h*h-t*t)*_t._radBias/(h*h))>>>0;n=e<_t._minpicturebytes?1:e%_t._prime1!=0?_t._prime1:e%_t._prime2!=0?_t._prime2:e%_t._prime3!=0?_t._prime3:_t._prime4;const l=new gt(i,99);for(let t=0,f=0;t<i;){l.shouldNotify(t)&&(yield{progress:l.progress});const i=this._pointArray[f],u=i.b<<3,c=i.g<<3,d=i.r<<3,p=i.a<<3,m=this._contest(u,c,d,p);if(this._alterSingle(o,m,u,c,d,p),0!==h&&this._alterNeighbour(h,m,u,c,d,p),f+=n,f>=e&&(f-=e),t++,0===a&&(a=1),t%a==0){o-=o/r|0,s-=s/_t._radiusDecrease|0,h=s>>_t._radiusBiasShift,h<=1&&(h=0);for(let t=0;t<h;t++)this._radPower[t]=o*((h*h-t*t)*_t._radBias/(h*h))>>>0}}}_buildPalette(){const t=new ut;return this._network.forEach((e=>{t.add(e.toPoint())})),t.sort(),t}_alterNeighbour(t,e,r,i,n,a){let o=e-t;o<-1&&(o=-1);let s=e+t;s>this._networkSize&&(s=this._networkSize);let h=e+1,l=e-1,f=1;for(;h<s||l>o;){const t=this._radPower[f++]/_t._alphaRadBias;if(h<s){const e=this._network[h++];e.subtract(t*(e.r-n),t*(e.g-i),t*(e.b-r),t*(e.a-a))}if(l>o){const e=this._network[l--];e.subtract(t*(e.r-n),t*(e.g-i),t*(e.b-r),t*(e.a-a))}}}_alterSingle(t,e,r,i,n,a){t/=_t._initAlpha;const o=this._network[e];o.subtract(t*(o.r-n),t*(o.g-i),t*(o.b-r),t*(o.a-a))}_contest(t,e,r,i){let n=~(1<<31),a=n,o=-1,s=o;for(let h=0;h<this._networkSize;h++){const l=this._network[h],f=8160*this._distance.calculateNormalized(l,{r,g:e,b:t,a:i})|0;f<n&&(n=f,o=h);const u=f-(this._bias[h]>>_t._initialBiasShift-3);u<a&&(a=u,s=h);const c=this._freq[h]>>_t._betaShift;this._freq[h]-=c,this._bias[h]+=c<<_t._gammaShift}return this._freq[o]+=_t._beta,this._bias[o]-=_t._betaGamma,s}},yt=_t;f(yt,\"_prime1\",499),f(yt,\"_prime2\",491),f(yt,\"_prime3\",487),f(yt,\"_prime4\",503),f(yt,\"_minpicturebytes\",_t._prime4),f(yt,\"_nCycles\",100),f(yt,\"_initialBiasShift\",16),f(yt,\"_initialBias\",1<<_t._initialBiasShift),f(yt,\"_gammaShift\",10),f(yt,\"_betaShift\",10),f(yt,\"_beta\",_t._initialBias>>_t._betaShift),f(yt,\"_betaGamma\",_t._initialBias<<_t._gammaShift-_t._betaShift),f(yt,\"_radiusBiasShift\",6),f(yt,\"_radiusBias\",1<<_t._radiusBiasShift),f(yt,\"_radiusDecrease\",30),f(yt,\"_alphaBiasShift\",10),f(yt,\"_initAlpha\",1<<_t._alphaBiasShift),f(yt,\"_radBiasShift\",8),f(yt,\"_radBias\",1<<_t._radBiasShift),f(yt,\"_alphaRadBiasShift\",_t._alphaBiasShift+_t._radBiasShift),f(yt,\"_alphaRadBias\",1<<_t._alphaRadBiasShift);var wt=class{constructor(t){f(this,\"r\"),f(this,\"g\"),f(this,\"b\"),f(this,\"a\"),this.r=this.g=this.b=this.a=t}toPoint(){return ht.createByRGBA(this.r>>3,this.g>>3,this.b>>3,this.a>>3)}subtract(t,e,r,i){this.r-=t,this.g-=e,this.b-=r,this.a-=i}},vt=class extends st{constructor(t,e=256){super(),f(this,\"_pointArray\"),f(this,\"_networkSize\"),f(this,\"_network\"),f(this,\"_sampleFactor\"),f(this,\"_radPower\"),f(this,\"_freq\"),f(this,\"_bias\"),f(this,\"_distance\"),this._distance=t,this._pointArray=[],this._sampleFactor=1,this._networkSize=e,this._distance.setWhitePoint(2040,2040,2040,2040)}sample(t){this._pointArray=this._pointArray.concat(t.getPointArray())}*quantize(){this._init(),yield*this._learn(),yield{palette:this._buildPalette(),progress:100}}_init(){this._freq=[],this._bias=[],this._radPower=[],this._network=[];for(let t=0;t<this._networkSize;t++)this._network[t]=new wt((t<<11)/this._networkSize),this._freq[t]=vt._initialBias/this._networkSize,this._bias[t]=0}*_learn(){let t=this._sampleFactor;const e=this._pointArray.length;e<vt._minpicturebytes&&(t=1);const r=30+(t-1)/3,i=e/t;let n,a=i/vt._nCycles|0,o=vt._initAlpha,s=(this._networkSize>>3)*vt._radiusBias,h=s>>vt._radiusBiasShift;h<=1&&(h=0);for(let t=0;t<h;t++)this._radPower[t]=o*((h*h-t*t)*vt._radBias/(h*h));n=e<vt._minpicturebytes?1:e%vt._prime1!=0?vt._prime1:e%vt._prime2!=0?vt._prime2:e%vt._prime3!=0?vt._prime3:vt._prime4;const l=new gt(i,99);for(let t=0,f=0;t<i;){l.shouldNotify(t)&&(yield{progress:l.progress});const i=this._pointArray[f],u=i.b<<3,c=i.g<<3,d=i.r<<3,p=i.a<<3,m=this._contest(u,c,d,p);if(this._alterSingle(o,m,u,c,d,p),0!==h&&this._alterNeighbour(h,m,u,c,d,p),f+=n,f>=e&&(f-=e),t++,0===a&&(a=1),t%a==0){o-=o/r,s-=s/vt._radiusDecrease,h=s>>vt._radiusBiasShift,h<=1&&(h=0);for(let t=0;t<h;t++)this._radPower[t]=o*((h*h-t*t)*vt._radBias/(h*h))}}}_buildPalette(){const t=new ut;return this._network.forEach((e=>{t.add(e.toPoint())})),t.sort(),t}_alterNeighbour(t,e,r,i,n,a){let o=e-t;o<-1&&(o=-1);let s=e+t;s>this._networkSize&&(s=this._networkSize);let h=e+1,l=e-1,f=1;for(;h<s||l>o;){const t=this._radPower[f++]/vt._alphaRadBias;if(h<s){const e=this._network[h++];e.subtract(t*(e.r-n),t*(e.g-i),t*(e.b-r),t*(e.a-a))}if(l>o){const e=this._network[l--];e.subtract(t*(e.r-n),t*(e.g-i),t*(e.b-r),t*(e.a-a))}}}_alterSingle(t,e,r,i,n,a){t/=vt._initAlpha;const o=this._network[e];o.subtract(t*(o.r-n),t*(o.g-i),t*(o.b-r),t*(o.a-a))}_contest(t,e,r,i){let n=~(1<<31),a=n,o=-1,s=o;for(let h=0;h<this._networkSize;h++){const l=this._network[h],f=8160*this._distance.calculateNormalized(l,{r,g:e,b:t,a:i});f<n&&(n=f,o=h);const u=f-(this._bias[h]>>vt._initialBiasShift-3);u<a&&(a=u,s=h);const c=this._freq[h]>>vt._betaShift;this._freq[h]-=c,this._bias[h]+=c<<vt._gammaShift}return this._freq[o]+=vt._beta,this._bias[o]-=vt._betaGamma,s}},xt=vt;f(xt,\"_prime1\",499),f(xt,\"_prime2\",491),f(xt,\"_prime3\",487),f(xt,\"_prime4\",503),f(xt,\"_minpicturebytes\",vt._prime4),f(xt,\"_nCycles\",100),f(xt,\"_initialBiasShift\",16),f(xt,\"_initialBias\",1<<vt._initialBiasShift),f(xt,\"_gammaShift\",10),f(xt,\"_betaShift\",10),f(xt,\"_beta\",vt._initialBias>>vt._betaShift),f(xt,\"_betaGamma\",vt._initialBias<<vt._gammaShift-vt._betaShift),f(xt,\"_radiusBiasShift\",6),f(xt,\"_radiusBias\",1<<vt._radiusBiasShift),f(xt,\"_radiusDecrease\",30),f(xt,\"_alphaBiasShift\",10),f(xt,\"_initAlpha\",1<<vt._alphaBiasShift),f(xt,\"_radBiasShift\",8),f(xt,\"_radBias\",1<<vt._radBiasShift),f(xt,\"_alphaRadBiasShift\",vt._alphaBiasShift+vt._radBiasShift),f(xt,\"_alphaRadBias\",1<<vt._alphaRadBiasShift);var Et=class{constructor(t,e){f(this,\"_method\"),f(this,\"_hueStats\"),f(this,\"_histogram\"),f(this,\"_initColors\"),f(this,\"_minHueCols\"),this._method=t,this._minHueCols=e<<2,this._initColors=e<<2,this._hueStats=new pt(Et._hueGroups,this._minHueCols),this._histogram=Object.create(null)}sample(t){switch(this._method){case 1:this._colorStats1D(t);break;case 2:this._colorStats2D(t)}}getImportanceSortedColorsIDXI32(){const t=A(Object.keys(this._histogram),((t,e)=>this._histogram[e]-this._histogram[t]));if(0===t.length)return[];let e;switch(this._method){case 1:const r=Math.min(t.length,this._initColors),i=t[r-1],n=this._histogram[i];e=t.slice(0,r);let a=r;const o=t.length;for(;a<o&&this._histogram[t[a]]===n;)e.push(t[a++]);this._hueStats.injectIntoArray(e);break;case 2:e=t;break;default:throw new Error(\"Incorrect method\")}return e.map((t=>+t))}_colorStats1D(t){const e=this._histogram,r=t.getPointArray(),i=r.length;for(let t=0;t<i;t++){const i=r[t].uint32;this._hueStats.check(i),i in e?e[i]++:e[i]=1}}_colorStats2D(t){const e=t.getWidth(),r=t.getHeight(),i=t.getPointArray(),n=Et._boxSize[0],a=Et._boxSize[1],o=n*a,s=this._makeBoxes(e,r,n,a),h=this._histogram;s.forEach((t=>{let r=Math.round(t.w*t.h/o)*Et._boxPixels;r<2&&(r=2);const n={};this._iterateBox(t,e,(t=>{const e=i[t].uint32;this._hueStats.check(e),e in h?h[e]++:e in n?++n[e]>=r&&(h[e]=n[e]):n[e]=1}))})),this._hueStats.injectIntoDictionary(h)}_iterateBox(t,e,r){const i=t,n=i.y*e+i.x,a=(i.y+i.h-1)*e+(i.x+i.w-1),o=e-i.w+1;let s=0,h=n;do{r.call(this,h),h+=++s%i.w==0?o:1}while(h<=a)}_makeBoxes(t,e,r,i){const n=t%r,a=e%i,o=t-n,s=e-a,h=[];for(let l=0;l<e;l+=i)for(let e=0;e<t;e+=r)h.push({x:e,y:l,w:e===o?n:r,h:l===s?a:i});return h}},kt=Et;f(kt,\"_boxSize\",[64,64]),f(kt,\"_boxPixels\",2),f(kt,\"_hueGroups\",10);var St=class{constructor(t,e,r){f(this,\"index\"),f(this,\"color\"),f(this,\"distance\"),this.index=t,this.color=e,this.distance=r}},Mt=class extends st{constructor(t,e=256,r=2){super(),f(this,\"_colors\"),f(this,\"_initialDistance\"),f(this,\"_distanceIncrement\"),f(this,\"_histogram\"),f(this,\"_distance\"),this._distance=t,this._colors=e,this._histogram=new kt(r,e),this._initialDistance=.01,this._distanceIncrement=.005}sample(t){this._histogram.sample(t)}*quantize(){const t=this._histogram.getImportanceSortedColorsIDXI32();if(0===t.length)throw new Error(\"No colors in image\");yield*this._buildPalette(t)}*_buildPalette(t){const e=new ut,r=e.getPointContainer().getPointArray(),i=new Array(t.length);for(let e=0;e<t.length;e++)r.push(ht.createByUint32(t[e])),i[e]=1;const n=r.length,a=[];let o=n,s=this._initialDistance;const h=new gt(o-this._colors,99);for(;o>this._colors;){a.length=0;for(let t=0;t<n;t++){if(h.shouldNotify(n-o)&&(yield{progress:h.progress}),0===i[t])continue;const e=r[t];for(let h=t+1;h<n;h++){if(0===i[h])continue;const t=r[h],n=this._distance.calculateNormalized(e,t);n<s&&(a.push(new St(h,t,n)),i[h]=0,o--)}}s+=o>3*this._colors?this._initialDistance:this._distanceIncrement}if(o<this._colors){A(a,((t,e)=>e.distance-t.distance));let t=0;for(;o<this._colors&&t<a.length;)i[a[t].index]=1,o++,t++}let l=r.length;for(let t=l-1;t>=0;t--)0===i[t]&&(t!==l-1&&(r[t]=r[l-1]),--l);r.length=l,e.sort(),yield{palette:e,progress:100}}};function At(t){const e=[];for(let r=0;r<t;r++)e[r]=0;return e}function It(t,e,r,i){const n=new Array(t);for(let a=0;a<t;a++){n[a]=new Array(e);for(let t=0;t<e;t++){n[a][t]=new Array(r);for(let e=0;e<r;e++){n[a][t][e]=new Array(i);for(let r=0;r<i;r++)n[a][t][e][r]=0}}}return n}function Bt(t,e,r){const i=new Array(t);for(let n=0;n<t;n++){i[n]=new Array(e);for(let t=0;t<e;t++){i[n][t]=new Array(r);for(let e=0;e<r;e++)i[n][t][e]=0}}return i}function Tt(t,e,r,i,n){for(let a=0;a<e;a++){t[a]=[];for(let e=0;e<r;e++){t[a][e]=[];for(let r=0;r<i;r++)t[a][e][r]=n}}}function Rt(t,e,r){for(let i=0;i<e;i++)t[i]=r}var Pt=class{constructor(){f(this,\"redMinimum\"),f(this,\"redMaximum\"),f(this,\"greenMinimum\"),f(this,\"greenMaximum\"),f(this,\"blueMinimum\"),f(this,\"blueMaximum\"),f(this,\"volume\"),f(this,\"alphaMinimum\"),f(this,\"alphaMaximum\")}},Ot=class extends st{constructor(t,e=256,r=5){super(),f(this,\"_reds\"),f(this,\"_greens\"),f(this,\"_blues\"),f(this,\"_alphas\"),f(this,\"_sums\"),f(this,\"_weights\"),f(this,\"_momentsRed\"),f(this,\"_momentsGreen\"),f(this,\"_momentsBlue\"),f(this,\"_momentsAlpha\"),f(this,\"_moments\"),f(this,\"_table\"),f(this,\"_pixels\"),f(this,\"_cubes\"),f(this,\"_colors\"),f(this,\"_significantBitsPerChannel\"),f(this,\"_maxSideIndex\"),f(this,\"_alphaMaxSideIndex\"),f(this,\"_sideSize\"),f(this,\"_alphaSideSize\"),f(this,\"_distance\"),this._distance=t,this._setQuality(r),this._initialize(e)}sample(t){const e=t.getPointArray();for(let t=0,r=e.length;t<r;t++)this._addColor(e[t]);this._pixels=this._pixels.concat(e)}*quantize(){yield*this._preparePalette();const t=new ut;for(let e=0;e<this._colors;e++)if(this._sums[e]>0){const r=this._sums[e],i=this._reds[e]/r,n=this._greens[e]/r,a=this._blues[e]/r,o=this._alphas[e]/r,s=ht.createByRGBA(0|i,0|n,0|a,0|o);t.add(s)}t.sort(),yield{palette:t,progress:100}}*_preparePalette(){yield*this._calculateMoments();let t=0;const e=At(this._colors);for(let r=1;r<this._colors;++r){this._cut(this._cubes[t],this._cubes[r])?(e[t]=this._cubes[t].volume>1?this._calculateVariance(this._cubes[t]):0,e[r]=this._cubes[r].volume>1?this._calculateVariance(this._cubes[r]):0):(e[t]=0,r--),t=0;let i=e[0];for(let n=1;n<=r;++n)e[n]>i&&(i=e[n],t=n);if(i<=0){this._colors=r+1;break}}const r=[],i=[],n=[],a=[];for(let t=0;t<this._colors;++t){const e=Ot._volume(this._cubes[t],this._weights);e>0?(r[t]=Ot._volume(this._cubes[t],this._momentsRed)/e|0,i[t]=Ot._volume(this._cubes[t],this._momentsGreen)/e|0,n[t]=Ot._volume(this._cubes[t],this._momentsBlue)/e|0,a[t]=Ot._volume(this._cubes[t],this._momentsAlpha)/e|0):(r[t]=0,i[t]=0,n[t]=0,a[t]=0)}this._reds=At(this._colors+1),this._greens=At(this._colors+1),this._blues=At(this._colors+1),this._alphas=At(this._colors+1),this._sums=At(this._colors+1);for(let t=0,e=this._pixels.length;t<e;t++){const e=this._pixels[t];let o=-1,s=Number.MAX_VALUE;for(let t=0;t<this._colors;t++){const h=r[t],l=i[t],f=n[t],u=a[t],c=this._distance.calculateRaw(h,l,f,u,e.r,e.g,e.b,e.a);c<s&&(s=c,o=t)}this._reds[o]+=e.r,this._greens[o]+=e.g,this._blues[o]+=e.b,this._alphas[o]+=e.a,this._sums[o]++}}_addColor(t){const e=8-this._significantBitsPerChannel,r=1+(t.r>>e),i=1+(t.g>>e),n=1+(t.b>>e),a=1+(t.a>>e);this._weights[a][r][i][n]++,this._momentsRed[a][r][i][n]+=t.r,this._momentsGreen[a][r][i][n]+=t.g,this._momentsBlue[a][r][i][n]+=t.b,this._momentsAlpha[a][r][i][n]+=t.a,this._moments[a][r][i][n]+=this._table[t.r]+this._table[t.g]+this._table[t.b]+this._table[t.a]}*_calculateMoments(){const t=[],e=[],r=[],i=[],n=[],a=[],o=Bt(this._sideSize,this._sideSize,this._sideSize),s=Bt(this._sideSize,this._sideSize,this._sideSize),h=Bt(this._sideSize,this._sideSize,this._sideSize),l=Bt(this._sideSize,this._sideSize,this._sideSize),f=Bt(this._sideSize,this._sideSize,this._sideSize),u=Bt(this._sideSize,this._sideSize,this._sideSize);let c=0;const d=new gt(this._alphaMaxSideIndex*this._maxSideIndex,99);for(let p=1;p<=this._alphaMaxSideIndex;++p){Tt(o,this._sideSize,this._sideSize,this._sideSize,0),Tt(s,this._sideSize,this._sideSize,this._sideSize,0),Tt(h,this._sideSize,this._sideSize,this._sideSize,0),Tt(l,this._sideSize,this._sideSize,this._sideSize,0),Tt(f,this._sideSize,this._sideSize,this._sideSize,0),Tt(u,this._sideSize,this._sideSize,this._sideSize,0);for(let m=1;m<=this._maxSideIndex;++m,++c){d.shouldNotify(c)&&(yield{progress:d.progress}),Rt(t,this._sideSize,0),Rt(e,this._sideSize,0),Rt(r,this._sideSize,0),Rt(i,this._sideSize,0),Rt(n,this._sideSize,0),Rt(a,this._sideSize,0);for(let c=1;c<=this._maxSideIndex;++c){let d=0,g=0,b=0,_=0,y=0,w=0;for(let v=1;v<=this._maxSideIndex;++v)d+=this._weights[p][m][c][v],g+=this._momentsRed[p][m][c][v],b+=this._momentsGreen[p][m][c][v],_+=this._momentsBlue[p][m][c][v],y+=this._momentsAlpha[p][m][c][v],w+=this._moments[p][m][c][v],t[v]+=d,e[v]+=g,r[v]+=b,i[v]+=_,n[v]+=y,a[v]+=w,o[m][c][v]=o[m-1][c][v]+t[v],s[m][c][v]=s[m-1][c][v]+e[v],h[m][c][v]=h[m-1][c][v]+r[v],l[m][c][v]=l[m-1][c][v]+i[v],f[m][c][v]=f[m-1][c][v]+n[v],u[m][c][v]=u[m-1][c][v]+a[v],this._weights[p][m][c][v]=this._weights[p-1][m][c][v]+o[m][c][v],this._momentsRed[p][m][c][v]=this._momentsRed[p-1][m][c][v]+s[m][c][v],this._momentsGreen[p][m][c][v]=this._momentsGreen[p-1][m][c][v]+h[m][c][v],this._momentsBlue[p][m][c][v]=this._momentsBlue[p-1][m][c][v]+l[m][c][v],this._momentsAlpha[p][m][c][v]=this._momentsAlpha[p-1][m][c][v]+f[m][c][v],this._moments[p][m][c][v]=this._moments[p-1][m][c][v]+u[m][c][v]}}}}static _volumeFloat(t,e){return e[t.alphaMaximum][t.redMaximum][t.greenMaximum][t.blueMaximum]-e[t.alphaMaximum][t.redMaximum][t.greenMinimum][t.blueMaximum]-e[t.alphaMaximum][t.redMinimum][t.greenMaximum][t.blueMaximum]+e[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMaximum]-e[t.alphaMinimum][t.redMaximum][t.greenMaximum][t.blueMaximum]+e[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMaximum]+e[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMaximum]-e[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMaximum]-(e[t.alphaMaximum][t.redMaximum][t.greenMaximum][t.blueMinimum]-e[t.alphaMinimum][t.redMaximum][t.greenMaximum][t.blueMinimum]-e[t.alphaMaximum][t.redMaximum][t.greenMinimum][t.blueMinimum]+e[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMinimum]-e[t.alphaMaximum][t.redMinimum][t.greenMaximum][t.blueMinimum]+e[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMinimum]+e[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMinimum]-e[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMinimum])}static _volume(t,e){return 0|Ot._volumeFloat(t,e)}static _top(t,e,r,i){let n;switch(e){case Ot._alpha:n=i[r][t.redMaximum][t.greenMaximum][t.blueMaximum]-i[r][t.redMaximum][t.greenMinimum][t.blueMaximum]-i[r][t.redMinimum][t.greenMaximum][t.blueMaximum]+i[r][t.redMinimum][t.greenMinimum][t.blueMaximum]-(i[r][t.redMaximum][t.greenMaximum][t.blueMinimum]-i[r][t.redMaximum][t.greenMinimum][t.blueMinimum]-i[r][t.redMinimum][t.greenMaximum][t.blueMinimum]+i[r][t.redMinimum][t.greenMinimum][t.blueMinimum]);break;case Ot._red:n=i[t.alphaMaximum][r][t.greenMaximum][t.blueMaximum]-i[t.alphaMaximum][r][t.greenMinimum][t.blueMaximum]-i[t.alphaMinimum][r][t.greenMaximum][t.blueMaximum]+i[t.alphaMinimum][r][t.greenMinimum][t.blueMaximum]-(i[t.alphaMaximum][r][t.greenMaximum][t.blueMinimum]-i[t.alphaMaximum][r][t.greenMinimum][t.blueMinimum]-i[t.alphaMinimum][r][t.greenMaximum][t.blueMinimum]+i[t.alphaMinimum][r][t.greenMinimum][t.blueMinimum]);break;case Ot._green:n=i[t.alphaMaximum][t.redMaximum][r][t.blueMaximum]-i[t.alphaMaximum][t.redMinimum][r][t.blueMaximum]-i[t.alphaMinimum][t.redMaximum][r][t.blueMaximum]+i[t.alphaMinimum][t.redMinimum][r][t.blueMaximum]-(i[t.alphaMaximum][t.redMaximum][r][t.blueMinimum]-i[t.alphaMaximum][t.redMinimum][r][t.blueMinimum]-i[t.alphaMinimum][t.redMaximum][r][t.blueMinimum]+i[t.alphaMinimum][t.redMinimum][r][t.blueMinimum]);break;case Ot._blue:n=i[t.alphaMaximum][t.redMaximum][t.greenMaximum][r]-i[t.alphaMaximum][t.redMaximum][t.greenMinimum][r]-i[t.alphaMaximum][t.redMinimum][t.greenMaximum][r]+i[t.alphaMaximum][t.redMinimum][t.greenMinimum][r]-(i[t.alphaMinimum][t.redMaximum][t.greenMaximum][r]-i[t.alphaMinimum][t.redMaximum][t.greenMinimum][r]-i[t.alphaMinimum][t.redMinimum][t.greenMaximum][r]+i[t.alphaMinimum][t.redMinimum][t.greenMinimum][r]);break;default:throw new Error(\"impossible\")}return 0|n}static _bottom(t,e,r){switch(e){case Ot._alpha:return-r[t.alphaMinimum][t.redMaximum][t.greenMaximum][t.blueMaximum]+r[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMaximum]+r[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMaximum]-r[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMaximum]-(-r[t.alphaMinimum][t.redMaximum][t.greenMaximum][t.blueMinimum]+r[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMinimum]+r[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMinimum]-r[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMinimum]);case Ot._red:return-r[t.alphaMaximum][t.redMinimum][t.greenMaximum][t.blueMaximum]+r[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMaximum]+r[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMaximum]-r[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMaximum]-(-r[t.alphaMaximum][t.redMinimum][t.greenMaximum][t.blueMinimum]+r[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMinimum]+r[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMinimum]-r[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMinimum]);case Ot._green:return-r[t.alphaMaximum][t.redMaximum][t.greenMinimum][t.blueMaximum]+r[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMaximum]+r[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMaximum]-r[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMaximum]-(-r[t.alphaMaximum][t.redMaximum][t.greenMinimum][t.blueMinimum]+r[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMinimum]+r[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMinimum]-r[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMinimum]);case Ot._blue:return-r[t.alphaMaximum][t.redMaximum][t.greenMaximum][t.blueMinimum]+r[t.alphaMaximum][t.redMaximum][t.greenMinimum][t.blueMinimum]+r[t.alphaMaximum][t.redMinimum][t.greenMaximum][t.blueMinimum]-r[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMinimum]-(-r[t.alphaMinimum][t.redMaximum][t.greenMaximum][t.blueMinimum]+r[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMinimum]+r[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMinimum]-r[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMinimum]);default:return 0}}_calculateVariance(t){const e=Ot._volume(t,this._momentsRed),r=Ot._volume(t,this._momentsGreen),i=Ot._volume(t,this._momentsBlue),n=Ot._volume(t,this._momentsAlpha);return Ot._volumeFloat(t,this._moments)-(e*e+r*r+i*i+n*n)/Ot._volume(t,this._weights)}_maximize(t,e,r,i,n,a,o,s,h){const l=0|Ot._bottom(t,e,this._momentsRed),f=0|Ot._bottom(t,e,this._momentsGreen),u=0|Ot._bottom(t,e,this._momentsBlue),c=0|Ot._bottom(t,e,this._momentsAlpha),d=0|Ot._bottom(t,e,this._weights);let p=0,m=-1;for(let g=r;g<i;++g){let r=l+Ot._top(t,e,g,this._momentsRed),i=f+Ot._top(t,e,g,this._momentsGreen),b=u+Ot._top(t,e,g,this._momentsBlue),_=c+Ot._top(t,e,g,this._momentsAlpha),y=d+Ot._top(t,e,g,this._weights);if(0!==y){let t=r*r+i*i+b*b+_*_,e=t/y;r=n-r,i=a-i,b=o-b,_=s-_,y=h-y,0!==y&&(t=r*r+i*i+b*b+_*_,e+=t/y,e>p&&(p=e,m=g))}}return{max:p,position:m}}_cut(t,e){let r;const i=Ot._volume(t,this._momentsRed),n=Ot._volume(t,this._momentsGreen),a=Ot._volume(t,this._momentsBlue),o=Ot._volume(t,this._momentsAlpha),s=Ot._volume(t,this._weights),h=this._maximize(t,Ot._red,t.redMinimum+1,t.redMaximum,i,n,a,o,s),l=this._maximize(t,Ot._green,t.greenMinimum+1,t.greenMaximum,i,n,a,o,s),f=this._maximize(t,Ot._blue,t.blueMinimum+1,t.blueMaximum,i,n,a,o,s),u=this._maximize(t,Ot._alpha,t.alphaMinimum+1,t.alphaMaximum,i,n,a,o,s);if(u.max>=h.max&&u.max>=l.max&&u.max>=f.max){if(r=Ot._alpha,u.position<0)return!1}else r=h.max>=u.max&&h.max>=l.max&&h.max>=f.max?Ot._red:l.max>=u.max&&l.max>=h.max&&l.max>=f.max?Ot._green:Ot._blue;switch(e.redMaximum=t.redMaximum,e.greenMaximum=t.greenMaximum,e.blueMaximum=t.blueMaximum,e.alphaMaximum=t.alphaMaximum,r){case Ot._red:e.redMinimum=t.redMaximum=h.position,e.greenMinimum=t.greenMinimum,e.blueMinimum=t.blueMinimum,e.alphaMinimum=t.alphaMinimum;break;case Ot._green:e.greenMinimum=t.greenMaximum=l.position,e.redMinimum=t.redMinimum,e.blueMinimum=t.blueMinimum,e.alphaMinimum=t.alphaMinimum;break;case Ot._blue:e.blueMinimum=t.blueMaximum=f.position,e.redMinimum=t.redMinimum,e.greenMinimum=t.greenMinimum,e.alphaMinimum=t.alphaMinimum;break;case Ot._alpha:e.alphaMinimum=t.alphaMaximum=u.position,e.blueMinimum=t.blueMinimum,e.redMinimum=t.redMinimum,e.greenMinimum=t.greenMinimum}return t.volume=(t.redMaximum-t.redMinimum)*(t.greenMaximum-t.greenMinimum)*(t.blueMaximum-t.blueMinimum)*(t.alphaMaximum-t.alphaMinimum),e.volume=(e.redMaximum-e.redMinimum)*(e.greenMaximum-e.greenMinimum)*(e.blueMaximum-e.blueMinimum)*(e.alphaMaximum-e.alphaMinimum),!0}_initialize(t){this._colors=t,this._cubes=[];for(let e=0;e<t;e++)this._cubes[e]=new Pt;this._cubes[0].redMinimum=0,this._cubes[0].greenMinimum=0,this._cubes[0].blueMinimum=0,this._cubes[0].alphaMinimum=0,this._cubes[0].redMaximum=this._maxSideIndex,this._cubes[0].greenMaximum=this._maxSideIndex,this._cubes[0].blueMaximum=this._maxSideIndex,this._cubes[0].alphaMaximum=this._alphaMaxSideIndex,this._weights=It(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._momentsRed=It(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._momentsGreen=It(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._momentsBlue=It(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._momentsAlpha=It(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._moments=It(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._table=[];for(let t=0;t<256;++t)this._table[t]=t*t;this._pixels=[]}_setQuality(t=5){this._significantBitsPerChannel=t,this._maxSideIndex=1<<this._significantBitsPerChannel,this._alphaMaxSideIndex=this._maxSideIndex,this._sideSize=this._maxSideIndex+1,this._alphaSideSize=this._alphaMaxSideIndex+1}},Lt=Ot;f(Lt,\"_alpha\",3),f(Lt,\"_red\",2),f(Lt,\"_green\",1),f(Lt,\"_blue\",0);var Ct={};h(Ct,{AbstractImageQuantizer:()=>Ut,ErrorDiffusionArray:()=>Nt,ErrorDiffusionArrayKernel:()=>Dt,ErrorDiffusionRiemersma:()=>Ht,NearestColor:()=>zt});var Ut=class{quantizeSync(t,e){for(const r of this.quantize(t,e))if(r.pointContainer)return r.pointContainer;throw new Error(\"unreachable\")}},zt=class extends Ut{constructor(t){super(),f(this,\"_distance\"),this._distance=t}*quantize(t,e){const r=t.getPointArray(),i=t.getWidth(),n=t.getHeight(),a=new gt(n,99);for(let t=0;t<n;t++){a.shouldNotify(t)&&(yield{progress:a.progress});for(let n=0,a=t*i;n<i;n++,a++){const t=r[a];t.from(e.getNearestColor(this._distance,t))}}yield{pointContainer:t,progress:100}}},Dt=(t=>(t[t.FloydSteinberg=0]=\"FloydSteinberg\",t[t.FalseFloydSteinberg=1]=\"FalseFloydSteinberg\",t[t.Stucki=2]=\"Stucki\",t[t.Atkinson=3]=\"Atkinson\",t[t.Jarvis=4]=\"Jarvis\",t[t.Burkes=5]=\"Burkes\",t[t.Sierra=6]=\"Sierra\",t[t.TwoSierra=7]=\"TwoSierra\",t[t.SierraLite=8]=\"SierraLite\",t))(Dt||{}),Nt=class extends Ut{constructor(t,e,r=!0,i=0,n=!1){super(),f(this,\"_minColorDistance\"),f(this,\"_serpentine\"),f(this,\"_kernel\"),f(this,\"_calculateErrorLikeGIMP\"),f(this,\"_distance\"),this._setKernel(e),this._distance=t,this._minColorDistance=i,this._serpentine=r,this._calculateErrorLikeGIMP=n}*quantize(t,e){const r=t.getPointArray(),i=new ht,n=t.getWidth(),a=t.getHeight(),o=[];let s=1,h=1;for(const t of this._kernel){const e=t[2]+1;h<e&&(h=e)}for(let t=0;t<h;t++)this._fillErrorLine(o[t]=[],n);const l=new gt(a,99);for(let t=0;t<a;t++){l.shouldNotify(t)&&(yield{progress:l.progress}),this._serpentine&&(s*=-1);const h=t*n,f=1===s?0:n-1,u=1===s?n:-1;this._fillErrorLine(o[0],n),o.push(o.shift());const c=o[0];for(let l=f,d=h+f;l!==u;l+=s,d+=s){const h=r[d],f=c[l];i.from(h);const u=ht.createByRGBA(S(h.r+f[0]),S(h.g+f[1]),S(h.b+f[2]),S(h.a+f[3])),p=e.getNearestColor(this._distance,u);if(h.from(p),this._minColorDistance&&this._distance.calculateNormalized(i,p)<this._minColorDistance)continue;let m,g,b,_;this._calculateErrorLikeGIMP?(m=u.r-p.r,g=u.g-p.g,b=u.b-p.b,_=u.a-p.a):(m=i.r-p.r,g=i.g-p.g,b=i.b-p.b,_=i.a-p.a);const y=1===s?0:this._kernel.length-1,w=1===s?this._kernel.length:-1;for(let e=y;e!==w;e+=s){const r=this._kernel[e][1]*s,i=this._kernel[e][2];if(r+l>=0&&r+l<n&&i+t>=0&&i+t<a){const t=this._kernel[e][0],n=o[i][r+l];n[0]+=m*t,n[1]+=g*t,n[2]+=b*t,n[3]+=_*t}}}}yield{pointContainer:t,progress:100}}_fillErrorLine(t,e){t.length>e&&(t.length=e);const r=t.length;for(let e=0;e<r;e++){const r=t[e];r[0]=r[1]=r[2]=r[3]=0}for(let i=r;i<e;i++)t[i]=[0,0,0,0]}_setKernel(t){switch(t){case 0:this._kernel=[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]];break;case 1:this._kernel=[[3/8,1,0],[3/8,0,1],[2/8,1,1]];break;case 2:this._kernel=[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]];break;case 3:this._kernel=[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]];break;case 4:this._kernel=[[7/48,1,0],[5/48,2,0],[3/48,-2,1],[5/48,-1,1],[7/48,0,1],[5/48,1,1],[3/48,2,1],[1/48,-2,2],[3/48,-1,2],[5/48,0,2],[3/48,1,2],[1/48,2,2]];break;case 5:this._kernel=[[.25,1,0],[4/32,2,0],[2/32,-2,1],[4/32,-1,1],[.25,0,1],[4/32,1,1],[2/32,2,1]];break;case 6:this._kernel=[[5/32,1,0],[3/32,2,0],[2/32,-2,1],[4/32,-1,1],[5/32,0,1],[4/32,1,1],[2/32,2,1],[2/32,-1,2],[3/32,0,2],[2/32,1,2]];break;case 7:this._kernel=[[.25,1,0],[3/16,2,0],[1/16,-2,1],[2/16,-1,1],[3/16,0,1],[2/16,1,1],[1/16,2,1]];break;case 8:this._kernel=[[.5,1,0],[1/4,-1,1],[1/4,0,1]];break;default:throw new Error(`ErrorDiffusionArray: unknown kernel = ${t}`)}}};function*Ft(t,e,r){const i=Math.max(t,e),n={width:t,height:e,level:Math.floor(Math.log(i)/Math.log(2)+1),callback:r,tracker:new gt(t*e,99),index:0,x:0,y:0};yield*jt(n,1),Gt(n,0)}function*jt(t,e){if(!(t.level<1)){switch(t.tracker.shouldNotify(t.index)&&(yield{progress:t.tracker.progress}),t.level--,e){case 2:yield*jt(t,1),Gt(t,3),yield*jt(t,2),Gt(t,4),yield*jt(t,2),Gt(t,2),yield*jt(t,4);break;case 3:yield*jt(t,4),Gt(t,2),yield*jt(t,3),Gt(t,1),yield*jt(t,3),Gt(t,3),yield*jt(t,1);break;case 1:yield*jt(t,2),Gt(t,4),yield*jt(t,1),Gt(t,3),yield*jt(t,1),Gt(t,1),yield*jt(t,3);break;case 4:yield*jt(t,3),Gt(t,1),yield*jt(t,4),Gt(t,2),yield*jt(t,4),Gt(t,4),yield*jt(t,2)}t.level++}}function Gt(t,e){switch(t.x>=0&&t.x<t.width&&t.y>=0&&t.y<t.height&&(t.callback(t.x,t.y),t.index++),e){case 2:t.x--;break;case 3:t.x++;break;case 1:t.y--;break;case 4:t.y++}}var Ht=class extends Ut{constructor(t,e=16,r=1){super(),f(this,\"_distance\"),f(this,\"_weights\"),f(this,\"_errorQueueSize\"),this._distance=t,this._errorQueueSize=e,this._weights=Ht._createWeights(r,e)}*quantize(t,e){const r=t.getPointArray(),i=t.getWidth(),n=t.getHeight(),a=[];let o=0;for(let t=0;t<this._errorQueueSize;t++)a[t]={r:0,g:0,b:0,a:0};yield*Ft(i,n,((t,n)=>{const s=r[t+n*i];let{r:h,g:l,b:f,a:u}=s;for(let t=0;t<this._errorQueueSize;t++){const e=this._weights[t],r=a[(t+o)%this._errorQueueSize];h+=r.r*e,l+=r.g*e,f+=r.b*e,u+=r.a*e}const c=ht.createByRGBA(S(h),S(l),S(f),S(u)),d=e.getNearestColor(this._distance,c);o=(o+1)%this._errorQueueSize;const p=(o+this._errorQueueSize-1)%this._errorQueueSize;a[p].r=s.r-d.r,a[p].g=s.g-d.g,a[p].b=s.b-d.b,a[p].a=s.a-d.a,s.from(d)})),yield{pointContainer:t,progress:100}}static _createWeights(t,e){const r=[],i=Math.exp(Math.log(e)/(e-1));for(let n=0,a=1;n<e;n++)r[n]=(a+.5|0)/e*t,a*=i;return r}},Wt={};h(Wt,{ssim:()=>Yt});var qt=.01,Zt=.03;function Yt(t,e){if(t.getHeight()!==e.getHeight()||t.getWidth()!==e.getWidth())throw new Error(\"Images have different sizes!\");const r=(255*qt)**2,i=(255*Zt)**2;let n=0,a=0;return function(t,e,r){const i=t.getWidth(),n=t.getHeight();for(let a=0;a<n;a+=8)for(let o=0;o<i;o+=8){const s=Math.min(8,i-o),h=Math.min(8,n-a),l=Vt(t,o,a,s,h),f=Vt(e,o,a,s,h);r(l,f,Xt(l),Xt(f))}}(t,e,((t,e,o,s)=>{let h=0,l=0,f=0;for(let r=0;r<t.length;r++)l+=(t[r]-o)**2,f+=(e[r]-s)**2,h+=(t[r]-o)*(e[r]-s);const u=t.length-1;l/=u,f/=u,h/=u,a+=(2*o*s+r)*(2*h+i)/((o**2+s**2+r)*(l+f+i)),n++})),a/n}function Vt(t,e,r,i,n){const a=t.getPointArray(),o=[];let s=0;for(let h=r;h<r+n;h++){const r=h*t.getWidth();for(let t=e;t<e+i;t++){const e=a[r+t];o[s]=.2126*e.r+.7152*e.g+.0722*e.b,s++}}return o}function Xt(t){let e=0;for(const r of t)e+=r;return e/t.length}var Jt=\"function\"==typeof setImmediate?setImmediate:void 0!==i&&\"function\"==typeof(null==i?void 0:i.nextTick)?t=>i.nextTick(t):t=>setTimeout(t,0);function Qt(t,{colorDistanceFormula:e,paletteQuantization:r,colors:i}={}){const n=ie(ee(e),r,i);return t.forEach((t=>n.sample(t))),n.quantizeSync()}async function Kt(t,{colorDistanceFormula:e,paletteQuantization:r,colors:i,onProgress:n}={}){return new Promise(((a,o)=>{const s=ie(ee(e),r,i);let h;t.forEach((t=>s.sample(t)));const l=s.quantize(),f=()=>{try{const t=l.next();t.done?a(h):(t.value.palette&&(h=t.value.palette),n&&n(t.value.progress),Jt(f))}catch(t){o(t)}};Jt(f)}))}function $t(t,e,{colorDistanceFormula:r,imageQuantization:i}={}){return re(ee(r),i).quantizeSync(t,e)}async function te(t,e,{colorDistanceFormula:r,imageQuantization:i,onProgress:n}={}){return new Promise(((a,o)=>{let s;const h=re(ee(r),i).quantize(t,e),l=()=>{try{const t=h.next();t.done?a(s):(t.value.pointContainer&&(s=t.value.pointContainer),n&&n(t.value.progress),Jt(l))}catch(t){o(t)}};Jt(l)}))}function ee(t=\"euclidean-bt709\"){switch(t){case\"cie94-graphic-arts\":return new Y;case\"cie94-textiles\":return new Z;case\"ciede2000\":return new X;case\"color-metric\":return new J;case\"euclidean\":return new K;case\"euclidean-bt709\":return new $;case\"euclidean-bt709-noalpha\":return new tt;case\"manhattan\":return new rt;case\"manhattan-bt709\":return new nt;case\"manhattan-nommyde\":return new it;case\"pngquant\":return new at;default:throw new Error(`Unknown colorDistanceFormula ${t}`)}}function re(t,e=\"floyd-steinberg\"){switch(e){case\"nearest\":return new zt(t);case\"riemersma\":return new Ht(t);case\"floyd-steinberg\":return new Nt(t,0);case\"false-floyd-steinberg\":return new Nt(t,1);case\"stucki\":return new Nt(t,2);case\"atkinson\":return new Nt(t,3);case\"jarvis\":return new Nt(t,4);case\"burkes\":return new Nt(t,5);case\"sierra\":return new Nt(t,6);case\"two-sierra\":return new Nt(t,7);case\"sierra-lite\":return new Nt(t,8);default:throw new Error(`Unknown imageQuantization ${e}`)}}function ie(t,e=\"wuquant\",r=256){switch(e){case\"neuquant\":return new yt(t,r);case\"rgbquant\":return new Mt(t,r);case\"wuquant\":return new Lt(t,r);case\"neuquant-float\":return new xt(t,r);default:throw new Error(`Unknown paletteQuantization ${e}`)}}t.exports=l(u)}},__webpack_module_cache__={};function __nested_webpack_require_505601__(t){var e=__webpack_module_cache__[t];if(void 0!==e)return e.exports;var r=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t](r,r.exports,__nested_webpack_require_505601__),r.exports}__nested_webpack_require_505601__.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return __nested_webpack_require_505601__.d(e,{a:e}),e},__nested_webpack_require_505601__.d=(t,e)=>{for(var r in e)__nested_webpack_require_505601__.o(e,r)&&!__nested_webpack_require_505601__.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},__nested_webpack_require_505601__.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(t){if(\"object\"==typeof window)return window}}(),__nested_webpack_require_505601__.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),__nested_webpack_require_505601__.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})};var __webpack_exports__={};(()=>{\"use strict\";var t={};__nested_webpack_require_505601__.r(t),__nested_webpack_require_505601__.d(t,{AUTO:()=>et,BLEND_ADD:()=>ut,BLEND_DARKEN:()=>pt,BLEND_DESTINATION_OVER:()=>lt,BLEND_DIFFERENCE:()=>bt,BLEND_EXCLUSION:()=>_t,BLEND_HARDLIGHT:()=>gt,BLEND_LIGHTEN:()=>mt,BLEND_MULTIPLY:()=>ft,BLEND_OVERLAY:()=>dt,BLEND_SCREEN:()=>ct,BLEND_SOURCE_OVER:()=>ht,EDGE_CROP:()=>vt,EDGE_EXTEND:()=>yt,EDGE_WRAP:()=>wt,HORIZONTAL_ALIGN_CENTER:()=>it,HORIZONTAL_ALIGN_LEFT:()=>rt,HORIZONTAL_ALIGN_RIGHT:()=>nt,VERTICAL_ALIGN_BOTTOM:()=>st,VERTICAL_ALIGN_MIDDLE:()=>ot,VERTICAL_ALIGN_TOP:()=>at});var e={};__nested_webpack_require_505601__.r(e),__nested_webpack_require_505601__.d(e,{add:()=>St,darken:()=>It,difference:()=>Rt,dstOver:()=>Et,exclusion:()=>Pt,hardLight:()=>Tt,lighten:()=>Bt,multiply:()=>kt,overlay:()=>At,screen:()=>Mt,srcOver:()=>xt});var r=__nested_webpack_require_505601__(5546),i=__nested_webpack_require_505601__.n(r),n=__nested_webpack_require_505601__(1023),a=__nested_webpack_require_505601__.n(n),o=__nested_webpack_require_505601__(2699),s=__nested_webpack_require_505601__.n(o);function h(t){if(void 0===t)return!1;if(\"function\"!=typeof t)throw new TypeError(\"Callback must be a function\");return!0}function l(t,e){if(\"string\"==typeof t&&(t=new Error(t)),\"function\"==typeof e)return e.call(this,t);throw t}function f(t,e,r,i,n,a){e=Math.round(e),r=Math.round(r),i=Math.round(i),n=Math.round(n);for(let o=r;o<r+n;o++)for(let r=e;r<e+i;r++){const e=t.bitmap.width*o+r<<2;a.call(t,r,o,e)}return t}var u=__nested_webpack_require_505601__(236),c=__nested_webpack_require_505601__.n(u),d=__nested_webpack_require_505601__(1294),p=__nested_webpack_require_505601__.n(d);function m(t){return m=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},m(t)}var g=/^\\s+/,b=/\\s+$/;function _(t,e){if(e=e||{},(t=t||\"\")instanceof _)return t;if(!(this instanceof _))return new _(t,e);var r=function(t){var e,r,i,n={r:0,g:0,b:0},a=1,o=null,s=null,h=null,l=!1,f=!1;return\"string\"==typeof t&&(t=function(t){t=t.replace(g,\"\").replace(b,\"\").toLowerCase();var e,r=!1;if(C[t])t=C[t],r=!0;else if(\"transparent\"==t)return{r:0,g:0,b:0,a:0,format:\"name\"};return(e=V.rgb.exec(t))?{r:e[1],g:e[2],b:e[3]}:(e=V.rgba.exec(t))?{r:e[1],g:e[2],b:e[3],a:e[4]}:(e=V.hsl.exec(t))?{h:e[1],s:e[2],l:e[3]}:(e=V.hsla.exec(t))?{h:e[1],s:e[2],l:e[3],a:e[4]}:(e=V.hsv.exec(t))?{h:e[1],s:e[2],v:e[3]}:(e=V.hsva.exec(t))?{h:e[1],s:e[2],v:e[3],a:e[4]}:(e=V.hex8.exec(t))?{r:F(e[1]),g:F(e[2]),b:F(e[3]),a:W(e[4]),format:r?\"name\":\"hex8\"}:(e=V.hex6.exec(t))?{r:F(e[1]),g:F(e[2]),b:F(e[3]),format:r?\"name\":\"hex\"}:(e=V.hex4.exec(t))?{r:F(e[1]+\"\"+e[1]),g:F(e[2]+\"\"+e[2]),b:F(e[3]+\"\"+e[3]),a:W(e[4]+\"\"+e[4]),format:r?\"name\":\"hex8\"}:!!(e=V.hex3.exec(t))&&{r:F(e[1]+\"\"+e[1]),g:F(e[2]+\"\"+e[2]),b:F(e[3]+\"\"+e[3]),format:r?\"name\":\"hex\"}}(t)),\"object\"==m(t)&&(X(t.r)&&X(t.g)&&X(t.b)?(e=t.r,r=t.g,i=t.b,n={r:255*D(e,255),g:255*D(r,255),b:255*D(i,255)},l=!0,f=\"%\"===String(t.r).substr(-1)?\"prgb\":\"rgb\"):X(t.h)&&X(t.s)&&X(t.v)?(o=G(t.s),s=G(t.v),n=function(t,e,r){t=6*D(t,360),e=D(e,100),r=D(r,100);var i=Math.floor(t),n=t-i,a=r*(1-e),o=r*(1-n*e),s=r*(1-(1-n)*e),h=i%6;return{r:255*[r,o,a,a,s,r][h],g:255*[s,r,r,o,a,a][h],b:255*[a,a,s,r,r,o][h]}}(t.h,o,s),l=!0,f=\"hsv\"):X(t.h)&&X(t.s)&&X(t.l)&&(o=G(t.s),h=G(t.l),n=function(t,e,r){var i,n,a;function o(t,e,r){return r<0&&(r+=1),r>1&&(r-=1),r<1/6?t+6*(e-t)*r:r<.5?e:r<2/3?t+(e-t)*(2/3-r)*6:t}if(t=D(t,360),e=D(e,100),r=D(r,100),0===e)i=n=a=r;else{var s=r<.5?r*(1+e):r+e-r*e,h=2*r-s;i=o(h,s,t+1/3),n=o(h,s,t),a=o(h,s,t-1/3)}return{r:255*i,g:255*n,b:255*a}}(t.h,o,h),l=!0,f=\"hsl\"),t.hasOwnProperty(\"a\")&&(a=t.a)),a=z(a),{ok:l,format:t.format||f,r:Math.min(255,Math.max(n.r,0)),g:Math.min(255,Math.max(n.g,0)),b:Math.min(255,Math.max(n.b,0)),a}}(t);this._originalInput=t,this._r=r.r,this._g=r.g,this._b=r.b,this._a=r.a,this._roundA=Math.round(100*this._a)/100,this._format=e.format||r.format,this._gradientType=e.gradientType,this._r<1&&(this._r=Math.round(this._r)),this._g<1&&(this._g=Math.round(this._g)),this._b<1&&(this._b=Math.round(this._b)),this._ok=r.ok}function y(t,e,r){t=D(t,255),e=D(e,255),r=D(r,255);var i,n,a=Math.max(t,e,r),o=Math.min(t,e,r),s=(a+o)/2;if(a==o)i=n=0;else{var h=a-o;switch(n=s>.5?h/(2-a-o):h/(a+o),a){case t:i=(e-r)/h+(e<r?6:0);break;case e:i=(r-t)/h+2;break;case r:i=(t-e)/h+4}i/=6}return{h:i,s:n,l:s}}function w(t,e,r){t=D(t,255),e=D(e,255),r=D(r,255);var i,n,a=Math.max(t,e,r),o=Math.min(t,e,r),s=a,h=a-o;if(n=0===a?0:h/a,a==o)i=0;else{switch(a){case t:i=(e-r)/h+(e<r?6:0);break;case e:i=(r-t)/h+2;break;case r:i=(t-e)/h+4}i/=6}return{h:i,s:n,v:s}}function v(t,e,r,i){var n=[j(Math.round(t).toString(16)),j(Math.round(e).toString(16)),j(Math.round(r).toString(16))];return i&&n[0].charAt(0)==n[0].charAt(1)&&n[1].charAt(0)==n[1].charAt(1)&&n[2].charAt(0)==n[2].charAt(1)?n[0].charAt(0)+n[1].charAt(0)+n[2].charAt(0):n.join(\"\")}function x(t,e,r,i){return[j(H(i)),j(Math.round(t).toString(16)),j(Math.round(e).toString(16)),j(Math.round(r).toString(16))].join(\"\")}function E(t,e){e=0===e?0:e||10;var r=_(t).toHsl();return r.s-=e/100,r.s=N(r.s),_(r)}function k(t,e){e=0===e?0:e||10;var r=_(t).toHsl();return r.s+=e/100,r.s=N(r.s),_(r)}function S(t){return _(t).desaturate(100)}function M(t,e){e=0===e?0:e||10;var r=_(t).toHsl();return r.l+=e/100,r.l=N(r.l),_(r)}function A(t,e){e=0===e?0:e||10;var r=_(t).toRgb();return r.r=Math.max(0,Math.min(255,r.r-Math.round(-e/100*255))),r.g=Math.max(0,Math.min(255,r.g-Math.round(-e/100*255))),r.b=Math.max(0,Math.min(255,r.b-Math.round(-e/100*255))),_(r)}function I(t,e){e=0===e?0:e||10;var r=_(t).toHsl();return r.l-=e/100,r.l=N(r.l),_(r)}function B(t,e){var r=_(t).toHsl(),i=(r.h+e)%360;return r.h=i<0?360+i:i,_(r)}function T(t){var e=_(t).toHsl();return e.h=(e.h+180)%360,_(e)}function R(t,e){if(isNaN(e)||e<=0)throw new Error(\"Argument to polyad must be a positive number\");for(var r=_(t).toHsl(),i=[_(t)],n=360/e,a=1;a<e;a++)i.push(_({h:(r.h+a*n)%360,s:r.s,l:r.l}));return i}function P(t){var e=_(t).toHsl(),r=e.h;return[_(t),_({h:(r+72)%360,s:e.s,l:e.l}),_({h:(r+216)%360,s:e.s,l:e.l})]}function O(t,e,r){e=e||6,r=r||30;var i=_(t).toHsl(),n=360/r,a=[_(t)];for(i.h=(i.h-(n*e>>1)+720)%360;--e;)i.h=(i.h+n)%360,a.push(_(i));return a}function L(t,e){e=e||6;for(var r=_(t).toHsv(),i=r.h,n=r.s,a=r.v,o=[],s=1/e;e--;)o.push(_({h:i,s:n,v:a})),a=(a+s)%1;return o}_.prototype={isDark:function(){return this.getBrightness()<128},isLight:function(){return!this.isDark()},isValid:function(){return this._ok},getOriginalInput:function(){return this._originalInput},getFormat:function(){return this._format},getAlpha:function(){return this._a},getBrightness:function(){var t=this.toRgb();return(299*t.r+587*t.g+114*t.b)/1e3},getLuminance:function(){var t,e,r,i=this.toRgb();return t=i.r/255,e=i.g/255,r=i.b/255,.2126*(t<=.03928?t/12.92:Math.pow((t+.055)/1.055,2.4))+.7152*(e<=.03928?e/12.92:Math.pow((e+.055)/1.055,2.4))+.0722*(r<=.03928?r/12.92:Math.pow((r+.055)/1.055,2.4))},setAlpha:function(t){return this._a=z(t),this._roundA=Math.round(100*this._a)/100,this},toHsv:function(){var t=w(this._r,this._g,this._b);return{h:360*t.h,s:t.s,v:t.v,a:this._a}},toHsvString:function(){var t=w(this._r,this._g,this._b),e=Math.round(360*t.h),r=Math.round(100*t.s),i=Math.round(100*t.v);return 1==this._a?\"hsv(\"+e+\", \"+r+\"%, \"+i+\"%)\":\"hsva(\"+e+\", \"+r+\"%, \"+i+\"%, \"+this._roundA+\")\"},toHsl:function(){var t=y(this._r,this._g,this._b);return{h:360*t.h,s:t.s,l:t.l,a:this._a}},toHslString:function(){var t=y(this._r,this._g,this._b),e=Math.round(360*t.h),r=Math.round(100*t.s),i=Math.round(100*t.l);return 1==this._a?\"hsl(\"+e+\", \"+r+\"%, \"+i+\"%)\":\"hsla(\"+e+\", \"+r+\"%, \"+i+\"%, \"+this._roundA+\")\"},toHex:function(t){return v(this._r,this._g,this._b,t)},toHexString:function(t){return\"#\"+this.toHex(t)},toHex8:function(t){return function(t,e,r,i,n){var a=[j(Math.round(t).toString(16)),j(Math.round(e).toString(16)),j(Math.round(r).toString(16)),j(H(i))];return n&&a[0].charAt(0)==a[0].charAt(1)&&a[1].charAt(0)==a[1].charAt(1)&&a[2].charAt(0)==a[2].charAt(1)&&a[3].charAt(0)==a[3].charAt(1)?a[0].charAt(0)+a[1].charAt(0)+a[2].charAt(0)+a[3].charAt(0):a.join(\"\")}(this._r,this._g,this._b,this._a,t)},toHex8String:function(t){return\"#\"+this.toHex8(t)},toRgb:function(){return{r:Math.round(this._r),g:Math.round(this._g),b:Math.round(this._b),a:this._a}},toRgbString:function(){return 1==this._a?\"rgb(\"+Math.round(this._r)+\", \"+Math.round(this._g)+\", \"+Math.round(this._b)+\")\":\"rgba(\"+Math.round(this._r)+\", \"+Math.round(this._g)+\", \"+Math.round(this._b)+\", \"+this._roundA+\")\"},toPercentageRgb:function(){return{r:Math.round(100*D(this._r,255))+\"%\",g:Math.round(100*D(this._g,255))+\"%\",b:Math.round(100*D(this._b,255))+\"%\",a:this._a}},toPercentageRgbString:function(){return 1==this._a?\"rgb(\"+Math.round(100*D(this._r,255))+\"%, \"+Math.round(100*D(this._g,255))+\"%, \"+Math.round(100*D(this._b,255))+\"%)\":\"rgba(\"+Math.round(100*D(this._r,255))+\"%, \"+Math.round(100*D(this._g,255))+\"%, \"+Math.round(100*D(this._b,255))+\"%, \"+this._roundA+\")\"},toName:function(){return 0===this._a?\"transparent\":!(this._a<1)&&(U[v(this._r,this._g,this._b,!0)]||!1)},toFilter:function(t){var e=\"#\"+x(this._r,this._g,this._b,this._a),r=e,i=this._gradientType?\"GradientType = 1, \":\"\";if(t){var n=_(t);r=\"#\"+x(n._r,n._g,n._b,n._a)}return\"progid:DXImageTransform.Microsoft.gradient(\"+i+\"startColorstr=\"+e+\",endColorstr=\"+r+\")\"},toString:function(t){var e=!!t;t=t||this._format;var r=!1,i=this._a<1&&this._a>=0;return e||!i||\"hex\"!==t&&\"hex6\"!==t&&\"hex3\"!==t&&\"hex4\"!==t&&\"hex8\"!==t&&\"name\"!==t?(\"rgb\"===t&&(r=this.toRgbString()),\"prgb\"===t&&(r=this.toPercentageRgbString()),\"hex\"!==t&&\"hex6\"!==t||(r=this.toHexString()),\"hex3\"===t&&(r=this.toHexString(!0)),\"hex4\"===t&&(r=this.toHex8String(!0)),\"hex8\"===t&&(r=this.toHex8String()),\"name\"===t&&(r=this.toName()),\"hsl\"===t&&(r=this.toHslString()),\"hsv\"===t&&(r=this.toHsvString()),r||this.toHexString()):\"name\"===t&&0===this._a?this.toName():this.toRgbString()},clone:function(){return _(this.toString())},_applyModification:function(t,e){var r=t.apply(null,[this].concat([].slice.call(e)));return this._r=r._r,this._g=r._g,this._b=r._b,this.setAlpha(r._a),this},lighten:function(){return this._applyModification(M,arguments)},brighten:function(){return this._applyModification(A,arguments)},darken:function(){return this._applyModification(I,arguments)},desaturate:function(){return this._applyModification(E,arguments)},saturate:function(){return this._applyModification(k,arguments)},greyscale:function(){return this._applyModification(S,arguments)},spin:function(){return this._applyModification(B,arguments)},_applyCombination:function(t,e){return t.apply(null,[this].concat([].slice.call(e)))},analogous:function(){return this._applyCombination(O,arguments)},complement:function(){return this._applyCombination(T,arguments)},monochromatic:function(){return this._applyCombination(L,arguments)},splitcomplement:function(){return this._applyCombination(P,arguments)},triad:function(){return this._applyCombination(R,[3])},tetrad:function(){return this._applyCombination(R,[4])}},_.fromRatio=function(t,e){if(\"object\"==m(t)){var r={};for(var i in t)t.hasOwnProperty(i)&&(r[i]=\"a\"===i?t[i]:G(t[i]));t=r}return _(t,e)},_.equals=function(t,e){return!(!t||!e)&&_(t).toRgbString()==_(e).toRgbString()},_.random=function(){return _.fromRatio({r:Math.random(),g:Math.random(),b:Math.random()})},_.mix=function(t,e,r){r=0===r?0:r||50;var i=_(t).toRgb(),n=_(e).toRgb(),a=r/100;return _({r:(n.r-i.r)*a+i.r,g:(n.g-i.g)*a+i.g,b:(n.b-i.b)*a+i.b,a:(n.a-i.a)*a+i.a})},_.readability=function(t,e){var r=_(t),i=_(e);return(Math.max(r.getLuminance(),i.getLuminance())+.05)/(Math.min(r.getLuminance(),i.getLuminance())+.05)},_.isReadable=function(t,e,r){var i,n,a,o,s,h=_.readability(t,e);switch(n=!1,(a=r,\"AA\"!==(o=((a=a||{level:\"AA\",size:\"small\"}).level||\"AA\").toUpperCase())&&\"AAA\"!==o&&(o=\"AA\"),\"small\"!==(s=(a.size||\"small\").toLowerCase())&&\"large\"!==s&&(s=\"small\"),i={level:o,size:s}).level+i.size){case\"AAsmall\":case\"AAAlarge\":n=h>=4.5;break;case\"AAlarge\":n=h>=3;break;case\"AAAsmall\":n=h>=7}return n},_.mostReadable=function(t,e,r){var i,n,a,o,s=null,h=0;n=(r=r||{}).includeFallbackColors,a=r.level,o=r.size;for(var l=0;l<e.length;l++)(i=_.readability(t,e[l]))>h&&(h=i,s=_(e[l]));return _.isReadable(t,s,{level:a,size:o})||!n?s:(r.includeFallbackColors=!1,_.mostReadable(t,[\"#fff\",\"#000\"],r))};var C=_.names={aliceblue:\"f0f8ff\",antiquewhite:\"faebd7\",aqua:\"0ff\",aquamarine:\"7fffd4\",azure:\"f0ffff\",beige:\"f5f5dc\",bisque:\"ffe4c4\",black:\"000\",blanchedalmond:\"ffebcd\",blue:\"00f\",blueviolet:\"8a2be2\",brown:\"a52a2a\",burlywood:\"deb887\",burntsienna:\"ea7e5d\",cadetblue:\"5f9ea0\",chartreuse:\"7fff00\",chocolate:\"d2691e\",coral:\"ff7f50\",cornflowerblue:\"6495ed\",cornsilk:\"fff8dc\",crimson:\"dc143c\",cyan:\"0ff\",darkblue:\"00008b\",darkcyan:\"008b8b\",darkgoldenrod:\"b8860b\",darkgray:\"a9a9a9\",darkgreen:\"006400\",darkgrey:\"a9a9a9\",darkkhaki:\"bdb76b\",darkmagenta:\"8b008b\",darkolivegreen:\"556b2f\",darkorange:\"ff8c00\",darkorchid:\"9932cc\",darkred:\"8b0000\",darksalmon:\"e9967a\",darkseagreen:\"8fbc8f\",darkslateblue:\"483d8b\",darkslategray:\"2f4f4f\",darkslategrey:\"2f4f4f\",darkturquoise:\"00ced1\",darkviolet:\"9400d3\",deeppink:\"ff1493\",deepskyblue:\"00bfff\",dimgray:\"696969\",dimgrey:\"696969\",dodgerblue:\"1e90ff\",firebrick:\"b22222\",floralwhite:\"fffaf0\",forestgreen:\"228b22\",fuchsia:\"f0f\",gainsboro:\"dcdcdc\",ghostwhite:\"f8f8ff\",gold:\"ffd700\",goldenrod:\"daa520\",gray:\"808080\",green:\"008000\",greenyellow:\"adff2f\",grey:\"808080\",honeydew:\"f0fff0\",hotpink:\"ff69b4\",indianred:\"cd5c5c\",indigo:\"4b0082\",ivory:\"fffff0\",khaki:\"f0e68c\",lavender:\"e6e6fa\",lavenderblush:\"fff0f5\",lawngreen:\"7cfc00\",lemonchiffon:\"fffacd\",lightblue:\"add8e6\",lightcoral:\"f08080\",lightcyan:\"e0ffff\",lightgoldenrodyellow:\"fafad2\",lightgray:\"d3d3d3\",lightgreen:\"90ee90\",lightgrey:\"d3d3d3\",lightpink:\"ffb6c1\",lightsalmon:\"ffa07a\",lightseagreen:\"20b2aa\",lightskyblue:\"87cefa\",lightslategray:\"789\",lightslategrey:\"789\",lightsteelblue:\"b0c4de\",lightyellow:\"ffffe0\",lime:\"0f0\",limegreen:\"32cd32\",linen:\"faf0e6\",magenta:\"f0f\",maroon:\"800000\",mediumaquamarine:\"66cdaa\",mediumblue:\"0000cd\",mediumorchid:\"ba55d3\",mediumpurple:\"9370db\",mediumseagreen:\"3cb371\",mediumslateblue:\"7b68ee\",mediumspringgreen:\"00fa9a\",mediumturquoise:\"48d1cc\",mediumvioletred:\"c71585\",midnightblue:\"191970\",mintcream:\"f5fffa\",mistyrose:\"ffe4e1\",moccasin:\"ffe4b5\",navajowhite:\"ffdead\",navy:\"000080\",oldlace:\"fdf5e6\",olive:\"808000\",olivedrab:\"6b8e23\",orange:\"ffa500\",orangered:\"ff4500\",orchid:\"da70d6\",palegoldenrod:\"eee8aa\",palegreen:\"98fb98\",paleturquoise:\"afeeee\",palevioletred:\"db7093\",papayawhip:\"ffefd5\",peachpuff:\"ffdab9\",peru:\"cd853f\",pink:\"ffc0cb\",plum:\"dda0dd\",powderblue:\"b0e0e6\",purple:\"800080\",rebeccapurple:\"663399\",red:\"f00\",rosybrown:\"bc8f8f\",royalblue:\"4169e1\",saddlebrown:\"8b4513\",salmon:\"fa8072\",sandybrown:\"f4a460\",seagreen:\"2e8b57\",seashell:\"fff5ee\",sienna:\"a0522d\",silver:\"c0c0c0\",skyblue:\"87ceeb\",slateblue:\"6a5acd\",slategray:\"708090\",slategrey:\"708090\",snow:\"fffafa\",springgreen:\"00ff7f\",steelblue:\"4682b4\",tan:\"d2b48c\",teal:\"008080\",thistle:\"d8bfd8\",tomato:\"ff6347\",turquoise:\"40e0d0\",violet:\"ee82ee\",wheat:\"f5deb3\",white:\"fff\",whitesmoke:\"f5f5f5\",yellow:\"ff0\",yellowgreen:\"9acd32\"},U=_.hexNames=function(t){var e={};for(var r in t)t.hasOwnProperty(r)&&(e[t[r]]=r);return e}(C);function z(t){return t=parseFloat(t),(isNaN(t)||t<0||t>1)&&(t=1),t}function D(t,e){(function(t){return\"string\"==typeof t&&-1!=t.indexOf(\".\")&&1===parseFloat(t)})(t)&&(t=\"100%\");var r=function(t){return\"string\"==typeof t&&-1!=t.indexOf(\"%\")}(t);return t=Math.min(e,Math.max(0,parseFloat(t))),r&&(t=parseInt(t*e,10)/100),Math.abs(t-e)<1e-6?1:t%e/parseFloat(e)}function N(t){return Math.min(1,Math.max(0,t))}function F(t){return parseInt(t,16)}function j(t){return 1==t.length?\"0\"+t:\"\"+t}function G(t){return t<=1&&(t=100*t+\"%\"),t}function H(t){return Math.round(255*parseFloat(t)).toString(16)}function W(t){return F(t)/255}var q,Z,Y,V=(Z=\"[\\\\s|\\\\(]+(\"+(q=\"(?:[-\\\\+]?\\\\d*\\\\.\\\\d+%?)|(?:[-\\\\+]?\\\\d+%?)\")+\")[,|\\\\s]+(\"+q+\")[,|\\\\s]+(\"+q+\")\\\\s*\\\\)?\",Y=\"[\\\\s|\\\\(]+(\"+q+\")[,|\\\\s]+(\"+q+\")[,|\\\\s]+(\"+q+\")[,|\\\\s]+(\"+q+\")\\\\s*\\\\)?\",{CSS_UNIT:new RegExp(q),rgb:new RegExp(\"rgb\"+Z),rgba:new RegExp(\"rgba\"+Y),hsl:new RegExp(\"hsl\"+Z),hsla:new RegExp(\"hsla\"+Y),hsv:new RegExp(\"hsv\"+Z),hsva:new RegExp(\"hsva\"+Y),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/});function X(t){return!!V.CSS_UNIT.exec(t)}function J(t,e){this.size=this.size||t,this.smallerSize=this.smallerSize||e,function(t){for(let e=1;e<t;e++)K[e]=1;K[0]=1/Math.sqrt(2)}(this.size)}function Q(t){const e={};return e.r=Math.floor(t/Math.pow(256,3)),e.g=Math.floor((t-e.r*Math.pow(256,3))/Math.pow(256,2)),e.b=Math.floor((t-e.r*Math.pow(256,3)-e.g*Math.pow(256,2))/Math.pow(256,1)),e.a=Math.floor((t-e.r*Math.pow(256,3)-e.g*Math.pow(256,2)-e.b*Math.pow(256,1))/Math.pow(256,0)),e}J.prototype.size=32,J.prototype.smallerSize=8,J.prototype.distance=function(t,e){let r=0;for(let i=0;i<t.length;i++)t[i]!==e[i]&&r++;return r/t.length},J.prototype.getHash=function(t){(t=t.clone().resize(this.size,this.size)).grayscale();const e=[];for(let r=0;r<t.bitmap.width;r++){e[r]=[];for(let i=0;i<t.bitmap.height;i++)e[r][i]=Q(t.getPixelColor(r,i)).b}const r=function(t,e){const r=e,i=[];for(let e=0;e<r;e++){i[e]=[];for(let n=0;n<r;n++){let a=0;for(let i=0;i<r;i++)for(let o=0;o<r;o++)a+=Math.cos((2*i+1)/(2*r)*e*Math.PI)*Math.cos((2*o+1)/(2*r)*n*Math.PI)*t[i][o];a*=K[e]*K[n]/4,i[e][n]=a}}return i}(e,this.size);let i=0;for(let t=0;t<this.smallerSize;t++)for(let e=0;e<this.smallerSize;e++)i+=r[t][e];const n=i/(this.smallerSize*this.smallerSize);let a=\"\";for(let t=0;t<this.smallerSize;t++)for(let e=0;e<this.smallerSize;e++)a+=r[t][e]>n?\"1\":\"0\";return a};const K=[],$=J;__nested_webpack_require_505601__(9307);const tt=(t,e)=>{let{url:r,...i}=t;fetch(r,i).then((t=>{if(t.ok)return t.arrayBuffer().catch((t=>{throw new Error(`Response is not a buffer for url ${r}. Error: ${t.message}`)}));throw new Error(`HTTP Status ${t.status} for url ${r}`)})).then((t=>e(null,t))).catch((t=>e(t)))},et=-1,rt=1,it=2,nt=4,at=8,ot=16,st=32,ht=\"srcOver\",lt=\"dstOver\",ft=\"multiply\",ut=\"add\",ct=\"screen\",dt=\"overlay\",pt=\"darken\",mt=\"lighten\",gt=\"hardLight\",bt=\"difference\",_t=\"exclusion\",yt=1,wt=2,vt=3;function xt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a;return{r:(t.r*t.a+e.r*e.a*(1-t.a))/i,g:(t.g*t.a+e.g*e.a*(1-t.a))/i,b:(t.b*t.a+e.b*e.a*(1-t.a))/i,a:i}}function Et(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a;return{r:(e.r*e.a+t.r*t.a*(1-e.a))/i,g:(e.g*e.a+t.g*t.a*(1-e.a))/i,b:(e.b*e.a+t.b*t.a*(1-e.a))/i,a:i}}function kt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a,n=t.r*t.a,a=t.g*t.a,o=t.b*t.a,s=e.r*e.a,h=e.g*e.a,l=e.b*e.a;return{r:(n*s+n*(1-e.a)+s*(1-t.a))/i,g:(a*h+a*(1-e.a)+h*(1-t.a))/i,b:(o*l+o*(1-e.a)+l*(1-t.a))/i,a:i}}function St(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a,n=t.r*t.a,a=t.g*t.a,o=t.b*t.a;return{r:(n+e.r*e.a)/i,g:(a+e.g*e.a)/i,b:(o+e.b*e.a)/i,a:i}}function Mt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a,n=t.r*t.a,a=t.g*t.a,o=t.b*t.a,s=e.r*e.a,h=e.g*e.a,l=e.b*e.a;return{r:(n*e.a+s*t.a-n*s+n*(1-e.a)+s*(1-t.a))/i,g:(a*e.a+h*t.a-a*h+a*(1-e.a)+h*(1-t.a))/i,b:(o*e.a+l*t.a-o*l+o*(1-e.a)+l*(1-t.a))/i,a:i}}function At(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a,n=t.r*t.a,a=t.g*t.a,o=t.b*t.a,s=e.r*e.a,h=e.g*e.a,l=e.b*e.a;return{r:(2*s<=e.a?2*n*s+n*(1-e.a)+s*(1-t.a):n*(1+e.a)+s*(1+t.a)-2*s*n-e.a*t.a)/i,g:(2*h<=e.a?2*a*h+a*(1-e.a)+h*(1-t.a):a*(1+e.a)+h*(1+t.a)-2*h*a-e.a*t.a)/i,b:(2*l<=e.a?2*o*l+o*(1-e.a)+l*(1-t.a):o*(1+e.a)+l*(1+t.a)-2*l*o-e.a*t.a)/i,a:i}}function It(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a,n=t.r*t.a,a=t.g*t.a,o=t.b*t.a,s=e.r*e.a,h=e.g*e.a,l=e.b*e.a;return{r:(Math.min(n*e.a,s*t.a)+n*(1-e.a)+s*(1-t.a))/i,g:(Math.min(a*e.a,h*t.a)+a*(1-e.a)+h*(1-t.a))/i,b:(Math.min(o*e.a,l*t.a)+o*(1-e.a)+l*(1-t.a))/i,a:i}}function Bt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a,n=t.r*t.a,a=t.g*t.a,o=t.b*t.a,s=e.r*e.a,h=e.g*e.a,l=e.b*e.a;return{r:(Math.max(n*e.a,s*t.a)+n*(1-e.a)+s*(1-t.a))/i,g:(Math.max(a*e.a,h*t.a)+a*(1-e.a)+h*(1-t.a))/i,b:(Math.max(o*e.a,l*t.a)+o*(1-e.a)+l*(1-t.a))/i,a:i}}function Tt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a,n=t.r*t.a,a=t.g*t.a,o=t.b*t.a,s=e.r*e.a,h=e.g*e.a,l=e.b*e.a;return{r:(2*n<=t.a?2*n*s+n*(1-e.a)+s*(1-t.a):n*(1+e.a)+s*(1+t.a)-2*s*n-e.a*t.a)/i,g:(2*a<=t.a?2*a*h+a*(1-e.a)+h*(1-t.a):a*(1+e.a)+h*(1+t.a)-2*h*a-e.a*t.a)/i,b:(2*o<=t.a?2*o*l+o*(1-e.a)+l*(1-t.a):o*(1+e.a)+l*(1+t.a)-2*l*o-e.a*t.a)/i,a:i}}function Rt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a,n=t.r*t.a,a=t.g*t.a,o=t.b*t.a,s=e.r*e.a,h=e.g*e.a,l=e.b*e.a;return{r:(n+s-2*Math.min(n*e.a,s*t.a))/i,g:(a+h-2*Math.min(a*e.a,h*t.a))/i,b:(o+l-2*Math.min(o*e.a,l*t.a))/i,a:i}}function Pt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t.a*=r;const i=e.a+t.a-e.a*t.a,n=t.r*t.a,a=t.g*t.a,o=t.b*t.a,s=e.r*e.a,h=e.g*e.a,l=e.b*e.a;return{r:(n*e.a+s*t.a-2*n*s+n*(1-e.a)+s*(1-t.a))/i,g:(a*e.a+h*t.a-2*a*h+a*(1-e.a)+h*(1-t.a))/i,b:(o*e.a+l*t.a-2*o*l+o*(1-e.a)+l*(1-t.a))/i,a:i}}const Ot=function(t,e){for(var r=arguments.length,i=new Array(r>2?r-2:0),n=2;n<r;n++)i[n-2]=arguments[n];return new Promise(((r,n)=>{i.push(((t,e)=>{t&&n(t),r(e)})),t.bind(e)(...i)}))},Lt={},Ct=(t,e)=>{Lt[t]=e},Ut=t=>{const e=t.split(\"/\").slice(-1);var r;return(r=e[e.length-1].split(\".\").pop(),Object.entries(Lt).find((t=>t[1].includes(r)))||[])[0]};var zt=__nested_webpack_require_505601__(5025),Dt=__nested_webpack_require_505601__.n(zt),Nt=__nested_webpack_require_505601__(6551),Ft=__nested_webpack_require_505601__.n(Nt),jt=__nested_webpack_require_505601__(8834).lW;function Gt(t){return t._exif&&t._exif.tags&&t._exif.tags.Orientation||1}async function Ht(t,e,r){const i=await async function(t,e){const r=await Dt().fromBuffer(t);return r?r.mime:e?Ut(e):null}(t,e);if(\"string\"!=typeof i)return r(new Error(\"Could not find MIME for Buffer <\"+e+\">\"));this._originalMime=i.toLowerCase();try{const e=this.getMIME();if(!this.constructor.decoders[e])return l.call(this,\"Unsupported MIME type: \"+e,r);this.bitmap=this.constructor.decoders[e](t)}catch(t){return r.call(this,t,this)}try{this._exif=Ft().create(t).parse(),function(t){if(Gt(t)<2)return;const e=function(t){const e=t.getWidth(),r=t.getHeight();switch(Gt(t)){case 1:default:return null;case 2:return function(t,r){return[e-t-1,r]};case 3:return function(t,i){return[e-t-1,r-i-1]};case 4:return function(t,e){return[t,r-e-1]};case 5:return function(t,e){return[e,t]};case 6:return function(t,e){return[e,r-t-1]};case 7:return function(t,i){return[e-i-1,r-t-1]};case 8:return function(t,r){return[e-r-1,t]}}}(t),r=Gt(t)>4;!function(t,e,r,i){const n=t.bitmap.data,a=t.bitmap.width,o=jt.alloc(n.length);for(let t=0;t<e;t++)for(let s=0;s<r;s++){const[r,h]=i(t,s),l=e*s+t<<2,f=a*h+r<<2,u=n.readUInt32BE(f);o.writeUInt32BE(u,l)}t.bitmap.data=o,t.bitmap.width=e,t.bitmap.height=r}(t,r?t.bitmap.height:t.bitmap.width,r?t.bitmap.width:t.bitmap.height,e)}(this)}catch(t){}return r.call(this,null,this),this}function Wt(t,e){if(t===et&&(t=this.getMIME()),\"string\"!=typeof t)return l.call(this,\"mime must be a string\",e);if(\"function\"!=typeof e)return l.call(this,\"cb must be a function\",e);if(t=t.toLowerCase(),this._rgba&&this.constructor.hasAlpha[t]?this.bitmap.data=jt.from(this.bitmap.data):this.bitmap.data=function(t,e){return new t(e.bitmap.width,e.bitmap.height,e._background).composite(e,0,0).bitmap}(this.constructor,this).data,!this.constructor.encoders[t])return l.call(this,\"Unsupported MIME type: \"+t,e);{const r=this.constructor.encoders[t](this);r instanceof Promise?r.then((t=>{e.call(this,null,t)})):e.call(this,null,r)}return this}function qt(t){return Ot(Wt,this,t)}var Zt=__nested_webpack_require_505601__(8834).lW;function Yt(t,e,r){return(e=function(t){var e=function(t,e){if(\"object\"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var i=r.call(t,\"string\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(t)}(t);return\"symbol\"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}const Vt=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\",Xt=[NaN,NaN];for(let t=2;t<65;t++){const e=c()(c().BIN,Vt.slice(0,t))(new Array(65).join(\"1\"));Xt.push(e.length)}function Jt(){}function Qt(t){return Object.prototype.toString.call(t).toLowerCase().indexOf(\"arraybuffer\")>-1}function Kt(t){const e=Zt.alloc(t.byteLength),r=new Uint8Array(t);for(let t=0;t<e.length;++t)e[t]=r[t];return e}function $t(t,e){tt(t,((r,i)=>r?e(r):\"object\"==typeof i&&Zt.isBuffer(i)?e(null,i):\"object\"==typeof i&&Qt(i)?e(null,Kt(i)):new Error(`Could not load Buffer from <${t.url}>`)))}const te={data:null,width:null,height:null};class ee extends(s()){constructor(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];super(),Yt(this,\"bitmap\",te),Yt(this,\"_background\",0),Yt(this,\"_originalMime\",ee.MIME_PNG),Yt(this,\"_exif\",null),Yt(this,\"_rgba\",!0),Yt(this,\"writeAsync\",(t=>Ot(this.write,this,t))),Yt(this,\"getBase64Async\",(t=>Ot(this.getBase64,this,t))),Yt(this,\"getBuffer\",Wt),Yt(this,\"getBufferAsync\",qt),Yt(this,\"getPixelColour\",this.getPixelColor),Yt(this,\"setPixelColour\",this.setPixelColor);const n=this;let a=Jt;function o(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];const[i]=e;(i||{}).methodName=\"constructor\",setTimeout((()=>{i&&a===Jt?n.emitError(\"constructor\",i):i||n.emitMulti(\"constructor\",\"initialized\"),a.call(n,...e)}),1)}if(Qt(e[0])&&(e[0]=Kt(e[0])),\"number\"==typeof e[0]&&\"number\"==typeof e[1]||parseInt(e[0],10)&&parseInt(e[1],10)){const t=parseInt(e[0],10),r=parseInt(e[1],10);if(a=e[2],\"number\"==typeof e[2]&&(this._background=e[2],a=e[3]),\"string\"==typeof e[2]&&(this._background=ee.cssColorToHex(e[2]),a=e[3]),void 0===a&&(a=Jt),\"function\"!=typeof a)return l.call(this,\"cb must be a function\",o);this.bitmap={data:Zt.alloc(t*r*4),width:t,height:r};for(let t=0;t<this.bitmap.data.length;t+=4)this.bitmap.data.writeUInt32BE(this._background,t);o(null,this)}else if(\"object\"==typeof e[0]&&e[0].url){if(a=e[1]||Jt,\"function\"!=typeof a)return l.call(this,\"cb must be a function\",o);$t(e[0],((t,r)=>{if(t)return l.call(this,t,o);this.parseBitmap(r,e[0].url,o)}))}else if(e[0]instanceof ee){const[t]=e;if(a=e[1],void 0===a&&(a=Jt),\"function\"!=typeof a)return l.call(this,\"cb must be a function\",o);this.bitmap={data:Zt.from(t.bitmap.data),width:t.bitmap.width,height:t.bitmap.height},this._quality=t._quality,this._deflateLevel=t._deflateLevel,this._deflateStrategy=t._deflateStrategy,this._filterType=t._filterType,this._rgba=t._rgba,this._background=t._background,this._originalMime=t._originalMime,o(null,this)}else if((s=e[0])&&\"object\"==typeof s&&\"number\"==typeof s.width&&\"number\"==typeof s.height&&(Zt.isBuffer(s.data)||s.data instanceof Uint8Array||\"function\"==typeof Uint8ClampedArray&&s.data instanceof Uint8ClampedArray)&&(s.data.length===s.width*s.height*4||s.data.length===s.width*s.height*3)){const[t]=e;a=e[1]||Jt;const r=t.width*t.height*4===t.data.length?Zt.from(t.data):function(t){if(t.length%3!=0)throw new Error(\"Buffer length is incorrect\");const e=Zt.allocUnsafe(t.length/3*4);let r=0;for(let i=0;i<t.length;i++)e[r]=t[i],(i+1)%3==0&&(e[++r]=255),r++;return e}(t.data);this.bitmap={data:r,width:t.width,height:t.height},o(null,this)}else if(\"string\"==typeof e[0]){const t=e[0];if(a=e[1],void 0===a&&(a=Jt),\"function\"!=typeof a)return l.call(this,\"cb must be a function\",o);!function(t,e){i()&&\"function\"==typeof i().readFile&&!t.match(/^(http|ftp)s?:\\/\\/./)?i().readFile(t,e):$t({url:t},e)}(t,((e,r)=>{if(e)return l.call(this,e,o);this.parseBitmap(r,t,o)}))}else if(\"object\"==typeof e[0]&&Zt.isBuffer(e[0])){const t=e[0];if(a=e[1],\"function\"!=typeof a)return l.call(this,\"cb must be a function\",o);this.parseBitmap(t,null,o)}else{a=e[e.length-1],\"function\"!=typeof a&&(a=e[e.length-2],\"function\"!=typeof a&&(a=Jt));const t=ee.__extraConstructors.find((t=>t.test(...e)));if(!t)return l.call(this,\"No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.\",o);new Promise(((r,i)=>{t.run.call(this,r,i,...e)})).then((()=>o(null,this))).catch(o)}var s}parseBitmap(t,e,r){Ht.call(this,t,null,r)}rgba(t,e){return\"boolean\"!=typeof t?l.call(this,\"bool must be a boolean, true for RGBA or false for RGB\",e):(this._rgba=t,h(e)&&e.call(this,null,this),this)}emitMulti(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};r=Object.assign(r,{methodName:t,eventName:e}),this.emit(\"any\",r),t&&this.emit(t,r),this.emit(e,r)}emitError(t,e){this.emitMulti(t,\"error\",e)}getHeight(){return this.bitmap.height}getWidth(){return this.bitmap.width}inspect(){return\"<Jimp \"+(this.bitmap===te?\"pending...\":this.bitmap.width+\"x\"+this.bitmap.height)+\">\"}toString(){return\"[object Jimp]\"}getMIME(){return this._originalMime||ee.MIME_PNG}getExtension(){const t=this.getMIME();return(Lt[t.toLowerCase()]||[])[0]}write(t,e){if(!i()||!i().createWriteStream)throw new Error(\"Cant access the filesystem. You can use the getBase64 method.\");if(\"string\"!=typeof t)return l.call(this,\"path must be a string\",e);if(void 0===e&&(e=Jt),\"function\"!=typeof e)return l.call(this,\"cb must be a function\",e);const r=Ut(t)||this.getMIME(),n=a().parse(t);return n.dir&&i().mkdirSync(n.dir,{recursive:!0}),this.getBuffer(r,((r,n)=>{if(r)return l.call(this,r,e);const a=i().createWriteStream(t);a.on(\"open\",(()=>{a.write(n),a.end()})).on(\"error\",(t=>l.call(this,t,e))),a.on(\"finish\",(()=>{e.call(this,null,this)}))})),this}getBase64(t,e){return t===ee.AUTO&&(t=this.getMIME()),\"string\"!=typeof t?l.call(this,\"mime must be a string\",e):\"function\"!=typeof e?l.call(this,\"cb must be a function\",e):(this.getBuffer(t,(function(r,i){if(r)return l.call(this,r,e);const n=\"data:\"+t+\";base64,\"+i.toString(\"base64\");e.call(this,null,n)})),this)}hash(t,e){if(\"function\"==typeof(t=t||64)&&(e=t,t=64),\"number\"!=typeof t)return l.call(this,\"base must be a number\",e);if(t<2||t>64)return l.call(this,\"base must be a number between 2 and 64\",e);let r=this.pHash();for(r=c()(c().BIN,Vt.slice(0,t))(r);r.length<Xt[t];)r=\"0\"+r;return h(e)&&e.call(this,null,r),r}pHash(){return(new $).getHash(this)}distanceFromHash(t){const e=new $,r=e.getHash(this);return e.distance(r,t)}getPixelIndex(t,e,r,i){let n,a;if(\"function\"==typeof r&&void 0===i&&(i=r,r=null),r||(r=ee.EDGE_EXTEND),\"number\"!=typeof t||\"number\"!=typeof e)return l.call(this,\"x and y must be numbers\",i);n=t=Math.round(t),a=e=Math.round(e),r===ee.EDGE_EXTEND&&(t<0&&(n=0),t>=this.bitmap.width&&(n=this.bitmap.width-1),e<0&&(a=0),e>=this.bitmap.height&&(a=this.bitmap.height-1)),r===ee.EDGE_WRAP&&(t<0&&(n=this.bitmap.width+t),t>=this.bitmap.width&&(n=t%this.bitmap.width),e<0&&(a=this.bitmap.height+e),e>=this.bitmap.height&&(a=e%this.bitmap.height));let o=this.bitmap.width*a+n<<2;return(n<0||n>=this.bitmap.width)&&(o=-1),(a<0||a>=this.bitmap.height)&&(o=-1),h(i)&&i.call(this,null,o),o}getPixelColor(t,e,r){if(\"number\"!=typeof t||\"number\"!=typeof e)return l.call(this,\"x and y must be numbers\",r);t=Math.round(t),e=Math.round(e);const i=this.getPixelIndex(t,e),n=this.bitmap.data.readUInt32BE(i);return h(r)&&r.call(this,null,n),n}setPixelColor(t,e,r,i){if(\"number\"!=typeof t||\"number\"!=typeof e||\"number\"!=typeof r)return l.call(this,\"hex, x and y must be numbers\",i);e=Math.round(e),r=Math.round(r);const n=this.getPixelIndex(e,r);return this.bitmap.data.writeUInt32BE(t,n),h(i)&&i.call(this,null,this),this}hasAlpha(){for(let t=0;t<this.bitmap.height;t++)for(let e=0;e<this.bitmap.width;e++){const r=this.bitmap.width*t+e<<2;if(255!==this.bitmap.data[r+3])return!0}return!1}scanIterator(t,e,r,i){return\"number\"!=typeof t||\"number\"!=typeof e?l.call(this,\"x and y must be numbers\"):\"number\"!=typeof r||\"number\"!=typeof i?l.call(this,\"w and h must be numbers\"):function*(t,e,r,i,n){e=Math.round(e),r=Math.round(r),i=Math.round(i),n=Math.round(n);for(let a=r;a<r+n;a++)for(let r=e;r<e+i;r++){const e=t.bitmap.width*a+r<<2;yield{x:r,y:a,idx:e,image:t}}}(this,t,e,r,i)}}function re(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ee;Object.entries(t).forEach((t=>{let[r,i]=t;e[r]=i}))}function ie(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ee;Object.entries(t).forEach((t=>{let[r,i]=t;e.prototype[r]=i}))}function ne(t,e,r){const i=\"before-\"+e,n=e.replace(/e$/,\"\")+\"ed\";ee.prototype[t]=function(){let e;for(var a=arguments.length,o=new Array(a),s=0;s<a;s++)o[s]=arguments[s];const h=o[r.length-1],l=this;let f;\"function\"==typeof h?(e=function(){for(var e=arguments.length,r=new Array(e),i=0;i<e;i++)r[i]=arguments[i];const[a,o]=r;a?l.emitError(t,a):l.emitMulti(t,n,{[t]:o}),h.apply(this,r)},o[o.length-1]=e):e=!1,this.emitMulti(t,i);try{f=r.apply(this,o),e||this.emitMulti(t,n,{[t]:f})}catch(e){e.methodName=t,this.emitError(t,e)}return f},ee.prototype[t+\"Quiet\"]=r}function ae(t,e){ne(t,\"change\",e)}re(t),ie({composite:function(t,r,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4?arguments[4]:void 0;if(\"function\"==typeof n&&(a=n,n={}),!(t instanceof this.constructor))return l.call(this,\"The source must be a Jimp image\",a);if(\"number\"!=typeof r||\"number\"!=typeof i)return l.call(this,\"x and y must be numbers\",a);let{mode:o,opacitySource:s,opacityDest:f}=n;o||(o=ht),(\"number\"!=typeof s||s<0||s>1)&&(s=1),(\"number\"!=typeof f||f<0||f>1)&&(f=1);const u=e[o];r=Math.round(r),i=Math.round(i);const c=this;return 1!==f&&c.opacity(f),t.scanQuiet(0,0,t.bitmap.width,t.bitmap.height,(function(t,e,n){const a=c.getPixelIndex(r+t,i+e,vt);if(-1===a)return;const o=u({r:this.bitmap.data[n+0]/255,g:this.bitmap.data[n+1]/255,b:this.bitmap.data[n+2]/255,a:this.bitmap.data[n+3]/255},{r:c.bitmap.data[a+0]/255,g:c.bitmap.data[a+1]/255,b:c.bitmap.data[a+2]/255,a:c.bitmap.data[a+3]/255},s);c.bitmap.data[a+0]=this.constructor.limit255(255*o.r),c.bitmap.data[a+1]=this.constructor.limit255(255*o.g),c.bitmap.data[a+2]=this.constructor.limit255(255*o.b),c.bitmap.data[a+3]=this.constructor.limit255(255*o.a)})),h(a)&&a.call(this,null,this),this}}),ee.__extraConstructors=[],ee.appendConstructorOption=function(t,e,r){ee.__extraConstructors.push({name:t,test:e,run:r})},ee.read=function(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return new Promise(((t,r)=>{new ee(...e,((e,i)=>{e?r(e):t(i)}))}))},ee.create=ee.read,ee.rgbaToInt=function(t,e,r,i,n){if(\"number\"!=typeof t||\"number\"!=typeof e||\"number\"!=typeof r||\"number\"!=typeof i)return l.call(this,\"r, g, b and a must be numbers\",n);if(t<0||t>255)return l.call(this,\"r must be between 0 and 255\",n);if((e<0||e>255)&&l.call(this,\"g must be between 0 and 255\",n),r<0||r>255)return l.call(this,\"b must be between 0 and 255\",n);if(i<0||i>255)return l.call(this,\"a must be between 0 and 255\",n);t=Math.round(t),r=Math.round(r),e=Math.round(e),i=Math.round(i);const a=t*Math.pow(256,3)+e*Math.pow(256,2)+r*Math.pow(256,1)+i*Math.pow(256,0);return h(n)&&n.call(this,null,a),a},ee.intToRGBA=function(t,e){if(\"number\"!=typeof t)return l.call(this,\"i must be a number\",e);const r={};return r.r=Math.floor(t/Math.pow(256,3)),r.g=Math.floor((t-r.r*Math.pow(256,3))/Math.pow(256,2)),r.b=Math.floor((t-r.r*Math.pow(256,3)-r.g*Math.pow(256,2))/Math.pow(256,1)),r.a=Math.floor((t-r.r*Math.pow(256,3)-r.g*Math.pow(256,2)-r.b*Math.pow(256,1))/Math.pow(256,0)),h(e)&&e.call(this,null,r),r},ee.cssColorToHex=function(t){return\"number\"==typeof(t=t||0)?Number(t):parseInt(_(t).toHex8(),16)},ee.limit255=function(t){return t=Math.max(t,0),Math.min(t,255)},ee.diff=function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;if(!(t instanceof ee&&e instanceof ee))return l.call(this,\"img1 and img2 must be an Jimp images\");const i=t.bitmap,n=e.bitmap;if(i.width===n.width&&i.height===n.height||(i.width*i.height>n.width*n.height?t=t.cloneQuiet().resize(n.width,n.height):e=e.cloneQuiet().resize(i.width,i.height)),\"number\"!=typeof r||r<0||r>1)return l.call(this,\"threshold must be a number between 0 and 1\");const a=new ee(i.width,i.height,4294967295);return{percent:p()(i.data,n.data,a.bitmap.data,a.bitmap.width,a.bitmap.height,{threshold:r})/(a.bitmap.width*a.bitmap.height),image:a}},ee.distance=function(t,e){const r=new $,i=r.getHash(t),n=r.getHash(e);return r.distance(i,n)},ee.compareHashes=function(t,e){return(new $).distance(t,e)},ee.colorDiff=function(t,e){const r=t=>Math.pow(t,2),{max:i}=Math;return 0===t.a||t.a||(t.a=255),0===e.a||e.a||(e.a=255),(i(r(t.r-e.r),r(t.r-e.r-t.a+e.a))+i(r(t.g-e.g),r(t.g-e.g-t.a+e.a))+i(r(t.b-e.b),r(t.b-e.b-t.a+e.a)))/195075},ne(\"clone\",\"clone\",(function(t){const e=new ee(this);return h(t)&&t.call(e,null,e),e})),ae(\"background\",(function(t,e){return\"number\"!=typeof t?l.call(this,\"hex must be a hexadecimal rgba value\",e):(this._background=t,h(e)&&e.call(this,null,this),this)})),ae(\"scan\",(function(t,e,r,i,n,a){if(\"number\"!=typeof t||\"number\"!=typeof e)return l.call(this,\"x and y must be numbers\",a);if(\"number\"!=typeof r||\"number\"!=typeof i)return l.call(this,\"w and h must be numbers\",a);if(\"function\"!=typeof n)return l.call(this,\"f must be a function\",a);const o=f(this,t,e,r,i,n);return h(a)&&a.call(this,null,o),o}));{let t;\"undefined\"!=typeof window&&\"object\"==typeof window&&(t=window),\"undefined\"!=typeof self&&\"object\"==typeof self&&(t=self),t.Jimp=ee,t.Buffer=Zt}const oe=ee;var se=__nested_webpack_require_505601__(643),he=__nested_webpack_require_505601__(2691),le=__nested_webpack_require_505601__.n(he);const fe=\"image/jpeg\",ue=()=>({mime:{[fe]:[\"jpeg\",\"jpg\",\"jpe\"]},constants:{MIME_JPEG:fe},decoders:{[fe]:le().decode},encoders:{[fe]:t=>le().encode(t.bitmap,t._quality).data},class:{_quality:100,quality(t,e){return\"number\"!=typeof t?l.call(this,\"n must be a number\",e):t<0||t>100?l.call(this,\"n must be a number 0 - 100\",e):(this._quality=Math.round(t),h(e)&&e.call(this,null,this),this)}}});var ce=__nested_webpack_require_505601__(9902);const de=\"image/png\",pe=()=>({mime:{[de]:[\"png\"]},constants:{MIME_PNG:de,PNG_FILTER_AUTO:-1,PNG_FILTER_NONE:0,PNG_FILTER_SUB:1,PNG_FILTER_UP:2,PNG_FILTER_AVERAGE:3,PNG_FILTER_PATH:4},hasAlpha:{[de]:!0},decoders:{[de]:ce.PNG.sync.read},encoders:{[de](t){const e=new ce.PNG({width:t.bitmap.width,height:t.bitmap.height});return e.data=t.bitmap.data,ce.PNG.sync.write(e,{deflateLevel:t._deflateLevel,deflateStrategy:t._deflateStrategy,filterType:t._filterType,colorType:\"number\"==typeof t._colorType?t._colorType:t._rgba?6:2,inputHasAlpha:t._rgba})}},class:{_deflateLevel:9,_deflateStrategy:3,_filterType:-1,_colorType:null,deflateLevel(t,e){return\"number\"!=typeof t?l.call(this,\"l must be a number\",e):t<0||t>9?l.call(this,\"l must be a number 0 - 9\",e):(this._deflateLevel=Math.round(t),h(e)&&e.call(this,null,this),this)},deflateStrategy(t,e){return\"number\"!=typeof t?l.call(this,\"s must be a number\",e):t<0||t>3?l.call(this,\"s must be a number 0 - 3\",e):(this._deflateStrategy=Math.round(t),h(e)&&e.call(this,null,this),this)},filterType(t,e){return\"number\"!=typeof t?l.call(this,\"n must be a number\",e):t<-1||t>4?l.call(this,\"n must be -1 (auto) or a number 0 - 4\",e):(this._filterType=Math.round(t),h(e)&&e.call(this,null,this),this)},colorType(t,e){return\"number\"!=typeof t?l.call(this,\"s must be a number\",e):0!==t&&2!==t&&4!==t&&6!==t?l.call(this,\"s must be a number 0, 2, 4, 6.\",e):(this._colorType=Math.round(t),h(e)&&e.call(this,null,this),this)}}});var me=__nested_webpack_require_505601__(486),ge=__nested_webpack_require_505601__.n(me);const be=\"image/bmp\",_e=\"image/x-ms-bmp\",ye=t=>{return f({bitmap:e=ge().decode(t)},0,0,e.width,e.height,(function(t,r,i){const n=this.bitmap.data[i+0],a=this.bitmap.data[i+1],o=this.bitmap.data[i+2],s=this.bitmap.data[i+3];this.bitmap.data[i+0]=s,this.bitmap.data[i+1]=o,this.bitmap.data[i+2]=a,this.bitmap.data[i+3]=e.is_with_alpha?n:255})).bitmap;var e},we=t=>ge().encode(function(t){return f(t,0,0,t.bitmap.width,t.bitmap.height,(function(t,e,r){const i=this.bitmap.data[r+0],n=this.bitmap.data[r+1],a=this.bitmap.data[r+2],o=this.bitmap.data[r+3];this.bitmap.data[r+0]=o,this.bitmap.data[r+1]=a,this.bitmap.data[r+2]=n,this.bitmap.data[r+3]=i})).bitmap}(t)).data;var ve=__nested_webpack_require_505601__(9299),xe=__nested_webpack_require_505601__.n(ve),Ee=__nested_webpack_require_505601__(8834).lW;const ke=\"image/tiff\";var Se=__nested_webpack_require_505601__(63),Me=__nested_webpack_require_505601__(9455),Ae=__nested_webpack_require_505601__(8834).lW;const Ie=\"image/gif\",Be=[1,57,41,21,203,34,97,73,227,91,149,62,105,45,39,137,241,107,3,173,39,71,65,238,219,101,187,87,81,151,141,133,249,117,221,209,197,187,177,169,5,153,73,139,133,127,243,233,223,107,103,99,191,23,177,171,165,159,77,149,9,139,135,131,253,245,119,231,224,109,211,103,25,195,189,23,45,175,171,83,81,79,155,151,147,9,141,137,67,131,129,251,123,30,235,115,113,221,217,53,13,51,50,49,193,189,185,91,179,175,43,169,83,163,5,79,155,19,75,147,145,143,35,69,17,67,33,65,255,251,247,243,239,59,29,229,113,111,219,27,213,105,207,51,201,199,49,193,191,47,93,183,181,179,11,87,43,85,167,165,163,161,159,157,155,77,19,75,37,73,145,143,141,35,138,137,135,67,33,131,129,255,63,250,247,61,121,239,237,117,29,229,227,225,111,55,109,216,213,211,209,207,205,203,201,199,197,195,193,48,190,47,93,185,183,181,179,178,176,175,173,171,85,21,167,165,41,163,161,5,79,157,78,154,153,19,75,149,74,147,73,144,143,71,141,140,139,137,17,135,134,133,66,131,65,129,1],Te=[0,9,10,10,14,12,14,14,16,15,16,15,16,15,15,17,18,17,12,18,16,17,17,19,19,18,19,18,18,19,19,19,20,19,20,20,20,20,20,20,15,20,19,20,20,20,21,21,21,20,20,20,21,18,21,21,21,21,20,21,17,21,21,21,22,22,21,22,22,21,22,21,19,22,22,19,20,22,22,21,21,21,22,22,22,18,22,22,21,22,22,23,22,20,23,22,22,23,23,21,19,21,21,21,23,23,23,22,23,23,21,23,22,23,18,22,23,20,22,23,23,23,21,22,20,22,21,22,24,24,24,24,24,22,21,24,23,23,24,21,24,23,24,22,24,24,22,24,24,22,23,24,24,24,20,23,22,23,24,24,24,24,24,24,24,23,21,23,22,23,24,24,24,22,24,24,24,23,22,24,24,25,23,25,25,23,24,25,25,24,22,25,25,25,24,23,24,25,25,25,25,25,25,25,25,25,25,25,25,23,25,23,24,25,25,25,25,25,25,25,25,25,24,22,25,25,23,25,25,20,24,25,24,25,25,22,24,25,24,25,24,25,25,24,25,25,25,25,22,25,25,25,24,25,24,25,18];var Re=__nested_webpack_require_505601__(8834).lW;function Pe(t,e,r,i){const n=[0,0,0],a=(e.length-1)/2;for(let o=0;o<e.length;o+=1)for(let s=0;s<e[o].length;s+=1){const h=t.getPixelIndex(r+o-a,i+s-a);n[0]+=t.bitmap.data[h]*e[o][s],n[1]+=t.bitmap.data[h+1]*e[o][s],n[2]+=t.bitmap.data[h+2]*e[o][s]}return n}const Oe=t=>null!=t;function Le(t){return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(t,e,r){const i=parseInt(.2126*this.bitmap.data[r]+.7152*this.bitmap.data[r+1]+.0722*this.bitmap.data[r+2],10);this.bitmap.data[r]=i,this.bitmap.data[r+1]=i,this.bitmap.data[r+2]=i})),h(t)&&t.call(this,null,this),this}function Ce(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:50;return{r:(e.r-t.r)*(r/100)+t.r,g:(e.g-t.g)*(r/100)+t.g,b:(e.b-t.b)*(r/100)+t.b}}function Ue(t,e){return t&&Array.isArray(t)?(t=t.map((t=>(\"xor\"!==t.apply&&\"mix\"!==t.apply||(t.params[0]=_(t.params[0]).toRgb()),t))),this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,((r,i,n)=>{let a={r:this.bitmap.data[n],g:this.bitmap.data[n+1],b:this.bitmap.data[n+2]};const o=(t,e)=>this.constructor.limit255(a[t]+e);t.forEach((t=>{if(\"mix\"===t.apply)a=Ce(a,t.params[0],t.params[1]);else if(\"tint\"===t.apply)a=Ce(a,{r:255,g:255,b:255},t.params[0]);else if(\"shade\"===t.apply)a=Ce(a,{r:0,g:0,b:0},t.params[0]);else if(\"xor\"===t.apply)a={r:a.r^t.params[0].r,g:a.g^t.params[0].g,b:a.b^t.params[0].b};else if(\"red\"===t.apply)a.r=o(\"r\",t.params[0]);else if(\"green\"===t.apply)a.g=o(\"g\",t.params[0]);else if(\"blue\"===t.apply)a.b=o(\"b\",t.params[0]);else{if(\"hue\"===t.apply&&(t.apply=\"spin\"),a=_(a),!a[t.apply])return l.call(this,\"action \"+t.apply+\" not supported\",e);a=a[t.apply](...t.params).toRgb()}})),this.bitmap.data[n]=a.r,this.bitmap.data[n+1]=a.g,this.bitmap.data[n+2]=a.b})),h(e)&&e.call(this,null,this),this):l.call(this,\"actions must be an array\",e)}Object.freeze({LIGHTEN:\"lighten\",BRIGHTEN:\"brighten\",DARKEN:\"darken\",DESATURATE:\"desaturate\",SATURATE:\"saturate\",GREYSCALE:\"greyscale\",SPIN:\"spin\",HUE:\"hue\",MIX:\"mix\",TINT:\"tint\",SHADE:\"shade\",XOR:\"xor\",RED:\"red\",GREEN:\"green\",BLUE:\"blue\"});var ze=__nested_webpack_require_505601__(8834).lW;function De(t){const e=[1,9,3,11,13,5,15,7,4,12,2,10,16,8,14,6];return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(t,r,i){const n=e[((3&r)<<2)+t%4];this.bitmap.data[i]=Math.min(this.bitmap.data[i]+n,255),this.bitmap.data[i+1]=Math.min(this.bitmap.data[i+1]+n,255),this.bitmap.data[i+2]=Math.min(this.bitmap.data[i+2]+n,255)})),h(t)&&t.call(this,null,this),this}var Ne=__nested_webpack_require_505601__(8834).lW;function Fe(t,e,r){if(\"boolean\"!=typeof t||\"boolean\"!=typeof e)return l.call(this,\"horizontal and vertical must be Booleans\",r);const i=Ne.alloc(this.bitmap.data.length);return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(r,n,a){const o=t?this.bitmap.width-1-r:r,s=e?this.bitmap.height-1-n:n,h=this.bitmap.width*s+o<<2,l=this.bitmap.data.readUInt32BE(a);i.writeUInt32BE(l,h)})),this.bitmap.data=Ne.from(i),h(r)&&r.call(this,null,this),this}function je(){const t={r:new Array(256).fill(0),g:new Array(256).fill(0),b:new Array(256).fill(0)};return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(e,r,i){t.r[this.bitmap.data[i+0]]++,t.g[this.bitmap.data[i+1]]++,t.b[this.bitmap.data[i+2]]++})),t}const Ge=function(t,e,r){return 255*(t-e)/(r-e)},He=function(t){return[t.findIndex((t=>t>0)),255-t.slice().reverse().findIndex((t=>t>0))]};var We=__nested_webpack_require_505601__(8058),qe=__nested_webpack_require_505601__.n(We);function Ze(t,e){let r=0;for(let i=0;i<e.length;i++)if(t.chars[e[i]]){const n=t.kernings[e[i]]&&t.kernings[e[i]][e[i+1]]?t.kernings[e[i]][e[i+1]]:0;r+=(t.chars[e[i]].xadvance||0)+n}return r}function Ye(t,e,r){const i=e.split(\" \"),n=[];let a=[],o=0;return i.forEach((e=>{const i=[...a,e].join(\" \"),s=Ze(t,i);s<=r?(s>o&&(o=s),a.push(e)):(n.push(a),a=[e])})),n.push(a),{lines:n,longestLine:o}}function Ve(t,e,r){const{lines:i}=Ye(t,e,r);return i.length*t.common.lineHeight}function Xe(t,e,r,i,n){if(n.width>0&&n.height>0){const a=e.pages[n.page];t.blit(a,r+n.xoffset,i+n.yoffset,n.x,n.y,n.width,n.height)}return t}function Je(t,e,r,i,n){for(let a=0;a<i.length;a++){let o;o=t.chars[i[a]]?i[a]:/\\s/.test(i[a])?\"\":\"?\";const s=t.chars[o]||{},h=t.kernings[o];Xe(this,t,e,r,s||{}),e+=(h&&h[i[a+1]]?h[i[a+1]]:0)+(s.xadvance||n)}}const Qe=\"//../\";function Ke(t,e,r,i,n,a,o){this.widthOriginal=Math.abs(Math.floor(t)||0),this.heightOriginal=Math.abs(Math.floor(e)||0),this.targetWidth=Math.abs(Math.floor(r)||0),this.targetHeight=Math.abs(Math.floor(i)||0),this.colorChannels=n?4:3,this.interpolationPass=Boolean(a),this.resizeCallback=\"function\"==typeof o?o:function(){},this.targetWidthMultipliedByChannels=this.targetWidth*this.colorChannels,this.originalWidthMultipliedByChannels=this.widthOriginal*this.colorChannels,this.originalHeightMultipliedByChannels=this.heightOriginal*this.colorChannels,this.widthPassResultSize=this.targetWidthMultipliedByChannels*this.heightOriginal,this.finalResultSize=this.targetWidthMultipliedByChannels*this.targetHeight,this.initialize()}Ke.prototype.initialize=function(){if(!(this.widthOriginal>0&&this.heightOriginal>0&&this.targetWidth>0&&this.targetHeight>0))throw new Error(\"Invalid settings specified for the resizer.\");this.configurePasses()},Ke.prototype.configurePasses=function(){this.widthOriginal===this.targetWidth?this.resizeWidth=this.bypassResizer:(this.ratioWeightWidthPass=this.widthOriginal/this.targetWidth,this.ratioWeightWidthPass<1&&this.interpolationPass?(this.initializeFirstPassBuffers(!0),this.resizeWidth=4===this.colorChannels?this.resizeWidthInterpolatedRGBA:this.resizeWidthInterpolatedRGB):(this.initializeFirstPassBuffers(!1),this.resizeWidth=4===this.colorChannels?this.resizeWidthRGBA:this.resizeWidthRGB)),this.heightOriginal===this.targetHeight?this.resizeHeight=this.bypassResizer:(this.ratioWeightHeightPass=this.heightOriginal/this.targetHeight,this.ratioWeightHeightPass<1&&this.interpolationPass?(this.initializeSecondPassBuffers(!0),this.resizeHeight=this.resizeHeightInterpolated):(this.initializeSecondPassBuffers(!1),this.resizeHeight=4===this.colorChannels?this.resizeHeightRGBA:this.resizeHeightRGB))},Ke.prototype._resizeWidthInterpolatedRGBChannels=function(t,e){const r=e?4:3,i=this.ratioWeightWidthPass,n=this.widthBuffer;let a,o,s=0,h=0,l=0,f=0,u=0;for(a=0;s<1/3;a+=r,s+=i)for(h=a,l=0;h<this.widthPassResultSize;l+=this.originalWidthMultipliedByChannels,h+=this.targetWidthMultipliedByChannels)n[h]=t[l],n[h+1]=t[l+1],n[h+2]=t[l+2],e&&(n[h+3]=t[l+3]);for(s-=1/3,o=this.widthOriginal-1;s<o;a+=r,s+=i)for(u=s%1,f=1-u,h=a,l=Math.floor(s)*r;h<this.widthPassResultSize;l+=this.originalWidthMultipliedByChannels,h+=this.targetWidthMultipliedByChannels)n[h+0]=t[l+0]*f+t[l+r+0]*u,n[h+1]=t[l+1]*f+t[l+r+1]*u,n[h+2]=t[l+2]*f+t[l+r+2]*u,e&&(n[h+3]=t[l+3]*f+t[l+r+3]*u);for(o=this.originalWidthMultipliedByChannels-r;a<this.targetWidthMultipliedByChannels;a+=r)for(h=a,l=o;h<this.widthPassResultSize;l+=this.originalWidthMultipliedByChannels,h+=this.targetWidthMultipliedByChannels)n[h]=t[l],n[h+1]=t[l+1],n[h+2]=t[l+2],e&&(n[h+3]=t[l+3]);return n},Ke.prototype._resizeWidthRGBChannels=function(t,e){const r=e?4:3,i=this.ratioWeightWidthPass,n=1/i,a=this.originalWidthMultipliedByChannels-r+1,o=this.targetWidthMultipliedByChannels-r+1,s=this.outputWidthWorkBench,h=this.widthBuffer,l=this.outputWidthWorkBenchOpaquePixelsCount;let f=0,u=0,c=0,d=0,p=0,m=0,g=0,b=1,_=0,y=0,w=0,v=0;do{for(p=0;p<this.originalHeightMultipliedByChannels;)s[p++]=0,s[p++]=0,s[p++]=0,e&&(s[p++]=0,l[p/r-1]=0);f=i;do{for(u=1+c-d,b=Math.min(f,u),p=0,m=c;p<this.originalHeightMultipliedByChannels;m+=a)_=t[m],y=t[++m],w=t[++m],v=e?t[++m]:255,s[p++]+=(v?_:0)*b,s[p++]+=(v?y:0)*b,s[p++]+=(v?w:0)*b,e&&(s[p++]+=v*b,l[p/r-1]+=v?b:0);if(!(f>=u)){d+=f;break}c+=r,d=c,f-=u}while(f>0&&c<this.originalWidthMultipliedByChannels);for(p=0,m=g;p<this.originalHeightMultipliedByChannels;m+=o)f=e?l[p/r]:1,b=e?f?1/f:0:n,h[m]=s[p++]*b,h[++m]=s[p++]*b,h[++m]=s[p++]*b,e&&(h[++m]=s[p++]*n);g+=r}while(g<this.targetWidthMultipliedByChannels);return h},Ke.prototype._resizeHeightRGBChannels=function(t,e){const r=this.ratioWeightHeightPass,i=1/r,n=this.outputHeightWorkBench,a=this.heightBuffer,o=this.outputHeightWorkBenchOpaquePixelsCount;let s=0,h=0,l=0,f=0,u=0,c=0,d=0,p=1,m=0,g=0,b=0,_=0;do{for(u=0;u<this.targetWidthMultipliedByChannels;)n[u++]=0,n[u++]=0,n[u++]=0,e&&(n[u++]=0,o[u/4-1]=0);s=r;do{for(h=1+l-f,p=Math.min(s,h),d=l,u=0;u<this.targetWidthMultipliedByChannels;)m=t[d++],g=t[d++],b=t[d++],_=e?t[d++]:255,n[u++]+=(_?m:0)*p,n[u++]+=(_?g:0)*p,n[u++]+=(_?b:0)*p,e&&(n[u++]+=_*p,o[u/4-1]+=_?p:0);if(!(s>=h)){f+=s;break}l=d,f=l,s-=h}while(s>0&&l<this.widthPassResultSize);for(u=0;u<this.targetWidthMultipliedByChannels;)s=e?o[u/4]:1,p=e?s?1/s:0:i,a[c++]=Math.round(n[u++]*p),a[c++]=Math.round(n[u++]*p),a[c++]=Math.round(n[u++]*p),e&&(a[c++]=Math.round(n[u++]*i))}while(c<this.finalResultSize);return a},Ke.prototype.resizeWidthInterpolatedRGB=function(t){return this._resizeWidthInterpolatedRGBChannels(t,!1)},Ke.prototype.resizeWidthInterpolatedRGBA=function(t){return this._resizeWidthInterpolatedRGBChannels(t,!0)},Ke.prototype.resizeWidthRGB=function(t){return this._resizeWidthRGBChannels(t,!1)},Ke.prototype.resizeWidthRGBA=function(t){return this._resizeWidthRGBChannels(t,!0)},Ke.prototype.resizeHeightInterpolated=function(t){const e=this.ratioWeightHeightPass,r=this.heightBuffer;let i,n=0,a=0,o=0,s=0,h=0,l=0,f=0;for(;n<1/3;n+=e)for(o=0;o<this.targetWidthMultipliedByChannels;)r[a++]=Math.round(t[o++]);for(n-=1/3,i=this.heightOriginal-1;n<i;n+=e)for(f=n%1,l=1-f,s=Math.floor(n)*this.targetWidthMultipliedByChannels,h=s+this.targetWidthMultipliedByChannels,o=0;o<this.targetWidthMultipliedByChannels;++o)r[a++]=Math.round(t[s++]*l+t[h++]*f);for(;a<this.finalResultSize;)for(o=0,s=i*this.targetWidthMultipliedByChannels;o<this.targetWidthMultipliedByChannels;++o)r[a++]=Math.round(t[s++]);return r},Ke.prototype.resizeHeightRGB=function(t){return this._resizeHeightRGBChannels(t,!1)},Ke.prototype.resizeHeightRGBA=function(t){return this._resizeHeightRGBChannels(t,!0)},Ke.prototype.resize=function(t){this.resizeCallback(this.resizeHeight(this.resizeWidth(t)))},Ke.prototype.bypassResizer=function(t){return t},Ke.prototype.initializeFirstPassBuffers=function(t){this.widthBuffer=this.generateFloatBuffer(this.widthPassResultSize),t||(this.outputWidthWorkBench=this.generateFloatBuffer(this.originalHeightMultipliedByChannels),this.colorChannels>3&&(this.outputWidthWorkBenchOpaquePixelsCount=this.generateFloat64Buffer(this.heightOriginal)))},Ke.prototype.initializeSecondPassBuffers=function(t){this.heightBuffer=this.generateUint8Buffer(this.finalResultSize),t||(this.outputHeightWorkBench=this.generateFloatBuffer(this.targetWidthMultipliedByChannels),this.colorChannels>3&&(this.outputHeightWorkBenchOpaquePixelsCount=this.generateFloat64Buffer(this.targetWidth)))},Ke.prototype.generateFloatBuffer=function(t){try{return new Float32Array(t)}catch(t){return[]}},Ke.prototype.generateFloat64Buffer=function(t){try{return new Float64Array(t)}catch(t){return[]}},Ke.prototype.generateUint8Buffer=function(t){try{return new Uint8Array(t)}catch(t){return[]}};const $e=Ke;var tr=__nested_webpack_require_505601__(8834).lW;const er={nearestNeighbor(t,e){const r=t.width,i=t.height,n=e.width,a=e.height,o=t.data,s=e.data;for(let t=0;t<a;t++)for(let e=0;e<n;e++){let h=4*(t*n+e),l=4*(Math.floor(t*i/a)*r+Math.floor(e*r/n));s[h++]=o[l++],s[h++]=o[l++],s[h++]=o[l++],s[h++]=o[l++]}},bilinearInterpolation(t,e){const r=t.width,i=t.height,n=e.width,a=e.height,o=t.data,s=e.data,h=function(t,e,r,i,n){return e===i?r:Math.round((t-e)*n+(i-t)*r)},l=function(t,e,i,n,a,l,f,u){let c=4*(f*r+n)+e,d=4*(f*r+a)+e;const p=h(i,n,o[c],a,o[d]);if(u===f)s[t+e]=p;else{c=4*(u*r+n)+e,d=4*(u*r+a)+e;const m=h(i,n,o[c],a,o[d]);s[t+e]=h(l,f,p,u,m)}};for(let t=0;t<a;t++)for(let e=0;e<n;e++){const o=4*(t*n+e),s=e*r/n,h=Math.floor(s),f=Math.min(Math.ceil(s),r-1),u=t*i/a,c=Math.floor(u),d=Math.min(Math.ceil(u),i-1);l(o,0,s,h,f,u,c,d),l(o,1,s,h,f,u,c,d),l(o,2,s,h,f,u,c,d),l(o,3,s,h,f,u,c,d)}},_interpolate2D(t,e,r,i){const n=t.data,a=e.data,o=t.width,s=t.height,h=e.width,l=e.height,f=Math.max(1,Math.floor(o/h)),u=h*f,c=Math.max(1,Math.floor(s/l)),d=l*c,p=tr.alloc(u*s*4);for(let t=0;t<s;t++)for(let e=0;e<u;e++){const r=e*(o-1)/u,a=Math.floor(r),s=r-a,h=4*(t*o+a),l=4*(t*u+e);for(let t=0;t<4;t++){const e=h+t,r=a>0?n[e-4]:2*n[e]-n[e+4],f=n[e],u=n[e+4],c=a<o-2?n[e+8]:2*n[e+4]-n[e];p[l+t]=i(r,f,u,c,s)}}const m=tr.alloc(u*d*4);for(let t=0;t<d;t++)for(let e=0;e<u;e++){const r=t*(s-1)/d,n=Math.floor(r),a=r-n,o=4*(n*u+e),h=4*(t*u+e);for(let t=0;t<4;t++){const e=o+t,r=n>0?p[e-4*u]:2*p[e]-p[e+4*u],l=p[e],f=p[e+4*u],c=n<s-2?p[e+8*u]:2*p[e+4*u]-p[e];m[h+t]=i(r,l,f,c,a)}}const g=f*c;if(g>1)for(let t=0;t<l;t++)for(let e=0;e<h;e++){let r=0,i=0,n=0,o=0,s=0;for(let a=0;a<c;a++){const h=t*c+a;for(let t=0;t<f;t++){const a=4*(h*u+(e*f+t)),l=m[a+3];l&&(r+=m[a],i+=m[a+1],n+=m[a+2],s++),o+=l}}const l=4*(t*h+e);a[l]=s?Math.round(r/s):0,a[l+1]=s?Math.round(i/s):0,a[l+2]=s?Math.round(n/s):0,a[l+3]=Math.round(o/g)}else e.data=m},bicubicInterpolation(t,e,r){return this._interpolate2D(t,e,r,(function(t,e,r,i,n){const a=i-r-t+e,o=t-e-a,s=r-t,h=e;return Math.max(0,Math.min(255,a*(n*n*n)+o*(n*n)+s*n+h))}))},hermiteInterpolation(t,e,r){return this._interpolate2D(t,e,r,(function(t,e,r,i,n){const a=e,o=.5*(r-t),s=t-2.5*e+2*r-.5*i,h=.5*(i-t)+1.5*(e-r);return Math.max(0,Math.min(255,Math.round(((h*n+s)*n+o)*n+a)))}))},bezierInterpolation(t,e,r){return this._interpolate2D(t,e,r,(function(t,e,r,i,n){const a=1-n,o=e*a*a*a,s=3*(e+(r-t)/4)*a*a*n,h=3*(r-(i-e)/4)*a*n*n,l=r*n*n*n;return Math.max(0,Math.min(255,Math.round(o+s+h+l)))}))}},rr=er;var ir=__nested_webpack_require_505601__(8834).lW,nr=__nested_webpack_require_505601__(8834).lW;function ar(t){if(Math.abs(t)%90!=0)throw new Error(\"Unsupported matrix rotation degree\");if(t%=360,0===Math.abs(t))return;const e=this.bitmap.width,r=this.bitmap.height;let i;switch(t){case 90:case-270:i=90;break;case 180:case-180:i=180;break;case 270:case-90:i=-90;break;default:throw new Error(\"Unsupported matrix rotation degree\")}const n=180===i?e:r,a=180===i?r:e,o=nr.alloc(this.bitmap.data.length);function s(t,e){return function(e,r){return r*t+e<<2}}const h=s(e),l=s(n);for(let t=0;t<e;t++)for(let n=0;n<r;n++){const a=h(t,n),s=this.bitmap.data.readUInt32BE(a);let f;switch(i){case 90:f=l(n,e-t-1);break;case-90:f=l(r-n-1,t);break;case 180:f=l(e-t-1,r-n-1);break;default:throw new Error(\"Unsupported matrix rotation angle\")}o.writeUInt32BE(s,f)}this.bitmap.data=o,this.bitmap.width=n,this.bitmap.height=a}function or(t,e){const r=(t%=360)*Math.PI/180,i=Math.cos(r),n=Math.sin(r);let a=this.bitmap.width,o=this.bitmap.height;if(!0===e||\"string\"==typeof e){a=Math.ceil(Math.abs(this.bitmap.width*i)+Math.abs(this.bitmap.height*n))+1,o=Math.ceil(Math.abs(this.bitmap.width*n)+Math.abs(this.bitmap.height*i))+1,a%2!=0&&a++,o%2!=0&&o++;const t=this.cloneQuiet();this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(t,e,r){this.bitmap.data.writeUInt32BE(this._background,r)}));const r=Math.max(a,o,this.bitmap.width,this.bitmap.height);this.resize(r,r,e),this.blit(t,this.bitmap.width/2-t.bitmap.width/2,this.bitmap.height/2-t.bitmap.height/2)}const s=this.bitmap.width,h=this.bitmap.height,l=nr.alloc(this.bitmap.data.length);function f(t,e){return function(r,i){return{x:r+t,y:i+e}}}const u=f(-s/2,-h/2),c=f(s/2+.5,h/2+.5);for(let t=1;t<=h;t++)for(let e=1;e<=s;e++){const r=u(e,t),a=c(i*r.x-n*r.y,i*r.y+n*r.x),o=s*(t-1)+e-1<<2;if(a.x>=0&&a.x<s&&a.y>=0&&a.y<h){const t=(s*(0|a.y)+a.x|0)<<2,e=this.bitmap.data.readUInt32BE(t);l.writeUInt32BE(e,o)}else l.writeUInt32BE(this._background,o)}if(this.bitmap.data=l,!0===e||\"string\"==typeof e){const t=s/2-a/2,e=h/2-o/2;this.crop(t,e,a,o)}}const sr=[()=>({blit(t,e,r,i,n,a,o,s){if(!(t instanceof this.constructor))return l.call(this,\"The source must be a Jimp image\",s);if(\"number\"!=typeof e||\"number\"!=typeof r)return l.call(this,\"x and y must be numbers\",s);if(\"function\"==typeof i)s=i,i=0,n=0,a=t.bitmap.width,o=t.bitmap.height;else{if(typeof i!=typeof n||typeof n!=typeof a||typeof a!=typeof o)return l.call(this,\"srcx, srcy, srcw, srch must be numbers\",s);i=i||0,n=n||0,a=a||t.bitmap.width,o=o||t.bitmap.height}e=Math.round(e),r=Math.round(r),i=Math.round(i),n=Math.round(n),a=Math.round(a),o=Math.round(o);const f=this.bitmap.width,u=this.bitmap.height,c=this;return t.scanQuiet(i,n,a,o,(function(t,a,o){const s=e+t-i,h=r+a-n;if(s>=0&&h>=0&&f-s>0&&u-h>0){const t=c.getPixelIndex(s,h),e={r:this.bitmap.data[o],g:this.bitmap.data[o+1],b:this.bitmap.data[o+2],a:this.bitmap.data[o+3]},r={r:c.bitmap.data[t],g:c.bitmap.data[t+1],b:c.bitmap.data[t+2],a:c.bitmap.data[t+3]};c.bitmap.data[t]=(e.a*(e.r-r.r)-r.r+255>>8)+r.r,c.bitmap.data[t+1]=(e.a*(e.g-r.g)-r.g+255>>8)+r.g,c.bitmap.data[t+2]=(e.a*(e.b-r.b)-r.b+255>>8)+r.b,c.bitmap.data[t+3]=this.constructor.limit255(r.a+e.a)}})),h(s)&&s.call(this,null,this),this}}),()=>({blur(t,e){if(\"number\"!=typeof t)return l.call(this,\"r must be a number\",e);if(t<1)return l.call(this,\"r must be greater than 0\",e);let r,i,n,a,o,s,f,u,c,d,p,m,g,b;const _=this.bitmap.width-1,y=this.bitmap.height-1,w=t+1,v=Be[t],x=Te[t],E=[],k=[],S=[],M=[],A=[],I=[];let B=2;for(;B-- >0;){for(m=0,g=0,s=0;s<this.bitmap.height;s++){for(r=this.bitmap.data[g]*w,i=this.bitmap.data[g+1]*w,n=this.bitmap.data[g+2]*w,a=this.bitmap.data[g+3]*w,f=1;f<=t;f++)u=g+((f>_?_:f)<<2),r+=this.bitmap.data[u++],i+=this.bitmap.data[u++],n+=this.bitmap.data[u++],a+=this.bitmap.data[u];for(o=0;o<this.bitmap.width;o++)E[m]=r,k[m]=i,S[m]=n,M[m]=a,0===s&&(A[o]=((u=o+w)<_?u:_)<<2,I[o]=(u=o-t)>0?u<<2:0),c=g+A[o],d=g+I[o],r+=this.bitmap.data[c++]-this.bitmap.data[d++],i+=this.bitmap.data[c++]-this.bitmap.data[d++],n+=this.bitmap.data[c++]-this.bitmap.data[d++],a+=this.bitmap.data[c]-this.bitmap.data[d],m++;g+=this.bitmap.width<<2}for(o=0;o<this.bitmap.width;o++){for(p=o,r=E[p]*w,i=k[p]*w,n=S[p]*w,a=M[p]*w,f=1;f<=t;f++)p+=f>y?0:this.bitmap.width,r+=E[p],i+=k[p],n+=S[p],a+=M[p];for(m=o<<2,s=0;s<this.bitmap.height;s++)b=a*v>>>x,this.bitmap.data[m+3]=b,b>255&&(this.bitmap.data[m+3]=255),b>0?(b=255/b,this.bitmap.data[m]=(r*v>>>x)*b,this.bitmap.data[m+1]=(i*v>>>x)*b,this.bitmap.data[m+2]=(n*v>>>x)*b):(this.bitmap.data[m+2]=0,this.bitmap.data[m+1]=0,this.bitmap.data[m]=0),0===o&&(A[s]=((u=s+w)<y?u:y)*this.bitmap.width,I[s]=(u=s-t)>0?u*this.bitmap.width:0),c=o+A[s],d=o+I[s],r+=E[c]-E[d],i+=k[c]-k[d],n+=S[c]-S[d],a+=M[c]-M[d],m+=this.bitmap.width<<2}}return h(e)&&e.call(this,null,this),this}}),()=>({circle(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1?arguments[1]:void 0;\"function\"==typeof t&&(e=t,t={});const r=t.radius||(this.bitmap.width>this.bitmap.height?this.bitmap.height:this.bitmap.width)/2,i=\"number\"==typeof t.x?t.x:this.bitmap.width/2,n=\"number\"==typeof t.y?t.y:this.bitmap.height/2;return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(t,e,a){const o=Math.sqrt(Math.pow(t-i,2)+Math.pow(e-n,2));r-o<=0?this.bitmap.data[a+3]=0:r-o<1&&(this.bitmap.data[a+3]=255*(r-o))})),h(e)&&e.call(this,null,this),this}}),()=>({brightness(t,e){return\"number\"!=typeof t?l.call(this,\"val must be numbers\",e):t<-1||t>1?l.call(this,\"val must be a number between -1 and +1\",e):(this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(e,r,i){t<0?(this.bitmap.data[i]*=1+t,this.bitmap.data[i+1]*=1+t,this.bitmap.data[i+2]*=1+t):(this.bitmap.data[i]+=(255-this.bitmap.data[i])*t,this.bitmap.data[i+1]+=(255-this.bitmap.data[i+1])*t,this.bitmap.data[i+2]+=(255-this.bitmap.data[i+2])*t)})),h(e)&&e.call(this,null,this),this)},contrast(t,e){if(\"number\"!=typeof t)return l.call(this,\"val must be numbers\",e);if(t<-1||t>1)return l.call(this,\"val must be a number between -1 and +1\",e);const r=(t+1)/(1-t);function i(t){return(t=Math.floor(r*(t-127)+127))<0?0:t>255?255:t}return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(t,e,r){this.bitmap.data[r]=i(this.bitmap.data[r]),this.bitmap.data[r+1]=i(this.bitmap.data[r+1]),this.bitmap.data[r+2]=i(this.bitmap.data[r+2])})),h(e)&&e.call(this,null,this),this},posterize(t,e){return\"number\"!=typeof t?l.call(this,\"n must be numbers\",e):(t<2&&(t=2),this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(e,r,i){this.bitmap.data[i]=Math.floor(this.bitmap.data[i]/255*(t-1))/(t-1)*255,this.bitmap.data[i+1]=Math.floor(this.bitmap.data[i+1]/255*(t-1))/(t-1)*255,this.bitmap.data[i+2]=Math.floor(this.bitmap.data[i+2]/255*(t-1))/(t-1)*255})),h(e)&&e.call(this,null,this),this)},greyscale:Le,grayscale:Le,opacity(t,e){return\"number\"!=typeof t?l.call(this,\"f must be a number\",e):t<0||t>1?l.call(this,\"f must be a number from 0 to 1\",e):(this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(e,r,i){const n=this.bitmap.data[i+3]*t;this.bitmap.data[i+3]=n})),h(e)&&e.call(this,null,this),this)},sepia(t){return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(t,e,r){let i=this.bitmap.data[r],n=this.bitmap.data[r+1],a=this.bitmap.data[r+2];i=.393*i+.769*n+.189*a,n=.349*i+.686*n+.168*a,a=.272*i+.534*n+.131*a,this.bitmap.data[r]=i<255?i:255,this.bitmap.data[r+1]=n<255?n:255,this.bitmap.data[r+2]=a<255?a:255})),h(t)&&t.call(this,null,this),this},fade(t,e){return\"number\"!=typeof t?l.call(this,\"f must be a number\",e):t<0||t>1?l.call(this,\"f must be a number from 0 to 1\",e):(this.opacity(1-t),h(e)&&e.call(this,null,this),this)},convolution(t,e,r){\"function\"==typeof e&&void 0===r&&(r=e,e=null),e||(e=this.constructor.EDGE_EXTEND);const i=Re.from(this.bitmap.data),n=t.length,a=t[0].length,o=Math.floor(n/2),s=Math.floor(a/2),l=-o,f=-s;let u,c,d,p,m,g,b,_,y,w;return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(r,n,a){p=0,d=0,c=0;for(let i=l;i<=o;i++)for(let a=f;a<=s;a++)_=r+a,y=n+i,u=t[i+o][a+s],w=this.getPixelIndex(_,y,e),-1===w?(b=0,g=0,m=0):(m=this.bitmap.data[w+0],g=this.bitmap.data[w+1],b=this.bitmap.data[w+2]),c+=u*m,d+=u*g,p+=u*b;c<0&&(c=0),d<0&&(d=0),p<0&&(p=0),c>255&&(c=255),d>255&&(d=255),p>255&&(p=255),i[a+0]=c,i[a+1]=d,i[a+2]=p})),this.bitmap.data=i,h(r)&&r.call(this,null,this),this},opaque(t){return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(t,e,r){this.bitmap.data[r+3]=255})),h(t)&&t.call(this,null,this),this},pixelate(t,e,r,i,n,a){if(\"function\"==typeof e)a=e,n=null,i=null,r=null,e=null;else{if(\"number\"!=typeof t)return l.call(this,\"size must be a number\",a);if(Oe(e)&&\"number\"!=typeof e)return l.call(this,\"x must be a number\",a);if(Oe(r)&&\"number\"!=typeof r)return l.call(this,\"y must be a number\",a);if(Oe(i)&&\"number\"!=typeof i)return l.call(this,\"w must be a number\",a);if(Oe(n)&&\"number\"!=typeof n)return l.call(this,\"h must be a number\",a)}const o=[[1/16,2/16,1/16],[2/16,.25,2/16],[1/16,2/16,1/16]];e=e||0,r=r||0,i=Oe(i)?i:this.bitmap.width-e,n=Oe(n)?n:this.bitmap.height-r;const s=this.cloneQuiet();return this.scanQuiet(e,r,i,n,(function(e,r,i){e=t*Math.floor(e/t),r=t*Math.floor(r/t);const n=Pe(s,o,e,r);this.bitmap.data[i]=n[0],this.bitmap.data[i+1]=n[1],this.bitmap.data[i+2]=n[2]})),h(a)&&a.call(this,null,this),this},convolute(t,e,r,i,n,a){if(!Array.isArray(t))return l.call(this,\"the kernel must be an array\",a);if(\"function\"==typeof e)a=e,e=null,r=null,i=null,n=null;else{if(Oe(e)&&\"number\"!=typeof e)return l.call(this,\"x must be a number\",a);if(Oe(r)&&\"number\"!=typeof r)return l.call(this,\"y must be a number\",a);if(Oe(i)&&\"number\"!=typeof i)return l.call(this,\"w must be a number\",a);if(Oe(n)&&\"number\"!=typeof n)return l.call(this,\"h must be a number\",a)}e=Oe(e)?e:0,r=Oe(r)?r:0,i=Oe(i)?i:this.bitmap.width-e,n=Oe(n)?n:this.bitmap.height-r;const o=this.cloneQuiet();return this.scanQuiet(e,r,i,n,(function(e,r,i){const n=Pe(o,t,e,r);this.bitmap.data[i]=this.constructor.limit255(n[0]),this.bitmap.data[i+1]=this.constructor.limit255(n[1]),this.bitmap.data[i+2]=this.constructor.limit255(n[2])})),h(a)&&a.call(this,null,this),this},color:Ue,colour:Ue}),()=>({contain(t,e,r,i,n){if(\"number\"!=typeof t||\"number\"!=typeof e)return l.call(this,\"w and h must be numbers\",n);\"string\"==typeof r&&(\"function\"==typeof i&&void 0===n&&(n=i),i=r,r=null),\"function\"==typeof r&&(void 0===n&&(n=r),i=null,r=null),\"function\"==typeof i&&void 0===n&&(n=i,i=null);const a=7&(r=r||this.constructor.HORIZONTAL_ALIGN_CENTER|this.constructor.VERTICAL_ALIGN_MIDDLE),o=r>>3;if((0===a||a&a-1)&&(0===o||o&o-1))return l.call(this,\"only use one flag per alignment direction\",n);const s=a>>1,f=o>>1,u=t/e>this.bitmap.width/this.bitmap.height?e/this.bitmap.height:t/this.bitmap.width,c=this.cloneQuiet().scale(u,i);return this.resize(t,e,i),this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(t,e,r){this.bitmap.data.writeUInt32BE(this._background,r)})),this.blit(c,(this.bitmap.width-c.bitmap.width)/2*s,(this.bitmap.height-c.bitmap.height)/2*f),h(n)&&n.call(this,null,this),this}}),()=>({cover(t,e,r,i,n){if(\"number\"!=typeof t||\"number\"!=typeof e)return l.call(this,\"w and h must be numbers\",n);r&&\"function\"==typeof r&&void 0===n?(n=r,r=null,i=null):\"function\"==typeof i&&void 0===n&&(n=i,i=null);const a=7&(r=r||this.constructor.HORIZONTAL_ALIGN_CENTER|this.constructor.VERTICAL_ALIGN_MIDDLE),o=r>>3;if((0===a||a&a-1)&&(0===o||o&o-1))return l.call(this,\"only use one flag per alignment direction\",n);const s=a>>1,f=o>>1,u=t/e>this.bitmap.width/this.bitmap.height?t/this.bitmap.width:e/this.bitmap.height;return this.scale(u,i),this.crop((this.bitmap.width-t)/2*s,(this.bitmap.height-e)/2*f,t,e),h(n)&&n.call(this,null,this),this}}),function(t){return t(\"crop\",(function(t,e,r,i,n){if(\"number\"!=typeof t||\"number\"!=typeof e)return l.call(this,\"x and y must be numbers\",n);if(\"number\"!=typeof r||\"number\"!=typeof i)return l.call(this,\"w and h must be numbers\",n);if(t=Math.round(t),e=Math.round(e),r=Math.round(r),i=Math.round(i),0===t&&r===this.bitmap.width){const n=r*e+t<<2,a=n+(i*r<<2);this.bitmap.data=this.bitmap.data.slice(n,a)}else{const n=ze.allocUnsafe(r*i*4);let a=0;this.scanQuiet(t,e,r,i,(function(t,e,r){const i=this.bitmap.data.readUInt32BE(r,!0);n.writeUInt32BE(i,a,!0),a+=4})),this.bitmap.data=n}return this.bitmap.width=r,this.bitmap.height=i,h(n)&&n.call(this,null,this),this})),{class:{autocrop(){const t=this.bitmap.width,e=this.bitmap.height;let r,i=0,n=2e-4,a=!0,o=!1,s={north:!1,south:!1,east:!1,west:!1};for(var l=arguments.length,f=new Array(l),u=0;u<l;u++)f[u]=arguments[u];for(let t=0,e=f.length;t<e;t++)if(\"number\"==typeof f[t]&&(n=f[t]),\"boolean\"==typeof f[t]&&(a=f[t]),\"function\"==typeof f[t]&&(r=f[t]),\"object\"==typeof f[t]){const e=f[t];void 0!==e.tolerance&&({tolerance:n}=e),void 0!==e.cropOnlyFrames&&({cropOnlyFrames:a}=e),void 0!==e.cropSymmetric&&({cropSymmetric:o}=e),void 0!==e.leaveBorder&&({leaveBorder:i}=e),void 0!==e.ignoreSides&&({ignoreSides:s}=e)}let c=this.getPixelColor(0,0);const d=this.constructor.intToRGBA(c);let p=0,m=0,g=0,b=0;if(c=this.getPixelColor(0,0),!s.north)t:for(let r=0;r<e-1;r++){for(let e=0;e<t;e++){const t=this.getPixelColor(e,r),i=this.constructor.intToRGBA(t);if(this.constructor.colorDiff(d,i)>n)break t}p++}if(c=this.getPixelColor(t,0),!s.west)t:for(let r=0;r<t-1;r++){for(let t=0+p;t<e;t++){const e=this.getPixelColor(r,t),i=this.constructor.intToRGBA(e);if(this.constructor.colorDiff(d,i)>n)break t}b++}if(c=this.getPixelColor(0,e),!s.south)t:for(let r=e-1;r>=p+1;r--){for(let e=t-m-1;e>=0;e--){const t=this.getPixelColor(e,r),i=this.constructor.intToRGBA(t);if(this.constructor.colorDiff(d,i)>n)break t}g++}if(c=this.getPixelColor(t,e),!s.east)t:for(let r=t-1;r>=0+b+1;r--){for(let t=e-1;t>=0+p;t--){const e=this.getPixelColor(r,t),i=this.constructor.intToRGBA(e);if(this.constructor.colorDiff(d,i)>n)break t}m++}let _=!1;if(b-=i,m-=i,p-=i,g-=i,o){const t=Math.min(m,b),e=Math.min(p,g);b=t,m=t,p=e,g=e}b=b>=0?b:0,m=m>=0?m:0,p=p>=0?p:0,g=g>=0?g:0;const y=t-(b+m),w=e-(g+p);return _=a?0!==m&&0!==p&&0!==b&&0!==g:0!==m||0!==p||0!==b||0!==g,_&&this.crop(b,p,y,w),h(r)&&r.call(this,null,this),this}}}},()=>({displace(t,e,r){if(\"object\"!=typeof t||t.constructor!==this.constructor)return l.call(this,\"The source must be a Jimp image\",r);if(\"number\"!=typeof e)return l.call(this,\"factor must be a number\",r);const i=this.cloneQuiet();return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(r,n,a){let o=t.bitmap.data[a]/256*e;o=Math.round(o);const s=this.getPixelIndex(r+o,n);this.bitmap.data[s]=i.bitmap.data[a],this.bitmap.data[s+1]=i.bitmap.data[a+1],this.bitmap.data[s+2]=i.bitmap.data[a+2]})),h(r)&&r.call(this,null,this),this}}),()=>({dither565:De,dither16:De}),()=>({fisheye(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{r:2.5},e=arguments.length>1?arguments[1]:void 0;\"function\"==typeof t&&(e=t,t={r:2.5});const r=this.cloneQuiet(),{width:i,height:n}=r.bitmap;return r.scanQuiet(0,0,i,n,((e,a)=>{const o=e/i,s=a/n,h=Math.sqrt(Math.pow(o-.5,2)+Math.pow(s-.5,2)),l=2*Math.pow(h,t.r),f=(o-.5)/h,u=(s-.5)/h,c=Math.round((l*f+.5)*i),d=Math.round((l*u+.5)*n),p=r.getPixelColor(c,d);this.setPixelColor(p,e,a)})),this.setPixelColor(r.getPixelColor(i/2,n/2),i/2,n/2),h(e)&&e.call(this,null,this),this}}),()=>({flip:Fe,mirror:Fe}),()=>({gaussian(t,e){if(\"number\"!=typeof t)return l.call(this,\"r must be a number\",e);if(t<1)return l.call(this,\"r must be greater than 0\",e);const r=Math.ceil(2.57*t),i=2*r+1,n=t*t*2,a=n*Math.PI,o=[];for(let t=0;t<i;t++){o[t]=[];for(let e=0;e<i;e++){const i=(e-r)**2+(t-r)**2;o[t][e]=Math.exp(-i/n)/a}}for(let t=0;t<this.bitmap.height;t++)for(let e=0;e<this.bitmap.width;e++){let n=0,a=0,s=0,h=0,l=0;for(let f=0;f<i;f++){for(let u=0;u<i;u++){const i=Math.min(this.bitmap.width-1,Math.max(0,u+e-r)),c=Math.min(this.bitmap.height-1,Math.max(0,f+t-r)),d=o[f][u],p=c*this.bitmap.width+i<<2;n+=this.bitmap.data[p]*d,a+=this.bitmap.data[p+1]*d,s+=this.bitmap.data[p+2]*d,h+=this.bitmap.data[p+3]*d,l+=d}const u=t*this.bitmap.width+e<<2;this.bitmap.data[u]=Math.round(n/l),this.bitmap.data[u+1]=Math.round(a/l),this.bitmap.data[u+2]=Math.round(s/l),this.bitmap.data[u+3]=Math.round(h/l)}}return h(e)&&e.call(this,null,this),this}}),()=>({invert(t){return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(t,e,r){this.bitmap.data[r]=255-this.bitmap.data[r],this.bitmap.data[r+1]=255-this.bitmap.data[r+1],this.bitmap.data[r+2]=255-this.bitmap.data[r+2]})),h(t)&&t.call(this,null,this),this}}),()=>({mask(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3?arguments[3]:void 0;if(!(t instanceof this.constructor))return l.call(this,\"The source must be a Jimp image\",i);if(\"number\"!=typeof e||\"number\"!=typeof r)return l.call(this,\"x and y must be numbers\",i);e=Math.round(e),r=Math.round(r);const n=this.bitmap.width,a=this.bitmap.height,o=this;return t.scanQuiet(0,0,t.bitmap.width,t.bitmap.height,(function(t,i,s){const h=e+t,l=r+i;if(h>=0&&l>=0&&h<n&&l<a){const t=o.getPixelIndex(h,l),{data:e}=this.bitmap,r=(e[s+0]+e[s+1]+e[s+2])/3;o.bitmap.data[t+3]*=r/255}})),h(i)&&i.call(this,null,this),this}}),()=>({normalize(t){const e=je.call(this),r={r:He(e.r),g:He(e.g),b:He(e.b)};return this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,(function(t,e,i){const n=this.bitmap.data[i+0],a=this.bitmap.data[i+1],o=this.bitmap.data[i+2];this.bitmap.data[i+0]=Ge(n,r.r[0],r.r[1]),this.bitmap.data[i+1]=Ge(a,r.g[0],r.g[1]),this.bitmap.data[i+2]=Ge(o,r.b[0],r.b[1])})),h(t)&&t.call(this,null,this),this}}),()=>({constants:{measureText:Ze,measureTextHeight:Ve,FONT_SANS_8_BLACK:a().join(Qe,\"fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt\"),FONT_SANS_10_BLACK:a().join(Qe,\"fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt\"),FONT_SANS_12_BLACK:a().join(Qe,\"fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt\"),FONT_SANS_14_BLACK:a().join(Qe,\"fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt\"),FONT_SANS_16_BLACK:a().join(Qe,\"fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt\"),FONT_SANS_32_BLACK:a().join(Qe,\"fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt\"),FONT_SANS_64_BLACK:a().join(Qe,\"fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt\"),FONT_SANS_128_BLACK:a().join(Qe,\"fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt\"),FONT_SANS_8_WHITE:a().join(Qe,\"fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt\"),FONT_SANS_16_WHITE:a().join(Qe,\"fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt\"),FONT_SANS_32_WHITE:a().join(Qe,\"fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt\"),FONT_SANS_64_WHITE:a().join(Qe,\"fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt\"),FONT_SANS_128_WHITE:a().join(Qe,\"fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt\"),loadFont(t,e){return\"string\"!=typeof t?l.call(this,\"file must be a string\",e):new Promise(((r,i)=>{e=e||function(t,e){t?i(t):r(e)},qe()(t,((r,i)=>{const n={},o={};if(r)return l.call(this,r,e);for(let t=0;t<i.chars.length;t++)n[String.fromCharCode(i.chars[t].id)]=i.chars[t];for(let t=0;t<i.kernings.length;t++){const e=String.fromCharCode(i.kernings[t].first);o[e]=o[e]||{},o[e][String.fromCharCode(i.kernings[t].second)]=i.kernings[t].amount}(function(t,e,r){const i=r.map((r=>t.read(e+\"/\"+r)));return Promise.all(i)})(this,a().dirname(t),i.pages).then((t=>{e(null,{chars:n,kernings:o,pages:t,common:i.common,info:i.info})}))}))}))}},class:{print(t,e,r,i,n,a,o){if(\"function\"==typeof n&&void 0===o&&(o=n,n=1/0),void 0===n&&(n=1/0),\"function\"==typeof a&&void 0===o&&(o=a,a=1/0),void 0===a&&(a=1/0),\"object\"!=typeof t)return l.call(this,\"font must be a Jimp loadFont\",o);if(\"number\"!=typeof e||\"number\"!=typeof r||\"number\"!=typeof n)return l.call(this,\"x, y and maxWidth must be numbers\",o);if(\"number\"!=typeof n)return l.call(this,\"maxWidth must be a number\",o);if(\"number\"!=typeof a)return l.call(this,\"maxHeight must be a number\",o);let s,f;\"object\"==typeof i&&null!==i.text&&void 0!==i.text?(s=i.alignmentX||this.constructor.HORIZONTAL_ALIGN_LEFT,f=i.alignmentY||this.constructor.VERTICAL_ALIGN_TOP,({text:i}=i)):(s=this.constructor.HORIZONTAL_ALIGN_LEFT,f=this.constructor.VERTICAL_ALIGN_TOP,i=i.toString()),a!==1/0&&f===this.constructor.VERTICAL_ALIGN_BOTTOM?r+=a-Ve(t,i,n):a!==1/0&&f===this.constructor.VERTICAL_ALIGN_MIDDLE&&(r+=a/2-Ve(t,i,n)/2);const u=Object.entries(t.chars)[0][1].xadvance,{lines:c,longestLine:d}=Ye(t,i,n);return c.forEach((i=>{const a=i.join(\" \"),o=function(t,e,r,i,n){return n===t.HORIZONTAL_ALIGN_LEFT?0:n===t.HORIZONTAL_ALIGN_CENTER?(i-Ze(e,r))/2:i-Ze(e,r)}(this.constructor,t,a,n,s);Je.call(this,t,e+o,r,a,u),r+=t.common.lineHeight})),h(o)&&o.call(this,null,this,{x:e+d,y:r}),this}}}),()=>({constants:{RESIZE_NEAREST_NEIGHBOR:\"nearestNeighbor\",RESIZE_BILINEAR:\"bilinearInterpolation\",RESIZE_BICUBIC:\"bicubicInterpolation\",RESIZE_HERMITE:\"hermiteInterpolation\",RESIZE_BEZIER:\"bezierInterpolation\"},class:{resize(t,e,r,i){if(\"number\"!=typeof t||\"number\"!=typeof e)return l.call(this,\"w and h must be numbers\",i);if(\"function\"==typeof r&&void 0===i&&(i=r,r=null),t===this.constructor.AUTO&&e===this.constructor.AUTO)return l.call(this,\"w and h cannot both be set to auto\",i);if(t===this.constructor.AUTO&&(t=this.bitmap.width*(e/this.bitmap.height)),e===this.constructor.AUTO&&(e=this.bitmap.height*(t/this.bitmap.width)),t<0||e<0)return l.call(this,\"w and h must be positive numbers\",i);if(t=Math.round(t)||1,e=Math.round(e)||1,\"function\"==typeof rr[r]){const i={data:ir.alloc(t*e*4),width:t,height:e};rr[r](this.bitmap,i),this.bitmap=i}else{const r=this;new $e(this.bitmap.width,this.bitmap.height,t,e,!0,!0,(i=>{r.bitmap.data=ir.from(i),r.bitmap.width=t,r.bitmap.height=e})).resize(this.bitmap.data)}return h(i)&&i.call(this,null,this),this}}}),()=>({rotate(t,e,r){return null==e&&(e=!0),\"function\"==typeof e&&void 0===r&&(r=e,e=!0),\"number\"!=typeof t?l.call(this,\"deg must be a number\",r):\"boolean\"!=typeof e&&\"string\"!=typeof e?l.call(this,\"mode must be a boolean or a string\",r):(t%90!=0||!e&&this.bitmap.width!==this.bitmap.height&&t%180!=0?or.call(this,t,e,r):ar.call(this,t),h(r)&&r.call(this,null,this),this)}}),()=>({scale(t,e,r){if(\"number\"!=typeof t)return l.call(this,\"f must be a number\",r);if(t<0)return l.call(this,\"f must be a positive number\",r);\"function\"==typeof e&&void 0===r&&(r=e,e=null);const i=this.bitmap.width*t,n=this.bitmap.height*t;return this.resize(i,n,e),h(r)&&r.call(this,null,this),this},scaleToFit(t,e,r,i){if(\"number\"!=typeof t||\"number\"!=typeof e)return l.call(this,\"w and h must be numbers\",i);\"function\"==typeof r&&void 0===i&&(i=r,r=null);const n=t/e>this.bitmap.width/this.bitmap.height?e/this.bitmap.height:t/this.bitmap.width;return this.scale(n,r),h(i)&&i.call(this,null,this),this}}),()=>({shadow(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1?arguments[1]:void 0;\"function\"==typeof t&&(e=t,t={});const{opacity:r=.7,size:i=1.1,x:n=-25,y:a=25,blur:o=5}=t,s=this.clone(),l=this.clone();return l.scan(0,0,l.bitmap.width,l.bitmap.height,((t,e,i)=>{l.bitmap.data[i]=0,l.bitmap.data[i+1]=0,l.bitmap.data[i+2]=0,l.bitmap.data[i+3]=l.constructor.limit255(l.bitmap.data[i+3]*r),this.bitmap.data[i]=0,this.bitmap.data[i+1]=0,this.bitmap.data[i+2]=0,this.bitmap.data[i+3]=0})),l.resize(l.bitmap.width*i,l.bitmap.height*i).blur(o),this.composite(l,n,a),this.composite(s,0,0),h(e)&&e.call(this,null,this),this}}),()=>({threshold(t,e){let{max:r,replace:i=255,autoGreyscale:n=!0}=t;return\"number\"!=typeof r?l.call(this,\"max must be a number\",e):\"number\"!=typeof i?l.call(this,\"replace must be a number\",e):\"boolean\"!=typeof n?l.call(this,\"autoGreyscale must be a boolean\",e):(r=this.constructor.limit255(r),i=this.constructor.limit255(i),n&&this.greyscale(),this.scanQuiet(0,0,this.bitmap.width,this.bitmap.height,((t,e,n)=>{const a=this.bitmap.data[n]<r?this.bitmap.data[n]:i;this.bitmap.data[n]=a,this.bitmap.data[n+1]=a,this.bitmap.data[n+2]=a})),h(e)&&e.call(this,null,this),this)}})];!function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:oe;const r={hasAlpha:{},encoders:{},decoders:{},class:{},constants:{}};function i(t){Object.entries(t).forEach((t=>{let[e,i]=t;r[e]={...r[e],...i}}))}t.types&&(t.types.forEach((function(t){const e=t();Array.isArray(e.mime)?Ct(...e.mime):Object.entries(e.mime).forEach((t=>Ct(...t))),delete e.mime,i(e)})),e.decoders={...e.decoders,...r.decoders},e.encoders={...e.encoders,...r.encoders},e.hasAlpha={...e.hasAlpha,...r.hasAlpha}),t.plugins&&t.plugins.forEach((function(t){const e=t(ae)||{};e.class||e.constants?i(e):i({class:e})})),ie(r.class,e),re(r.constants,e)}({types:[()=>(0,se.Ee)(ue(),pe(),{mime:{[be]:[\"bmp\"]},constants:{MIME_BMP:be,MIME_X_MS_BMP:_e},decoders:{[be]:ye,[_e]:ye},encoders:{[be]:we,[_e]:we}},{mime:{[ke]:[\"tiff\",\"tif\"]},constants:{MIME_TIFF:ke},decoders:{[ke]:t=>{const e=xe().decode(t),r=e[0];e.forEach((e=>{xe().decodeImage(t,e)}));const i=xe().toRGBA8(r);return{data:Ee.from(i),width:r.t256[0],height:r.t257[0]}}},encoders:{[ke]:t=>{const e=xe().encodeImage(t.bitmap.data,t.bitmap.width,t.bitmap.height);return Ee.from(e)}}},{mime:{[Ie]:[\"gif\"]},constants:{MIME_GIF:Ie},decoders:{[Ie]:t=>{const e=new Se.N(t),r=Ae.alloc(e.width*e.height*4);return e.decodeAndBlitFrameRGBA(0,r),{data:r,width:e.width,height:e.height}}},encoders:{[Ie]:t=>{const e=new Me.BitmapImage(t.bitmap);Me.GifUtil.quantizeDekker(e,256);const r=new Me.GifFrame(e);return(new Me.GifCodec).encodeGif([r],{}).then((t=>t.buffer))}}})],plugins:[t=>{const e=sr.map((e=>{let r=e(t)||{};return r.class||r.constants||(r={class:r}),r}));return(0,se.Ee)(...e)}]})})()})();\n//# sourceMappingURL=jimp.js.map\n\n//# sourceURL=webpack://webgpu-prog-iso/./node_modules/jimp/browser/lib/jimp.js?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _volumes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./volumes */ \"./src/volumes.js\");\n/* harmony import */ var _volume_raycaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./volume_raycaster */ \"./src/volume_raycaster.js\");\n/* harmony import */ var _run_benchmark__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./run_benchmark */ \"./src/run_benchmark.js\");\n/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webgl-util */ \"./src/webgl-util.js\");\n/* harmony import */ var _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./embedded_shaders */ \"./src/embedded_shaders.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/vec3.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/mat4.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! file-saver */ \"./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _inference__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./inference */ \"./src/inference.js\");\n/* harmony import */ var onnxruntime_web_webgpu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! onnxruntime-web/webgpu */ \"./node_modules/onnxruntime-web/dist/ort.webgpu.min.mjs\");\n\n\n\n\n\n\n\n\n\n\n(async () => {\n    console.log(self.crossOriginIsolated);\n    console.log(\"test\")\n    function runBenchmark(benchmark) {\n        requestBenchmark = benchmark;\n    }\n\n    function saveScreenShotButton() {\n        saveScreenshot = true;\n    }\n\n    // Assumes the input renderTarget and outCanvas have the same image dimensions\n    async function takeScreenshot(device, name, renderTarget, imageBuffer, outCanvas) {\n        var commandEncoder = device.createCommandEncoder();\n        commandEncoder.copyTextureToBuffer({texture: renderTarget},\n            {buffer: imageBuffer, bytesPerRow: outCanvas.width * 4},\n            [outCanvas.width, outCanvas.height, 1]);\n        device.queue.submit([commandEncoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n\n        await imageBuffer.mapAsync(GPUMapMode.READ);\n        var imageReadbackArray = new Uint8ClampedArray(imageBuffer.getMappedRange());\n\n        var context = outCanvas.getContext('2d');\n        var imgData = context.createImageData(outCanvas.width, outCanvas.height);\n        imgData.data.set(imageReadbackArray);\n        context.putImageData(imgData, 0, 0);\n        outCanvas.toBlob(function (b) {\n            (0,file_saver__WEBPACK_IMPORTED_MODULE_5__.saveAs)(b, `${name}.png`);\n        }, \"image/png\");\n\n        imageBuffer.unmap();\n    }\n\n    document.getElementById(\"runRandomBenchmark\").onclick = () => {runBenchmark(\"random\")};\n    document.getElementById(\"runSweepUp\").onclick = () => {runBenchmark(\"sweepUp\")};\n    document.getElementById(\"runSweepDown\").onclick = () => {runBenchmark(\"sweepDown\")};\n    document.getElementById(\"runRotate\").onclick = () => {runBenchmark(\"rotate\")};\n    document.getElementById(\"recomputeSurface\").onclick = () => {runBenchmark(\"manualSingle\")};\n    document.getElementById(\"saveScreenShotButton\").onclick = () => {saveScreenShotButton()};\n\n    var adapter = await navigator.gpu.requestAdapter();\n    console.log(adapter.limits);\n\n    var gpuDeviceDesc = {\n        requiredLimits: {\n            maxStorageBuffersPerShaderStage: adapter.limits.maxStorageBuffersPerShaderStage,\n            maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,\n            maxBufferSize: adapter.limits.maxBufferSize\n        },\n    };\n    var device = await adapter.requestDevice(gpuDeviceDesc);\n    var canvas = document.getElementById(\"webgpu-canvas\");\n    var context = canvas.getContext(\"webgpu\");\n\n    var requestBenchmark = null;\n    var saveScreenshot = false;\n\n    var benchmarkConfigs = (0,_run_benchmark__WEBPACK_IMPORTED_MODULE_2__.generateBenchmarkConfigurations)();\n    console.log(`# of benchmarkConfigs to run ${benchmarkConfigs.length}`);\n\n    var dataset = _volumes__WEBPACK_IMPORTED_MODULE_0__.datasets.skull;\n    let autobenchmarkIndex = -1;\n    if (window.location.hash) {\n        var urlParams = window.location.hash.substring(1).split(\"&\");\n        for (let i = 0; i < urlParams.length; ++i) {\n            let str = decodeURI(urlParams[i]);\n            if (str.startsWith(\"dataset=\")) {\n                let name = str.split(\"=\")[1];\n                console.log(`Linked to data set ${name}`);\n                dataset = _volumes__WEBPACK_IMPORTED_MODULE_0__.datasets[name];\n            } else if (str.startsWith(\"autobenchmark=\")) {\n                autobenchmarkIndex = parseInt(str.split(\"=\")[1]);\n                console.log(`Linked to autobenchmark ${autobenchmarkIndex}`);\n            }\n        }\n    }\n\n    let autobenchmarkConfig = null;\n    if (autobenchmarkIndex > -1) {\n        autobenchmarkConfig = benchmarkConfigs[autobenchmarkIndex];\n        console.log(`Running autobenchmark`);\n        console.log(autobenchmarkConfig);\n        dataset = _volumes__WEBPACK_IMPORTED_MODULE_0__.datasets[autobenchmarkConfig.dataset];\n        console.log(dataset);\n\n        document.getElementById(\"autobenchmark-status-div\").hidden = false;\n        document.getElementById(\"autobenchmark-status\").innerHTML =\n            `Autobenchmark ${autobenchmarkIndex + 1}/${benchmarkConfigs.length}`;\n    }\n\n    var volumeDims = (0,_volumes__WEBPACK_IMPORTED_MODULE_0__.getVolumeDimensions)(dataset.name);\n    var zfpDataName = dataset.name + \".zfp\";\n    var volumeURL = null;\n    if (window.location.hostname != \"localhost\") {\n        volumeURL = \"https://cdn.willusher.io/bcmc-demo-data/\" + zfpDataName;\n    } else {\n        volumeURL = \"/models/bcmc-data/\" + zfpDataName;\n    }\n    var compressedData =\n        await fetch(volumeURL).then((res) => res.arrayBuffer().then(function (arr) {\n            return new Uint8Array(arr);\n        }));\n\n    if (compressedData == null) {\n        alert(`Failed to load compressed data`);\n        return;\n    }\n    var resolution = document.getElementById(\"resolution\");\n    var resolutionDims = {\"1080\": [1920, 1088], \"720\": [1280, 720], \"360\": [640, 368]};\n    var width = resolutionDims[resolution.value][0];\n    var height = resolutionDims[resolution.value][1];\n    if (autobenchmarkConfig) {\n        width = resolutionDims[autobenchmarkConfig.resolution][0];\n        height = resolutionDims[autobenchmarkConfig.resolution][1];\n    }\n\n    var imageBuffer = device.createBuffer({\n        size: width * height * 4,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n    var resolutionBuffer = device.createBuffer({\n        size: 2 * 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    var commandEncoder = device.createCommandEncoder();\n    var uploadResolution = device.createBuffer(\n        {size: 2 * 4, usage: GPUBufferUsage.COPY_SRC, mappedAtCreation: true});\n    new Uint32Array(uploadResolution.getMappedRange()).set([canvas.width, canvas.height]);\n    uploadResolution.unmap();\n    commandEncoder.copyBufferToBuffer(uploadResolution, 0, resolutionBuffer, 0, 2 * 4);\n    device.queue.submit([commandEncoder.finish()]);\n    var renderBGLayout = device.createBindGroupLayout({\n        entries: [\n            {binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {viewDimension: \"2d\"}},\n            {binding: 1, visibility: GPUShaderStage.FRAGMENT, buffer: {type: \"uniform\"}},\n            {binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: {type: \"filtering\"}}\n        ]\n    });\n    const sampler = device.createSampler({\n        magFilter: 'linear',\n        minFilter: 'linear',\n    });\n\n    var enableSpeculationUI = document.getElementById(\"enableSpeculation\");\n    enableSpeculationUI.checked = true;\n    var recordVisibleBlocksUI = document.getElementById(\"recordVisibleBlocks\")\n\n    var session;\n    try {\n        onnxruntime_web_webgpu__WEBPACK_IMPORTED_MODULE_7__.env.wasm.numThreads = 4;\n        session = await onnxruntime_web_webgpu__WEBPACK_IMPORTED_MODULE_7__.InferenceSession.create(`./noof${width}.onnx`,\n            {executionProviders: ['webgpu'], graphOptimizationLevel: 'all'});\n        console.log(session);\n        var imageReadbackArray = new Uint8ClampedArray(width * height);\n        var inputTensor = (0,_inference__WEBPACK_IMPORTED_MODULE_6__.imageDataToTensor)(imageReadbackArray, [1, 3, height, width]);\n    } catch (e) {\n        console.log(e);\n    }\n\n    let completenessThreshold = document.getElementById(\"completenessThreshold\");\n    var outCanvas = document.getElementById(\"out-canvas\");\n    var headstartSlider = document.getElementById(\"startSpecCount\");\n    if (autobenchmarkConfig) {\n        completenessThreshold.value = autobenchmarkConfig.imageCompleteness;\n        headstartSlider.value = autobenchmarkConfig.startSpecCount;\n    }\n    var volumeRC =\n        new _volume_raycaster__WEBPACK_IMPORTED_MODULE_1__.VolumeRaycaster(device, width, height, recordVisibleBlocksUI, enableSpeculationUI, parseInt(headstartSlider.value));\n\n    resolution.onchange = async () => {\n        width = resolutionDims[resolution.value][0];\n        height = resolutionDims[resolution.value][1];\n        console.log(`Changed resolution to ${width}x${height}`);\n        outCanvas.width = width;\n        outCanvas.height = height;\n        // canvas.width = width;\n        // canvas.height = height;\n        // var commandEncoder = device.createCommandEncoder();\n        // var uploadResolution = device.createBuffer(\n        //     {size: 2 * 4, usage: GPUBufferUsage.COPY_SRC, mappedAtCreation: true});\n        // new Uint32Array(uploadResolution.getMappedRange()).set([canvas.width, canvas.height]);\n        // uploadResolution.unmap();\n        // commandEncoder.copyBufferToBuffer(uploadResolution, 0, resolutionBuffer, 0, 2 * 4);\n        // device.queue.submit([commandEncoder.finish()]);\n        // camera = new ArcballCamera(defaultEye, center, up, 4, [\n        //     width,\n        //     height,\n        // ]);\n\n        volumeRC = new _volume_raycaster__WEBPACK_IMPORTED_MODULE_1__.VolumeRaycaster(\n            device, width, height, recordVisibleBlocksUI, enableSpeculationUI, parseInt(headstartSlider.value));\n        await volumeRC.setCompressedVolume(\n            compressedData, dataset.compressionRate, volumeDims, dataset.scale);\n        recomputeSurface = true;\n        renderPipelineBG = device.createBindGroup({\n            layout: renderBGLayout,\n            entries: [\n                {binding: 0, resource: volumeRC.renderTarget.createView()},\n                {binding: 1, resource: {buffer: resolutionBuffer}},\n                {binding: 2, resource: sampler}\n            ]\n        });\n        imageBuffer = device.createBuffer({\n            size: width * height * 4,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n        onnxruntime_web_webgpu__WEBPACK_IMPORTED_MODULE_7__.env.wasm.wasmPaths = './ort-wasm-simd-threaded.jsep.wasm';\n        session = await onnxruntime_web_webgpu__WEBPACK_IMPORTED_MODULE_7__.InferenceSession.create(`./noof${width}.onnx`,\n            {executionProviders: ['webgpu'], graphOptimizationLevel: 'all'});\n        (0,_inference__WEBPACK_IMPORTED_MODULE_6__.cleanRecurrentState)();\n    };\n    headstartSlider.onchange = async () => {\n        volumeRC = new _volume_raycaster__WEBPACK_IMPORTED_MODULE_1__.VolumeRaycaster(\n            device, width, height, recordVisibleBlocksUI, enableSpeculationUI, parseInt(headstartSlider.value));\n        await volumeRC.setCompressedVolume(\n            compressedData, dataset.compressionRate, volumeDims, dataset.scale);\n        recomputeSurface = true;\n        renderPipelineBG = device.createBindGroup({\n            layout: renderBGLayout,\n            entries: [\n                {binding: 0, resource: volumeRC.renderTarget.createView()},\n                {binding: 1, resource: {buffer: resolutionBuffer}},\n                {binding: 2, resource: sampler}\n            ]\n        });\n    }\n    await volumeRC.setCompressedVolume(\n        compressedData, dataset.compressionRate, volumeDims, dataset.scale);\n\n    var totalMemDisplay = document.getElementById(\"totalMemDisplay\");\n    var mcMemDisplay = document.getElementById(\"mcMemDisplay\");\n    var cacheMemDisplay = document.getElementById(\"cacheMemDisplay\");\n    var fpsDisplay = document.getElementById(\"fps\");\n    var camDisplay = document.getElementById(\"camDisplay\");\n\n    var enableCache = document.getElementById(\"enableCache\");\n    enableCache.checked = true;\n\n    var isovalueSlider = document.getElementById(\"isovalue\");\n    isovalueSlider.min = dataset.range[0];\n    isovalueSlider.max = dataset.range[1];\n    if (dataset.step !== undefined) {\n        isovalueSlider.step = dataset.step;\n    } else {\n        isovalueSlider.step = (isovalueSlider.max - isovalueSlider.min) / 255.0;\n    }\n    isovalueSlider.value = (dataset.range[0] + dataset.range[1]) / 2.0;\n    var currentIsovalue = isovalueSlider.value;\n\n    var cacheInfo = document.getElementById(\"cacheInfo\");\n    var displayCacheInfo = function () {\n        var percentActive = (volumeRC.numVisibleBlocks / volumeRC.totalBlocks) * 100;\n        cacheInfo.innerHTML = `Cache Space: ${volumeRC.lruCache.cacheSize\n            } blocks\n            (${(\n                (volumeRC.lruCache.cacheSize / volumeRC.totalBlocks) *\n                100\n            ).toFixed(2)} %\n            of ${volumeRC.totalBlocks} total blocks)<br/>\n            # Cache Slots Available ${volumeRC.lruCache.displayNumSlotsAvailable}<br/>\n            <b>For this Pass:</b><br/>\n            # Newly Decompressed: ${volumeRC.newDecompressed}<br/>\n            # Visible Blocks: ${volumeRC.numVisibleBlocks}\n            (${percentActive.toFixed(2)}%)<br/>`;\n    };\n    displayCacheInfo();\n\n    const defaultEye = gl_matrix__WEBPACK_IMPORTED_MODULE_8__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_8__.create(), 0.0, 0.0, -1.5);\n    const center = gl_matrix__WEBPACK_IMPORTED_MODULE_8__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_8__.create(), 0.0, 0.0, 0.0);\n    const up = gl_matrix__WEBPACK_IMPORTED_MODULE_8__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_8__.create(), 0.0, 1.0, 0.0);\n    /*\n    // For matching benchmark configurations\n    var benchmarkEye = {\n        \"eyePos\": [-1.012491226196289, 0.7122936248779297, 0.8317527174949646],\n        \"eyeDir\": [0.6625354886054993, -0.5211779475212097, -0.537977933883667],\n        \"upDir\": [0.4094274640083313, 0.8534227609634399, -0.3225504457950592],\n    };\n    const defaultEye = vec3.set(vec3.create(),\n                                benchmarkEye[\"eyePos\"][0],\n                                benchmarkEye[\"eyePos\"][1],\n                                benchmarkEye[\"eyePos\"][2]);\n    const center = vec3.add(vec3.create(),\n                            defaultEye,\n                            vec3.set(vec3.create(),\n                                     benchmarkEye[\"eyeDir\"][0],\n                                     benchmarkEye[\"eyeDir\"][1],\n                                     benchmarkEye[\"eyeDir\"][2]));\n    const up = vec3.set(vec3.create(),\n                        benchmarkEye[\"upDir\"][0],\n                        benchmarkEye[\"upDir\"][1],\n                        benchmarkEye[\"upDir\"][2]);\n                        */\n\n    var camera = new _webgl_util__WEBPACK_IMPORTED_MODULE_3__.ArcballCamera(defaultEye, center, up, 4, [\n        canvas.width,\n        canvas.height,\n    ]);\n    const nearPlane = 0.1;\n    var proj = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.perspective(\n        gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create(), (50 * Math.PI) / 180.0, canvas.width / canvas.height, nearPlane, 1000);\n    var projView = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create();\n    var benchmarkRadius = 1.5;\n\n    var numFrames = 0;\n    var totalTimeMS = 0;\n    var cameraChanged = true;\n\n    var controller = new _webgl_util__WEBPACK_IMPORTED_MODULE_3__.Controller();\n    controller.mousemove = function (prev, cur, evt) {\n        if (evt.buttons == 1) {\n            cameraChanged = true;\n            camera.rotate(prev, cur);\n            numFrames = 0;\n            totalTimeMS = 0;\n        } else if (evt.buttons == 2) {\n            cameraChanged = true;\n            camera.pan([cur[0] - prev[0], prev[1] - cur[1]]);\n            numFrames = 0;\n            totalTimeMS = 0;\n        }\n    };\n    controller.wheel = function (amt) {\n        cameraChanged = true;\n        camera.zoom(amt * 0.05);\n        numFrames = 0;\n        totalTimeMS = 0;\n    };\n    controller.pinch = controller.wheel;\n    controller.twoFingerDrag = function (drag) {\n        cameraChanged = true;\n        camera.pan(drag);\n        numFrames = 0;\n        totalTimeMS = 0;\n    };\n    controller.registerForCanvas(canvas);\n\n    var animationFrame = function () {\n        var resolve = null;\n        var promise = new Promise((r) => (resolve = r));\n        window.requestAnimationFrame(resolve);\n        return promise;\n    };\n\n    requestAnimationFrame(animationFrame);\n\n    var upload = device.createBuffer({\n        // mat4, 2 vec4's and a float + some extra to align\n        size: 32 * 4,\n        usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,\n    });\n\n    /* We need a render pass to blit the image that is computed by the volume\n     * raycaster to the screen. This just draws a quad to the screen and loads\n     * the corresponding texel from the render to show on the screen\n     */\n    var swapChainFormat = \"bgra8unorm\";\n    context.configure(\n        {device: device, format: swapChainFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT});\n\n    var vertModule = device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.display_render_vert_spv});\n    var fragModule = device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.display_render_frag_spv});\n\n    var renderPipeline = device.createRenderPipeline({\n        layout: device.createPipelineLayout({bindGroupLayouts: [renderBGLayout]}),\n        vertex: {\n            module: vertModule,\n            entryPoint: \"main\",\n        },\n        fragment:\n            {module: fragModule, entryPoint: \"main\", targets: [{format: swapChainFormat}]}\n    });\n\n    var renderPipelineBG = device.createBindGroup({\n        layout: renderBGLayout,\n        entries: [\n            {binding: 0, resource: volumeRC.renderTarget.createView()},\n            {binding: 1, resource: {buffer: resolutionBuffer}},\n            {binding: 2, resource: sampler}\n        ]\n    });\n\n    var renderPassDesc = {\n        colorAttachments: [{\n            view: undefined,\n            loadOp: \"clear\",\n            clearValue: [0.3, 0.3, 0.3, 1],\n            storeOp: \"store\"\n        }],\n    };\n\n    var currentBenchmark = null;\n    var cameraBenchmark = null;\n\n    var perfStats = [];\n\n    if (autobenchmarkConfig) {\n        requestBenchmark = \"random\";\n        document.getElementById(\"infer\").checked = autobenchmarkConfig.infer;\n        benchmarkRadius = autobenchmarkConfig.radius;\n    }\n\n    var recomputeSurface = true;\n    var surfaceDone = false;\n    var averageComputeTime = 0;\n    while (true) {\n        await animationFrame();\n        var start = performance.now();\n\n        if (requestBenchmark && !currentBenchmark) {\n            perfStats = [];\n            await volumeRC.lruCache.reset();\n            if (requestBenchmark == \"random\") {\n                var valueBenchmark =\n                    new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.RandomIsovalueBenchmark(isovalueSlider, dataset.range);\n                // cameraBenchmark = new CameraOrbitBenchmark(1.5);\n                cameraBenchmark = new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.RotateBenchmark(benchmarkRadius, canvas.width, canvas.height);\n                currentBenchmark = new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.NestedBenchmark(valueBenchmark, cameraBenchmark);\n            } else if (requestBenchmark == \"sweepUp\") {\n                var valueBenchmark =\n                    new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.SweepIsovalueBenchmark(isovalueSlider, dataset.range, true);\n                // cameraBenchmark = new CameraOrbitBenchmark(1.5);\n                cameraBenchmark = new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.RotateBenchmark(benchmarkRadius, canvas.width, canvas.height);\n                currentBenchmark = new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.NestedBenchmark(valueBenchmark, cameraBenchmark);\n            } else if (requestBenchmark == \"sweepDown\") {\n                var valueBenchmark =\n                    new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.SweepIsovalueBenchmark(isovalueSlider, dataset.range, false);\n                // cameraBenchmark = new CameraOrbitBenchmark(1.5);\n                cameraBenchmark = new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.RotateBenchmark(benchmarkRadius, canvas.width, canvas.height);\n                currentBenchmark = new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.NestedBenchmark(valueBenchmark, cameraBenchmark);\n            } else if (requestBenchmark == \"manualSingle\") {\n                currentBenchmark = new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.ManualSingleBenchmark();\n                recomputeSurface = true;\n            } else {\n                // cameraBenchmark = new CameraOrbitBenchmark(1.5);\n                cameraBenchmark = new _run_benchmark__WEBPACK_IMPORTED_MODULE_2__.RotateBenchmark(benchmarkRadius, canvas.width, canvas.height);\n                currentBenchmark = cameraBenchmark;\n            }\n            requestBenchmark = null;\n        }\n\n        if (currentBenchmark && surfaceDone) {\n            if (!currentBenchmark.run()) {\n                var blob = new Blob([JSON.stringify(perfStats)], {type: \"text/plain\"});\n                let outputName = `perf-${dataset.name}-${currentBenchmark.name}.json`;\n                if (autobenchmarkConfig) {\n                    outputName = `perf-${dataset.name}-${currentBenchmark.name}` +\n                        `-${autobenchmarkConfig.resolution}p` +\n                        `-${autobenchmarkConfig.startSpecCount}ssc` +\n                        `-${autobenchmarkConfig.radius}r` +\n                        `-${autobenchmarkConfig.imageCompleteness}ic.json`;\n                }\n                (0,file_saver__WEBPACK_IMPORTED_MODULE_5__.saveAs)(blob, outputName);\n\n                currentBenchmark = null;\n\n                // Advance to the next benchmark\n                if (autobenchmarkConfig) {\n                    if (autobenchmarkIndex + 1 < benchmarkConfigs.length) {\n                        window.location.hash = `autobenchmark=${autobenchmarkIndex + 1}`;\n                        window.location.reload();\n                    } else {\n                        console.log('Autobenchmark complete');\n                        document.getElementById(\"autobenchmark-status\").innerHTML = \"Autobenchmark Complete!\";\n                    }\n                }\n            } else if (currentBenchmark.name.includes(\"cameraOrbit\")) {\n                camera = new _webgl_util__WEBPACK_IMPORTED_MODULE_3__.ArcballCamera(cameraBenchmark.currentPoint, center, up, 4, [\n                    canvas.width,\n                    canvas.height,\n                ]);\n                cameraChanged = true;\n            } else if (currentBenchmark.name.includes(\"rotate\")) {\n                if (cameraBenchmark.iteration == 1) {\n                    camera = new _webgl_util__WEBPACK_IMPORTED_MODULE_3__.ArcballCamera(cameraBenchmark.startPoint, center, up, 4, [\n                        canvas.width,\n                        canvas.height,\n                    ]);\n                } else {\n                    camera.rotate([cameraBenchmark.lastX, cameraBenchmark.lastY], [cameraBenchmark.currentX, cameraBenchmark.currentY]);\n                }\n                cameraChanged = true;\n            }\n        }\n\n        projView = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.mul(projView, proj, camera.camera);\n        await upload.mapAsync(GPUMapMode.WRITE);\n        var uploadArray = new Float32Array(upload.getMappedRange());\n        uploadArray.set(projView);\n        uploadArray.set(camera.eyePos(), 16);\n        uploadArray.set(camera.eyeDir(), 20);\n        uploadArray.set([nearPlane], 24);\n        upload.unmap();\n\n        if (cameraChanged) {\n            cameraChanged = false;\n            recomputeSurface = true;\n\n            var eyePos = camera.eyePos();\n            var eyeDir = camera.eyeDir();\n            var upDir = camera.upDir();\n            camDisplay.innerHTML = `eye = ${eyePos[0].toFixed(4)}, ${eyePos[1].toFixed(\n                4\n            )}, ${eyePos[2].toFixed(4)}<br/>\n                dir = ${eyeDir[0].toFixed(4)}, ${eyeDir[1].toFixed(\n                4\n            )}, ${eyeDir[2].toFixed(4)}<br/>\n                up = ${upDir[0].toFixed(4)}, ${upDir[1].toFixed(\n                4\n            )}, ${upDir[2].toFixed(4)}`;\n        }\n\n        if (!enableCache.checked) {\n            await volumeRC.lruCache.reset();\n        }\n\n        if (isovalueSlider.value != currentIsovalue) {\n            recomputeSurface = true;\n            currentIsovalue = parseFloat(isovalueSlider.value);\n            (0,_inference__WEBPACK_IMPORTED_MODULE_6__.cleanRecurrentState)();\n        }\n\n        if (recomputeSurface || !surfaceDone) {\n            var inferenceTime = false;\n            var eyePos = camera.eyePos();\n            var eyeDir = camera.eyeDir();\n            var upDir = camera.upDir();\n\n            var start = performance.now();\n            surfaceDone = await volumeRC.renderSurface(\n                currentIsovalue, 1, upload, recomputeSurface, eyePos, eyeDir, upDir);\n            var end = performance.now();\n\n            averageComputeTime =\n                Math.round(volumeRC.totalPassTime / volumeRC.numPasses);\n            recomputeSurface = false;\n\n            displayCacheInfo();\n            var memUse = volumeRC.reportMemoryUse();\n            mcMemDisplay.innerHTML = memUse[0];\n            cacheMemDisplay.innerHTML = memUse[1];\n            totalMemDisplay.innerHTML = `Total Memory: ${memUse[2]}`;\n\n            if (document.getElementById(\"outputImages\").checked) {\n                // if (volumeRC.numPasses == 1 || surfaceDone){\n                var filename = dataset.name.replace(/_/g, '').substring(0, 5);\n                if (currentBenchmark) {\n                    if (currentBenchmark.name.includes(\"rotate\")) {\n                        filename = filename + \"_seq\" + cameraBenchmark.renderID + \"_\" + cameraBenchmark.iteration;\n                        filename += \"_\" + Math.floor(volumeRC.imageCompleteness * 100);\n                        if (surfaceDone) {\n                            filename += \"_ref\";\n                        } else {\n                            filename += `_${String(volumeRC.numPasses).padStart(4, '0')}spp`;\n                        }\n                    } else {\n                        filename += volumeRC.renderID + \"_\" + String(volumeRC.numPasses).padStart(4, '0');\n                    }\n                }\n                else {\n                    filename += volumeRC.renderID + \"_\" + String(volumeRC.numPasses).padStart(4, '0');\n                }\n                await takeScreenshot(\n                    device,\n                    filename,\n                    volumeRC.renderTarget,\n                    imageBuffer,\n                    document.getElementById('out-canvas'));\n                // }\n            }\n            if (document.getElementById(\"infer\").checked && surfaceDone) {\n                var commandEncoder = device.createCommandEncoder();\n                commandEncoder.copyTextureToBuffer({texture: volumeRC.renderTarget},\n                    {buffer: imageBuffer, bytesPerRow: width * 4},\n                    [width, height, 1]);\n                device.queue.submit([commandEncoder.finish()]);\n                await device.queue.onSubmittedWorkDone();\n\n                await imageBuffer.mapAsync(GPUMapMode.READ);\n                var imageReadbackArray = new Uint8ClampedArray(imageBuffer.getMappedRange());\n                var inputTensor = (0,_inference__WEBPACK_IMPORTED_MODULE_6__.imageDataToTensor)(imageReadbackArray, [1, 3, height, width]);\n                imageBuffer.unmap();\n                try {\n                    var [results, inferenceTime] = await (0,_inference__WEBPACK_IMPORTED_MODULE_6__.runInference)(session, inputTensor, width, height);\n                    // console.log(\"results\", results);\n                    console.log(\"inference time\", inferenceTime);\n                    var textureData = new Uint8ClampedArray(results.length + width * height);\n                    // var min = 32767, max = 0;\n                    // for (var i = 0; i < results.length; i++) {\n                    //     if (results[i] < min) {\n                    //         min = results[i];\n                    //     }\n                    //     if (results[i] > max) {\n                    //         max = results[i]\n                    //     }\n                    // }\n                    // console.log(\"min\", min);\n                    // console.log(\"max\", max);\n                    // let testCanvas = document.getElementById(\"test-canvas\");\n                    // let ctx = testCanvas.getContext(\"2d\");\n                    // let idata = ctx.createImageData(canvas.width, canvas.height);\n                    // idata.data.set(textureData);\n                    // ctx.putImageData(idata, 0, 0);\n\n                    var start = new Date();\n                    for (var i = 0; i < width * height; i++) {\n                        textureData[i * 4] = results[i] * 255;\n                        textureData[i * 4 + 1] = results[i + width * height] * 255;\n                        textureData[i * 4 + 2] = results[i + 2 * width * height] * 255;\n                        textureData[i * 4 + 3] = 255;\n                    }\n                    device.queue.writeTexture(\n                        {texture: volumeRC.renderTarget},\n                        textureData,\n                        {bytesPerRow: width * 4},\n                        {width: width, height: height}\n                    );\n                    await device.queue.onSubmittedWorkDone();\n                    var end = new Date();\n                    console.log(\"Texture write time\", Math.round(end - start))\n                } catch (e) {\n                    console.log(\"ERROR WITH INFERENCE, CHECK DIMENSIONS\");\n                    console.log(e)\n                }\n            }\n            if (surfaceDone) {\n                perfStats.push(\n                    {\n                        \"isovalue\": currentIsovalue,\n                        \"stats\": volumeRC.surfacePerfStats,\n                        \"inferenceTime\": inferenceTime,\n                        \"config\": {\n                            \"resolution\": [width, height],\n                            \"startSpecCount\": headstartSlider.value,\n                            \"completenessThreshold\": completenessThreshold.value,\n                        }\n                    });\n            }\n\n        }\n        if (saveScreenshot) {\n            saveScreenshot = false;\n            await takeScreenshot(device,\n                `${dataset.name}_prog_iso`,\n                volumeRC.renderTarget,\n                imageBuffer,\n                document.getElementById('out-canvas'));\n        }\n\n        // Blit the image rendered by the raycaster onto the screen\n        var commandEncoder = device.createCommandEncoder();\n\n        renderPassDesc.colorAttachments[0].view = context.getCurrentTexture().createView();\n        var renderPass = commandEncoder.beginRenderPass(renderPassDesc);\n\n        renderPass.setPipeline(renderPipeline);\n        renderPass.setBindGroup(0, renderPipelineBG);\n        // Draw a full screen quad\n        renderPass.draw(6, 1, 0, 0);\n        renderPass.end();\n        device.queue.submit([commandEncoder.finish()]);\n\n        // Measure render time by waiting for the work done\n        await device.queue.onSubmittedWorkDone();\n        var end = performance.now();\n        numFrames += 1;\n        totalTimeMS += end - start;\n        fpsDisplay.innerHTML = `Avg. FPS ${Math.round((1000.0 * numFrames) / totalTimeMS)}<br/>\n            Avg. pass time: ${averageComputeTime}ms<br/>\n            Pass # ${volumeRC.numPasses}<br/>\n            ${inferenceTime ? \"Inference Time: \" + inferenceTime + \"ms<br/>\" : \"\"}\n            Total pipeline time: ${Math.round(volumeRC.totalPassTime)}ms`;\n    }\n})();\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/app.js?");

/***/ }),

/***/ "./src/embedded_shaders.js":
/*!*********************************!*\
  !*** ./src/embedded_shaders.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScanBlockSize\": () => (/* binding */ ScanBlockSize),\n/* harmony export */   \"SortChunkSize\": () => (/* binding */ SortChunkSize),\n/* harmony export */   \"add_block_sums_comp_spv\": () => (/* binding */ add_block_sums_comp_spv),\n/* harmony export */   \"block_prefix_sum_comp_spv\": () => (/* binding */ block_prefix_sum_comp_spv),\n/* harmony export */   \"color_active_rays_comp_spv\": () => (/* binding */ color_active_rays_comp_spv),\n/* harmony export */   \"combine_block_information_comp_spv\": () => (/* binding */ combine_block_information_comp_spv),\n/* harmony export */   \"compute_coarse_cell_range_comp_spv\": () => (/* binding */ compute_coarse_cell_range_comp_spv),\n/* harmony export */   \"compute_initial_rays_frag_spv\": () => (/* binding */ compute_initial_rays_frag_spv),\n/* harmony export */   \"compute_initial_rays_vert_spv\": () => (/* binding */ compute_initial_rays_vert_spv),\n/* harmony export */   \"compute_voxel_range_comp_spv\": () => (/* binding */ compute_voxel_range_comp_spv),\n/* harmony export */   \"count_block_rays_wgsl_spv\": () => (/* binding */ count_block_rays_wgsl_spv),\n/* harmony export */   \"debug_view_rays_per_block_comp_spv\": () => (/* binding */ debug_view_rays_per_block_comp_spv),\n/* harmony export */   \"depth_composite_comp_spv\": () => (/* binding */ depth_composite_comp_spv),\n/* harmony export */   \"display_render_frag_spv\": () => (/* binding */ display_render_frag_spv),\n/* harmony export */   \"display_render_vert_spv\": () => (/* binding */ display_render_vert_spv),\n/* harmony export */   \"lru_cache_age_slots_comp_spv\": () => (/* binding */ lru_cache_age_slots_comp_spv),\n/* harmony export */   \"lru_cache_extract_slot_available_comp_spv\": () => (/* binding */ lru_cache_extract_slot_available_comp_spv),\n/* harmony export */   \"lru_cache_init_comp_spv\": () => (/* binding */ lru_cache_init_comp_spv),\n/* harmony export */   \"lru_cache_mark_new_items_comp_spv\": () => (/* binding */ lru_cache_mark_new_items_comp_spv),\n/* harmony export */   \"lru_cache_update_comp_spv\": () => (/* binding */ lru_cache_update_comp_spv),\n/* harmony export */   \"lru_copy_available_slot_age_comp_spv\": () => (/* binding */ lru_copy_available_slot_age_comp_spv),\n/* harmony export */   \"macro_traverse_comp_spv\": () => (/* binding */ macro_traverse_comp_spv),\n/* harmony export */   \"mark_block_active_wgsl_spv\": () => (/* binding */ mark_block_active_wgsl_spv),\n/* harmony export */   \"mark_ray_active_comp_spv\": () => (/* binding */ mark_ray_active_comp_spv),\n/* harmony export */   \"merge_sorted_chunks_comp_spv\": () => (/* binding */ merge_sorted_chunks_comp_spv),\n/* harmony export */   \"prefix_sum_comp_spv\": () => (/* binding */ prefix_sum_comp_spv),\n/* harmony export */   \"radix_sort_chunk_comp_spv\": () => (/* binding */ radix_sort_chunk_comp_spv),\n/* harmony export */   \"raytrace_active_block_comp_spv\": () => (/* binding */ raytrace_active_block_comp_spv),\n/* harmony export */   \"reset_block_active_comp_spv\": () => (/* binding */ reset_block_active_comp_spv),\n/* harmony export */   \"reset_block_num_rays_comp_spv\": () => (/* binding */ reset_block_num_rays_comp_spv),\n/* harmony export */   \"reset_rays_comp_spv\": () => (/* binding */ reset_rays_comp_spv),\n/* harmony export */   \"reset_speculative_ids_comp_spv\": () => (/* binding */ reset_speculative_ids_comp_spv),\n/* harmony export */   \"reverse_buffer_comp_spv\": () => (/* binding */ reverse_buffer_comp_spv),\n/* harmony export */   \"stream_compact_comp_spv\": () => (/* binding */ stream_compact_comp_spv),\n/* harmony export */   \"stream_compact_data_comp_spv\": () => (/* binding */ stream_compact_data_comp_spv),\n/* harmony export */   \"write_ray_and_block_id_comp_spv\": () => (/* binding */ write_ray_and_block_id_comp_spv),\n/* harmony export */   \"zfp_compute_block_range_comp_spv\": () => (/* binding */ zfp_compute_block_range_comp_spv),\n/* harmony export */   \"zfp_decompress_block_comp_spv\": () => (/* binding */ zfp_decompress_block_comp_spv)\n/* harmony export */ });\nconst ScanBlockSize = 512;\nconst SortChunkSize = 256;\nconst prefix_sum_comp_spv = `alias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct Data {\n  vals : RTArr_1,\n}\n\nstruct BlockSums {\n  block_sums : RTArr_1,\n}\n\nvar<workgroup> chunk : array<u32, 512u>;\n\nvar<private> gl_LocalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<storage, read_write> x_23 : Data;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(1) var<storage, read_write> x_105 : BlockSums;\n\nvar<private> gl_WorkGroupID : vec3<u32>;\n\nfn main_1() {\n  var offs : u32;\n  var d : i32;\n  var a : u32;\n  var b : u32;\n  var d_1 : i32;\n  var a_1 : u32;\n  var b_1 : u32;\n  var tmp : u32;\n  let x_18 : u32 = gl_LocalInvocationID.x;\n  let x_28 : u32 = gl_GlobalInvocationID.x;\n  let x_32 : u32 = x_23.vals[(2u * x_28)];\n  chunk[(2u * x_18)] = x_32;\n  let x_36 : u32 = gl_LocalInvocationID.x;\n  let x_41 : u32 = gl_GlobalInvocationID.x;\n  let x_45 : u32 = x_23.vals[((2u * x_41) + 1u)];\n  chunk[((2u * x_36) + 1u)] = x_45;\n  offs = 1u;\n  d = 256i;\n  loop {\n    let x_57 : i32 = d;\n    if ((x_57 > 0i)) {\n    } else {\n      break;\n    }\n    workgroupBarrier();\n    let x_62 : u32 = gl_LocalInvocationID.x;\n    let x_63 : i32 = d;\n    if ((x_62 < bitcast<u32>(x_63))) {\n      let x_69 : u32 = offs;\n      let x_71 : u32 = gl_LocalInvocationID.x;\n      a = ((x_69 * ((2u * x_71) + 1u)) - 1u);\n      let x_77 : u32 = offs;\n      let x_79 : u32 = gl_LocalInvocationID.x;\n      b = ((x_77 * ((2u * x_79) + 2u)) - 1u);\n      let x_84 : u32 = b;\n      let x_85 : u32 = a;\n      let x_87 : u32 = chunk[x_85];\n      let x_89 : u32 = chunk[x_84];\n      chunk[x_84] = (x_89 + x_87);\n    }\n    let x_92 : u32 = offs;\n    offs = (x_92 << bitcast<u32>(1i));\n\n    continuing {\n      let x_95 : i32 = d;\n      d = (x_95 >> bitcast<u32>(1i));\n    }\n  }\n  let x_98 : u32 = gl_LocalInvocationID.x;\n  if ((x_98 == 0u)) {\n    let x_108 : u32 = gl_WorkGroupID.x;\n    let x_111 : u32 = chunk[511i];\n    x_105.block_sums[x_108] = x_111;\n    chunk[511i] = 0u;\n  }\n  d_1 = 1i;\n  loop {\n    let x_120 : i32 = d_1;\n    if ((x_120 < 512i)) {\n    } else {\n      break;\n    }\n    let x_123 : u32 = offs;\n    offs = (x_123 >> bitcast<u32>(1i));\n    workgroupBarrier();\n    let x_126 : u32 = gl_LocalInvocationID.x;\n    let x_127 : i32 = d_1;\n    if ((x_126 < bitcast<u32>(x_127))) {\n      let x_133 : u32 = offs;\n      let x_135 : u32 = gl_LocalInvocationID.x;\n      a_1 = ((x_133 * ((2u * x_135) + 1u)) - 1u);\n      let x_141 : u32 = offs;\n      let x_143 : u32 = gl_LocalInvocationID.x;\n      b_1 = ((x_141 * ((2u * x_143) + 2u)) - 1u);\n      let x_149 : u32 = a_1;\n      let x_151 : u32 = chunk[x_149];\n      tmp = x_151;\n      let x_152 : u32 = a_1;\n      let x_153 : u32 = b_1;\n      let x_155 : u32 = chunk[x_153];\n      chunk[x_152] = x_155;\n      let x_157 : u32 = b_1;\n      let x_158 : u32 = tmp;\n      let x_160 : u32 = chunk[x_157];\n      chunk[x_157] = (x_160 + x_158);\n    }\n\n    continuing {\n      let x_163 : i32 = d_1;\n      d_1 = (x_163 << bitcast<u32>(1i));\n    }\n  }\n  workgroupBarrier();\n  let x_166 : u32 = gl_GlobalInvocationID.x;\n  let x_169 : u32 = gl_LocalInvocationID.x;\n  let x_172 : u32 = chunk[(2u * x_169)];\n  x_23.vals[(2u * x_166)] = x_172;\n  let x_175 : u32 = gl_GlobalInvocationID.x;\n  let x_179 : u32 = gl_LocalInvocationID.x;\n  let x_183 : u32 = chunk[((2u * x_179) + 1u)];\n  x_23.vals[((2u * x_175) + 1u)] = x_183;\n  return;\n}\n\n@compute @workgroup_size(256i, 1i, 1i)\nfn main(@builtin(local_invocation_id) gl_LocalInvocationID_param : vec3<u32>, @builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>, @builtin(workgroup_id) gl_WorkGroupID_param : vec3<u32>) {\n  gl_LocalInvocationID = gl_LocalInvocationID_param;\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  gl_WorkGroupID = gl_WorkGroupID_param;\n  main_1();\n}\n`;\n\nconst block_prefix_sum_comp_spv = `alias RTArr = array<u32>;\n\nstruct Data {\n  vals : RTArr,\n}\n\nstruct CarryInOut {\n  carry_in : u32,\n  carry_out : u32,\n}\n\nvar<workgroup> chunk : array<u32, 512u>;\n\nvar<private> gl_LocalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<storage, read_write> x_23 : Data;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(1) var<storage, read_write> x_104 : CarryInOut;\n\nfn main_1() {\n  var offs : u32;\n  var d : i32;\n  var a : u32;\n  var b : u32;\n  var d_1 : i32;\n  var a_1 : u32;\n  var b_1 : u32;\n  var tmp : u32;\n  let x_18 : u32 = gl_LocalInvocationID.x;\n  let x_28 : u32 = gl_GlobalInvocationID.x;\n  let x_32 : u32 = x_23.vals[(2u * x_28)];\n  chunk[(2u * x_18)] = x_32;\n  let x_36 : u32 = gl_LocalInvocationID.x;\n  let x_41 : u32 = gl_GlobalInvocationID.x;\n  let x_45 : u32 = x_23.vals[((2u * x_41) + 1u)];\n  chunk[((2u * x_36) + 1u)] = x_45;\n  offs = 1u;\n  d = 256i;\n  loop {\n    let x_57 : i32 = d;\n    if ((x_57 > 0i)) {\n    } else {\n      break;\n    }\n    workgroupBarrier();\n    let x_62 : u32 = gl_LocalInvocationID.x;\n    let x_63 : i32 = d;\n    if ((x_62 < bitcast<u32>(x_63))) {\n      let x_69 : u32 = offs;\n      let x_71 : u32 = gl_LocalInvocationID.x;\n      a = ((x_69 * ((2u * x_71) + 1u)) - 1u);\n      let x_77 : u32 = offs;\n      let x_79 : u32 = gl_LocalInvocationID.x;\n      b = ((x_77 * ((2u * x_79) + 2u)) - 1u);\n      let x_84 : u32 = b;\n      let x_85 : u32 = a;\n      let x_87 : u32 = chunk[x_85];\n      let x_89 : u32 = chunk[x_84];\n      chunk[x_84] = (x_89 + x_87);\n    }\n    let x_92 : u32 = offs;\n    offs = (x_92 << bitcast<u32>(1i));\n\n    continuing {\n      let x_95 : i32 = d;\n      d = (x_95 >> bitcast<u32>(1i));\n    }\n  }\n  let x_98 : u32 = gl_LocalInvocationID.x;\n  if ((x_98 == 0u)) {\n    let x_107 : u32 = chunk[511i];\n    let x_109 : u32 = x_104.carry_in;\n    x_104.carry_out = (x_107 + x_109);\n    chunk[511i] = 0u;\n  }\n  d_1 = 1i;\n  loop {\n    let x_119 : i32 = d_1;\n    if ((x_119 < 512i)) {\n    } else {\n      break;\n    }\n    let x_122 : u32 = offs;\n    offs = (x_122 >> bitcast<u32>(1i));\n    workgroupBarrier();\n    let x_125 : u32 = gl_LocalInvocationID.x;\n    let x_126 : i32 = d_1;\n    if ((x_125 < bitcast<u32>(x_126))) {\n      let x_132 : u32 = offs;\n      let x_134 : u32 = gl_LocalInvocationID.x;\n      a_1 = ((x_132 * ((2u * x_134) + 1u)) - 1u);\n      let x_140 : u32 = offs;\n      let x_142 : u32 = gl_LocalInvocationID.x;\n      b_1 = ((x_140 * ((2u * x_142) + 2u)) - 1u);\n      let x_148 : u32 = a_1;\n      let x_150 : u32 = chunk[x_148];\n      tmp = x_150;\n      let x_151 : u32 = a_1;\n      let x_152 : u32 = b_1;\n      let x_154 : u32 = chunk[x_152];\n      chunk[x_151] = x_154;\n      let x_156 : u32 = b_1;\n      let x_157 : u32 = tmp;\n      let x_159 : u32 = chunk[x_156];\n      chunk[x_156] = (x_159 + x_157);\n    }\n\n    continuing {\n      let x_162 : i32 = d_1;\n      d_1 = (x_162 << bitcast<u32>(1i));\n    }\n  }\n  workgroupBarrier();\n  let x_165 : u32 = gl_GlobalInvocationID.x;\n  let x_168 : u32 = gl_LocalInvocationID.x;\n  let x_171 : u32 = chunk[(2u * x_168)];\n  let x_173 : u32 = x_104.carry_in;\n  x_23.vals[(2u * x_165)] = (x_171 + x_173);\n  let x_177 : u32 = gl_GlobalInvocationID.x;\n  let x_181 : u32 = gl_LocalInvocationID.x;\n  let x_185 : u32 = chunk[((2u * x_181) + 1u)];\n  let x_187 : u32 = x_104.carry_in;\n  x_23.vals[((2u * x_177) + 1u)] = (x_185 + x_187);\n  return;\n}\n\n@compute @workgroup_size(256i, 1i, 1i)\nfn main(@builtin(local_invocation_id) gl_LocalInvocationID_param : vec3<u32>, @builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_LocalInvocationID = gl_LocalInvocationID_param;\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst add_block_sums_comp_spv = `alias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct BlockSums {\n  block_sums : RTArr_1,\n}\n\nstruct Data {\n  vals : RTArr_1,\n}\n\n@group(0) @binding(1) var<storage, read_write> x_12 : BlockSums;\n\nvar<private> gl_WorkGroupID : vec3<u32>;\n\n@group(0) @binding(0) var<storage, read_write> x_28 : Data;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\nfn main_1() {\n  var prev_sum : u32;\n  let x_21 : u32 = gl_WorkGroupID.x;\n  let x_24 : u32 = x_12.block_sums[x_21];\n  prev_sum = x_24;\n  let x_32 : u32 = gl_GlobalInvocationID.x;\n  let x_33 : u32 = (2u * x_32);\n  let x_34 : u32 = prev_sum;\n  let x_36 : u32 = x_28.vals[x_33];\n  x_28.vals[x_33] = (x_36 + x_34);\n  let x_40 : u32 = gl_GlobalInvocationID.x;\n  let x_43 : u32 = ((2u * x_40) + 1u);\n  let x_44 : u32 = prev_sum;\n  let x_46 : u32 = x_28.vals[x_43];\n  x_28.vals[x_43] = (x_46 + x_44);\n  return;\n}\n\n@compute @workgroup_size(256i, 1i, 1i)\nfn main(@builtin(workgroup_id) gl_WorkGroupID_param : vec3<u32>, @builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_WorkGroupID = gl_WorkGroupID_param;\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst stream_compact_comp_spv = `alias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct Input {\n  inputs : RTArr_1,\n}\n\nalias RTArr_2 = array<u32>;\n\nstruct Output {\n  outputs : RTArr_1,\n}\n\nstruct Offsets {\n  offsets : RTArr_1,\n}\n\nstruct CompactionOffset {\n  compact_offset : u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> x_10 : Input;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(3) var<storage, read_write> x_30 : Output;\n\n@group(0) @binding(1) var<storage, read_write> x_34 : Offsets;\n\n@group(0) @binding(2) var<uniform> x_43 : CompactionOffset;\n\nfn main_1() {\n  let x_19 : u32 = gl_GlobalInvocationID.x;\n  let x_22 : u32 = x_10.inputs[x_19];\n  if ((x_22 != 0u)) {\n    let x_36 : u32 = gl_GlobalInvocationID.x;\n    let x_38 : u32 = x_34.offsets[x_36];\n    let x_40 : u32 = gl_GlobalInvocationID.x;\n    let x_45 : u32 = x_43.compact_offset;\n    x_30.outputs[x_38] = (x_40 + x_45);\n  }\n  return;\n}\n\n@compute @workgroup_size(8i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst stream_compact_data_comp_spv = `struct CompactionOffset {\n  compact_offset : u32,\n}\n\nalias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct Input {\n  inputs : RTArr_1,\n}\n\nalias RTArr_2 = array<u32>;\n\nstruct Output {\n  outputs : RTArr_1,\n}\n\nalias RTArr_3 = array<u32>;\n\nstruct Offsets {\n  offsets : RTArr_1,\n}\n\nstruct Data {\n  input_data : RTArr_1,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(2) var<uniform> x_18 : CompactionOffset;\n\n@group(0) @binding(0) var<storage, read_write> x_28 : Input;\n\n@group(0) @binding(3) var<storage, read_write> x_39 : Output;\n\n@group(0) @binding(1) var<storage, read_write> x_43 : Offsets;\n\n@group(1) @binding(0) var<storage, read_write> x_50 : Data;\n\nfn main_1() {\n  var i : u32;\n  let x_15 : u32 = gl_GlobalInvocationID.x;\n  let x_23 : u32 = x_18.compact_offset;\n  i = (x_15 + x_23);\n  let x_29 : u32 = i;\n  let x_31 : u32 = x_28.inputs[x_29];\n  if ((x_31 != 0u)) {\n    let x_44 : u32 = i;\n    let x_46 : u32 = x_43.offsets[x_44];\n    let x_51 : u32 = i;\n    let x_53 : u32 = x_50.input_data[x_51];\n    x_39.outputs[x_46] = x_53;\n  }\n  return;\n}\n\n@compute @workgroup_size(8i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst compute_initial_rays_vert_spv = `struct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nstruct ViewParams {\n  proj_view : mat4x4<f32>,\n  eye_pos : vec4<f32>,\n  eye_dir : vec4<f32>,\n  near_plane : f32,\n}\n\n@group(0) @binding(2) var<uniform> x_17 : VolumeParams;\n\n@group(0) @binding(0) var<uniform> x_36 : ViewParams;\n\nvar<private> pos : vec3<f32>;\n\nvar<private> transformed_eye : vec3<f32>;\n\nvar<private> vray_dir : vec3<f32>;\n\nvar<private> gl_Position : vec4<f32>;\n\nfn main_1() {\n  var volume_translation : vec3<f32>;\n  let x_22 : vec4<f32> = x_17.volume_scale;\n  volume_translation = (vec3<f32>(0.0f, 0.0f, 0.0f) - (vec3<f32>(x_22.x, x_22.y, x_22.z) * 0.5f));\n  let x_39 : mat4x4<f32> = x_36.proj_view;\n  let x_42 : vec3<f32> = pos;\n  let x_44 : vec4<f32> = x_17.volume_scale;\n  let x_47 : vec3<f32> = volume_translation;\n  let x_48 : vec3<f32> = ((x_42 * vec3<f32>(x_44.x, x_44.y, x_44.z)) + x_47);\n  gl_Position = (x_39 * vec4<f32>(x_48.x, x_48.y, x_48.z, 1.0f));\n  let x_61 : vec4<f32> = x_36.eye_pos;\n  let x_63 : vec3<f32> = volume_translation;\n  let x_66 : vec4<f32> = x_17.volume_scale;\n  transformed_eye = ((vec3<f32>(x_61.x, x_61.y, x_61.z) - x_63) / vec3<f32>(x_66.x, x_66.y, x_66.z));\n  let x_70 : vec3<f32> = pos;\n  let x_71 : vec3<f32> = transformed_eye;\n  vray_dir = (x_70 - x_71);\n  return;\n}\n\nstruct main_out {\n  @builtin(position)\n  gl_Position : vec4<f32>,\n  @location(1) @interpolate(flat)\n  transformed_eye_1 : vec3<f32>,\n  @location(0)\n  vray_dir_1 : vec3<f32>,\n}\n\n@vertex\nfn main(@location(0) pos_param : vec3<f32>) -> main_out {\n  pos = pos_param;\n  main_1();\n  return main_out(gl_Position, transformed_eye, vray_dir);\n}\n`;\n\nconst compute_initial_rays_frag_spv = `struct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nstruct RayInfo {\n  ray_dir : vec3<f32>,\n  t : f32,\n}\n\nalias RTArr = array<RayInfo>;\n\nstruct RayInformation {\n  rays : RTArr,\n}\n\nalias RTArr_1 = array<u32>;\n\nstruct RayBlockIDs {\n  block_ids : RTArr_1,\n}\n\nvar<private> vray_dir : vec3<f32>;\n\nvar<private> transformed_eye : vec3<f32>;\n\n@group(0) @binding(2) var<uniform> x_80 : VolumeParams;\n\nvar<private> gl_FragCoord : vec4<f32>;\n\n@group(0) @binding(1) var<storage, read_write> x_149 : RayInformation;\n\n@group(0) @binding(3) var<storage, read_write> x_157 : RayBlockIDs;\n\nfn intersect_box_vf3_vf3_vf3_vf3_(orig : ptr<function, vec3<f32>>, dir : ptr<function, vec3<f32>>, box_min : vec3<f32>, box_max : vec3<f32>) -> vec2<f32> {\n  var inv_dir : vec3<f32>;\n  var tmin_tmp : vec3<f32>;\n  var tmax_tmp : vec3<f32>;\n  var tmin : vec3<f32>;\n  var tmax : vec3<f32>;\n  var t0 : f32;\n  var t1 : f32;\n  let x_19 : vec3<f32> = *(dir);\n  inv_dir = (vec3<f32>(1.0f, 1.0f, 1.0f) / x_19);\n  let x_23 : vec3<f32> = *(orig);\n  let x_25 : vec3<f32> = inv_dir;\n  tmin_tmp = ((box_min - x_23) * x_25);\n  let x_28 : vec3<f32> = *(orig);\n  let x_30 : vec3<f32> = inv_dir;\n  tmax_tmp = ((box_max - x_28) * x_30);\n  let x_33 : vec3<f32> = tmin_tmp;\n  let x_34 : vec3<f32> = tmax_tmp;\n  tmin = min(x_33, x_34);\n  let x_37 : vec3<f32> = tmin_tmp;\n  let x_38 : vec3<f32> = tmax_tmp;\n  tmax = max(x_37, x_38);\n  let x_45 : f32 = tmin.x;\n  let x_48 : f32 = tmin.y;\n  let x_51 : f32 = tmin.z;\n  t0 = max(x_45, max(x_48, x_51));\n  let x_56 : f32 = tmax.x;\n  let x_58 : f32 = tmax.y;\n  let x_60 : f32 = tmax.z;\n  t1 = min(x_56, min(x_58, x_60));\n  let x_63 : f32 = t0;\n  let x_64 : f32 = t1;\n  return vec2<f32>(x_63, x_64);\n}\n\nfn main_1() {\n  var ray_dir : vec3<f32>;\n  var vol_eye : vec3<f32>;\n  var grid_ray_dir : vec3<f32>;\n  var t_hit : vec2<f32>;\n  var param : vec3<f32>;\n  var param_1 : vec3<f32>;\n  var pixel : u32;\n  let x_71 : vec3<f32> = vray_dir;\n  ray_dir = normalize(x_71);\n  let x_75 : vec3<f32> = transformed_eye;\n  let x_86 : vec4<u32> = x_80.volume_dims;\n  vol_eye = ((x_75 * vec3<f32>(vec3<u32>(x_86.x, x_86.y, x_86.z))) - vec3<f32>(0.5f, 0.5f, 0.5f));\n  let x_94 : vec3<f32> = ray_dir;\n  let x_96 : vec4<u32> = x_80.volume_dims;\n  grid_ray_dir = normalize((x_94 * vec3<f32>(vec3<u32>(x_96.x, x_96.y, x_96.z))));\n  let x_106 : vec4<u32> = x_80.volume_dims;\n  let x_112 : vec3<f32> = vol_eye;\n  param = x_112;\n  let x_114 : vec3<f32> = grid_ray_dir;\n  param_1 = x_114;\n  let x_115 : vec2<f32> = intersect_box_vf3_vf3_vf3_vf3_(&(param), &(param_1), vec3<f32>(0.0f, 0.0f, 0.0f), vec3<f32>((vec3<u32>(x_106.x, x_106.y, x_106.z) - vec3<u32>(1u, 1u, 1u))));\n  t_hit = x_115;\n  let x_117 : f32 = t_hit.x;\n  t_hit.x = max(x_117, 0.0f);\n  let x_126 : f32 = gl_FragCoord.x;\n  let x_131 : u32 = x_80.image_width;\n  let x_133 : f32 = gl_FragCoord.y;\n  pixel = (u32(x_126) + (x_131 * u32(x_133)));\n  let x_138 : f32 = t_hit.x;\n  let x_140 : f32 = t_hit.y;\n  if ((x_138 < x_140)) {\n    let x_150 : u32 = pixel;\n    let x_151 : vec3<f32> = grid_ray_dir;\n    x_149.rays[x_150].ray_dir = x_151;\n    let x_158 : u32 = pixel;\n    x_157.block_ids[x_158] = 4294967295u;\n    let x_161 : u32 = pixel;\n    let x_164 : f32 = t_hit.x;\n    x_149.rays[x_161].t = x_164;\n  }\n  return;\n}\n\n@fragment\nfn main(@location(0) vray_dir_param : vec3<f32>, @location(1) @interpolate(flat) transformed_eye_param : vec3<f32>, @builtin(position) gl_FragCoord_param : vec4<f32>) {\n  vray_dir = vray_dir_param;\n  transformed_eye = transformed_eye_param;\n  gl_FragCoord = gl_FragCoord_param;\n  main_1();\n}\n`;\n\nconst zfp_compute_block_range_comp_spv = `struct EmulateUint64 {\n  lo : u32,\n  hi : u32,\n}\n\nstruct BlockReader {\n  current_bit : u32,\n  current_word : u32,\n  word_buffer : EmulateUint64,\n}\n\nstruct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nstruct EmulateUint64_1 {\n  lo : u32,\n  hi : u32,\n}\n\nalias RTArr = array<EmulateUint64_1>;\n\nstruct Compressed {\n  compressed : RTArr,\n}\n\nstruct BlockIDOffset {\n  block_id_offset : u32,\n}\n\nalias RTArr_1 = array<vec2<f32>>;\n\nstruct BlockInformation {\n  block_ranges : RTArr_1,\n}\n\n@group(0) @binding(1) var<uniform> x_240 : VolumeParams;\n\n@group(0) @binding(0) var<storage, read_write> x_270 : Compressed;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(1) @binding(0) var<uniform> x_872 : BlockIDOffset;\n\n@group(0) @binding(2) var<storage, read_write> x_1073 : BlockInformation;\n\nfn shift_right_struct_EmulateUint64_u1_u11_u1_(a_3 : EmulateUint64, n_1 : ptr<function, u32>) -> EmulateUint64 {\n  var carry_1 : u32;\n  var b_3 : EmulateUint64;\n  let x_167 : u32 = *(n_1);\n  if ((x_167 == 0u)) {\n    return a_3;\n  }\n  let x_172 : u32 = *(n_1);\n  if ((x_172 < 32u)) {\n    let x_178 : u32 = *(n_1);\n    carry_1 = (a_3.hi & (4294967295u >> (32u - x_178)));\n    let x_184 : u32 = *(n_1);\n    let x_186 : u32 = carry_1;\n    let x_187 : u32 = *(n_1);\n    b_3.lo = ((a_3.lo >> x_184) | (x_186 << (32u - x_187)));\n    let x_193 : u32 = *(n_1);\n    b_3.hi = (a_3.hi >> x_193);\n  } else {\n    let x_198 : u32 = *(n_1);\n    b_3.lo = (a_3.hi >> (x_198 - 32u));\n    b_3.hi = 0u;\n  }\n  let x_203 : EmulateUint64 = b_3;\n  return x_203;\n}\n\nfn create_block_reader_u1_(block_index : ptr<function, u32>) -> BlockReader {\n  var reader_5 : BlockReader;\n  var param_2 : u32;\n  let x_244 : u32 = x_240.max_bits;\n  if ((x_244 != 64u)) {\n    let x_249 : u32 = *(block_index);\n    let x_251 : u32 = x_240.max_bits;\n    reader_5.current_word = ((x_249 * x_251) / 64u);\n    let x_255 : u32 = *(block_index);\n    let x_257 : u32 = x_240.max_bits;\n    reader_5.current_bit = ((x_255 * x_257) % 64u);\n  } else {\n    let x_262 : u32 = *(block_index);\n    reader_5.current_word = x_262;\n    reader_5.current_bit = 0u;\n  }\n  let x_272 : u32 = reader_5.current_word;\n  let x_275 : EmulateUint64_1 = x_270.compressed[x_272];\n  reader_5.word_buffer.lo = x_275.lo;\n  reader_5.word_buffer.hi = x_275.hi;\n  let x_282 : EmulateUint64 = reader_5.word_buffer;\n  let x_285 : u32 = reader_5.current_bit;\n  param_2 = x_285;\n  let x_286 : EmulateUint64 = shift_right_struct_EmulateUint64_u1_u11_u1_(x_282, &(param_2));\n  reader_5.word_buffer = x_286;\n  let x_288 : BlockReader = reader_5;\n  return x_288;\n}\n\nfn advance_word_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(reader : ptr<function, BlockReader>) {\n  (*(reader)).current_bit = 0u;\n  let x_293 : u32 = (*(reader)).current_word;\n  (*(reader)).current_word = (x_293 + bitcast<u32>(1i));\n  let x_296 : u32 = (*(reader)).current_word;\n  let x_298 : EmulateUint64_1 = x_270.compressed[x_296];\n  (*(reader)).word_buffer.lo = x_298.lo;\n  (*(reader)).word_buffer.hi = x_298.hi;\n  return;\n}\n\nfn read_bit_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(reader_1 : ptr<function, BlockReader>) -> u32 {\n  var bit : u32;\n  var param_3 : u32;\n  var param_4 : BlockReader;\n  let x_306 : u32 = (*(reader_1)).word_buffer.lo;\n  bit = (x_306 & 1u);\n  let x_310 : u32 = (*(reader_1)).current_bit;\n  (*(reader_1)).current_bit = (x_310 + bitcast<u32>(1i));\n  let x_313 : EmulateUint64 = (*(reader_1)).word_buffer;\n  param_3 = 1u;\n  let x_315 : EmulateUint64 = shift_right_struct_EmulateUint64_u1_u11_u1_(x_313, &(param_3));\n  (*(reader_1)).word_buffer = x_315;\n  let x_318 : u32 = (*(reader_1)).current_bit;\n  if ((x_318 >= 64u)) {\n    let x_323 : BlockReader = *(reader_1);\n    param_4 = x_323;\n    advance_word_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(&(param_4));\n    let x_325 : BlockReader = param_4;\n    *(reader_1) = x_325;\n  }\n  let x_326 : u32 = bit;\n  return x_326;\n}\n\nfn make_emulate_uint64_u1_u1_(hi : ptr<function, u32>, lo : ptr<function, u32>) -> EmulateUint64 {\n  var a_4 : EmulateUint64;\n  let x_92 : u32 = *(lo);\n  a_4.lo = x_92;\n  let x_95 : u32 = *(hi);\n  a_4.hi = x_95;\n  let x_97 : EmulateUint64 = a_4;\n  return x_97;\n}\n\nfn make_mask_u1_(n_2 : ptr<function, u32>) -> EmulateUint64 {\n  var a_5 : EmulateUint64;\n  var param : u32;\n  var param_1 : u32;\n  param = 0u;\n  param_1 = 0u;\n  let x_209 : EmulateUint64 = make_emulate_uint64_u1_u1_(&(param), &(param_1));\n  a_5 = x_209;\n  let x_210 : u32 = *(n_2);\n  let x_212 : u32 = *(n_2);\n  if (((x_210 > 0u) & (x_212 < 65u))) {\n    let x_218 : u32 = *(n_2);\n    if ((x_218 > 32u)) {\n      a_5.lo = 4294967295u;\n      let x_223 : u32 = *(n_2);\n      a_5.hi = (4294967295u >> (64u - x_223));\n    } else {\n      let x_228 : u32 = *(n_2);\n      a_5.lo = (4294967295u >> (32u - x_228));\n      a_5.hi = 0u;\n    }\n  }\n  let x_233 : EmulateUint64 = a_5;\n  return x_233;\n}\n\nfn bitwise_and_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(a : EmulateUint64, b : EmulateUint64) -> EmulateUint64 {\n  var c : EmulateUint64;\n  c.lo = (a.lo & b.lo);\n  c.hi = (a.hi & b.hi);\n  let x_109 : EmulateUint64 = c;\n  return x_109;\n}\n\nfn shift_left_struct_EmulateUint64_u1_u11_u1_(a_2 : EmulateUint64, n : ptr<function, u32>) -> EmulateUint64 {\n  var carry : u32;\n  var b_2 : EmulateUint64;\n  let x_124 : u32 = *(n);\n  if ((x_124 == 0u)) {\n    return a_2;\n  }\n  let x_131 : u32 = *(n);\n  if ((x_131 < 32u)) {\n    let x_139 : u32 = *(n);\n    carry = (a_2.lo & (4294967295u << (32u - x_139)));\n    let x_145 : u32 = *(n);\n    b_2.lo = (a_2.lo << x_145);\n    let x_149 : u32 = *(n);\n    let x_151 : u32 = carry;\n    let x_152 : u32 = *(n);\n    b_2.hi = ((a_2.hi << x_149) | (x_151 >> (32u - x_152)));\n  } else {\n    b_2.lo = 0u;\n    let x_160 : u32 = *(n);\n    b_2.hi = (a_2.lo << (x_160 - 32u));\n  }\n  let x_164 : EmulateUint64 = b_2;\n  return x_164;\n}\n\nfn bitwise_or_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(a_1 : EmulateUint64, b_1 : EmulateUint64) -> EmulateUint64 {\n  var c_1 : EmulateUint64;\n  c_1.lo = (a_1.lo | b_1.lo);\n  c_1.hi = (a_1.hi | b_1.hi);\n  let x_121 : EmulateUint64 = c_1;\n  return x_121;\n}\n\nfn read_bits_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_u1_(reader_2 : ptr<function, BlockReader>, n_bits : u32) -> EmulateUint64 {\n  var rem_bits : u32;\n  var first_read : u32;\n  var mask : EmulateUint64;\n  var param_5 : u32;\n  var bits : EmulateUint64;\n  var param_6 : u32;\n  var next_read : u32;\n  var param_7 : BlockReader;\n  var param_8 : u32;\n  var param_9 : u32;\n  var param_10 : u32;\n  let x_331 : u32 = (*(reader_2)).current_bit;\n  rem_bits = (64u - x_331);\n  let x_334 : u32 = rem_bits;\n  first_read = min(x_334, n_bits);\n  let x_338 : u32 = first_read;\n  param_5 = x_338;\n  let x_339 : EmulateUint64 = make_mask_u1_(&(param_5));\n  mask = x_339;\n  let x_342 : EmulateUint64 = (*(reader_2)).word_buffer;\n  let x_343 : EmulateUint64 = mask;\n  let x_344 : EmulateUint64 = bitwise_and_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(x_342, x_343);\n  bits = x_344;\n  let x_346 : EmulateUint64 = (*(reader_2)).word_buffer;\n  param_6 = n_bits;\n  let x_348 : EmulateUint64 = shift_right_struct_EmulateUint64_u1_u11_u1_(x_346, &(param_6));\n  (*(reader_2)).word_buffer = x_348;\n  let x_350 : u32 = first_read;\n  let x_352 : u32 = (*(reader_2)).current_bit;\n  (*(reader_2)).current_bit = (x_352 + x_350);\n  next_read = 0u;\n  let x_356 : u32 = rem_bits;\n  if ((n_bits >= x_356)) {\n    let x_361 : BlockReader = *(reader_2);\n    param_7 = x_361;\n    advance_word_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(&(param_7));\n    let x_363 : BlockReader = param_7;\n    *(reader_2) = x_363;\n    let x_364 : u32 = first_read;\n    next_read = (n_bits - x_364);\n  }\n  let x_367 : u32 = next_read;\n  param_8 = x_367;\n  let x_368 : EmulateUint64 = make_mask_u1_(&(param_8));\n  mask = x_368;\n  let x_369 : EmulateUint64 = bits;\n  let x_371 : EmulateUint64 = (*(reader_2)).word_buffer;\n  let x_372 : EmulateUint64 = mask;\n  let x_373 : EmulateUint64 = bitwise_and_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(x_371, x_372);\n  let x_375 : u32 = first_read;\n  param_9 = x_375;\n  let x_376 : EmulateUint64 = shift_left_struct_EmulateUint64_u1_u11_u1_(x_373, &(param_9));\n  let x_377 : EmulateUint64 = bitwise_or_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(x_369, x_376);\n  bits = x_377;\n  let x_379 : EmulateUint64 = (*(reader_2)).word_buffer;\n  let x_381 : u32 = next_read;\n  param_10 = x_381;\n  let x_382 : EmulateUint64 = shift_right_struct_EmulateUint64_u1_u11_u1_(x_379, &(param_10));\n  (*(reader_2)).word_buffer = x_382;\n  let x_384 : u32 = next_read;\n  let x_386 : u32 = (*(reader_2)).current_bit;\n  (*(reader_2)).current_bit = (x_386 + x_384);\n  let x_389 : EmulateUint64 = bits;\n  return x_389;\n}\n\nfn decode_ints_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_u1_u1_64__(reader_3 : ptr<function, BlockReader>, block_max_bits : u32, block_1 : ptr<function, array<u32, 64u>>) {\n  var i : u32;\n  var x_1 : EmulateUint64;\n  var param_11 : u32;\n  var param_12 : u32;\n  var one : EmulateUint64;\n  var param_13 : u32;\n  var param_14 : u32;\n  var bits_1 : u32;\n  var k : u32;\n  var n_3 : u32;\n  var m : u32;\n  var param_15 : BlockReader;\n  var param_16 : BlockReader;\n  var param_17 : BlockReader;\n  var param_18 : u32;\n  var i_1 : u32;\n  var param_19 : u32;\n  i = 0u;\n  loop {\n    let x_405 : u32 = i;\n    if ((x_405 < 64u)) {\n    } else {\n      break;\n    }\n    let x_407 : u32 = i;\n    (*(block_1))[x_407] = 0u;\n\n    continuing {\n      let x_409 : u32 = i;\n      i = (x_409 + bitcast<u32>(1i));\n    }\n  }\n  param_11 = 0u;\n  param_12 = 0u;\n  let x_414 : EmulateUint64 = make_emulate_uint64_u1_u1_(&(param_11), &(param_12));\n  x_1 = x_414;\n  param_13 = 0u;\n  param_14 = 1u;\n  let x_418 : EmulateUint64 = make_emulate_uint64_u1_u1_(&(param_13), &(param_14));\n  one = x_418;\n  bits_1 = block_max_bits;\n  k = 32u;\n  n_3 = 0u;\n  loop {\n    var x_433 : bool;\n    var x_434 : bool;\n    let x_427 : u32 = bits_1;\n    let x_428 : bool = (x_427 != 0u);\n    x_434 = x_428;\n    if (x_428) {\n      let x_431 : u32 = k;\n      k = (x_431 - bitcast<u32>(1i));\n      x_433 = (x_431 > 0u);\n      x_434 = x_433;\n    }\n    if (x_434) {\n    } else {\n      break;\n    }\n    let x_436 : u32 = n_3;\n    let x_437 : u32 = bits_1;\n    m = min(x_436, x_437);\n    let x_439 : u32 = m;\n    let x_440 : u32 = bits_1;\n    bits_1 = (x_440 - x_439);\n    let x_442 : u32 = m;\n    let x_444 : BlockReader = *(reader_3);\n    param_15 = x_444;\n    let x_445 : EmulateUint64 = read_bits_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_u1_(&(param_15), x_442);\n    let x_446 : BlockReader = param_15;\n    *(reader_3) = x_446;\n    x_1 = x_445;\n    loop {\n      var x_465 : bool;\n      var x_466 : bool;\n      let x_452 : u32 = n_3;\n      let x_454 : u32 = bits_1;\n      let x_456 : bool = ((x_452 < 64u) & (x_454 != 0u));\n      x_466 = x_456;\n      if (x_456) {\n        let x_459 : u32 = bits_1;\n        bits_1 = (x_459 - bitcast<u32>(1i));\n        let x_462 : BlockReader = *(reader_3);\n        param_16 = x_462;\n        let x_463 : u32 = read_bit_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(&(param_16));\n        let x_464 : BlockReader = param_16;\n        *(reader_3) = x_464;\n        x_465 = (x_463 != 0u);\n        x_466 = x_465;\n      }\n      if (x_466) {\n      } else {\n        break;\n      }\n      loop {\n        var x_486 : bool;\n        var x_487 : bool;\n        let x_472 : u32 = n_3;\n        let x_475 : u32 = bits_1;\n        let x_477 : bool = ((x_472 < 63u) & (x_475 != 0u));\n        x_487 = x_477;\n        if (x_477) {\n          let x_480 : u32 = bits_1;\n          bits_1 = (x_480 - bitcast<u32>(1i));\n          let x_483 : BlockReader = *(reader_3);\n          param_17 = x_483;\n          let x_484 : u32 = read_bit_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(&(param_17));\n          let x_485 : BlockReader = param_17;\n          *(reader_3) = x_485;\n          x_486 = (x_484 == 0u);\n          x_487 = x_486;\n        }\n        if (x_487) {\n        } else {\n          break;\n        }\n\n        continuing {\n          let x_488 : u32 = n_3;\n          n_3 = (x_488 + bitcast<u32>(1i));\n        }\n      }\n\n      continuing {\n        let x_490 : EmulateUint64 = x_1;\n        let x_491 : EmulateUint64 = one;\n        let x_492 : u32 = n_3;\n        n_3 = (x_492 + bitcast<u32>(1i));\n        param_18 = x_492;\n        let x_495 : EmulateUint64 = shift_left_struct_EmulateUint64_u1_u11_u1_(x_491, &(param_18));\n        let x_496 : EmulateUint64 = bitwise_or_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(x_490, x_495);\n        x_1 = x_496;\n      }\n    }\n    i_1 = 0u;\n    loop {\n      let x_503 : u32 = i_1;\n      if ((x_503 < 64u)) {\n      } else {\n        break;\n      }\n      let x_505 : u32 = i_1;\n      let x_507 : u32 = x_1.lo;\n      let x_509 : u32 = k;\n      let x_512 : u32 = (*(block_1))[x_505];\n      (*(block_1))[x_505] = (x_512 + ((x_507 & 1u) << x_509));\n\n      continuing {\n        let x_515 : u32 = i_1;\n        i_1 = (x_515 + bitcast<u32>(1i));\n        let x_517 : EmulateUint64 = x_1;\n        param_19 = 1u;\n        let x_519 : EmulateUint64 = shift_right_struct_EmulateUint64_u1_u11_u1_(x_517, &(param_19));\n        x_1 = x_519;\n      }\n    }\n  }\n  return;\n}\n\nfn uint2int_u1_(x : ptr<function, u32>) -> i32 {\n  let x_392 : u32 = *(x);\n  return bitcast<i32>(((x_392 ^ 2863311530u) - 2863311530u));\n}\n\nfn inverse_lift_i1_64__u1_u1_(block_2 : ptr<function, array<i32, 64u>>, s : u32, idx : u32) {\n  var i_2 : u32;\n  var v : vec4<i32>;\n  var i_3 : u32;\n  i_2 = 0u;\n  loop {\n    let x_526 : u32 = i_2;\n    if ((x_526 < 4u)) {\n    } else {\n      break;\n    }\n    let x_532 : u32 = i_2;\n    let x_533 : u32 = i_2;\n    let x_538 : i32 = (*(block_2))[(idx + (x_533 * s))];\n    v[x_532] = x_538;\n\n    continuing {\n      let x_540 : u32 = i_2;\n      i_2 = (x_540 + bitcast<u32>(1i));\n    }\n  }\n  let x_544 : i32 = v.w;\n  let x_547 : i32 = v.y;\n  v.y = (x_547 + (x_544 >> bitcast<u32>(1i)));\n  let x_551 : i32 = v.y;\n  let x_554 : i32 = v.w;\n  v.w = (x_554 - (x_551 >> bitcast<u32>(1i)));\n  let x_558 : i32 = v.w;\n  let x_560 : i32 = v.y;\n  v.y = (x_560 + x_558);\n  let x_564 : i32 = v.w;\n  v.w = (x_564 << bitcast<u32>(1i));\n  let x_568 : i32 = v.y;\n  let x_570 : i32 = v.w;\n  v.w = (x_570 - x_568);\n  let x_574 : i32 = v.x;\n  let x_577 : i32 = v.z;\n  v.z = (x_577 + x_574);\n  let x_581 : i32 = v.x;\n  v.x = (x_581 << bitcast<u32>(1i));\n  let x_585 : i32 = v.z;\n  let x_587 : i32 = v.x;\n  v.x = (x_587 - x_585);\n  let x_591 : i32 = v.z;\n  let x_593 : i32 = v.y;\n  v.y = (x_593 + x_591);\n  let x_597 : i32 = v.z;\n  v.z = (x_597 << bitcast<u32>(1i));\n  let x_601 : i32 = v.y;\n  let x_603 : i32 = v.z;\n  v.z = (x_603 - x_601);\n  let x_607 : i32 = v.x;\n  let x_609 : i32 = v.w;\n  v.w = (x_609 + x_607);\n  let x_613 : i32 = v.x;\n  v.x = (x_613 << bitcast<u32>(1i));\n  let x_617 : i32 = v.w;\n  let x_619 : i32 = v.x;\n  v.x = (x_619 - x_617);\n  i_3 = 0u;\n  loop {\n    let x_628 : u32 = i_3;\n    if ((x_628 < 4u)) {\n    } else {\n      break;\n    }\n    let x_630 : u32 = i_3;\n    let x_633 : u32 = i_3;\n    let x_635 : i32 = v[x_633];\n    (*(block_2))[(idx + (x_630 * s))] = x_635;\n\n    continuing {\n      let x_637 : u32 = i_3;\n      i_3 = (x_637 + bitcast<u32>(1i));\n    }\n  }\n  return;\n}\n\nfn inverse_transform_i1_64__(block_3 : ptr<function, array<i32, 64u>>) {\n  var y : u32;\n  var x_2 : u32;\n  var param_20 : array<i32, 64u>;\n  var x_3 : u32;\n  var z : u32;\n  var param_21 : array<i32, 64u>;\n  var z_1 : u32;\n  var y_1 : u32;\n  var param_22 : array<i32, 64u>;\n  y = 0u;\n  loop {\n    let x_645 : u32 = y;\n    if ((x_645 < 4u)) {\n    } else {\n      break;\n    }\n    x_2 = 0u;\n    loop {\n      let x_653 : u32 = x_2;\n      if ((x_653 < 4u)) {\n      } else {\n        break;\n      }\n      let x_656 : u32 = x_2;\n      let x_657 : u32 = y;\n      let x_661 : array<i32, 64u> = *(block_3);\n      param_20 = x_661;\n      inverse_lift_i1_64__u1_u1_(&(param_20), 16u, (x_656 + (4u * x_657)));\n      let x_663 : array<i32, 64u> = param_20;\n      *(block_3) = x_663;\n\n      continuing {\n        let x_664 : u32 = x_2;\n        x_2 = (x_664 + bitcast<u32>(1i));\n      }\n    }\n\n    continuing {\n      let x_666 : u32 = y;\n      y = (x_666 + bitcast<u32>(1i));\n    }\n  }\n  x_3 = 0u;\n  loop {\n    let x_674 : u32 = x_3;\n    if ((x_674 < 4u)) {\n    } else {\n      break;\n    }\n    z = 0u;\n    loop {\n      let x_682 : u32 = z;\n      if ((x_682 < 4u)) {\n      } else {\n        break;\n      }\n      let x_684 : u32 = z;\n      let x_686 : u32 = x_3;\n      let x_689 : array<i32, 64u> = *(block_3);\n      param_21 = x_689;\n      inverse_lift_i1_64__u1_u1_(&(param_21), 4u, ((16u * x_684) + x_686));\n      let x_691 : array<i32, 64u> = param_21;\n      *(block_3) = x_691;\n\n      continuing {\n        let x_692 : u32 = z;\n        z = (x_692 + bitcast<u32>(1i));\n      }\n    }\n\n    continuing {\n      let x_694 : u32 = x_3;\n      x_3 = (x_694 + bitcast<u32>(1i));\n    }\n  }\n  z_1 = 0u;\n  loop {\n    let x_702 : u32 = z_1;\n    if ((x_702 < 4u)) {\n    } else {\n      break;\n    }\n    y_1 = 0u;\n    loop {\n      let x_710 : u32 = y_1;\n      if ((x_710 < 4u)) {\n      } else {\n        break;\n      }\n      let x_712 : u32 = y_1;\n      let x_714 : u32 = z_1;\n      let x_718 : array<i32, 64u> = *(block_3);\n      param_22 = x_718;\n      inverse_lift_i1_64__u1_u1_(&(param_22), 1u, ((4u * x_712) + (16u * x_714)));\n      let x_720 : array<i32, 64u> = param_22;\n      *(block_3) = x_720;\n\n      continuing {\n        let x_721 : u32 = y_1;\n        y_1 = (x_721 + bitcast<u32>(1i));\n      }\n    }\n\n    continuing {\n      let x_723 : u32 = z_1;\n      z_1 = (x_723 + bitcast<u32>(1i));\n    }\n  }\n  return;\n}\n\nfn decompress_block_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_f1_64__(reader_4 : ptr<function, BlockReader>, decompressed_block : ptr<function, array<f32, 64u>>) {\n  var s_cont : u32;\n  var param_23 : BlockReader;\n  var emax : i32;\n  var param_24 : BlockReader;\n  var block_max_bits_1 : u32;\n  var uint_block : array<u32, 64u>;\n  var param_25 : BlockReader;\n  var param_26 : array<u32, 64u>;\n  var i_4 : u32;\n  var int_block : array<i32, 64u>;\n  var indexable : array<u32, 64u>;\n  var param_27 : u32;\n  var param_28 : array<i32, 64u>;\n  var inv_w : f32;\n  var i_5 : u32;\n  let x_727 : BlockReader = *(reader_4);\n  param_23 = x_727;\n  let x_728 : u32 = read_bit_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(&(param_23));\n  let x_729 : BlockReader = param_23;\n  *(reader_4) = x_729;\n  s_cont = x_728;\n  let x_730 : u32 = s_cont;\n  if ((x_730 != 0u)) {\n    let x_737 : BlockReader = *(reader_4);\n    param_24 = x_737;\n    let x_738 : EmulateUint64 = read_bits_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_u1_(&(param_24), 8u);\n    let x_739 : BlockReader = param_24;\n    *(reader_4) = x_739;\n    emax = bitcast<i32>((x_738.lo - 127u));\n    let x_746 : u32 = x_240.max_bits;\n    block_max_bits_1 = (x_746 - 9u);\n    let x_749 : u32 = block_max_bits_1;\n    let x_752 : BlockReader = *(reader_4);\n    param_25 = x_752;\n    let x_754 : array<u32, 64u> = uint_block;\n    param_26 = x_754;\n    decode_ints_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_u1_u1_64__(&(param_25), x_749, &(param_26));\n    let x_756 : BlockReader = param_25;\n    *(reader_4) = x_756;\n    let x_757 : array<u32, 64u> = param_26;\n    uint_block = x_757;\n    i_4 = 0u;\n    loop {\n      let x_764 : u32 = i_4;\n      if ((x_764 < 64u)) {\n      } else {\n        break;\n      }\n      let x_822 : u32 = i_4;\n      indexable = array<u32, 64u>(0u, 1u, 4u, 16u, 20u, 17u, 5u, 2u, 8u, 32u, 21u, 6u, 18u, 24u, 9u, 33u, 36u, 3u, 12u, 48u, 22u, 25u, 37u, 40u, 34u, 10u, 7u, 19u, 28u, 13u, 49u, 52u, 41u, 38u, 26u, 23u, 29u, 53u, 11u, 35u, 44u, 14u, 50u, 56u, 42u, 27u, 39u, 45u, 30u, 54u, 57u, 60u, 51u, 15u, 43u, 46u, 58u, 61u, 55u, 31u, 62u, 59u, 47u, 63u);\n      let x_825 : u32 = indexable[x_822];\n      let x_826 : u32 = i_4;\n      let x_829 : u32 = uint_block[x_826];\n      param_27 = x_829;\n      let x_830 : i32 = uint2int_u1_(&(param_27));\n      int_block[x_825] = x_830;\n\n      continuing {\n        let x_832 : u32 = i_4;\n        i_4 = (x_832 + bitcast<u32>(1i));\n      }\n    }\n    let x_835 : array<i32, 64u> = int_block;\n    param_28 = x_835;\n    inverse_transform_i1_64__(&(param_28));\n    let x_837 : array<i32, 64u> = param_28;\n    int_block = x_837;\n    let x_841 : i32 = emax;\n    inv_w = ldexp(1.0f, (x_841 - 30i));\n    i_5 = 0u;\n    loop {\n      let x_851 : u32 = i_5;\n      if ((x_851 < 64u)) {\n      } else {\n        break;\n      }\n      let x_853 : u32 = i_5;\n      let x_854 : f32 = inv_w;\n      let x_855 : u32 = i_5;\n      let x_857 : i32 = int_block[x_855];\n      (*(decompressed_block))[x_853] = (x_854 * f32(x_857));\n\n      continuing {\n        let x_861 : u32 = i_5;\n        i_5 = (x_861 + bitcast<u32>(1i));\n      }\n    }\n  }\n  return;\n}\n\nfn main_1() {\n  var block_index_1 : u32;\n  var total_blocks : u32;\n  var reader_6 : BlockReader;\n  var param_29 : u32;\n  var decompressed_block_1 : array<f32, 64u>;\n  var param_30 : BlockReader;\n  var param_31 : array<f32, 64u>;\n  var stride : vec3<u32>;\n  var nblocks : vec3<u32>;\n  var block_4 : vec3<u32>;\n  var block_range : vec2<f32>;\n  var partial : vec3<bool>;\n  var partial_size : vec3<u32>;\n  var x_973 : u32;\n  var x_985 : u32;\n  var x_997 : u32;\n  var z_2 : u32;\n  var y_2 : u32;\n  var x_4 : u32;\n  let x_869 : u32 = gl_GlobalInvocationID.x;\n  let x_874 : u32 = x_872.block_id_offset;\n  block_index_1 = (x_869 + (x_874 * 32u));\n  let x_879 : u32 = x_240.padded_dims.x;\n  let x_881 : u32 = x_240.padded_dims.y;\n  let x_885 : u32 = x_240.padded_dims.z;\n  total_blocks = (((x_879 * x_881) / 64u) * x_885);\n  let x_887 : u32 = block_index_1;\n  let x_888 : u32 = total_blocks;\n  if ((x_887 >= x_888)) {\n    return;\n  }\n  let x_895 : u32 = block_index_1;\n  param_29 = x_895;\n  let x_896 : BlockReader = create_block_reader_u1_(&(param_29));\n  reader_6 = x_896;\n  let x_899 : BlockReader = reader_6;\n  param_30 = x_899;\n  let x_901 : array<f32, 64u> = decompressed_block_1;\n  param_31 = x_901;\n  decompress_block_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_f1_64__(&(param_30), &(param_31));\n  let x_903 : array<f32, 64u> = param_31;\n  decompressed_block_1 = x_903;\n  let x_907 : u32 = x_240.volume_dims.x;\n  let x_909 : u32 = x_240.volume_dims.x;\n  let x_911 : u32 = x_240.volume_dims.y;\n  stride = vec3<u32>(1u, x_907, (x_909 * x_911));\n  let x_916 : u32 = x_240.padded_dims.x;\n  nblocks.x = (x_916 >> bitcast<u32>(2i));\n  let x_920 : u32 = x_240.padded_dims.y;\n  nblocks.y = (x_920 >> bitcast<u32>(2i));\n  let x_924 : u32 = x_240.padded_dims.z;\n  nblocks.z = (x_924 >> bitcast<u32>(2i));\n  let x_928 : u32 = block_index_1;\n  let x_930 : u32 = nblocks.x;\n  block_4.x = ((x_928 % x_930) * 4u);\n  let x_934 : u32 = block_index_1;\n  let x_936 : u32 = nblocks.x;\n  let x_939 : u32 = nblocks.y;\n  block_4.y = (((x_934 / x_936) % x_939) * 4u);\n  let x_943 : u32 = block_index_1;\n  let x_945 : u32 = nblocks.x;\n  let x_947 : u32 = nblocks.y;\n  block_4.z = ((x_943 / (x_945 * x_947)) * 4u);\n  block_range = vec2<f32>(100000002004087734272.0f, -100000002004087734272.0f);\n  let x_961 : vec3<u32> = block_4;\n  let x_966 : vec4<u32> = x_240.volume_dims;\n  partial = ((x_961 + vec3<u32>(4u, 4u, 4u)) > vec3<u32>(x_966.x, x_966.y, x_966.z));\n  let x_972 : bool = partial.x;\n  if (x_972) {\n    let x_977 : u32 = x_240.volume_dims.x;\n    let x_979 : u32 = block_4.x;\n    x_973 = (x_977 - x_979);\n  } else {\n    x_973 = 4u;\n  }\n  let x_982 : u32 = x_973;\n  let x_984 : bool = partial.y;\n  if (x_984) {\n    let x_989 : u32 = x_240.volume_dims.y;\n    let x_991 : u32 = block_4.y;\n    x_985 = (x_989 - x_991);\n  } else {\n    x_985 = 4u;\n  }\n  let x_994 : u32 = x_985;\n  let x_996 : bool = partial.z;\n  if (x_996) {\n    let x_1001 : u32 = x_240.volume_dims.z;\n    let x_1003 : u32 = block_4.z;\n    x_997 = (x_1001 - x_1003);\n  } else {\n    x_997 = 4u;\n  }\n  let x_1006 : u32 = x_997;\n  partial_size = vec3<u32>(x_982, x_994, x_1006);\n  z_2 = 0u;\n  loop {\n    let x_1014 : u32 = z_2;\n    let x_1016 : u32 = partial_size.z;\n    if ((x_1014 < x_1016)) {\n    } else {\n      break;\n    }\n    y_2 = 0u;\n    loop {\n      let x_1024 : u32 = y_2;\n      let x_1026 : u32 = partial_size.y;\n      if ((x_1024 < x_1026)) {\n      } else {\n        break;\n      }\n      x_4 = 0u;\n      loop {\n        let x_1034 : u32 = x_4;\n        let x_1036 : u32 = partial_size.x;\n        if ((x_1034 < x_1036)) {\n        } else {\n          break;\n        }\n        let x_1039 : f32 = block_range.x;\n        let x_1040 : u32 = z_2;\n        let x_1042 : u32 = y_2;\n        let x_1045 : u32 = x_4;\n        let x_1048 : f32 = decompressed_block_1[(((16u * x_1040) + (4u * x_1042)) + x_1045)];\n        block_range.x = min(x_1039, x_1048);\n        let x_1052 : f32 = block_range.y;\n        let x_1053 : u32 = z_2;\n        let x_1055 : u32 = y_2;\n        let x_1058 : u32 = x_4;\n        let x_1061 : f32 = decompressed_block_1[(((16u * x_1053) + (4u * x_1055)) + x_1058)];\n        block_range.y = max(x_1052, x_1061);\n\n        continuing {\n          let x_1064 : u32 = x_4;\n          x_4 = (x_1064 + bitcast<u32>(1i));\n        }\n      }\n\n      continuing {\n        let x_1066 : u32 = y_2;\n        y_2 = (x_1066 + bitcast<u32>(1i));\n      }\n    }\n\n    continuing {\n      let x_1068 : u32 = z_2;\n      z_2 = (x_1068 + bitcast<u32>(1i));\n    }\n  }\n  let x_1074 : u32 = block_index_1;\n  let x_1075 : vec2<f32> = block_range;\n  x_1073.block_ranges[x_1074] = x_1075;\n  return;\n}\n\n@compute @workgroup_size(32i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst zfp_decompress_block_comp_spv = `struct EmulateUint64 {\n  lo : u32,\n  hi : u32,\n}\n\nstruct BlockReader {\n  current_bit : u32,\n  current_word : u32,\n  word_buffer : EmulateUint64,\n}\n\nstruct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nstruct EmulateUint64_1 {\n  lo : u32,\n  hi : u32,\n}\n\nalias RTArr = array<EmulateUint64_1>;\n\nstruct Compressed {\n  compressed : RTArr,\n}\n\nstruct DecompressBlockOffset {\n  start_block_offset : u32,\n  total_n_blocks : u32,\n}\n\nalias RTArr_1 = array<u32>;\n\nalias RTArr_2 = array<u32>;\n\nstruct BlockIDs {\n  block_ids : RTArr_2,\n}\n\nstruct CachedItemSlots {\n  cached_item_slots : RTArr_2,\n}\n\nalias RTArr_3 = array<f32>;\n\nstruct Decompressed {\n  decompressed : RTArr_3,\n}\n\n@group(0) @binding(1) var<uniform> x_240 : VolumeParams;\n\n@group(0) @binding(0) var<storage, read_write> x_270 : Compressed;\n\n@group(1) @binding(0) var<uniform> x_865 : DecompressBlockOffset;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(3) var<storage, read_write> x_885 : BlockIDs;\n\n@group(0) @binding(4) var<storage, read_write> x_897 : CachedItemSlots;\n\n@group(0) @binding(2) var<storage, read_write> x_923 : Decompressed;\n\nfn shift_right_struct_EmulateUint64_u1_u11_u1_(a_3 : EmulateUint64, n_1 : ptr<function, u32>) -> EmulateUint64 {\n  var carry_1 : u32;\n  var b_3 : EmulateUint64;\n  let x_167 : u32 = *(n_1);\n  if ((x_167 == 0u)) {\n    return a_3;\n  }\n  let x_172 : u32 = *(n_1);\n  if ((x_172 < 32u)) {\n    let x_178 : u32 = *(n_1);\n    carry_1 = (a_3.hi & (4294967295u >> (32u - x_178)));\n    let x_184 : u32 = *(n_1);\n    let x_186 : u32 = carry_1;\n    let x_187 : u32 = *(n_1);\n    b_3.lo = ((a_3.lo >> x_184) | (x_186 << (32u - x_187)));\n    let x_193 : u32 = *(n_1);\n    b_3.hi = (a_3.hi >> x_193);\n  } else {\n    let x_198 : u32 = *(n_1);\n    b_3.lo = (a_3.hi >> (x_198 - 32u));\n    b_3.hi = 0u;\n  }\n  let x_203 : EmulateUint64 = b_3;\n  return x_203;\n}\n\nfn create_block_reader_u1_(block_index : ptr<function, u32>) -> BlockReader {\n  var reader_5 : BlockReader;\n  var param_2 : u32;\n  let x_244 : u32 = x_240.max_bits;\n  if ((x_244 != 64u)) {\n    let x_249 : u32 = *(block_index);\n    let x_251 : u32 = x_240.max_bits;\n    reader_5.current_word = ((x_249 * x_251) / 64u);\n    let x_255 : u32 = *(block_index);\n    let x_257 : u32 = x_240.max_bits;\n    reader_5.current_bit = ((x_255 * x_257) % 64u);\n  } else {\n    let x_262 : u32 = *(block_index);\n    reader_5.current_word = x_262;\n    reader_5.current_bit = 0u;\n  }\n  let x_272 : u32 = reader_5.current_word;\n  let x_275 : EmulateUint64_1 = x_270.compressed[x_272];\n  reader_5.word_buffer.lo = x_275.lo;\n  reader_5.word_buffer.hi = x_275.hi;\n  let x_282 : EmulateUint64 = reader_5.word_buffer;\n  let x_285 : u32 = reader_5.current_bit;\n  param_2 = x_285;\n  let x_286 : EmulateUint64 = shift_right_struct_EmulateUint64_u1_u11_u1_(x_282, &(param_2));\n  reader_5.word_buffer = x_286;\n  let x_288 : BlockReader = reader_5;\n  return x_288;\n}\n\nfn advance_word_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(reader : ptr<function, BlockReader>) {\n  (*(reader)).current_bit = 0u;\n  let x_293 : u32 = (*(reader)).current_word;\n  (*(reader)).current_word = (x_293 + bitcast<u32>(1i));\n  let x_296 : u32 = (*(reader)).current_word;\n  let x_298 : EmulateUint64_1 = x_270.compressed[x_296];\n  (*(reader)).word_buffer.lo = x_298.lo;\n  (*(reader)).word_buffer.hi = x_298.hi;\n  return;\n}\n\nfn read_bit_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(reader_1 : ptr<function, BlockReader>) -> u32 {\n  var bit : u32;\n  var param_3 : u32;\n  var param_4 : BlockReader;\n  let x_306 : u32 = (*(reader_1)).word_buffer.lo;\n  bit = (x_306 & 1u);\n  let x_310 : u32 = (*(reader_1)).current_bit;\n  (*(reader_1)).current_bit = (x_310 + bitcast<u32>(1i));\n  let x_313 : EmulateUint64 = (*(reader_1)).word_buffer;\n  param_3 = 1u;\n  let x_315 : EmulateUint64 = shift_right_struct_EmulateUint64_u1_u11_u1_(x_313, &(param_3));\n  (*(reader_1)).word_buffer = x_315;\n  let x_318 : u32 = (*(reader_1)).current_bit;\n  if ((x_318 >= 64u)) {\n    let x_323 : BlockReader = *(reader_1);\n    param_4 = x_323;\n    advance_word_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(&(param_4));\n    let x_325 : BlockReader = param_4;\n    *(reader_1) = x_325;\n  }\n  let x_326 : u32 = bit;\n  return x_326;\n}\n\nfn make_emulate_uint64_u1_u1_(hi : ptr<function, u32>, lo : ptr<function, u32>) -> EmulateUint64 {\n  var a_4 : EmulateUint64;\n  let x_92 : u32 = *(lo);\n  a_4.lo = x_92;\n  let x_95 : u32 = *(hi);\n  a_4.hi = x_95;\n  let x_97 : EmulateUint64 = a_4;\n  return x_97;\n}\n\nfn make_mask_u1_(n_2 : ptr<function, u32>) -> EmulateUint64 {\n  var a_5 : EmulateUint64;\n  var param : u32;\n  var param_1 : u32;\n  param = 0u;\n  param_1 = 0u;\n  let x_209 : EmulateUint64 = make_emulate_uint64_u1_u1_(&(param), &(param_1));\n  a_5 = x_209;\n  let x_210 : u32 = *(n_2);\n  let x_212 : u32 = *(n_2);\n  if (((x_210 > 0u) & (x_212 < 65u))) {\n    let x_218 : u32 = *(n_2);\n    if ((x_218 > 32u)) {\n      a_5.lo = 4294967295u;\n      let x_223 : u32 = *(n_2);\n      a_5.hi = (4294967295u >> (64u - x_223));\n    } else {\n      let x_228 : u32 = *(n_2);\n      a_5.lo = (4294967295u >> (32u - x_228));\n      a_5.hi = 0u;\n    }\n  }\n  let x_233 : EmulateUint64 = a_5;\n  return x_233;\n}\n\nfn bitwise_and_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(a : EmulateUint64, b : EmulateUint64) -> EmulateUint64 {\n  var c : EmulateUint64;\n  c.lo = (a.lo & b.lo);\n  c.hi = (a.hi & b.hi);\n  let x_109 : EmulateUint64 = c;\n  return x_109;\n}\n\nfn shift_left_struct_EmulateUint64_u1_u11_u1_(a_2 : EmulateUint64, n : ptr<function, u32>) -> EmulateUint64 {\n  var carry : u32;\n  var b_2 : EmulateUint64;\n  let x_124 : u32 = *(n);\n  if ((x_124 == 0u)) {\n    return a_2;\n  }\n  let x_131 : u32 = *(n);\n  if ((x_131 < 32u)) {\n    let x_139 : u32 = *(n);\n    carry = (a_2.lo & (4294967295u << (32u - x_139)));\n    let x_145 : u32 = *(n);\n    b_2.lo = (a_2.lo << x_145);\n    let x_149 : u32 = *(n);\n    let x_151 : u32 = carry;\n    let x_152 : u32 = *(n);\n    b_2.hi = ((a_2.hi << x_149) | (x_151 >> (32u - x_152)));\n  } else {\n    b_2.lo = 0u;\n    let x_160 : u32 = *(n);\n    b_2.hi = (a_2.lo << (x_160 - 32u));\n  }\n  let x_164 : EmulateUint64 = b_2;\n  return x_164;\n}\n\nfn bitwise_or_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(a_1 : EmulateUint64, b_1 : EmulateUint64) -> EmulateUint64 {\n  var c_1 : EmulateUint64;\n  c_1.lo = (a_1.lo | b_1.lo);\n  c_1.hi = (a_1.hi | b_1.hi);\n  let x_121 : EmulateUint64 = c_1;\n  return x_121;\n}\n\nfn read_bits_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_u1_(reader_2 : ptr<function, BlockReader>, n_bits : u32) -> EmulateUint64 {\n  var rem_bits : u32;\n  var first_read : u32;\n  var mask : EmulateUint64;\n  var param_5 : u32;\n  var bits : EmulateUint64;\n  var param_6 : u32;\n  var next_read : u32;\n  var param_7 : BlockReader;\n  var param_8 : u32;\n  var param_9 : u32;\n  var param_10 : u32;\n  let x_331 : u32 = (*(reader_2)).current_bit;\n  rem_bits = (64u - x_331);\n  let x_334 : u32 = rem_bits;\n  first_read = min(x_334, n_bits);\n  let x_338 : u32 = first_read;\n  param_5 = x_338;\n  let x_339 : EmulateUint64 = make_mask_u1_(&(param_5));\n  mask = x_339;\n  let x_342 : EmulateUint64 = (*(reader_2)).word_buffer;\n  let x_343 : EmulateUint64 = mask;\n  let x_344 : EmulateUint64 = bitwise_and_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(x_342, x_343);\n  bits = x_344;\n  let x_346 : EmulateUint64 = (*(reader_2)).word_buffer;\n  param_6 = n_bits;\n  let x_348 : EmulateUint64 = shift_right_struct_EmulateUint64_u1_u11_u1_(x_346, &(param_6));\n  (*(reader_2)).word_buffer = x_348;\n  let x_350 : u32 = first_read;\n  let x_352 : u32 = (*(reader_2)).current_bit;\n  (*(reader_2)).current_bit = (x_352 + x_350);\n  next_read = 0u;\n  let x_356 : u32 = rem_bits;\n  if ((n_bits >= x_356)) {\n    let x_361 : BlockReader = *(reader_2);\n    param_7 = x_361;\n    advance_word_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(&(param_7));\n    let x_363 : BlockReader = param_7;\n    *(reader_2) = x_363;\n    let x_364 : u32 = first_read;\n    next_read = (n_bits - x_364);\n  }\n  let x_367 : u32 = next_read;\n  param_8 = x_367;\n  let x_368 : EmulateUint64 = make_mask_u1_(&(param_8));\n  mask = x_368;\n  let x_369 : EmulateUint64 = bits;\n  let x_371 : EmulateUint64 = (*(reader_2)).word_buffer;\n  let x_372 : EmulateUint64 = mask;\n  let x_373 : EmulateUint64 = bitwise_and_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(x_371, x_372);\n  let x_375 : u32 = first_read;\n  param_9 = x_375;\n  let x_376 : EmulateUint64 = shift_left_struct_EmulateUint64_u1_u11_u1_(x_373, &(param_9));\n  let x_377 : EmulateUint64 = bitwise_or_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(x_369, x_376);\n  bits = x_377;\n  let x_379 : EmulateUint64 = (*(reader_2)).word_buffer;\n  let x_381 : u32 = next_read;\n  param_10 = x_381;\n  let x_382 : EmulateUint64 = shift_right_struct_EmulateUint64_u1_u11_u1_(x_379, &(param_10));\n  (*(reader_2)).word_buffer = x_382;\n  let x_384 : u32 = next_read;\n  let x_386 : u32 = (*(reader_2)).current_bit;\n  (*(reader_2)).current_bit = (x_386 + x_384);\n  let x_389 : EmulateUint64 = bits;\n  return x_389;\n}\n\nfn decode_ints_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_u1_u1_64__(reader_3 : ptr<function, BlockReader>, block_max_bits : u32, block_1 : ptr<function, array<u32, 64u>>) {\n  var i : u32;\n  var x_1 : EmulateUint64;\n  var param_11 : u32;\n  var param_12 : u32;\n  var one : EmulateUint64;\n  var param_13 : u32;\n  var param_14 : u32;\n  var bits_1 : u32;\n  var k : u32;\n  var n_3 : u32;\n  var m : u32;\n  var param_15 : BlockReader;\n  var param_16 : BlockReader;\n  var param_17 : BlockReader;\n  var param_18 : u32;\n  var i_1 : u32;\n  var param_19 : u32;\n  i = 0u;\n  loop {\n    let x_405 : u32 = i;\n    if ((x_405 < 64u)) {\n    } else {\n      break;\n    }\n    let x_407 : u32 = i;\n    (*(block_1))[x_407] = 0u;\n\n    continuing {\n      let x_409 : u32 = i;\n      i = (x_409 + bitcast<u32>(1i));\n    }\n  }\n  param_11 = 0u;\n  param_12 = 0u;\n  let x_414 : EmulateUint64 = make_emulate_uint64_u1_u1_(&(param_11), &(param_12));\n  x_1 = x_414;\n  param_13 = 0u;\n  param_14 = 1u;\n  let x_418 : EmulateUint64 = make_emulate_uint64_u1_u1_(&(param_13), &(param_14));\n  one = x_418;\n  bits_1 = block_max_bits;\n  k = 32u;\n  n_3 = 0u;\n  loop {\n    var x_433 : bool;\n    var x_434 : bool;\n    let x_427 : u32 = bits_1;\n    let x_428 : bool = (x_427 != 0u);\n    x_434 = x_428;\n    if (x_428) {\n      let x_431 : u32 = k;\n      k = (x_431 - bitcast<u32>(1i));\n      x_433 = (x_431 > 0u);\n      x_434 = x_433;\n    }\n    if (x_434) {\n    } else {\n      break;\n    }\n    let x_436 : u32 = n_3;\n    let x_437 : u32 = bits_1;\n    m = min(x_436, x_437);\n    let x_439 : u32 = m;\n    let x_440 : u32 = bits_1;\n    bits_1 = (x_440 - x_439);\n    let x_442 : u32 = m;\n    let x_444 : BlockReader = *(reader_3);\n    param_15 = x_444;\n    let x_445 : EmulateUint64 = read_bits_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_u1_(&(param_15), x_442);\n    let x_446 : BlockReader = param_15;\n    *(reader_3) = x_446;\n    x_1 = x_445;\n    loop {\n      var x_465 : bool;\n      var x_466 : bool;\n      let x_452 : u32 = n_3;\n      let x_454 : u32 = bits_1;\n      let x_456 : bool = ((x_452 < 64u) & (x_454 != 0u));\n      x_466 = x_456;\n      if (x_456) {\n        let x_459 : u32 = bits_1;\n        bits_1 = (x_459 - bitcast<u32>(1i));\n        let x_462 : BlockReader = *(reader_3);\n        param_16 = x_462;\n        let x_463 : u32 = read_bit_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(&(param_16));\n        let x_464 : BlockReader = param_16;\n        *(reader_3) = x_464;\n        x_465 = (x_463 != 0u);\n        x_466 = x_465;\n      }\n      if (x_466) {\n      } else {\n        break;\n      }\n      loop {\n        var x_486 : bool;\n        var x_487 : bool;\n        let x_472 : u32 = n_3;\n        let x_475 : u32 = bits_1;\n        let x_477 : bool = ((x_472 < 63u) & (x_475 != 0u));\n        x_487 = x_477;\n        if (x_477) {\n          let x_480 : u32 = bits_1;\n          bits_1 = (x_480 - bitcast<u32>(1i));\n          let x_483 : BlockReader = *(reader_3);\n          param_17 = x_483;\n          let x_484 : u32 = read_bit_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(&(param_17));\n          let x_485 : BlockReader = param_17;\n          *(reader_3) = x_485;\n          x_486 = (x_484 == 0u);\n          x_487 = x_486;\n        }\n        if (x_487) {\n        } else {\n          break;\n        }\n\n        continuing {\n          let x_488 : u32 = n_3;\n          n_3 = (x_488 + bitcast<u32>(1i));\n        }\n      }\n\n      continuing {\n        let x_490 : EmulateUint64 = x_1;\n        let x_491 : EmulateUint64 = one;\n        let x_492 : u32 = n_3;\n        n_3 = (x_492 + bitcast<u32>(1i));\n        param_18 = x_492;\n        let x_495 : EmulateUint64 = shift_left_struct_EmulateUint64_u1_u11_u1_(x_491, &(param_18));\n        let x_496 : EmulateUint64 = bitwise_or_struct_EmulateUint64_u1_u11_struct_EmulateUint64_u1_u11_(x_490, x_495);\n        x_1 = x_496;\n      }\n    }\n    i_1 = 0u;\n    loop {\n      let x_503 : u32 = i_1;\n      if ((x_503 < 64u)) {\n      } else {\n        break;\n      }\n      let x_505 : u32 = i_1;\n      let x_507 : u32 = x_1.lo;\n      let x_509 : u32 = k;\n      let x_512 : u32 = (*(block_1))[x_505];\n      (*(block_1))[x_505] = (x_512 + ((x_507 & 1u) << x_509));\n\n      continuing {\n        let x_515 : u32 = i_1;\n        i_1 = (x_515 + bitcast<u32>(1i));\n        let x_517 : EmulateUint64 = x_1;\n        param_19 = 1u;\n        let x_519 : EmulateUint64 = shift_right_struct_EmulateUint64_u1_u11_u1_(x_517, &(param_19));\n        x_1 = x_519;\n      }\n    }\n  }\n  return;\n}\n\nfn uint2int_u1_(x : ptr<function, u32>) -> i32 {\n  let x_392 : u32 = *(x);\n  return bitcast<i32>(((x_392 ^ 2863311530u) - 2863311530u));\n}\n\nfn inverse_lift_i1_64__u1_u1_(block_2 : ptr<function, array<i32, 64u>>, s : u32, idx : u32) {\n  var i_2 : u32;\n  var v : vec4<i32>;\n  var i_3 : u32;\n  i_2 = 0u;\n  loop {\n    let x_526 : u32 = i_2;\n    if ((x_526 < 4u)) {\n    } else {\n      break;\n    }\n    let x_532 : u32 = i_2;\n    let x_533 : u32 = i_2;\n    let x_538 : i32 = (*(block_2))[(idx + (x_533 * s))];\n    v[x_532] = x_538;\n\n    continuing {\n      let x_540 : u32 = i_2;\n      i_2 = (x_540 + bitcast<u32>(1i));\n    }\n  }\n  let x_544 : i32 = v.w;\n  let x_547 : i32 = v.y;\n  v.y = (x_547 + (x_544 >> bitcast<u32>(1i)));\n  let x_551 : i32 = v.y;\n  let x_554 : i32 = v.w;\n  v.w = (x_554 - (x_551 >> bitcast<u32>(1i)));\n  let x_558 : i32 = v.w;\n  let x_560 : i32 = v.y;\n  v.y = (x_560 + x_558);\n  let x_564 : i32 = v.w;\n  v.w = (x_564 << bitcast<u32>(1i));\n  let x_568 : i32 = v.y;\n  let x_570 : i32 = v.w;\n  v.w = (x_570 - x_568);\n  let x_574 : i32 = v.x;\n  let x_577 : i32 = v.z;\n  v.z = (x_577 + x_574);\n  let x_581 : i32 = v.x;\n  v.x = (x_581 << bitcast<u32>(1i));\n  let x_585 : i32 = v.z;\n  let x_587 : i32 = v.x;\n  v.x = (x_587 - x_585);\n  let x_591 : i32 = v.z;\n  let x_593 : i32 = v.y;\n  v.y = (x_593 + x_591);\n  let x_597 : i32 = v.z;\n  v.z = (x_597 << bitcast<u32>(1i));\n  let x_601 : i32 = v.y;\n  let x_603 : i32 = v.z;\n  v.z = (x_603 - x_601);\n  let x_607 : i32 = v.x;\n  let x_609 : i32 = v.w;\n  v.w = (x_609 + x_607);\n  let x_613 : i32 = v.x;\n  v.x = (x_613 << bitcast<u32>(1i));\n  let x_617 : i32 = v.w;\n  let x_619 : i32 = v.x;\n  v.x = (x_619 - x_617);\n  i_3 = 0u;\n  loop {\n    let x_628 : u32 = i_3;\n    if ((x_628 < 4u)) {\n    } else {\n      break;\n    }\n    let x_630 : u32 = i_3;\n    let x_633 : u32 = i_3;\n    let x_635 : i32 = v[x_633];\n    (*(block_2))[(idx + (x_630 * s))] = x_635;\n\n    continuing {\n      let x_637 : u32 = i_3;\n      i_3 = (x_637 + bitcast<u32>(1i));\n    }\n  }\n  return;\n}\n\nfn inverse_transform_i1_64__(block_3 : ptr<function, array<i32, 64u>>) {\n  var y : u32;\n  var x_2 : u32;\n  var param_20 : array<i32, 64u>;\n  var x_3 : u32;\n  var z : u32;\n  var param_21 : array<i32, 64u>;\n  var z_1 : u32;\n  var y_1 : u32;\n  var param_22 : array<i32, 64u>;\n  y = 0u;\n  loop {\n    let x_645 : u32 = y;\n    if ((x_645 < 4u)) {\n    } else {\n      break;\n    }\n    x_2 = 0u;\n    loop {\n      let x_653 : u32 = x_2;\n      if ((x_653 < 4u)) {\n      } else {\n        break;\n      }\n      let x_656 : u32 = x_2;\n      let x_657 : u32 = y;\n      let x_661 : array<i32, 64u> = *(block_3);\n      param_20 = x_661;\n      inverse_lift_i1_64__u1_u1_(&(param_20), 16u, (x_656 + (4u * x_657)));\n      let x_663 : array<i32, 64u> = param_20;\n      *(block_3) = x_663;\n\n      continuing {\n        let x_664 : u32 = x_2;\n        x_2 = (x_664 + bitcast<u32>(1i));\n      }\n    }\n\n    continuing {\n      let x_666 : u32 = y;\n      y = (x_666 + bitcast<u32>(1i));\n    }\n  }\n  x_3 = 0u;\n  loop {\n    let x_674 : u32 = x_3;\n    if ((x_674 < 4u)) {\n    } else {\n      break;\n    }\n    z = 0u;\n    loop {\n      let x_682 : u32 = z;\n      if ((x_682 < 4u)) {\n      } else {\n        break;\n      }\n      let x_684 : u32 = z;\n      let x_686 : u32 = x_3;\n      let x_689 : array<i32, 64u> = *(block_3);\n      param_21 = x_689;\n      inverse_lift_i1_64__u1_u1_(&(param_21), 4u, ((16u * x_684) + x_686));\n      let x_691 : array<i32, 64u> = param_21;\n      *(block_3) = x_691;\n\n      continuing {\n        let x_692 : u32 = z;\n        z = (x_692 + bitcast<u32>(1i));\n      }\n    }\n\n    continuing {\n      let x_694 : u32 = x_3;\n      x_3 = (x_694 + bitcast<u32>(1i));\n    }\n  }\n  z_1 = 0u;\n  loop {\n    let x_702 : u32 = z_1;\n    if ((x_702 < 4u)) {\n    } else {\n      break;\n    }\n    y_1 = 0u;\n    loop {\n      let x_710 : u32 = y_1;\n      if ((x_710 < 4u)) {\n      } else {\n        break;\n      }\n      let x_712 : u32 = y_1;\n      let x_714 : u32 = z_1;\n      let x_718 : array<i32, 64u> = *(block_3);\n      param_22 = x_718;\n      inverse_lift_i1_64__u1_u1_(&(param_22), 1u, ((4u * x_712) + (16u * x_714)));\n      let x_720 : array<i32, 64u> = param_22;\n      *(block_3) = x_720;\n\n      continuing {\n        let x_721 : u32 = y_1;\n        y_1 = (x_721 + bitcast<u32>(1i));\n      }\n    }\n\n    continuing {\n      let x_723 : u32 = z_1;\n      z_1 = (x_723 + bitcast<u32>(1i));\n    }\n  }\n  return;\n}\n\nfn decompress_block_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_f1_64__(reader_4 : ptr<function, BlockReader>, decompressed_block : ptr<function, array<f32, 64u>>) {\n  var s_cont : u32;\n  var param_23 : BlockReader;\n  var emax : i32;\n  var param_24 : BlockReader;\n  var block_max_bits_1 : u32;\n  var uint_block : array<u32, 64u>;\n  var param_25 : BlockReader;\n  var param_26 : array<u32, 64u>;\n  var i_4 : u32;\n  var int_block : array<i32, 64u>;\n  var indexable : array<u32, 64u>;\n  var param_27 : u32;\n  var param_28 : array<i32, 64u>;\n  var inv_w : f32;\n  var i_5 : u32;\n  let x_727 : BlockReader = *(reader_4);\n  param_23 = x_727;\n  let x_728 : u32 = read_bit_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_(&(param_23));\n  let x_729 : BlockReader = param_23;\n  *(reader_4) = x_729;\n  s_cont = x_728;\n  let x_730 : u32 = s_cont;\n  if ((x_730 != 0u)) {\n    let x_737 : BlockReader = *(reader_4);\n    param_24 = x_737;\n    let x_738 : EmulateUint64 = read_bits_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_u1_(&(param_24), 8u);\n    let x_739 : BlockReader = param_24;\n    *(reader_4) = x_739;\n    emax = bitcast<i32>((x_738.lo - 127u));\n    let x_746 : u32 = x_240.max_bits;\n    block_max_bits_1 = (x_746 - 9u);\n    let x_749 : u32 = block_max_bits_1;\n    let x_752 : BlockReader = *(reader_4);\n    param_25 = x_752;\n    let x_754 : array<u32, 64u> = uint_block;\n    param_26 = x_754;\n    decode_ints_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_u1_u1_64__(&(param_25), x_749, &(param_26));\n    let x_756 : BlockReader = param_25;\n    *(reader_4) = x_756;\n    let x_757 : array<u32, 64u> = param_26;\n    uint_block = x_757;\n    i_4 = 0u;\n    loop {\n      let x_764 : u32 = i_4;\n      if ((x_764 < 64u)) {\n      } else {\n        break;\n      }\n      let x_822 : u32 = i_4;\n      indexable = array<u32, 64u>(0u, 1u, 4u, 16u, 20u, 17u, 5u, 2u, 8u, 32u, 21u, 6u, 18u, 24u, 9u, 33u, 36u, 3u, 12u, 48u, 22u, 25u, 37u, 40u, 34u, 10u, 7u, 19u, 28u, 13u, 49u, 52u, 41u, 38u, 26u, 23u, 29u, 53u, 11u, 35u, 44u, 14u, 50u, 56u, 42u, 27u, 39u, 45u, 30u, 54u, 57u, 60u, 51u, 15u, 43u, 46u, 58u, 61u, 55u, 31u, 62u, 59u, 47u, 63u);\n      let x_825 : u32 = indexable[x_822];\n      let x_826 : u32 = i_4;\n      let x_829 : u32 = uint_block[x_826];\n      param_27 = x_829;\n      let x_830 : i32 = uint2int_u1_(&(param_27));\n      int_block[x_825] = x_830;\n\n      continuing {\n        let x_832 : u32 = i_4;\n        i_4 = (x_832 + bitcast<u32>(1i));\n      }\n    }\n    let x_835 : array<i32, 64u> = int_block;\n    param_28 = x_835;\n    inverse_transform_i1_64__(&(param_28));\n    let x_837 : array<i32, 64u> = param_28;\n    int_block = x_837;\n    let x_841 : i32 = emax;\n    inv_w = ldexp(1.0f, (x_841 - 30i));\n    i_5 = 0u;\n    loop {\n      let x_851 : u32 = i_5;\n      if ((x_851 < 64u)) {\n      } else {\n        break;\n      }\n      let x_853 : u32 = i_5;\n      let x_854 : f32 = inv_w;\n      let x_855 : u32 = i_5;\n      let x_857 : i32 = int_block[x_855];\n      (*(decompressed_block))[x_853] = (x_854 * f32(x_857));\n\n      continuing {\n        let x_861 : u32 = i_5;\n        i_5 = (x_861 + bitcast<u32>(1i));\n      }\n    }\n  }\n  return;\n}\n\nfn main_1() {\n  var block_index_1 : u32;\n  var cache_location : u32;\n  var reader_6 : BlockReader;\n  var param_29 : u32;\n  var decompressed_block_1 : array<f32, 64u>;\n  var param_30 : BlockReader;\n  var param_31 : array<f32, 64u>;\n  var i_6 : u32;\n  let x_867 : u32 = x_865.start_block_offset;\n  let x_873 : u32 = gl_GlobalInvocationID.x;\n  let x_876 : u32 = x_865.total_n_blocks;\n  if (((x_867 + x_873) >= x_876)) {\n    return;\n  }\n  let x_887 : u32 = x_865.start_block_offset;\n  let x_889 : u32 = gl_GlobalInvocationID.x;\n  let x_892 : u32 = x_885.block_ids[(x_887 + x_889)];\n  block_index_1 = x_892;\n  let x_898 : u32 = block_index_1;\n  let x_900 : u32 = x_897.cached_item_slots[x_898];\n  cache_location = x_900;\n  let x_903 : u32 = block_index_1;\n  param_29 = x_903;\n  let x_904 : BlockReader = create_block_reader_u1_(&(param_29));\n  reader_6 = x_904;\n  let x_907 : BlockReader = reader_6;\n  param_30 = x_907;\n  let x_909 : array<f32, 64u> = decompressed_block_1;\n  param_31 = x_909;\n  decompress_block_struct_BlockReader_u1_u1_struct_EmulateUint64_u1_u111_f1_64__(&(param_30), &(param_31));\n  let x_911 : array<f32, 64u> = param_31;\n  decompressed_block_1 = x_911;\n  i_6 = 0u;\n  loop {\n    let x_918 : u32 = i_6;\n    if ((x_918 < 64u)) {\n    } else {\n      break;\n    }\n    let x_924 : u32 = cache_location;\n    let x_926 : u32 = i_6;\n    let x_928 : u32 = i_6;\n    let x_930 : f32 = decompressed_block_1[x_928];\n    x_923.decompressed[((x_924 * 64u) + x_926)] = x_930;\n\n    continuing {\n      let x_933 : u32 = i_6;\n      i_6 = (x_933 + bitcast<u32>(1i));\n    }\n  }\n  return;\n}\n\n@compute @workgroup_size(64i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst lru_cache_init_comp_spv = `struct Slot {\n  age : u32,\n  available : u32,\n  item_id : i32,\n}\n\nalias RTArr = array<Slot>;\n\nstruct SlotData {\n  slot_data : RTArr,\n}\n\nstruct OldSize {\n  old_size : u32,\n}\n\nalias RTArr_1 = array<i32>;\n\nstruct CachedItemSlots {\n  cached_item_slot : RTArr_1,\n}\n\nalias RTArr_2 = array<u32>;\n\nstruct SlotAvailableIDs {\n  slot_available_id : RTArr_2,\n}\n\n@group(0) @binding(2) var<storage, read_write> x_12 : SlotData;\n\n@group(1) @binding(0) var<uniform> x_16 : OldSize;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<storage, read_write> x_50 : CachedItemSlots;\n\n@group(0) @binding(1) var<storage, read_write> x_54 : SlotAvailableIDs;\n\nfn main_1() {\n  let x_19 : u32 = x_16.old_size;\n  let x_26 : u32 = gl_GlobalInvocationID.x;\n  x_12.slot_data[(x_19 + x_26)].age = 100000u;\n  let x_31 : u32 = x_16.old_size;\n  let x_33 : u32 = gl_GlobalInvocationID.x;\n  x_12.slot_data[(x_31 + x_33)].available = 1u;\n  let x_39 : u32 = x_16.old_size;\n  let x_41 : u32 = gl_GlobalInvocationID.x;\n  x_12.slot_data[(x_39 + x_41)].item_id = -1i;\n  return;\n}\n\n@compute @workgroup_size(64i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst lru_cache_mark_new_items_comp_spv = `struct PushConstants {\n  global_idx_offset : u32,\n  num_work_items : u32,\n}\n\nalias RTArr = array<i32>;\n\nstruct CachedItemSlots {\n  cached_item_slot : RTArr,\n}\n\nalias RTArr_1 = array<u32>;\n\nalias RTArr_2 = array<u32>;\n\nstruct ItemNeedsCaching {\n  item_needs_caching : RTArr_2,\n}\n\nalias RTArr_3 = array<u32>;\n\nstruct ItemNeeded {\n  item_needed : RTArr_2,\n}\n\nstruct Slot {\n  age : u32,\n  available : u32,\n  item_id : i32,\n}\n\nalias RTArr_4 = array<Slot>;\n\nstruct SlotData {\n  slot_data : RTArr_4,\n}\n\nstruct SlotAvailableIDs {\n  slot_available_id : RTArr_2,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(2) @binding(0) var<uniform> x_18 : PushConstants;\n\n@group(0) @binding(0) var<storage, read_write> x_32 : CachedItemSlots;\n\n@group(1) @binding(1) var<storage, read_write> x_45 : ItemNeedsCaching;\n\n@group(1) @binding(0) var<storage, read> x_51 : ItemNeeded;\n\n@group(0) @binding(2) var<storage, read_write> x_63 : SlotData;\n\n@group(0) @binding(1) var<storage, read_write> x_81 : SlotAvailableIDs;\n\nfn main_1() {\n  var idx : u32;\n  var slot : i32;\n  let x_15 : u32 = gl_GlobalInvocationID.x;\n  let x_23 : u32 = x_18.global_idx_offset;\n  idx = (x_15 + (x_23 * 32u));\n  let x_33 : u32 = idx;\n  let x_36 : i32 = x_32.cached_item_slot[x_33];\n  slot = x_36;\n  let x_37 : i32 = slot;\n  if ((x_37 >= 0i)) {\n    let x_46 : u32 = idx;\n    x_45.item_needs_caching[x_46] = 0u;\n    let x_52 : u32 = idx;\n    let x_54 : u32 = x_51.item_needed[x_52];\n    if ((x_54 == 1u)) {\n      let x_64 : i32 = slot;\n      x_63.slot_data[x_64].age = 0u;\n      let x_66 : i32 = slot;\n      x_63.slot_data[x_66].available = 0u;\n    } else {\n      let x_70 : i32 = slot;\n      x_63.slot_data[x_70].available = 1u;\n    }\n  } else {\n    let x_73 : u32 = idx;\n    let x_74 : u32 = idx;\n    let x_76 : u32 = x_51.item_needed[x_74];\n    x_45.item_needs_caching[x_73] = x_76;\n  }\n  return;\n}\n\n@compute @workgroup_size(32i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst lru_cache_update_comp_spv = `struct NumNewItemIDs {\n  num_new_items : u32,\n}\n\nalias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct NewItemIDs {\n  new_items : RTArr_1,\n}\n\nstruct SlotAvailableIDs {\n  slot_available_id : RTArr_1,\n}\n\nstruct Slot {\n  age : u32,\n  available : u32,\n  item_id : i32,\n}\n\nalias RTArr_2 = array<Slot>;\n\nstruct SlotData {\n  slot_data : RTArr_2,\n}\n\nalias RTArr_3 = array<i32>;\n\nstruct CachedItemSlots {\n  cached_item_slot : RTArr_3,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(2) @binding(0) var<uniform> x_16 : NumNewItemIDs;\n\n@group(1) @binding(0) var<storage, read_write> x_32 : NewItemIDs;\n\n@group(0) @binding(1) var<storage, read_write> x_41 : SlotAvailableIDs;\n\n@group(0) @binding(2) var<storage, read_write> x_52 : SlotData;\n\n@group(0) @binding(0) var<storage, read_write> x_66 : CachedItemSlots;\n\nfn main_1() {\n  var item : u32;\n  var slot : u32;\n  var prev : i32;\n  let x_13 : u32 = gl_GlobalInvocationID.x;\n  let x_21 : u32 = x_16.num_new_items;\n  if ((x_13 >= x_21)) {\n    return;\n  }\n  let x_34 : u32 = gl_GlobalInvocationID.x;\n  let x_36 : u32 = x_32.new_items[x_34];\n  item = x_36;\n  let x_43 : u32 = gl_GlobalInvocationID.x;\n  let x_45 : u32 = x_41.slot_available_id[x_43];\n  slot = x_45;\n  let x_53 : u32 = slot;\n  let x_57 : i32 = x_52.slot_data[x_53].item_id;\n  prev = x_57;\n  let x_58 : i32 = prev;\n  if ((x_58 != -1i)) {\n    let x_67 : i32 = prev;\n    x_66.cached_item_slot[x_67] = -1i;\n  }\n  let x_69 : u32 = slot;\n  x_52.slot_data[x_69].age = 0u;\n  let x_71 : u32 = slot;\n  let x_72 : u32 = item;\n  x_52.slot_data[x_71].item_id = bitcast<i32>(x_72);\n  let x_75 : u32 = slot;\n  x_52.slot_data[x_75].available = 0u;\n  let x_78 : u32 = item;\n  let x_79 : u32 = slot;\n  x_66.cached_item_slot[x_78] = bitcast<i32>(x_79);\n  return;\n}\n\n@compute @workgroup_size(64i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst lru_copy_available_slot_age_comp_spv = `struct NumNewItemIDs {\n  num_slots_available : u32,\n}\n\nalias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct AvailableSlotAges {\n  available_slot_ages : RTArr_1,\n}\n\nstruct Slot {\n  age : u32,\n  available : u32,\n  item_id : i32,\n}\n\nalias RTArr_2 = array<Slot>;\n\nstruct SlotData {\n  slot_data : RTArr_2,\n}\n\nstruct SlotAvailableIDs {\n  slot_available_id : RTArr_1,\n}\n\nalias RTArr_3 = array<i32>;\n\nstruct CachedItemSlots {\n  cached_item_slot : RTArr_3,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(2) @binding(0) var<uniform> x_16 : NumNewItemIDs;\n\n@group(1) @binding(0) var<storage, read_write> x_30 : AvailableSlotAges;\n\n@group(0) @binding(2) var<storage, read_write> x_37 : SlotData;\n\n@group(0) @binding(1) var<storage, read_write> x_41 : SlotAvailableIDs;\n\n@group(0) @binding(0) var<storage, read_write> x_52 : CachedItemSlots;\n\nfn main_1() {\n  let x_13 : u32 = gl_GlobalInvocationID.x;\n  let x_21 : u32 = x_16.num_slots_available;\n  if ((x_13 >= x_21)) {\n    return;\n  }\n  let x_32 : u32 = gl_GlobalInvocationID.x;\n  let x_43 : u32 = gl_GlobalInvocationID.x;\n  let x_45 : u32 = x_41.slot_available_id[x_43];\n  let x_47 : u32 = x_37.slot_data[x_45].age;\n  x_30.available_slot_ages[x_32] = x_47;\n  return;\n}\n\n@compute @workgroup_size(64i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst lru_cache_age_slots_comp_spv = `struct Slot {\n  age : u32,\n  available : u32,\n  item_id : i32,\n}\n\nalias RTArr = array<Slot>;\n\nstruct SlotData {\n  slot_data : RTArr,\n}\n\nalias RTArr_1 = array<i32>;\n\nstruct CachedItemSlots {\n  cached_item_slot : RTArr_1,\n}\n\nalias RTArr_2 = array<u32>;\n\nstruct SlotAvailableIDs {\n  slot_available_id : RTArr_2,\n}\n\n@group(0) @binding(2) var<storage, read_write> x_12 : SlotData;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<storage, read_write> x_30 : CachedItemSlots;\n\n@group(0) @binding(1) var<storage, read_write> x_34 : SlotAvailableIDs;\n\nfn main_1() {\n  let x_20 : u32 = gl_GlobalInvocationID.x;\n  let x_24 : u32 = x_12.slot_data[x_20].age;\n  x_12.slot_data[x_20].age = (x_24 + 1u);\n  return;\n}\n\n@compute @workgroup_size(64i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst lru_cache_extract_slot_available_comp_spv = `alias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct Output {\n  out_buf : RTArr_1,\n}\n\nstruct Slot {\n  age : u32,\n  available : u32,\n  item_id : i32,\n}\n\nalias RTArr_2 = array<Slot>;\n\nstruct SlotData {\n  slot_data : RTArr_2,\n}\n\nalias RTArr_3 = array<i32>;\n\nstruct CachedItemSlots {\n  cached_item_slot : RTArr_3,\n}\n\nstruct SlotAvailableIDs {\n  slot_available_id : RTArr_1,\n}\n\n@group(1) @binding(0) var<storage, read_write> x_10 : Output;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(2) var<storage, read_write> x_24 : SlotData;\n\n@group(0) @binding(0) var<storage, read_write> x_35 : CachedItemSlots;\n\n@group(0) @binding(1) var<storage, read_write> x_39 : SlotAvailableIDs;\n\nfn main_1() {\n  let x_19 : u32 = gl_GlobalInvocationID.x;\n  let x_26 : u32 = gl_GlobalInvocationID.x;\n  let x_30 : u32 = x_24.slot_data[x_26].available;\n  x_10.out_buf[x_19] = x_30;\n  return;\n}\n\n@compute @workgroup_size(64i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst macro_traverse_comp_spv = `struct GridIterator {\n  grid_dims : vec3<i32>,\n  grid_step : vec3<i32>,\n  t_delta : vec3<f32>,\n  cell : vec3<i32>,\n  t_max : vec3<f32>,\n  t : f32,\n}\n\nstruct GridIteratorState {\n  t_max : vec3<f32>,\n  cell_id : i32,\n}\n\nstruct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nstruct RayInfo {\n  ray_dir : vec3<f32>,\n  t : f32,\n}\n\nalias RTArr = array<RayInfo>;\n\nstruct RayInformation {\n  rays : RTArr,\n}\n\nstruct ViewParams {\n  proj_view : mat4x4<f32>,\n  eye_pos : vec4<f32>,\n  eye_dir : vec4<f32>,\n  near_plane : f32,\n  current_pass_index : u32,\n  speculation_count : u32,\n}\n\nalias RTArr_1 = array<u32>;\n\nalias RTArr_2 = array<u32>;\n\nstruct RayIDs {\n  ray_ids : RTArr_2,\n}\n\nalias RTArr_3 = array<u32>;\n\nstruct RayOffsets {\n  ray_offsets : RTArr_2,\n}\n\nstruct GridIteratorState_1 {\n  t_max : vec3<f32>,\n  cell_id : i32,\n}\n\nalias RTArr_4 = array<GridIteratorState_1>;\n\nstruct GridIterState {\n  iterator_state : RTArr_4,\n}\n\nalias RTArr_5 = array<vec2<f32>>;\n\nalias RTArr_6 = array<vec2<f32>>;\n\nstruct CoarseCellRange {\n  coarse_cell_ranges : RTArr_6,\n}\n\nstruct VoxelInformation {\n  voxel_ranges : RTArr_6,\n}\n\nstruct RayBlockIDs {\n  block_ids : RTArr_2,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<uniform> x_312 : VolumeParams;\n\n@group(0) @binding(2) var<storage, read_write> x_334 : RayInformation;\n\n@group(0) @binding(1) var<uniform> x_347 : ViewParams;\n\n@group(0) @binding(5) var<storage, read_write> x_367 : RayIDs;\n\n@group(0) @binding(6) var<storage, read_write> x_371 : RayOffsets;\n\n@group(0) @binding(4) var<storage, read_write> x_479 : GridIterState;\n\n@group(1) @binding(1) var<storage, read_write> x_533 : CoarseCellRange;\n\n@group(1) @binding(0) var<storage, read_write> x_667 : VoxelInformation;\n\n@group(0) @binding(7) var<storage, read_write> x_695 : RayBlockIDs;\n\n@group(0) @binding(3) var render_target : texture_storage_2d<rgba8unorm, write>;\n\nfn init_grid_iterator_vf3_vf3_f1_vi3_(ray_org : ptr<function, vec3<f32>>, ray_dir : ptr<function, vec3<f32>>, t : ptr<function, f32>, grid_dims_1 : ptr<function, vec3<i32>>) -> GridIterator {\n  var grid_iter : GridIterator;\n  var inv_ray_dir : vec3<f32>;\n  var p_1 : vec3<f32>;\n  var cell : vec3<f32>;\n  var t_max_neg : vec3<f32>;\n  var t_max_pos : vec3<f32>;\n  var is_neg_dir : vec3<bool>;\n  let x_67 : vec3<i32> = *(grid_dims_1);\n  grid_iter.grid_dims = x_67;\n  let x_70 : vec3<f32> = *(ray_dir);\n  grid_iter.grid_step = vec3<i32>(sign(x_70));\n  let x_76 : vec3<f32> = *(ray_dir);\n  inv_ray_dir = (vec3<f32>(1.0f, 1.0f, 1.0f) / x_76);\n  let x_80 : vec3<f32> = inv_ray_dir;\n  grid_iter.t_delta = abs(x_80);\n  let x_84 : vec3<f32> = *(ray_org);\n  let x_85 : f32 = *(t);\n  let x_86 : vec3<f32> = *(ray_dir);\n  p_1 = (x_84 + (x_86 * x_85));\n  let x_89 : vec3<f32> = p_1;\n  let x_92 : vec3<i32> = *(grid_dims_1);\n  p_1 = clamp(x_89, vec3<f32>(0.0f, 0.0f, 0.0f), vec3<f32>((x_92 - vec3<i32>(1i, 1i, 1i))));\n  let x_98 : vec3<f32> = p_1;\n  cell = floor(x_98);\n  let x_101 : vec3<f32> = cell;\n  let x_102 : vec3<f32> = *(ray_org);\n  let x_104 : vec3<f32> = inv_ray_dir;\n  t_max_neg = ((x_101 - x_102) * x_104);\n  let x_107 : vec3<f32> = cell;\n  let x_110 : vec3<f32> = *(ray_org);\n  let x_112 : vec3<f32> = inv_ray_dir;\n  t_max_pos = (((x_107 + vec3<f32>(1.0f, 1.0f, 1.0f)) - x_110) * x_112);\n  let x_116 : vec3<f32> = *(ray_dir);\n  is_neg_dir = (x_116 < vec3<f32>(0.0f, 0.0f, 0.0f));\n  let x_119 : vec3<f32> = t_max_pos;\n  let x_120 : vec3<f32> = t_max_neg;\n  let x_121 : vec3<bool> = is_neg_dir;\n  grid_iter.t_max = select(x_119, x_120, x_121);\n  let x_125 : vec3<f32> = cell;\n  grid_iter.cell = vec3<i32>(x_125);\n  let x_129 : f32 = *(t);\n  grid_iter.t = x_129;\n  let x_131 : GridIterator = grid_iter;\n  return x_131;\n}\n\nfn restore_grid_iterator_vf3_vf3_vi3_struct_GridIteratorState_vf3_i11_(ray_org_1 : ptr<function, vec3<f32>>, ray_dir_1 : ptr<function, vec3<f32>>, grid_dims_2 : ptr<function, vec3<i32>>, state : ptr<function, GridIteratorState>) -> GridIterator {\n  var grid_iter_1 : GridIterator;\n  var inv_ray_dir_1 : vec3<f32>;\n  let x_135 : vec3<i32> = *(grid_dims_2);\n  grid_iter_1.grid_dims = x_135;\n  let x_137 : vec3<f32> = *(ray_dir_1);\n  grid_iter_1.grid_step = vec3<i32>(sign(x_137));\n  let x_142 : vec3<f32> = *(ray_dir_1);\n  inv_ray_dir_1 = (vec3<f32>(1.0f, 1.0f, 1.0f) / x_142);\n  let x_145 : vec3<f32> = inv_ray_dir_1;\n  grid_iter_1.t_delta = abs(x_145);\n  let x_150 : i32 = (*(state)).cell_id;\n  let x_154 : i32 = (*(grid_dims_2)).x;\n  let x_157 : i32 = (*(state)).cell_id;\n  let x_159 : i32 = (*(grid_dims_2)).x;\n  let x_163 : i32 = (*(grid_dims_2)).y;\n  let x_166 : i32 = (*(state)).cell_id;\n  let x_168 : i32 = (*(grid_dims_2)).x;\n  let x_170 : i32 = (*(grid_dims_2)).y;\n  grid_iter_1.cell = vec3<i32>((x_150 % x_154), ((x_157 / x_159) % x_163), (x_166 / (x_168 * x_170)));\n  let x_176 : vec3<f32> = (*(state)).t_max;\n  grid_iter_1.t_max = x_176;\n  let x_179 : f32 = (*(state)).t_max.x;\n  let x_181 : f32 = (*(state)).t_max.y;\n  let x_184 : f32 = (*(state)).t_max.z;\n  grid_iter_1.t = min(x_179, min(x_181, x_184));\n  let x_188 : GridIterator = grid_iter_1;\n  return x_188;\n}\n\nfn outside_grid_vi3_vi3_(p : vec3<i32>, grid_dims : vec3<i32>) -> bool {\n  var x_62 : bool;\n  var x_63 : bool;\n  let x_57 : bool = any((p < vec3<i32>(0i, 0i, 0i)));\n  x_63 = x_57;\n  if (!(x_57)) {\n    x_62 = any((p >= grid_dims));\n    x_63 = x_62;\n  }\n  return x_63;\n}\n\nfn grid_iterator_get_cell_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_vf2_vi3_(iter : ptr<function, GridIterator>, cell_t_range : ptr<function, vec2<f32>>, cell_id : ptr<function, vec3<i32>>) -> bool {\n  let x_192 : vec3<i32> = (*(iter)).cell;\n  let x_194 : vec3<i32> = (*(iter)).grid_dims;\n  let x_195 : bool = outside_grid_vi3_vi3_(x_192, x_194);\n  if (x_195) {\n    return false;\n  }\n  let x_201 : f32 = (*(iter)).t;\n  (*(cell_t_range)).x = x_201;\n  let x_204 : f32 = (*(iter)).t_max.x;\n  let x_206 : f32 = (*(iter)).t_max.y;\n  let x_208 : f32 = (*(iter)).t_max.z;\n  (*(cell_t_range)).y = min(x_204, min(x_206, x_208));\n  let x_213 : vec3<i32> = (*(iter)).cell;\n  *(cell_id) = x_213;\n  let x_215 : f32 = (*(cell_t_range)).y;\n  let x_217 : f32 = (*(cell_t_range)).x;\n  if ((x_215 < x_217)) {\n    return false;\n  }\n  return true;\n}\n\nfn grid_iterator_advance_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_(iter_2 : ptr<function, GridIterator>) {\n  let x_242 : f32 = (*(iter_2)).t_max.x;\n  let x_244 : f32 = (*(iter_2)).t_max.y;\n  let x_246 : f32 = (*(iter_2)).t_max.z;\n  (*(iter_2)).t = min(x_242, min(x_244, x_246));\n  let x_251 : f32 = (*(iter_2)).t;\n  let x_253 : f32 = (*(iter_2)).t_max.x;\n  if ((x_251 == x_253)) {\n    let x_258 : i32 = (*(iter_2)).grid_step.x;\n    let x_260 : i32 = (*(iter_2)).cell.x;\n    (*(iter_2)).cell.x = (x_260 + x_258);\n    let x_264 : f32 = (*(iter_2)).t_delta.x;\n    let x_266 : f32 = (*(iter_2)).t_max.x;\n    (*(iter_2)).t_max.x = (x_266 + x_264);\n  } else {\n    let x_271 : f32 = (*(iter_2)).t;\n    let x_273 : f32 = (*(iter_2)).t_max.y;\n    if ((x_271 == x_273)) {\n      let x_278 : i32 = (*(iter_2)).grid_step.y;\n      let x_280 : i32 = (*(iter_2)).cell.y;\n      (*(iter_2)).cell.y = (x_280 + x_278);\n      let x_284 : f32 = (*(iter_2)).t_delta.y;\n      let x_286 : f32 = (*(iter_2)).t_max.y;\n      (*(iter_2)).t_max.y = (x_286 + x_284);\n    } else {\n      let x_291 : i32 = (*(iter_2)).grid_step.z;\n      let x_293 : i32 = (*(iter_2)).cell.z;\n      (*(iter_2)).cell.z = (x_293 + x_291);\n      let x_297 : f32 = (*(iter_2)).t_delta.z;\n      let x_299 : f32 = (*(iter_2)).t_max.z;\n      (*(iter_2)).t_max.z = (x_299 + x_297);\n    }\n  }\n  return;\n}\n\nfn grid_iterator_get_cell_id_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_(iter_1 : ptr<function, GridIterator>) -> i32 {\n  let x_226 : i32 = (*(iter_1)).cell.x;\n  let x_228 : i32 = (*(iter_1)).grid_dims.x;\n  let x_230 : i32 = (*(iter_1)).cell.y;\n  let x_232 : i32 = (*(iter_1)).grid_dims.y;\n  let x_234 : i32 = (*(iter_1)).cell.z;\n  return (x_226 + (x_228 * (x_230 + (x_232 * x_234))));\n}\n\nfn main_1() {\n  var ray_index : u32;\n  var i : i32;\n  var n_blocks : vec3<u32>;\n  var macrogrid_dims : vec3<i32>;\n  var coarse_grid_dims : vec3<i32>;\n  var volume_translation : vec3<f32>;\n  var transformed_eye : vec3<f32>;\n  var ray_org_2 : vec3<f32>;\n  var macrocell_grid_org : vec3<f32>;\n  var macrocell_grid_ray_dir : vec3<f32>;\n  var coarse_grid_org : vec3<f32>;\n  var coarse_grid_ray_dir : vec3<f32>;\n  var first_coarse_iter : bool;\n  var coarse_grid_iter : GridIterator;\n  var param : vec3<f32>;\n  var param_1 : vec3<f32>;\n  var param_2 : f32;\n  var param_3 : vec3<i32>;\n  var param_4 : vec3<f32>;\n  var param_5 : vec3<f32>;\n  var param_6 : vec3<i32>;\n  var param_7 : GridIteratorState;\n  var speculated : u32;\n  var coarse_cell_t_range : vec2<f32>;\n  var coarse_cell_id : vec3<i32>;\n  var param_8 : GridIterator;\n  var param_9 : vec2<f32>;\n  var param_10 : vec3<i32>;\n  var coarse_cell_index : u32;\n  var coarse_cell_range : vec2<f32>;\n  var param_11 : GridIterator;\n  var coarse_grid_cell_org : vec3<i32>;\n  var macrocell_grid_dims : vec3<i32>;\n  var grid_iter_2 : GridIterator;\n  var param_12 : vec3<f32>;\n  var param_13 : vec3<f32>;\n  var param_14 : f32;\n  var param_15 : vec3<i32>;\n  var param_16 : vec3<f32>;\n  var param_17 : vec3<f32>;\n  var param_18 : vec3<i32>;\n  var param_19 : GridIteratorState;\n  var param_20 : GridIterator;\n  var cell_t_range_1 : vec2<f32>;\n  var cell_id_1 : vec3<i32>;\n  var param_21 : GridIterator;\n  var param_22 : vec2<f32>;\n  var param_23 : vec3<i32>;\n  var block_index : u32;\n  var cell_range : vec2<f32>;\n  var param_24 : GridIterator;\n  var param_25 : GridIterator;\n  var param_26 : GridIterator;\n  var param_27 : GridIterator;\n  let x_307 : u32 = gl_GlobalInvocationID.x;\n  let x_315 : u32 = x_312.image_width;\n  if ((x_307 >= x_315)) {\n    return;\n  }\n  let x_323 : u32 = gl_GlobalInvocationID.x;\n  let x_325 : u32 = gl_GlobalInvocationID.y;\n  let x_327 : u32 = x_312.image_width;\n  ray_index = (x_323 + (x_325 * x_327));\n  let x_335 : u32 = ray_index;\n  let x_338 : f32 = x_334.rays[x_335].t;\n  if ((x_338 == 340282346638528859811704183484516925440.0f)) {\n    return;\n  }\n  let x_349 : u32 = x_347.speculation_count;\n  if ((x_349 > 1u)) {\n    i = 0i;\n    loop {\n      let x_359 : i32 = i;\n      let x_362 : u32 = x_347.speculation_count;\n      if ((bitcast<u32>(x_359) < x_362)) {\n      } else {\n        break;\n      }\n      let x_372 : u32 = ray_index;\n      let x_374 : u32 = x_371.ray_offsets[x_372];\n      let x_376 : u32 = x_347.speculation_count;\n      let x_378 : i32 = i;\n      let x_381 : u32 = ray_index;\n      x_367.ray_ids[((x_374 * x_376) + bitcast<u32>(x_378))] = x_381;\n\n      continuing {\n        let x_383 : i32 = i;\n        i = (x_383 + 1i);\n      }\n    }\n  } else {\n    let x_386 : u32 = ray_index;\n    let x_387 : u32 = ray_index;\n    x_367.ray_ids[x_386] = x_387;\n    let x_389 : u32 = ray_index;\n    let x_390 : u32 = ray_index;\n    x_371.ray_offsets[x_389] = x_390;\n  }\n  let x_396 : vec4<u32> = x_312.padded_dims;\n  n_blocks = (vec3<u32>(x_396.x, x_396.y, x_396.z) / vec3<u32>(4u, 4u, 4u));\n  let x_402 : vec3<u32> = n_blocks;\n  macrogrid_dims = bitcast<vec3<i32>>(x_402);\n  let x_405 : vec3<i32> = macrogrid_dims;\n  coarse_grid_dims = vec3<i32>(ceil((vec3<f32>(x_405) / vec3<f32>(4.0f, 4.0f, 4.0f))));\n  let x_415 : vec4<f32> = x_312.volume_scale;\n  volume_translation = (vec3<f32>(0.0f, 0.0f, 0.0f) - (vec3<f32>(x_415.x, x_415.y, x_415.z) * 0.5f));\n  let x_422 : vec4<f32> = x_347.eye_pos;\n  let x_424 : vec3<f32> = volume_translation;\n  let x_427 : vec4<f32> = x_312.volume_scale;\n  transformed_eye = ((vec3<f32>(x_422.x, x_422.y, x_422.z) - x_424) / vec3<f32>(x_427.x, x_427.y, x_427.z));\n  let x_431 : vec3<f32> = transformed_eye;\n  let x_433 : vec4<u32> = x_312.volume_dims;\n  ray_org_2 = ((x_431 * vec3<f32>(vec3<u32>(x_433.x, x_433.y, x_433.z))) - vec3<f32>(0.5f, 0.5f, 0.5f));\n  let x_440 : vec3<f32> = ray_org_2;\n  macrocell_grid_org = (x_440 * 0.25f);\n  let x_444 : u32 = ray_index;\n  let x_447 : vec3<f32> = x_334.rays[x_444].ray_dir;\n  macrocell_grid_ray_dir = (x_447 * 0.25f);\n  let x_450 : vec3<f32> = macrocell_grid_org;\n  coarse_grid_org = (x_450 * 0.25f);\n  let x_453 : vec3<f32> = macrocell_grid_ray_dir;\n  coarse_grid_ray_dir = (x_453 * 0.25f);\n  first_coarse_iter = true;\n  let x_458 : u32 = x_347.current_pass_index;\n  if ((x_458 == 0u)) {\n    let x_463 : u32 = ray_index;\n    let x_465 : vec3<f32> = coarse_grid_org;\n    param = x_465;\n    let x_467 : vec3<f32> = coarse_grid_ray_dir;\n    param_1 = x_467;\n    let x_470 : f32 = x_334.rays[x_463].t;\n    param_2 = x_470;\n    let x_472 : vec3<i32> = coarse_grid_dims;\n    param_3 = x_472;\n    let x_473 : GridIterator = init_grid_iterator_vf3_vf3_f1_vi3_(&(param), &(param_1), &(param_2), &(param_3));\n    coarse_grid_iter = x_473;\n  } else {\n    let x_480 : u32 = ray_index;\n    let x_483 : vec3<f32> = coarse_grid_org;\n    param_4 = x_483;\n    let x_485 : vec3<f32> = coarse_grid_ray_dir;\n    param_5 = x_485;\n    let x_487 : vec3<i32> = coarse_grid_dims;\n    param_6 = x_487;\n    let x_491 : GridIteratorState_1 = x_479.iterator_state[(x_480 * 2u)];\n    param_7.t_max = x_491.t_max;\n    param_7.cell_id = x_491.cell_id;\n    let x_496 : GridIterator = restore_grid_iterator_vf3_vf3_vi3_struct_GridIteratorState_vf3_i11_(&(param_4), &(param_5), &(param_6), &(param_7));\n    coarse_grid_iter = x_496;\n  }\n  speculated = 0u;\n  loop {\n    var x_550 : bool;\n    var x_551 : bool;\n    let x_506 : GridIterator = coarse_grid_iter;\n    param_8 = x_506;\n    let x_509 : bool = grid_iterator_get_cell_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_vf2_vi3_(&(param_8), &(param_9), &(param_10));\n    let x_510 : GridIterator = param_8;\n    coarse_grid_iter = x_510;\n    let x_511 : vec2<f32> = param_9;\n    coarse_cell_t_range = x_511;\n    let x_512 : vec3<i32> = param_10;\n    coarse_cell_id = x_512;\n    if (x_509) {\n    } else {\n      break;\n    }\n    let x_515 : i32 = coarse_cell_id.x;\n    let x_517 : i32 = coarse_grid_dims.x;\n    let x_519 : i32 = coarse_cell_id.y;\n    let x_521 : i32 = coarse_grid_dims.y;\n    let x_523 : i32 = coarse_cell_id.z;\n    coarse_cell_index = bitcast<u32>((x_515 + (x_517 * (x_519 + (x_521 * x_523)))));\n    let x_534 : u32 = coarse_cell_index;\n    let x_537 : vec2<f32> = x_533.coarse_cell_ranges[x_534];\n    coarse_cell_range = x_537;\n    let x_539 : f32 = x_312.isovalue;\n    let x_541 : f32 = coarse_cell_range.x;\n    let x_542 : bool = (x_539 < x_541);\n    x_551 = x_542;\n    if (!(x_542)) {\n      let x_547 : f32 = x_312.isovalue;\n      let x_549 : f32 = coarse_cell_range.y;\n      x_550 = (x_547 > x_549);\n      x_551 = x_550;\n    }\n    if (x_551) {\n      first_coarse_iter = false;\n      let x_555 : GridIterator = coarse_grid_iter;\n      param_11 = x_555;\n      grid_iterator_advance_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_(&(param_11));\n      let x_557 : GridIterator = param_11;\n      coarse_grid_iter = x_557;\n      continue;\n    }\n    let x_560 : vec3<i32> = coarse_cell_id;\n    coarse_grid_cell_org = (x_560 * vec3<i32>(4i, 4i, 4i));\n    let x_564 : vec3<i32> = coarse_grid_cell_org;\n    let x_567 : vec3<i32> = macrogrid_dims;\n    let x_570 : vec3<i32> = coarse_grid_cell_org;\n    macrocell_grid_dims = vec3<i32>((min((vec3<f32>(x_564) + vec3<f32>(4.0f, 4.0f, 4.0f)), vec3<f32>(x_567)) - vec3<f32>(x_570)));\n    let x_575 : u32 = x_347.current_pass_index;\n    let x_577 : bool = first_coarse_iter;\n    if (((x_575 == 0u) | !(x_577))) {\n      let x_583 : vec3<f32> = macrocell_grid_org;\n      let x_584 : vec3<i32> = coarse_grid_cell_org;\n      param_12 = (x_583 - vec3<f32>(x_584));\n      let x_589 : vec3<f32> = macrocell_grid_ray_dir;\n      param_13 = x_589;\n      let x_592 : f32 = coarse_cell_t_range.x;\n      param_14 = x_592;\n      let x_594 : vec3<i32> = macrocell_grid_dims;\n      param_15 = x_594;\n      let x_595 : GridIterator = init_grid_iterator_vf3_vf3_f1_vi3_(&(param_12), &(param_13), &(param_14), &(param_15));\n      grid_iter_2 = x_595;\n    } else {\n      let x_597 : vec3<f32> = macrocell_grid_org;\n      let x_598 : vec3<i32> = coarse_grid_cell_org;\n      let x_601 : u32 = ray_index;\n      param_16 = (x_597 - vec3<f32>(x_598));\n      let x_606 : vec3<f32> = macrocell_grid_ray_dir;\n      param_17 = x_606;\n      let x_608 : vec3<i32> = macrocell_grid_dims;\n      param_18 = x_608;\n      let x_611 : GridIteratorState_1 = x_479.iterator_state[((x_601 * 2u) + 1u)];\n      param_19.t_max = x_611.t_max;\n      param_19.cell_id = x_611.cell_id;\n      let x_616 : GridIterator = restore_grid_iterator_vf3_vf3_vi3_struct_GridIteratorState_vf3_i11_(&(param_16), &(param_17), &(param_18), &(param_19));\n      grid_iter_2 = x_616;\n      let x_618 : GridIterator = grid_iter_2;\n      param_20 = x_618;\n      grid_iterator_advance_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_(&(param_20));\n      let x_620 : GridIterator = param_20;\n      grid_iter_2 = x_620;\n    }\n    loop {\n      var x_682 : bool;\n      var x_683 : bool;\n      let x_629 : GridIterator = grid_iter_2;\n      param_21 = x_629;\n      let x_632 : bool = grid_iterator_get_cell_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_vf2_vi3_(&(param_21), &(param_22), &(param_23));\n      let x_633 : GridIterator = param_21;\n      grid_iter_2 = x_633;\n      let x_634 : vec2<f32> = param_22;\n      cell_t_range_1 = x_634;\n      let x_635 : vec3<i32> = param_23;\n      cell_id_1 = x_635;\n      if (x_632) {\n      } else {\n        break;\n      }\n      let x_638 : i32 = coarse_grid_cell_org.x;\n      let x_640 : i32 = cell_id_1.x;\n      let x_644 : u32 = n_blocks.x;\n      let x_646 : i32 = coarse_grid_cell_org.y;\n      let x_648 : i32 = cell_id_1.y;\n      let x_652 : u32 = n_blocks.y;\n      let x_654 : i32 = coarse_grid_cell_org.z;\n      let x_656 : i32 = cell_id_1.z;\n      block_index = (bitcast<u32>((x_638 + x_640)) + (x_644 * (bitcast<u32>((x_646 + x_648)) + (x_652 * bitcast<u32>((x_654 + x_656))))));\n      let x_668 : u32 = block_index;\n      let x_670 : vec2<f32> = x_667.voxel_ranges[x_668];\n      cell_range = x_670;\n      let x_672 : f32 = x_312.isovalue;\n      let x_674 : f32 = cell_range.x;\n      let x_675 : bool = (x_672 >= x_674);\n      x_683 = x_675;\n      if (x_675) {\n        let x_679 : f32 = x_312.isovalue;\n        let x_681 : f32 = cell_range.y;\n        x_682 = (x_679 <= x_681);\n        x_683 = x_682;\n      }\n      if (x_683) {\n        let x_687 : u32 = x_347.speculation_count;\n        if ((x_687 == 0u)) {\n          return;\n        }\n        let x_696 : u32 = ray_index;\n        let x_698 : u32 = x_371.ray_offsets[x_696];\n        let x_700 : u32 = x_347.speculation_count;\n        let x_702 : u32 = speculated;\n        let x_704 : u32 = block_index;\n        x_695.block_ids[((x_698 * x_700) + x_702)] = x_704;\n        let x_706 : u32 = speculated;\n        speculated = (x_706 + bitcast<u32>(1i));\n        let x_708 : u32 = speculated;\n        let x_710 : u32 = x_347.speculation_count;\n        if ((x_708 == x_710)) {\n          let x_714 : u32 = ray_index;\n          let x_717 : GridIterator = coarse_grid_iter;\n          param_24 = x_717;\n          let x_718 : i32 = grid_iterator_get_cell_id_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_(&(param_24));\n          x_479.iterator_state[(x_714 * 2u)].cell_id = x_718;\n          let x_721 : u32 = ray_index;\n          let x_724 : vec3<f32> = coarse_grid_iter.t_max;\n          x_479.iterator_state[(x_721 * 2u)].t_max = x_724;\n          let x_726 : u32 = ray_index;\n          let x_730 : GridIterator = grid_iter_2;\n          param_25 = x_730;\n          let x_731 : i32 = grid_iterator_get_cell_id_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_(&(param_25));\n          x_479.iterator_state[((x_726 * 2u) + 1u)].cell_id = x_731;\n          let x_733 : u32 = ray_index;\n          let x_737 : vec3<f32> = grid_iter_2.t_max;\n          x_479.iterator_state[((x_733 * 2u) + 1u)].t_max = x_737;\n          return;\n        }\n      }\n      let x_741 : GridIterator = grid_iter_2;\n      param_26 = x_741;\n      grid_iterator_advance_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_(&(param_26));\n      let x_743 : GridIterator = param_26;\n      grid_iter_2 = x_743;\n    }\n    first_coarse_iter = false;\n    let x_745 : GridIterator = coarse_grid_iter;\n    param_27 = x_745;\n    grid_iterator_advance_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_(&(param_27));\n    let x_747 : GridIterator = param_27;\n    coarse_grid_iter = x_747;\n  }\n  let x_748 : u32 = ray_index;\n  x_334.rays[x_748].t = 340282346638528859811704183484516925440.0f;\n  return;\n}\n\n@compute @workgroup_size(64i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst radix_sort_chunk_comp_spv = `struct BufferInfo {\n  size : u32,\n}\n\nalias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct Keys {\n  keys : RTArr_1,\n}\n\nstruct Values {\n  values : RTArr_1,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<uniform> x_16 : BufferInfo;\n\nvar<workgroup> key_buf : array<u32, 256u>;\n\nvar<private> gl_LocalInvocationID : vec3<u32>;\n\n@group(1) @binding(0) var<storage, read_write> x_36 : Keys;\n\nvar<workgroup> val_buf : array<u32, 256u>;\n\n@group(1) @binding(1) var<storage, read_write> x_49 : Values;\n\nvar<workgroup> scratch : array<u32, 256u>;\n\nvar<workgroup> total_false : u32;\n\nvar<workgroup> sorted_key_buf : array<u32, 256u>;\n\nvar<workgroup> sorted_val_buf : array<u32, 256u>;\n\nfn main_1() {\n  var i : u32;\n  var mask : u32;\n  var offs : u32;\n  var d : i32;\n  var a : u32;\n  var b : u32;\n  var d_1 : i32;\n  var a_1 : u32;\n  var b_1 : u32;\n  var tmp : u32;\n  var f : u32;\n  var t : u32;\n  let x_13 : u32 = gl_GlobalInvocationID.x;\n  let x_21 : u32 = x_16.size;\n  if ((x_13 < x_21)) {\n    let x_32 : u32 = gl_LocalInvocationID.x;\n    let x_38 : u32 = gl_GlobalInvocationID.x;\n    let x_40 : u32 = x_36.keys[x_38];\n    key_buf[x_32] = x_40;\n    let x_45 : u32 = gl_LocalInvocationID.x;\n    let x_51 : u32 = gl_GlobalInvocationID.x;\n    let x_53 : u32 = x_49.values[x_51];\n    val_buf[x_45] = x_53;\n  } else {\n    let x_57 : u32 = gl_LocalInvocationID.x;\n    key_buf[x_57] = 4294967295u;\n    let x_61 : u32 = gl_LocalInvocationID.x;\n    val_buf[x_61] = 4294967295u;\n  }\n  i = 0u;\n  loop {\n    let x_70 : u32 = i;\n    if ((x_70 < 32u)) {\n    } else {\n      break;\n    }\n    workgroupBarrier();\n    let x_77 : u32 = i;\n    mask = bitcast<u32>((1i << x_77));\n    let x_82 : u32 = gl_LocalInvocationID.x;\n    let x_84 : u32 = gl_LocalInvocationID.x;\n    let x_86 : u32 = key_buf[x_84];\n    let x_87 : u32 = mask;\n    scratch[x_82] = bitcast<u32>(select(1i, 0i, ((x_86 & x_87) != 0u)));\n    offs = 1u;\n    d = 128i;\n    loop {\n      let x_103 : i32 = d;\n      if ((x_103 > 0i)) {\n      } else {\n        break;\n      }\n      workgroupBarrier();\n      let x_106 : u32 = gl_LocalInvocationID.x;\n      let x_107 : i32 = d;\n      if ((x_106 < bitcast<u32>(x_107))) {\n        let x_113 : u32 = offs;\n        let x_115 : u32 = gl_LocalInvocationID.x;\n        a = ((x_113 * ((2u * x_115) + 1u)) - 1u);\n        let x_121 : u32 = offs;\n        let x_123 : u32 = gl_LocalInvocationID.x;\n        b = ((x_121 * ((2u * x_123) + 2u)) - 1u);\n        let x_128 : u32 = b;\n        let x_129 : u32 = a;\n        let x_131 : u32 = scratch[x_129];\n        let x_133 : u32 = scratch[x_128];\n        scratch[x_128] = (x_133 + x_131);\n      }\n      let x_136 : u32 = offs;\n      offs = (x_136 << bitcast<u32>(1i));\n\n      continuing {\n        let x_138 : i32 = d;\n        d = (x_138 >> bitcast<u32>(1i));\n      }\n    }\n    let x_141 : u32 = gl_LocalInvocationID.x;\n    if ((x_141 == 0u)) {\n      let x_148 : u32 = scratch[255i];\n      total_false = x_148;\n      scratch[255i] = 0u;\n    }\n    d_1 = 1i;\n    loop {\n      let x_156 : i32 = d_1;\n      if ((x_156 < 256i)) {\n      } else {\n        break;\n      }\n      let x_159 : u32 = offs;\n      offs = (x_159 >> bitcast<u32>(1i));\n      workgroupBarrier();\n      let x_162 : u32 = gl_LocalInvocationID.x;\n      let x_163 : i32 = d_1;\n      if ((x_162 < bitcast<u32>(x_163))) {\n        let x_169 : u32 = offs;\n        let x_171 : u32 = gl_LocalInvocationID.x;\n        a_1 = ((x_169 * ((2u * x_171) + 1u)) - 1u);\n        let x_177 : u32 = offs;\n        let x_179 : u32 = gl_LocalInvocationID.x;\n        b_1 = ((x_177 * ((2u * x_179) + 2u)) - 1u);\n        let x_185 : u32 = a_1;\n        let x_187 : u32 = scratch[x_185];\n        tmp = x_187;\n        let x_188 : u32 = a_1;\n        let x_189 : u32 = b_1;\n        let x_191 : u32 = scratch[x_189];\n        scratch[x_188] = x_191;\n        let x_193 : u32 = b_1;\n        let x_194 : u32 = tmp;\n        let x_196 : u32 = scratch[x_193];\n        scratch[x_193] = (x_196 + x_194);\n      }\n\n      continuing {\n        let x_199 : i32 = d_1;\n        d_1 = (x_199 << bitcast<u32>(1i));\n      }\n    }\n    workgroupBarrier();\n    let x_203 : u32 = gl_LocalInvocationID.x;\n    let x_205 : u32 = scratch[x_203];\n    f = x_205;\n    let x_208 : u32 = gl_LocalInvocationID.x;\n    let x_209 : u32 = f;\n    let x_211 : u32 = total_false;\n    t = ((x_208 - x_209) + x_211);\n    let x_214 : u32 = gl_LocalInvocationID.x;\n    let x_216 : u32 = key_buf[x_214];\n    let x_217 : u32 = mask;\n    if (((x_216 & x_217) != 0u)) {\n      let x_223 : u32 = t;\n      let x_225 : u32 = gl_LocalInvocationID.x;\n      let x_227 : u32 = key_buf[x_225];\n      sorted_key_buf[x_223] = x_227;\n      let x_230 : u32 = t;\n      let x_232 : u32 = gl_LocalInvocationID.x;\n      let x_234 : u32 = val_buf[x_232];\n      sorted_val_buf[x_230] = x_234;\n    } else {\n      let x_237 : u32 = f;\n      let x_239 : u32 = gl_LocalInvocationID.x;\n      let x_241 : u32 = key_buf[x_239];\n      sorted_key_buf[x_237] = x_241;\n      let x_243 : u32 = f;\n      let x_245 : u32 = gl_LocalInvocationID.x;\n      let x_247 : u32 = val_buf[x_245];\n      sorted_val_buf[x_243] = x_247;\n    }\n    workgroupBarrier();\n    let x_250 : u32 = gl_LocalInvocationID.x;\n    let x_252 : u32 = gl_LocalInvocationID.x;\n    let x_254 : u32 = sorted_key_buf[x_252];\n    key_buf[x_250] = x_254;\n    let x_257 : u32 = gl_LocalInvocationID.x;\n    let x_259 : u32 = gl_LocalInvocationID.x;\n    let x_261 : u32 = sorted_val_buf[x_259];\n    val_buf[x_257] = x_261;\n\n    continuing {\n      let x_263 : u32 = i;\n      i = (x_263 + bitcast<u32>(1i));\n    }\n  }\n  workgroupBarrier();\n  let x_266 : u32 = gl_GlobalInvocationID.x;\n  let x_268 : u32 = gl_LocalInvocationID.x;\n  let x_270 : u32 = key_buf[x_268];\n  x_36.keys[x_266] = x_270;\n  let x_273 : u32 = gl_GlobalInvocationID.x;\n  let x_275 : u32 = gl_LocalInvocationID.x;\n  let x_277 : u32 = val_buf[x_275];\n  x_49.values[x_273] = x_277;\n  return;\n}\n\n@compute @workgroup_size(256i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>, @builtin(local_invocation_id) gl_LocalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  gl_LocalInvocationID = gl_LocalInvocationID_param;\n  main_1();\n}\n`;\n\nconst reverse_buffer_comp_spv = `struct BufferInfo {\n  size : u32,\n}\n\nalias RTArr = array<u32>;\n\nstruct Values {\n  values : RTArr,\n}\n\n@group(0) @binding(0) var<uniform> x_48 : BufferInfo;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(1) @binding(0) var<storage, read_write> x_94 : Values;\n\nfn next_pow2_u1_(x : ptr<function, u32>) -> u32 {\n  let x_12 : u32 = *(x);\n  *(x) = (x_12 - 1u);\n  let x_15 : u32 = *(x);\n  let x_19 : u32 = *(x);\n  *(x) = (x_19 | (x_15 >> bitcast<u32>(1i)));\n  let x_21 : u32 = *(x);\n  let x_24 : u32 = *(x);\n  *(x) = (x_24 | (x_21 >> bitcast<u32>(2i)));\n  let x_26 : u32 = *(x);\n  let x_29 : u32 = *(x);\n  *(x) = (x_29 | (x_26 >> bitcast<u32>(4i)));\n  let x_31 : u32 = *(x);\n  let x_34 : u32 = *(x);\n  *(x) = (x_34 | (x_31 >> bitcast<u32>(8i)));\n  let x_36 : u32 = *(x);\n  let x_39 : u32 = *(x);\n  *(x) = (x_39 | (x_36 >> bitcast<u32>(16i)));\n  let x_41 : u32 = *(x);\n  return (x_41 + 1u);\n}\n\nfn main_1() {\n  var aligned_size : u32;\n  var param : u32;\n  var i : u32;\n  var j : u32;\n  var tmp : u32;\n  var x_76 : bool;\n  var x_77 : bool;\n  let x_52 : u32 = x_48.size;\n  param = u32(ceil((f32(x_52) / 256.0f)));\n  let x_60 : u32 = next_pow2_u1_(&(param));\n  aligned_size = (x_60 * 256u);\n  let x_64 : u32 = aligned_size;\n  let x_65 : bool = (x_64 < 256u);\n  x_77 = x_65;\n  if (x_65) {\n    let x_74 : u32 = gl_GlobalInvocationID.x;\n    x_76 = (x_74 > 128u);\n    x_77 = x_76;\n  }\n  if (x_77) {\n    return;\n  }\n  let x_83 : u32 = gl_GlobalInvocationID.x;\n  i = x_83;\n  let x_85 : u32 = aligned_size;\n  let x_87 : u32 = gl_GlobalInvocationID.x;\n  j = ((x_85 - x_87) - 1u);\n  let x_95 : u32 = i;\n  let x_97 : u32 = x_94.values[x_95];\n  tmp = x_97;\n  let x_98 : u32 = i;\n  let x_99 : u32 = j;\n  let x_101 : u32 = x_94.values[x_99];\n  x_94.values[x_98] = x_101;\n  let x_103 : u32 = j;\n  let x_104 : u32 = tmp;\n  x_94.values[x_103] = x_104;\n  return;\n}\n\n@compute @workgroup_size(256i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst merge_sorted_chunks_comp_spv = `alias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct InputKeys {\n  input_keys : RTArr_1,\n}\n\nstruct BufferInfo {\n  size : u32,\n}\n\nstruct NumWorkGroups {\n  work_groups_x : u32,\n}\n\nalias RTArr_2 = array<u32>;\n\nstruct OutputKeys {\n  output_keys : RTArr_1,\n}\n\nalias RTArr_3 = array<u32>;\n\nstruct OutputValues {\n  output_values : RTArr_1,\n}\n\nstruct InputValues {\n  input_values : RTArr_1,\n}\n\n@group(1) @binding(0) var<storage, read_write> x_75 : InputKeys;\n\n@group(0) @binding(0) var<uniform> x_132 : BufferInfo;\n\n@group(2) @binding(0) var<uniform> x_149 : NumWorkGroups;\n\nvar<private> gl_WorkGroupID : vec3<u32>;\n\nvar<private> gl_LocalInvocationID : vec3<u32>;\n\n@group(1) @binding(2) var<storage, read_write> x_231 : OutputKeys;\n\n@group(1) @binding(3) var<storage, read_write> x_240 : OutputValues;\n\n@group(1) @binding(1) var<storage, read_write> x_245 : InputValues;\n\nfn next_pow2_u1_(x : ptr<function, u32>) -> u32 {\n  let x_23 : u32 = *(x);\n  *(x) = (x_23 - 1u);\n  let x_26 : u32 = *(x);\n  let x_30 : u32 = *(x);\n  *(x) = (x_30 | (x_26 >> bitcast<u32>(1i)));\n  let x_32 : u32 = *(x);\n  let x_35 : u32 = *(x);\n  *(x) = (x_35 | (x_32 >> bitcast<u32>(2i)));\n  let x_37 : u32 = *(x);\n  let x_40 : u32 = *(x);\n  *(x) = (x_40 | (x_37 >> bitcast<u32>(4i)));\n  let x_42 : u32 = *(x);\n  let x_45 : u32 = *(x);\n  *(x) = (x_45 | (x_42 >> bitcast<u32>(8i)));\n  let x_47 : u32 = *(x);\n  let x_50 : u32 = *(x);\n  *(x) = (x_50 | (x_47 >> bitcast<u32>(16i)));\n  let x_52 : u32 = *(x);\n  return (x_52 + 1u);\n}\n\nfn upper_bound_u1_u1_u1_(start : ptr<function, u32>, count : ptr<function, u32>, element : ptr<function, u32>) -> u32 {\n  var i : u32;\n  loop {\n    let x_61 : u32 = *(count);\n    if ((x_61 > 0u)) {\n    } else {\n      break;\n    }\n    let x_66 : u32 = *(start);\n    let x_67 : u32 = *(count);\n    i = (x_66 + (x_67 / 2u));\n    let x_71 : u32 = *(element);\n    let x_77 : u32 = i;\n    let x_80 : u32 = x_75.input_keys[x_77];\n    if ((x_71 >= x_80)) {\n      let x_84 : u32 = i;\n      *(start) = (x_84 + 1u);\n      let x_86 : u32 = *(count);\n      let x_89 : u32 = *(count);\n      *(count) = (x_89 - ((x_86 / 2u) + 1u));\n    } else {\n      let x_92 : u32 = *(count);\n      *(count) = (x_92 / 2u);\n    }\n  }\n  let x_94 : u32 = *(start);\n  return x_94;\n}\n\nfn lower_bound_u1_u1_u1_(start_1 : ptr<function, u32>, count_1 : ptr<function, u32>, element_1 : ptr<function, u32>) -> u32 {\n  var i_1 : u32;\n  loop {\n    let x_102 : u32 = *(count_1);\n    if ((x_102 > 0u)) {\n    } else {\n      break;\n    }\n    let x_105 : u32 = *(start_1);\n    let x_106 : u32 = *(count_1);\n    i_1 = (x_105 + (x_106 / 2u));\n    let x_109 : u32 = i_1;\n    let x_111 : u32 = x_75.input_keys[x_109];\n    let x_112 : u32 = *(element_1);\n    if ((x_111 < x_112)) {\n      let x_116 : u32 = i_1;\n      *(start_1) = (x_116 + 1u);\n      let x_118 : u32 = *(count_1);\n      let x_121 : u32 = *(count_1);\n      *(count_1) = (x_121 - ((x_118 / 2u) + 1u));\n    } else {\n      let x_124 : u32 = *(count_1);\n      *(count_1) = (x_124 / 2u);\n    }\n  }\n  let x_126 : u32 = *(start_1);\n  return x_126;\n}\n\nfn main_1() {\n  var aligned_size : u32;\n  var param : u32;\n  var merge_output_size : u32;\n  var merge_chunk_size : u32;\n  var offs : u32;\n  var i_2 : u32;\n  var a_in : u32;\n  var b_in : u32;\n  var base_idx : u32;\n  var a_loc : u32;\n  var param_1 : u32;\n  var param_2 : u32;\n  var param_3 : u32;\n  var b_loc : u32;\n  var param_4 : u32;\n  var param_5 : u32;\n  var param_6 : u32;\n  let x_134 : u32 = x_132.size;\n  param = u32(ceil((f32(x_134) / 256.0f)));\n  let x_142 : u32 = next_pow2_u1_(&(param));\n  aligned_size = (x_142 * 256u);\n  let x_146 : u32 = aligned_size;\n  let x_151 : u32 = x_149.work_groups_x;\n  merge_output_size = (x_146 / x_151);\n  let x_154 : u32 = merge_output_size;\n  merge_chunk_size = (x_154 / 2u);\n  let x_162 : u32 = gl_WorkGroupID.x;\n  let x_163 : u32 = merge_output_size;\n  offs = (x_162 * x_163);\n  i_2 = 0u;\n  loop {\n    let x_171 : u32 = i_2;\n    let x_172 : u32 = merge_chunk_size;\n    if ((x_171 < (x_172 / 256u))) {\n    } else {\n      break;\n    }\n    let x_176 : u32 = offs;\n    let x_177 : u32 = i_2;\n    let x_182 : u32 = gl_LocalInvocationID.x;\n    a_in = ((x_176 + (x_177 * 256u)) + x_182);\n    let x_185 : u32 = offs;\n    let x_186 : u32 = merge_chunk_size;\n    let x_188 : u32 = i_2;\n    let x_192 : u32 = gl_LocalInvocationID.x;\n    b_in = (((x_185 + x_186) + (x_188 * 256u)) + x_192);\n    let x_196 : u32 = gl_LocalInvocationID.x;\n    let x_197 : u32 = i_2;\n    base_idx = (x_196 + (x_197 * 256u));\n    let x_201 : u32 = base_idx;\n    let x_202 : u32 = offs;\n    let x_203 : u32 = merge_chunk_size;\n    let x_205 : u32 = a_in;\n    param_1 = (x_202 + x_203);\n    let x_208 : u32 = merge_chunk_size;\n    param_2 = x_208;\n    let x_211 : u32 = x_75.input_keys[x_205];\n    param_3 = x_211;\n    let x_212 : u32 = upper_bound_u1_u1_u1_(&(param_1), &(param_2), &(param_3));\n    let x_214 : u32 = merge_chunk_size;\n    a_loc = ((x_201 + x_212) - x_214);\n    let x_217 : u32 = base_idx;\n    let x_218 : u32 = b_in;\n    let x_220 : u32 = offs;\n    param_4 = x_220;\n    let x_222 : u32 = merge_chunk_size;\n    param_5 = x_222;\n    let x_225 : u32 = x_75.input_keys[x_218];\n    param_6 = x_225;\n    let x_226 : u32 = lower_bound_u1_u1_u1_(&(param_4), &(param_5), &(param_6));\n    b_loc = (x_217 + x_226);\n    let x_232 : u32 = a_loc;\n    let x_233 : u32 = a_in;\n    let x_235 : u32 = x_75.input_keys[x_233];\n    x_231.output_keys[x_232] = x_235;\n    let x_241 : u32 = a_loc;\n    let x_246 : u32 = a_in;\n    let x_248 : u32 = x_245.input_values[x_246];\n    x_240.output_values[x_241] = x_248;\n    let x_250 : u32 = b_loc;\n    let x_251 : u32 = b_in;\n    let x_253 : u32 = x_75.input_keys[x_251];\n    x_231.output_keys[x_250] = x_253;\n    let x_255 : u32 = b_loc;\n    let x_256 : u32 = b_in;\n    let x_258 : u32 = x_245.input_values[x_256];\n    x_240.output_values[x_255] = x_258;\n\n    continuing {\n      let x_260 : u32 = i_2;\n      i_2 = (x_260 + bitcast<u32>(1i));\n    }\n  }\n  return;\n}\n\n@compute @workgroup_size(256i, 1i, 1i)\nfn main(@builtin(workgroup_id) gl_WorkGroupID_param : vec3<u32>, @builtin(local_invocation_id) gl_LocalInvocationID_param : vec3<u32>) {\n  gl_WorkGroupID = gl_WorkGroupID_param;\n  gl_LocalInvocationID = gl_LocalInvocationID_param;\n  main_1();\n}\n`;\n\nconst display_render_vert_spv = `var<private> gl_VertexIndex : i32;\n\nvar<private> gl_Position : vec4<f32>;\n\nfn main_1() {\n  var indexable : array<vec4<f32>, 6u>;\n  let x_28 : i32 = gl_VertexIndex;\n  indexable = array<vec4<f32>, 6u>(vec4<f32>(-1.0f, 1.0f, 0.5f, 1.0f), vec4<f32>(-1.0f, -1.0f, 0.5f, 1.0f), vec4<f32>(1.0f, 1.0f, 0.5f, 1.0f), vec4<f32>(-1.0f, -1.0f, 0.5f, 1.0f), vec4<f32>(1.0f, 1.0f, 0.5f, 1.0f), vec4<f32>(1.0f, -1.0f, 0.5f, 1.0f));\n  let x_33 : vec4<f32> = indexable[x_28];\n  gl_Position = x_33;\n  return;\n}\n\nstruct main_out {\n  @builtin(position)\n  gl_Position : vec4<f32>,\n}\n\n@vertex\nfn main(@builtin(vertex_index) gl_VertexIndex_param : u32) -> main_out {\n  gl_VertexIndex = bitcast<i32>(gl_VertexIndex_param);\n  main_1();\n  return main_out(gl_Position);\n}\n`;\n\nconst display_render_frag_spv = `struct Resolution {\n  width : u32,\n  height : u32,\n}\n\nvar<private> color : vec4<f32>;\n\n@group(0) @binding(0) var output_texture : texture_2d<f32>;\n\n@group(0) @binding(2) var u_sampler : sampler;\n\nvar<private> gl_FragCoord : vec4<f32>;\n\n@group(0) @binding(1) var<uniform> x_28 : Resolution;\n\nfn main_1() {\n  let x_23 : vec4<f32> = gl_FragCoord;\n  let x_33 : u32 = x_28.width;\n  let x_37 : u32 = x_28.height;\n  let x_41 : vec4<f32> = textureSample(output_texture, u_sampler, (vec2<f32>(x_23.x, x_23.y) / vec2<f32>(f32(x_33), f32(x_37))));\n  color = x_41;\n  color.w = 1.0f;\n  return;\n}\n\nstruct main_out {\n  @location(0)\n  color_1 : vec4<f32>,\n}\n\n@fragment\nfn main(@builtin(position) gl_FragCoord_param : vec4<f32>) -> main_out {\n  gl_FragCoord = gl_FragCoord_param;\n  main_1();\n  return main_out(color);\n}\n`;\n\nconst reset_rays_comp_spv = `struct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nstruct RayInfo {\n  ray_dir : vec3<f32>,\n  t : f32,\n}\n\nalias RTArr = array<RayInfo>;\n\nstruct RayInformation {\n  rays : RTArr,\n}\n\nstruct ViewParams {\n  proj_view : mat4x4<f32>,\n  eye_pos : vec4<f32>,\n  eye_dir : vec4<f32>,\n  near_plane : f32,\n  current_pass_index : u32,\n  speculation_count : u32,\n}\n\nalias RTArr_1 = array<u32>;\n\nstruct RayBlockIDs {\n  block_ids : RTArr_1,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(1) var<uniform> x_19 : VolumeParams;\n\n@group(0) @binding(0) var<storage, read_write> x_46 : RayInformation;\n\n@group(0) @binding(3) var<uniform> x_68 : ViewParams;\n\n@group(0) @binding(2) var<storage, read_write> x_75 : RayBlockIDs;\n\nfn main_1() {\n  var ray_index : u32;\n  var i : u32;\n  let x_13 : u32 = gl_GlobalInvocationID.x;\n  let x_24 : u32 = x_19.image_width;\n  if ((x_13 >= x_24)) {\n    return;\n  }\n  let x_33 : u32 = gl_GlobalInvocationID.x;\n  let x_36 : u32 = gl_GlobalInvocationID.y;\n  let x_38 : u32 = x_19.image_width;\n  ray_index = (x_33 + (x_36 * x_38));\n  let x_48 : u32 = ray_index;\n  x_46.rays[x_48].ray_dir = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_53 : u32 = ray_index;\n  x_46.rays[x_53].t = 340282346638528859811704183484516925440.0f;\n  i = 0u;\n  loop {\n    let x_64 : u32 = i;\n    let x_70 : u32 = x_68.speculation_count;\n    if ((x_64 < x_70)) {\n    } else {\n      break;\n    }\n    let x_76 : u32 = ray_index;\n    let x_78 : u32 = x_68.speculation_count;\n    let x_80 : u32 = i;\n    x_75.block_ids[((x_76 * x_78) + x_80)] = 4294967295u;\n\n    continuing {\n      let x_84 : u32 = i;\n      i = (x_84 + bitcast<u32>(1i));\n    }\n  }\n  return;\n}\n\n@compute @workgroup_size(8i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst reset_block_active_comp_spv = `struct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n}\n\nalias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct BlockActive {\n  block_active : RTArr_1,\n}\n\nstruct BlockVisible {\n  block_visible : RTArr_1,\n}\n\n@group(0) @binding(0) var<uniform> x_15 : VolumeParams;\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(1) var<storage, read_write> x_59 : BlockActive;\n\n@group(0) @binding(2) var<storage, read_write> x_67 : BlockVisible;\n\nfn main_1() {\n  var n_blocks : vec3<u32>;\n  var block_id : u32;\n  let x_20 : vec4<u32> = x_15.padded_dims;\n  n_blocks = (vec3<u32>(x_20.x, x_20.y, x_20.z) / vec3<u32>(4u, 4u, 4u));\n  let x_30 : u32 = gl_GlobalInvocationID.x;\n  let x_33 : u32 = n_blocks.x;\n  if ((x_30 >= x_33)) {\n    return;\n  }\n  let x_41 : u32 = gl_GlobalInvocationID.x;\n  let x_43 : u32 = n_blocks.x;\n  let x_46 : u32 = gl_GlobalInvocationID.y;\n  let x_48 : u32 = n_blocks.y;\n  let x_51 : u32 = gl_GlobalInvocationID.z;\n  block_id = (x_41 + (x_43 * (x_46 + (x_48 * x_51))));\n  let x_61 : u32 = block_id;\n  x_59.block_active[x_61] = 0u;\n  let x_68 : u32 = block_id;\n  x_67.block_visible[x_68] = 0u;\n  return;\n}\n\n@compute @workgroup_size(8i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst reset_block_num_rays_comp_spv = `struct BlockIDOffset {\n  id_offset : u32,\n  total_visible_blocks : u32,\n}\n\nalias RTArr = array<u32>;\n\nstruct BlockNumRays {\n  block_num_rays : RTArr,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<uniform> x_18 : BlockIDOffset;\n\n@group(0) @binding(1) var<storage, read_write> x_37 : BlockNumRays;\n\nfn main_1() {\n  var block_id : u32;\n  let x_15 : u32 = gl_GlobalInvocationID.x;\n  let x_23 : u32 = x_18.id_offset;\n  block_id = (x_15 + x_23);\n  let x_25 : u32 = block_id;\n  let x_28 : u32 = x_18.total_visible_blocks;\n  if ((x_25 >= x_28)) {\n    return;\n  }\n  let x_38 : u32 = block_id;\n  x_37.block_num_rays[x_38] = 0u;\n  return;\n}\n\n@compute @workgroup_size(32i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst debug_view_rays_per_block_comp_spv = `struct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nstruct RayInfo {\n  ray_dir : vec3<f32>,\n  t : f32,\n}\n\nalias RTArr = array<RayInfo>;\n\nstruct RayInformation {\n  rays : RTArr,\n}\n\nalias RTArr_1 = array<u32>;\n\nalias RTArr_2 = array<u32>;\n\nstruct RayBlockIDs {\n  block_ids : RTArr_2,\n}\n\nstruct BlockNumRays {\n  block_num_rays : RTArr_2,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<uniform> x_24 : VolumeParams;\n\n@group(0) @binding(2) var<storage, read_write> x_37 : RayInformation;\n\n@group(0) @binding(4) var<storage, read_write> x_54 : RayBlockIDs;\n\n@group(0) @binding(1) var<storage, read_write> x_63 : BlockNumRays;\n\n@group(0) @binding(3) var render_target : texture_storage_2d<rgba8unorm, write>;\n\nfn main_1() {\n  var ray_index : u32;\n  var block_id : u32;\n  var color : vec4<f32>;\n  let x_15 : u32 = gl_GlobalInvocationID.x;\n  let x_18 : u32 = gl_GlobalInvocationID.y;\n  let x_29 : u32 = x_24.image_width;\n  ray_index = (x_15 + (x_18 * x_29));\n  let x_39 : u32 = ray_index;\n  let x_43 : f32 = x_37.rays[x_39].t;\n  if ((x_43 == 340282346638528859811704183484516925440.0f)) {\n    return;\n  }\n  let x_55 : u32 = ray_index;\n  let x_57 : u32 = x_54.block_ids[x_55];\n  block_id = x_57;\n  let x_64 : u32 = block_id;\n  let x_66 : u32 = x_63.block_num_rays[x_64];\n  let x_69 : f32 = (f32(x_66) / 256.0f);\n  let x_70 : vec3<f32> = vec3<f32>(x_69, x_69, x_69);\n  let x_71 : vec4<f32> = color;\n  color = vec4<f32>(x_70.x, x_70.y, x_70.z, x_71.w);\n  color.w = 1.0f;\n  let x_82 : vec3<u32> = gl_GlobalInvocationID;\n  let x_86 : vec4<f32> = color;\n  textureStore(render_target, bitcast<vec2<i32>>(vec2<u32>(x_82.x, x_82.y)), x_86);\n  return;\n}\n\n@compute @workgroup_size(1i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst write_ray_and_block_id_comp_spv = `struct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nalias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct RayActive {\n  ray_active : RTArr_1,\n}\n\nstruct RayBlockID {\n  block_id : RTArr_1,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<uniform> x_19 : VolumeParams;\n\n@group(0) @binding(2) var<storage, read_write> x_44 : RayActive;\n\n@group(0) @binding(1) var<storage, read_write> x_50 : RayBlockID;\n\nfn main_1() {\n  var ray_index : u32;\n  let x_13 : u32 = gl_GlobalInvocationID.x;\n  let x_24 : u32 = x_19.image_width;\n  if ((x_13 >= x_24)) {\n    return;\n  }\n  let x_33 : u32 = gl_GlobalInvocationID.x;\n  let x_36 : u32 = gl_GlobalInvocationID.y;\n  let x_38 : u32 = x_19.image_width;\n  ray_index = (x_33 + (x_36 * x_38));\n  let x_46 : u32 = ray_index;\n  let x_51 : u32 = ray_index;\n  let x_53 : u32 = x_50.block_id[x_51];\n  x_44.ray_active[x_46] = bitcast<u32>(select(0i, 1i, (x_53 != 4294967295u)));\n  return;\n}\n\n@compute @workgroup_size(8i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst combine_block_information_comp_spv = `struct BlockIDOffset {\n  id_offset : u32,\n  total_work_groups : u32,\n  total_active_blocks : u32,\n}\n\nalias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct BlockIDs {\n  block_ids : RTArr_1,\n}\n\nstruct BlockInfo {\n  id : u32,\n  ray_offset : u32,\n  num_rays : u32,\n  lod : u32,\n}\n\nalias RTArr_2 = array<BlockInfo>;\n\nstruct BlockInformation {\n  blocks : RTArr_2,\n}\n\nalias RTArr_3 = array<u32>;\n\nstruct BlockRayOffset {\n  block_ray_offsets : RTArr_1,\n}\n\nalias RTArr_4 = array<u32>;\n\nstruct BlockNumRays {\n  block_num_rays : RTArr_1,\n}\n\nstruct BlockActive {\n  block_active : RTArr_1,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(1) @binding(0) var<uniform> x_18 : BlockIDOffset;\n\n@group(0) @binding(1) var<storage, read_write> x_40 : BlockIDs;\n\n@group(0) @binding(0) var<storage, read_write> x_48 : BlockInformation;\n\n@group(0) @binding(2) var<storage, read_write> x_57 : BlockRayOffset;\n\n@group(0) @binding(3) var<storage, read_write> x_66 : BlockNumRays;\n\n@group(0) @binding(4) var<storage, read_write> x_79 : BlockActive;\n\nfn main_1() {\n  var item_idx : u32;\n  var id : u32;\n  let x_15 : u32 = gl_GlobalInvocationID.x;\n  let x_23 : u32 = x_18.id_offset;\n  item_idx = (x_15 + (x_23 * 64u));\n  let x_27 : u32 = item_idx;\n  let x_30 : u32 = x_18.total_active_blocks;\n  if ((x_27 >= x_30)) {\n    return;\n  }\n  let x_41 : u32 = item_idx;\n  let x_43 : u32 = x_40.block_ids[x_41];\n  id = x_43;\n  let x_49 : u32 = item_idx;\n  let x_50 : u32 = id;\n  x_48.blocks[x_49].id = x_50;\n  let x_52 : u32 = item_idx;\n  let x_58 : u32 = item_idx;\n  let x_60 : u32 = x_57.block_ray_offsets[x_58];\n  x_48.blocks[x_52].ray_offset = x_60;\n  let x_62 : u32 = item_idx;\n  let x_67 : u32 = item_idx;\n  let x_69 : u32 = x_66.block_num_rays[x_67];\n  x_48.blocks[x_62].num_rays = x_69;\n  let x_71 : u32 = item_idx;\n  x_48.blocks[x_71].lod = 0u;\n  return;\n}\n\n@compute @workgroup_size(64i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst raytrace_active_block_comp_spv = `struct GridIterator {\n  grid_dims : vec3<i32>,\n  grid_step : vec3<i32>,\n  t_delta : vec3<f32>,\n  cell : vec3<i32>,\n  t_max : vec3<f32>,\n  t : f32,\n}\n\nstruct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nalias RTArr = array<i32>;\n\nstruct BlockLocations {\n  block_locations : RTArr,\n}\n\nalias RTArr_1 = array<f32>;\n\nstruct Decompressed {\n  decompressed : RTArr_1,\n}\n\nstruct BlockInfo {\n  id : u32,\n  ray_offset : u32,\n  num_rays : u32,\n  lod : u32,\n}\n\nstruct BlockInfo_1 {\n  id : u32,\n  ray_offset : u32,\n  num_rays : u32,\n  lod : u32,\n}\n\nalias RTArr_2 = array<BlockInfo_1>;\n\nstruct BlockInformation {\n  blocks : RTArr_2,\n}\n\nstruct BlockIDOffset {\n  id_offset : u32,\n  total_active_blocks : u32,\n}\n\nstruct ViewParams {\n  proj_view : mat4x4<f32>,\n  eye_pos : vec4<f32>,\n  eye_dir : vec4<f32>,\n  near_plane : f32,\n  current_pass_index : u32,\n}\n\nalias RTArr_3 = array<u32>;\n\nalias RTArr_4 = array<u32>;\n\nstruct RayIDs {\n  ray_ids : RTArr_4,\n}\n\nstruct SpeculativeIDs {\n  spec_ids : RTArr_4,\n}\n\nstruct RayInfo {\n  ray_dir : vec3<f32>,\n  t : f32,\n}\n\nalias RTArr_5 = array<RayInfo>;\n\nstruct RayInformation {\n  rays : RTArr_5,\n}\n\nalias RTArr_6 = array<vec2<f32>>;\n\nstruct RayRGBZ {\n  ray_rgbz : RTArr_6,\n}\n\n@group(0) @binding(0) var<uniform> x_409 : VolumeParams;\n\nvar<workgroup> volume_block : array<f32, 128u>;\n\n@group(0) @binding(2) var<storage, read_write> x_621 : BlockLocations;\n\n@group(0) @binding(1) var<storage, read_write> x_760 : Decompressed;\n\nvar<private> gl_LocalInvocationID : vec3<u32>;\n\nvar<workgroup> block_info : BlockInfo;\n\n@group(1) @binding(3) var<storage, read_write> x_1612 : BlockInformation;\n\nvar<private> gl_WorkGroupID : vec3<u32>;\n\n@group(2) @binding(0) var<uniform> x_1618 : BlockIDOffset;\n\n@group(1) @binding(0) var<uniform> x_1678 : ViewParams;\n\n@group(1) @binding(2) var<storage, read_write> x_1744 : RayIDs;\n\n@group(1) @binding(5) var<storage, read_write> x_1759 : SpeculativeIDs;\n\n@group(1) @binding(1) var<storage, read_write> x_1771 : RayInformation;\n\n@group(1) @binding(6) var<storage, read_write> x_1926 : RayRGBZ;\n\n@group(1) @binding(4) var render_target : texture_storage_2d<rgba8unorm, write>;\n\nfn block_id_to_pos_u1_(id_1 : ptr<function, u32>) -> vec3<u32> {\n  var n_blocks : vec3<u32>;\n  let x_424 : vec4<u32> = x_409.padded_dims;\n  n_blocks = (vec3<u32>(x_424.x, x_424.y, x_424.z) / vec3<u32>(4u, 4u, 4u));\n  let x_429 : u32 = *(id_1);\n  let x_431 : u32 = n_blocks.x;\n  let x_433 : u32 = *(id_1);\n  let x_435 : u32 = n_blocks.x;\n  let x_438 : u32 = n_blocks.y;\n  let x_440 : u32 = *(id_1);\n  let x_442 : u32 = n_blocks.x;\n  let x_444 : u32 = n_blocks.y;\n  return vec3<u32>((x_429 % x_431), ((x_433 / x_435) % x_438), (x_440 / (x_442 * x_444)));\n}\n\nfn compute_block_id_vu3_(block_pos : ptr<function, vec3<u32>>) -> u32 {\n  var n_blocks_1 : vec3<u32>;\n  let x_452 : vec4<u32> = x_409.padded_dims;\n  n_blocks_1 = (vec3<u32>(x_452.x, x_452.y, x_452.z) / vec3<u32>(4u, 4u, 4u));\n  let x_456 : u32 = (*(block_pos)).x;\n  let x_458 : u32 = n_blocks_1.x;\n  let x_460 : u32 = (*(block_pos)).y;\n  let x_462 : u32 = n_blocks_1.y;\n  let x_464 : u32 = (*(block_pos)).z;\n  return (x_456 + (x_458 * (x_460 + (x_462 * x_464))));\n}\n\nfn compute_block_dims_with_ghost_vu3_(block_pos_1 : vec3<u32>) -> vec3<u32> {\n  var n_blocks_2 : vec3<u32>;\n  var block_dims_3 : vec3<u32>;\n  var corner : u32;\n  var param : vec3<u32>;\n  var edge : u32;\n  var param_1 : vec3<u32>;\n  var edge_1 : u32;\n  var param_2 : vec3<u32>;\n  var edge_2 : u32;\n  var param_3 : vec3<u32>;\n  var face : u32;\n  var param_4 : vec3<u32>;\n  var face_1 : u32;\n  var param_5 : vec3<u32>;\n  var face_2 : u32;\n  var param_6 : vec3<u32>;\n  let x_578 : vec4<u32> = x_409.padded_dims;\n  n_blocks_2 = (vec3<u32>(x_578.x, x_578.y, x_578.z) / vec3<u32>(4u, 4u, 4u));\n  block_dims_3 = vec3<u32>(4u, 4u, 4u);\n  let x_585 : u32 = n_blocks_2.x;\n  if (((block_pos_1.x + 1u) < x_585)) {\n    block_dims_3.x = 5u;\n  }\n  let x_594 : u32 = n_blocks_2.y;\n  if (((block_pos_1.y + 1u) < x_594)) {\n    block_dims_3.y = 5u;\n  }\n  let x_602 : u32 = n_blocks_2.z;\n  if (((block_pos_1.z + 1u) < x_602)) {\n    block_dims_3.z = 5u;\n  }\n  let x_607 : vec3<u32> = block_dims_3;\n  if (all((x_607 == vec3<u32>(5u, 5u, 5u)))) {\n    param = (block_pos_1 + vec3<u32>(1u, 1u, 1u));\n    let x_617 : u32 = compute_block_id_vu3_(&(param));\n    corner = x_617;\n    let x_622 : u32 = corner;\n    let x_625 : i32 = x_621.block_locations[x_622];\n    if ((x_625 == -1i)) {\n      block_dims_3 = vec3<u32>(4u, 4u, 4u);\n    }\n  }\n  let x_630 : vec3<u32> = block_dims_3;\n  if (all((vec2<u32>(x_630.x, x_630.y) == vec2<u32>(5u, 5u)))) {\n    param_1 = (block_pos_1 + vec3<u32>(1u, 1u, 0u));\n    let x_642 : u32 = compute_block_id_vu3_(&(param_1));\n    edge = x_642;\n    let x_643 : u32 = edge;\n    let x_645 : i32 = x_621.block_locations[x_643];\n    if ((x_645 == -1i)) {\n      let x_650 : vec3<u32> = block_dims_3;\n      block_dims_3 = vec3<u32>(vec2<u32>(4u, 4u).x, vec2<u32>(4u, 4u).y, x_650.z);\n    }\n  }\n  let x_652 : vec3<u32> = block_dims_3;\n  if (all((vec2<u32>(x_652.x, x_652.z) == vec2<u32>(5u, 5u)))) {\n    param_2 = (block_pos_1 + vec3<u32>(1u, 0u, 1u));\n    let x_662 : u32 = compute_block_id_vu3_(&(param_2));\n    edge_1 = x_662;\n    let x_663 : u32 = edge_1;\n    let x_665 : i32 = x_621.block_locations[x_663];\n    if ((x_665 == -1i)) {\n      let x_669 : vec3<u32> = block_dims_3;\n      block_dims_3 = vec3<u32>(vec2<u32>(4u, 4u).x, x_669.y, vec2<u32>(4u, 4u).y);\n    }\n  }\n  let x_671 : vec3<u32> = block_dims_3;\n  if (all((vec2<u32>(x_671.y, x_671.z) == vec2<u32>(5u, 5u)))) {\n    param_3 = (block_pos_1 + vec3<u32>(0u, 1u, 1u));\n    let x_681 : u32 = compute_block_id_vu3_(&(param_3));\n    edge_2 = x_681;\n    let x_682 : u32 = edge_2;\n    let x_684 : i32 = x_621.block_locations[x_682];\n    if ((x_684 == -1i)) {\n      let x_688 : vec3<u32> = block_dims_3;\n      block_dims_3 = vec3<u32>(x_688.x, vec2<u32>(4u, 4u).x, vec2<u32>(4u, 4u).y);\n    }\n  }\n  let x_691 : u32 = block_dims_3.x;\n  if ((x_691 == 5u)) {\n    param_4 = (block_pos_1 + vec3<u32>(1u, 0u, 0u));\n    let x_699 : u32 = compute_block_id_vu3_(&(param_4));\n    face = x_699;\n    let x_700 : u32 = face;\n    let x_702 : i32 = x_621.block_locations[x_700];\n    if ((x_702 == -1i)) {\n      block_dims_3.x = 4u;\n    }\n  }\n  let x_708 : u32 = block_dims_3.y;\n  if ((x_708 == 5u)) {\n    param_5 = (block_pos_1 + vec3<u32>(0u, 1u, 0u));\n    let x_716 : u32 = compute_block_id_vu3_(&(param_5));\n    face_1 = x_716;\n    let x_717 : u32 = face_1;\n    let x_719 : i32 = x_621.block_locations[x_717];\n    if ((x_719 == -1i)) {\n      block_dims_3.y = 4u;\n    }\n  }\n  let x_725 : u32 = block_dims_3.z;\n  if ((x_725 == 5u)) {\n    param_6 = (block_pos_1 + vec3<u32>(0u, 0u, 1u));\n    let x_733 : u32 = compute_block_id_vu3_(&(param_6));\n    face_2 = x_733;\n    let x_734 : u32 = face_2;\n    let x_736 : i32 = x_621.block_locations[x_734];\n    if ((x_736 == -1i)) {\n      block_dims_3.z = 4u;\n    }\n  }\n  let x_741 : vec3<u32> = block_dims_3;\n  return x_741;\n}\n\nfn voxel_id_to_voxel_u1_(id_2 : ptr<function, u32>) -> vec3<u32> {\n  let x_471 : u32 = *(id_2);\n  let x_473 : u32 = *(id_2);\n  let x_476 : u32 = *(id_2);\n  return vec3<u32>((x_471 % 4u), ((x_473 / 4u) % 4u), (x_476 / 16u));\n}\n\nfn compute_voxel_id_vu3_vu3_(voxel_pos : ptr<function, vec3<u32>>, block_dims : ptr<function, vec3<u32>>) -> u32 {\n  let x_483 : u32 = (*(voxel_pos)).x;\n  let x_485 : u32 = (*(block_dims)).x;\n  let x_487 : u32 = (*(voxel_pos)).y;\n  let x_489 : u32 = (*(block_dims)).y;\n  let x_491 : u32 = (*(voxel_pos)).z;\n  return (x_483 + (x_485 * (x_487 + (x_489 * x_491))));\n}\n\nfn load_voxel_u1_vu3_vu3_vu3_(neighbor_id : u32, ghost_voxel_pos : vec3<u32>, neighbor_voxel_pos : vec3<u32>, block_dims_2 : vec3<u32>) {\n  var neighbor_location : u32;\n  var ghost_voxel_id : u32;\n  var param_7 : vec3<u32>;\n  var param_8 : vec3<u32>;\n  var neighbor_voxel_id : u32;\n  var param_9 : vec3<u32>;\n  var param_10 : vec3<u32>;\n  let x_746 : i32 = x_621.block_locations[neighbor_id];\n  neighbor_location = bitcast<u32>(x_746);\n  param_7 = ghost_voxel_pos;\n  param_8 = block_dims_2;\n  let x_751 : u32 = compute_voxel_id_vu3_vu3_(&(param_7), &(param_8));\n  ghost_voxel_id = x_751;\n  param_9 = neighbor_voxel_pos;\n  param_10 = vec3<u32>(4u, 4u, 4u);\n  let x_755 : u32 = compute_voxel_id_vu3_vu3_(&(param_9), &(param_10));\n  neighbor_voxel_id = x_755;\n  let x_756 : u32 = ghost_voxel_id;\n  let x_761 : u32 = neighbor_location;\n  let x_764 : u32 = neighbor_voxel_id;\n  let x_768 : f32 = x_760.decompressed[((x_761 * 64u) + x_764)];\n  volume_block[x_756] = x_768;\n  return;\n}\n\nfn load_block_u1_(block_id : u32) -> vec3<u32> {\n  var block_pos_2 : vec3<u32>;\n  var param_11 : u32;\n  var n_blocks_3 : vec3<u32>;\n  var block_dims_4 : vec3<u32>;\n  var voxel_pos_2 : vec3<u32>;\n  var param_12 : u32;\n  var i_1 : u32;\n  var ghost_voxel_pos_1 : vec3<u32>;\n  var indexable_1 : array<vec3<u32>, 3u>;\n  var neighbor_voxel_pos_1 : vec3<u32>;\n  var indexable_2 : array<vec3<u32>, 3u>;\n  var indexable_3 : array<vec3<u32>, 3u>;\n  var neighbor_block_pos : vec3<u32>;\n  var indexable_4 : array<vec3<u32>, 3u>;\n  var neighbor_id_1 : u32;\n  var param_13 : vec3<u32>;\n  var i_2 : u32;\n  var b : vec3<u32>;\n  var indexable_5 : array<vec3<u32>, 3u>;\n  var p_3 : vec3<u32>;\n  var indexable_6 : array<vec3<u32>, 3u>;\n  var ghost_voxel_pos_2 : vec3<u32>;\n  var indexable_7 : array<vec3<u32>, 3u>;\n  var neighbor_voxel_pos_2 : vec3<u32>;\n  var indexable_8 : array<vec3<u32>, 3u>;\n  var indexable_9 : array<vec3<u32>, 3u>;\n  var indexable_10 : array<vec3<u32>, 3u>;\n  var neighbor_block_pos_1 : vec3<u32>;\n  var indexable_11 : array<vec3<u32>, 3u>;\n  var neighbor_id_2 : u32;\n  var param_14 : vec3<u32>;\n  var ghost_voxel_pos_3 : vec3<u32>;\n  var neighbor_block_pos_2 : vec3<u32>;\n  var neighbor_id_3 : u32;\n  var param_15 : vec3<u32>;\n  let x_774 : u32 = gl_LocalInvocationID.x;\n  volume_block[(x_774 * 2u)] = 0.0f;\n  let x_778 : u32 = gl_LocalInvocationID.x;\n  volume_block[((x_778 * 2u) + 1u)] = 0.0f;\n  workgroupBarrier();\n  param_11 = block_id;\n  let x_785 : vec3<u32> = block_id_to_pos_u1_(&(param_11));\n  block_pos_2 = x_785;\n  let x_788 : vec4<u32> = x_409.padded_dims;\n  n_blocks_3 = (vec3<u32>(x_788.x, x_788.y, x_788.z) / vec3<u32>(4u, 4u, 4u));\n  let x_792 : vec3<u32> = block_pos_2;\n  let x_793 : vec3<u32> = compute_block_dims_with_ghost_vu3_(x_792);\n  block_dims_4 = x_793;\n  let x_797 : u32 = gl_LocalInvocationID.x;\n  param_12 = x_797;\n  let x_798 : vec3<u32> = voxel_id_to_voxel_u1_(&(param_12));\n  voxel_pos_2 = x_798;\n  let x_799 : vec3<u32> = voxel_pos_2;\n  let x_800 : vec3<u32> = voxel_pos_2;\n  let x_801 : vec3<u32> = block_dims_4;\n  load_voxel_u1_vu3_vu3_vu3_(block_id, x_799, x_800, x_801);\n  i_1 = 0u;\n  loop {\n    var x_821 : bool;\n    var x_822 : bool;\n    let x_809 : u32 = i_1;\n    if ((x_809 < 3u)) {\n    } else {\n      break;\n    }\n    let x_812 : u32 = i_1;\n    let x_814 : u32 = block_dims_4[x_812];\n    let x_815 : bool = (x_814 == 5u);\n    x_822 = x_815;\n    if (x_815) {\n      let x_818 : u32 = i_1;\n      let x_820 : u32 = voxel_pos_2[x_818];\n      x_821 = (x_820 == 3u);\n      x_822 = x_821;\n    }\n    if (x_822) {\n      let x_826 : vec3<u32> = voxel_pos_2;\n      let x_829 : u32 = i_1;\n      indexable_1 = array<vec3<u32>, 3u>(vec3<u32>(1u, 0u, 0u), vec3<u32>(0u, 1u, 0u), vec3<u32>(0u, 0u, 1u));\n      let x_833 : vec3<u32> = indexable_1[x_829];\n      ghost_voxel_pos_1 = (x_826 + x_833);\n      let x_836 : vec3<u32> = ghost_voxel_pos_1;\n      neighbor_voxel_pos_1 = x_836;\n      let x_837 : u32 = i_1;\n      indexable_2 = array<vec3<u32>, 3u>(vec3<u32>(1u, 0u, 0u), vec3<u32>(0u, 1u, 0u), vec3<u32>(0u, 0u, 1u));\n      let x_840 : u32 = indexable_2[x_837].x;\n      if ((x_840 == 1u)) {\n        neighbor_voxel_pos_1.x = 0u;\n      } else {\n        let x_846 : u32 = i_1;\n        indexable_3 = array<vec3<u32>, 3u>(vec3<u32>(1u, 0u, 0u), vec3<u32>(0u, 1u, 0u), vec3<u32>(0u, 0u, 1u));\n        let x_849 : u32 = indexable_3[x_846].y;\n        if ((x_849 == 1u)) {\n          neighbor_voxel_pos_1.y = 0u;\n        } else {\n          neighbor_voxel_pos_1.z = 0u;\n        }\n      }\n      let x_857 : vec3<u32> = block_pos_2;\n      let x_858 : u32 = i_1;\n      indexable_4 = array<vec3<u32>, 3u>(vec3<u32>(1u, 0u, 0u), vec3<u32>(0u, 1u, 0u), vec3<u32>(0u, 0u, 1u));\n      let x_861 : vec3<u32> = indexable_4[x_858];\n      neighbor_block_pos = (x_857 + x_861);\n      let x_865 : vec3<u32> = neighbor_block_pos;\n      param_13 = x_865;\n      let x_866 : u32 = compute_block_id_vu3_(&(param_13));\n      neighbor_id_1 = x_866;\n      let x_867 : u32 = neighbor_id_1;\n      let x_868 : vec3<u32> = ghost_voxel_pos_1;\n      let x_869 : vec3<u32> = neighbor_voxel_pos_1;\n      let x_870 : vec3<u32> = block_dims_4;\n      load_voxel_u1_vu3_vu3_vu3_(x_867, x_868, x_869, x_870);\n    }\n\n    continuing {\n      let x_872 : u32 = i_1;\n      i_1 = (x_872 + bitcast<u32>(1i));\n    }\n  }\n  i_2 = 0u;\n  loop {\n    var x_918 : bool;\n    var x_919 : bool;\n    let x_880 : u32 = i_2;\n    if ((x_880 < 3u)) {\n    } else {\n      break;\n    }\n    let x_883 : vec3<u32> = block_dims_4;\n    let x_885 : u32 = i_2;\n    indexable_5 = array<vec3<u32>, 3u>(vec3<u32>(1u, 1u, 0u), vec3<u32>(1u, 0u, 1u), vec3<u32>(0u, 1u, 1u));\n    let x_888 : vec3<u32> = indexable_5[x_885];\n    b = (x_883 * x_888);\n    let x_891 : vec3<u32> = voxel_pos_2;\n    let x_892 : u32 = i_2;\n    indexable_6 = array<vec3<u32>, 3u>(vec3<u32>(1u, 1u, 0u), vec3<u32>(1u, 0u, 1u), vec3<u32>(0u, 1u, 1u));\n    let x_895 : vec3<u32> = indexable_6[x_892];\n    p_3 = (x_891 * x_895);\n    let x_898 : u32 = b.x;\n    let x_900 : u32 = b.y;\n    let x_903 : u32 = b.z;\n    let x_906 : bool = (((x_898 + x_900) + x_903) == 10u);\n    x_919 = x_906;\n    if (x_906) {\n      let x_910 : u32 = p_3.x;\n      let x_912 : u32 = p_3.y;\n      let x_915 : u32 = p_3.z;\n      x_918 = (((x_910 + x_912) + x_915) == 6u);\n      x_919 = x_918;\n    }\n    if (x_919) {\n      let x_923 : vec3<u32> = voxel_pos_2;\n      let x_924 : u32 = i_2;\n      indexable_7 = array<vec3<u32>, 3u>(vec3<u32>(1u, 1u, 0u), vec3<u32>(1u, 0u, 1u), vec3<u32>(0u, 1u, 1u));\n      let x_927 : vec3<u32> = indexable_7[x_924];\n      ghost_voxel_pos_2 = (x_923 + x_927);\n      let x_930 : vec3<u32> = ghost_voxel_pos_2;\n      neighbor_voxel_pos_2 = x_930;\n      let x_931 : u32 = i_2;\n      indexable_8 = array<vec3<u32>, 3u>(vec3<u32>(1u, 1u, 0u), vec3<u32>(1u, 0u, 1u), vec3<u32>(0u, 1u, 1u));\n      let x_934 : u32 = indexable_8[x_931].x;\n      if ((x_934 == 1u)) {\n        neighbor_voxel_pos_2.x = 0u;\n      }\n      let x_939 : u32 = i_2;\n      indexable_9 = array<vec3<u32>, 3u>(vec3<u32>(1u, 1u, 0u), vec3<u32>(1u, 0u, 1u), vec3<u32>(0u, 1u, 1u));\n      let x_942 : u32 = indexable_9[x_939].y;\n      if ((x_942 == 1u)) {\n        neighbor_voxel_pos_2.y = 0u;\n      }\n      let x_947 : u32 = i_2;\n      indexable_10 = array<vec3<u32>, 3u>(vec3<u32>(1u, 1u, 0u), vec3<u32>(1u, 0u, 1u), vec3<u32>(0u, 1u, 1u));\n      let x_950 : u32 = indexable_10[x_947].z;\n      if ((x_950 == 1u)) {\n        neighbor_voxel_pos_2.z = 0u;\n      }\n      let x_956 : vec3<u32> = block_pos_2;\n      let x_957 : u32 = i_2;\n      indexable_11 = array<vec3<u32>, 3u>(vec3<u32>(1u, 1u, 0u), vec3<u32>(1u, 0u, 1u), vec3<u32>(0u, 1u, 1u));\n      let x_960 : vec3<u32> = indexable_11[x_957];\n      neighbor_block_pos_1 = (x_956 + x_960);\n      let x_964 : vec3<u32> = neighbor_block_pos_1;\n      param_14 = x_964;\n      let x_965 : u32 = compute_block_id_vu3_(&(param_14));\n      neighbor_id_2 = x_965;\n      let x_966 : u32 = neighbor_id_2;\n      let x_967 : vec3<u32> = ghost_voxel_pos_2;\n      let x_968 : vec3<u32> = neighbor_voxel_pos_2;\n      let x_969 : vec3<u32> = block_dims_4;\n      load_voxel_u1_vu3_vu3_vu3_(x_966, x_967, x_968, x_969);\n    }\n\n    continuing {\n      let x_971 : u32 = i_2;\n      i_2 = (x_971 + bitcast<u32>(1i));\n    }\n  }\n  let x_973 : vec3<u32> = block_dims_4;\n  let x_976 : vec3<u32> = voxel_pos_2;\n  if ((all((x_973 == vec3<u32>(5u, 5u, 5u))) & all((x_976 == vec3<u32>(3u, 3u, 3u))))) {\n    let x_984 : vec3<u32> = voxel_pos_2;\n    ghost_voxel_pos_3 = (x_984 + vec3<u32>(1u, 1u, 1u));\n    let x_987 : vec3<u32> = block_pos_2;\n    neighbor_block_pos_2 = (x_987 + vec3<u32>(1u, 1u, 1u));\n    let x_991 : vec3<u32> = neighbor_block_pos_2;\n    param_15 = x_991;\n    let x_992 : u32 = compute_block_id_vu3_(&(param_15));\n    neighbor_id_3 = x_992;\n    let x_993 : u32 = neighbor_id_3;\n    let x_994 : vec3<u32> = ghost_voxel_pos_3;\n    let x_996 : vec3<u32> = block_dims_4;\n    load_voxel_u1_vu3_vu3_vu3_(x_993, x_994, vec3<u32>(0u, 0u, 0u), x_996);\n  }\n  workgroupBarrier();\n  let x_998 : vec3<u32> = block_dims_4;\n  return x_998;\n}\n\nfn ray_id_to_pos_u1_(id : ptr<function, u32>) -> vec2<u32> {\n  let x_405 : u32 = *(id);\n  let x_412 : u32 = x_409.image_width;\n  let x_414 : u32 = *(id);\n  let x_416 : u32 = x_409.image_width;\n  return vec2<u32>((x_405 % x_412), (x_414 / x_416));\n}\n\nfn intersect_box_vf3_vf3_vf3_vf3_(orig : ptr<function, vec3<f32>>, dir : ptr<function, vec3<f32>>, box_min : vec3<f32>, box_max : vec3<f32>) -> vec2<f32> {\n  var inv_dir : vec3<f32>;\n  var tmin_tmp : vec3<f32>;\n  var tmax_tmp : vec3<f32>;\n  var tmin : vec3<f32>;\n  var tmax : vec3<f32>;\n  var t0 : f32;\n  var t1 : f32;\n  let x_325 : vec3<f32> = *(dir);\n  inv_dir = (vec3<f32>(1.0f, 1.0f, 1.0f) / x_325);\n  let x_329 : vec3<f32> = *(orig);\n  let x_331 : vec3<f32> = inv_dir;\n  tmin_tmp = ((box_min - x_329) * x_331);\n  let x_334 : vec3<f32> = *(orig);\n  let x_336 : vec3<f32> = inv_dir;\n  tmax_tmp = ((box_max - x_334) * x_336);\n  let x_339 : vec3<f32> = tmin_tmp;\n  let x_340 : vec3<f32> = tmax_tmp;\n  tmin = min(x_339, x_340);\n  let x_343 : vec3<f32> = tmin_tmp;\n  let x_344 : vec3<f32> = tmax_tmp;\n  tmax = max(x_343, x_344);\n  let x_348 : f32 = tmin.x;\n  let x_350 : f32 = tmin.y;\n  let x_352 : f32 = tmin.z;\n  t0 = max(x_348, max(x_350, x_352));\n  let x_357 : f32 = tmax.x;\n  let x_359 : f32 = tmax.y;\n  let x_361 : f32 = tmax.z;\n  t1 = min(x_357, min(x_359, x_361));\n  let x_364 : f32 = t0;\n  let x_365 : f32 = t1;\n  return vec2<f32>(x_364, x_365);\n}\n\nfn init_grid_iterator_vf3_vf3_f1_vi3_(ray_org : ptr<function, vec3<f32>>, ray_dir : ptr<function, vec3<f32>>, t : ptr<function, f32>, grid_dims_1 : ptr<function, vec3<i32>>) -> GridIterator {\n  var grid_iter : GridIterator;\n  var inv_ray_dir : vec3<f32>;\n  var p_2 : vec3<f32>;\n  var cell : vec3<f32>;\n  var t_max_neg : vec3<f32>;\n  var t_max_pos : vec3<f32>;\n  var is_neg_dir : vec3<bool>;\n  let x_159 : vec3<i32> = *(grid_dims_1);\n  grid_iter.grid_dims = x_159;\n  let x_162 : vec3<f32> = *(ray_dir);\n  grid_iter.grid_step = vec3<i32>(sign(x_162));\n  let x_168 : vec3<f32> = *(ray_dir);\n  inv_ray_dir = (vec3<f32>(1.0f, 1.0f, 1.0f) / x_168);\n  let x_172 : vec3<f32> = inv_ray_dir;\n  grid_iter.t_delta = abs(x_172);\n  let x_176 : vec3<f32> = *(ray_org);\n  let x_177 : f32 = *(t);\n  let x_178 : vec3<f32> = *(ray_dir);\n  p_2 = (x_176 + (x_178 * x_177));\n  let x_181 : vec3<f32> = p_2;\n  let x_184 : vec3<i32> = *(grid_dims_1);\n  p_2 = clamp(x_181, vec3<f32>(0.0f, 0.0f, 0.0f), vec3<f32>((x_184 - vec3<i32>(1i, 1i, 1i))));\n  let x_190 : vec3<f32> = p_2;\n  cell = floor(x_190);\n  let x_193 : vec3<f32> = cell;\n  let x_194 : vec3<f32> = *(ray_org);\n  let x_196 : vec3<f32> = inv_ray_dir;\n  t_max_neg = ((x_193 - x_194) * x_196);\n  let x_199 : vec3<f32> = cell;\n  let x_202 : vec3<f32> = *(ray_org);\n  let x_204 : vec3<f32> = inv_ray_dir;\n  t_max_pos = (((x_199 + vec3<f32>(1.0f, 1.0f, 1.0f)) - x_202) * x_204);\n  let x_208 : vec3<f32> = *(ray_dir);\n  is_neg_dir = (x_208 < vec3<f32>(0.0f, 0.0f, 0.0f));\n  let x_211 : vec3<f32> = t_max_pos;\n  let x_212 : vec3<f32> = t_max_neg;\n  let x_213 : vec3<bool> = is_neg_dir;\n  grid_iter.t_max = select(x_211, x_212, x_213);\n  let x_217 : vec3<f32> = cell;\n  grid_iter.cell = vec3<i32>(x_217);\n  let x_221 : f32 = *(t);\n  grid_iter.t = x_221;\n  let x_223 : GridIterator = grid_iter;\n  return x_223;\n}\n\nfn outside_grid_vi3_vi3_(p : vec3<i32>, grid_dims : vec3<i32>) -> bool {\n  var x_154 : bool;\n  var x_155 : bool;\n  let x_149 : bool = any((p < vec3<i32>(0i, 0i, 0i)));\n  x_155 = x_149;\n  if (!(x_149)) {\n    x_154 = any((p >= grid_dims));\n    x_155 = x_154;\n  }\n  return x_155;\n}\n\nfn grid_iterator_get_cell_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_vf2_vi3_(iter : ptr<function, GridIterator>, cell_t_range : ptr<function, vec2<f32>>, cell_id : ptr<function, vec3<i32>>) -> bool {\n  let x_227 : vec3<i32> = (*(iter)).cell;\n  let x_229 : vec3<i32> = (*(iter)).grid_dims;\n  let x_230 : bool = outside_grid_vi3_vi3_(x_227, x_229);\n  if (x_230) {\n    return false;\n  }\n  let x_236 : f32 = (*(iter)).t;\n  (*(cell_t_range)).x = x_236;\n  let x_240 : f32 = (*(iter)).t_max.x;\n  let x_243 : f32 = (*(iter)).t_max.y;\n  let x_245 : f32 = (*(iter)).t_max.z;\n  (*(cell_t_range)).y = min(x_240, min(x_243, x_245));\n  let x_250 : vec3<i32> = (*(iter)).cell;\n  *(cell_id) = x_250;\n  let x_252 : f32 = (*(cell_t_range)).y;\n  let x_254 : f32 = (*(cell_t_range)).x;\n  if ((x_252 < x_254)) {\n    return false;\n  }\n  return true;\n}\n\nfn compute_vertex_values_vu3_vu3_f1_8__vf2_(voxel_pos_1 : ptr<function, vec3<u32>>, block_dims_1 : ptr<function, vec3<u32>>, values : ptr<function, array<f32, 8u>>, value_range : ptr<function, vec2<f32>>) {\n  var i : i32;\n  var v : vec3<u32>;\n  var indexable : array<vec3<i32>, 8u>;\n  var voxel : u32;\n  (*(value_range)).x = 100000002004087734272.0f;\n  (*(value_range)).y = -100000002004087734272.0f;\n  i = 0i;\n  loop {\n    let x_508 : i32 = i;\n    if ((x_508 < 8i)) {\n    } else {\n      break;\n    }\n    let x_520 : i32 = i;\n    indexable = array<vec3<i32>, 8u>(vec3<i32>(0i, 0i, 0i), vec3<i32>(1i, 0i, 0i), vec3<i32>(0i, 1i, 0i), vec3<i32>(1i, 1i, 0i), vec3<i32>(0i, 0i, 1i), vec3<i32>(1i, 0i, 1i), vec3<i32>(0i, 1i, 1i), vec3<i32>(1i, 1i, 1i));\n    let x_524 : vec3<i32> = indexable[x_520];\n    v = bitcast<vec3<u32>>(x_524);\n    let x_528 : u32 = (*(voxel_pos_1)).z;\n    let x_530 : u32 = v.z;\n    let x_533 : u32 = (*(block_dims_1)).y;\n    let x_536 : u32 = (*(voxel_pos_1)).y;\n    let x_539 : u32 = v.y;\n    let x_542 : u32 = (*(block_dims_1)).x;\n    let x_545 : u32 = (*(voxel_pos_1)).x;\n    let x_548 : u32 = v.x;\n    voxel = (((((((x_528 + x_530) * x_533) + x_536) + x_539) * x_542) + x_545) + x_548);\n    let x_550 : i32 = i;\n    let x_555 : u32 = voxel;\n    let x_558 : f32 = volume_block[x_555];\n    (*(values))[x_550] = x_558;\n    let x_561 : f32 = (*(value_range)).x;\n    let x_562 : i32 = i;\n    let x_564 : f32 = (*(values))[x_562];\n    (*(value_range)).x = min(x_561, x_564);\n    let x_568 : f32 = (*(value_range)).y;\n    let x_569 : i32 = i;\n    let x_571 : f32 = (*(values))[x_569];\n    (*(value_range)).y = max(x_568, x_571);\n\n    continuing {\n      let x_574 : i32 = i;\n      i = (x_574 + 1i);\n    }\n  }\n  return;\n}\n\nfn compute_polynomial_vf3_vf3_vf3_f1_8__(p_1 : vec3<f32>, dir_1 : vec3<f32>, v000 : vec3<f32>, values_1 : ptr<function, array<f32, 8u>>) -> vec4<f32> {\n  var v111 : vec3<f32>;\n  var a : array<vec3<f32>, 2u>;\n  var b_1 : array<vec3<f32>, 2u>;\n  var poly_2 : vec4<f32>;\n  var k : i32;\n  var j : i32;\n  var i_3 : i32;\n  var val : f32;\n  v111 = (v000 + vec3<f32>(1.0f, 1.0f, 1.0f));\n  let x_1006 : vec3<f32> = v111;\n  a = array<vec3<f32>, 2u>((x_1006 - p_1), (p_1 - v000));\n  b_1 = array<vec3<f32>, 2u>(-(dir_1), dir_1);\n  poly_2 = vec4<f32>(0.0f, 0.0f, 0.0f, 0.0f);\n  k = 0i;\n  loop {\n    let x_1022 : i32 = k;\n    if ((x_1022 < 2i)) {\n    } else {\n      break;\n    }\n    j = 0i;\n    loop {\n      let x_1030 : i32 = j;\n      if ((x_1030 < 2i)) {\n      } else {\n        break;\n      }\n      i_3 = 0i;\n      loop {\n        let x_1038 : i32 = i_3;\n        if ((x_1038 < 2i)) {\n        } else {\n          break;\n        }\n        let x_1041 : i32 = i_3;\n        let x_1042 : i32 = j;\n        let x_1043 : i32 = k;\n        let x_1049 : f32 = (*(values_1))[(x_1041 + (2i * (x_1042 + (2i * x_1043))))];\n        val = x_1049;\n        let x_1050 : i32 = i_3;\n        let x_1052 : f32 = b_1[x_1050].x;\n        let x_1053 : i32 = j;\n        let x_1055 : f32 = b_1[x_1053].y;\n        let x_1057 : i32 = k;\n        let x_1059 : f32 = b_1[x_1057].z;\n        let x_1061 : f32 = val;\n        let x_1064 : f32 = poly_2.x;\n        poly_2.x = (x_1064 + (((x_1052 * x_1055) * x_1059) * x_1061));\n        let x_1067 : i32 = i_3;\n        let x_1069 : f32 = a[x_1067].x;\n        let x_1070 : i32 = j;\n        let x_1072 : f32 = b_1[x_1070].y;\n        let x_1074 : i32 = k;\n        let x_1076 : f32 = b_1[x_1074].z;\n        let x_1078 : i32 = i_3;\n        let x_1080 : f32 = b_1[x_1078].x;\n        let x_1081 : i32 = j;\n        let x_1083 : f32 = a[x_1081].y;\n        let x_1085 : i32 = k;\n        let x_1087 : f32 = b_1[x_1085].z;\n        let x_1090 : i32 = i_3;\n        let x_1092 : f32 = b_1[x_1090].x;\n        let x_1093 : i32 = j;\n        let x_1095 : f32 = b_1[x_1093].y;\n        let x_1097 : i32 = k;\n        let x_1099 : f32 = a[x_1097].z;\n        let x_1102 : f32 = val;\n        let x_1105 : f32 = poly_2.y;\n        poly_2.y = (x_1105 + (((((x_1069 * x_1072) * x_1076) + ((x_1080 * x_1083) * x_1087)) + ((x_1092 * x_1095) * x_1099)) * x_1102));\n        let x_1108 : i32 = i_3;\n        let x_1110 : f32 = b_1[x_1108].x;\n        let x_1111 : i32 = j;\n        let x_1113 : f32 = a[x_1111].y;\n        let x_1115 : i32 = k;\n        let x_1117 : f32 = a[x_1115].z;\n        let x_1119 : i32 = i_3;\n        let x_1121 : f32 = a[x_1119].x;\n        let x_1122 : i32 = j;\n        let x_1124 : f32 = b_1[x_1122].y;\n        let x_1126 : i32 = k;\n        let x_1128 : f32 = a[x_1126].z;\n        let x_1131 : i32 = i_3;\n        let x_1133 : f32 = a[x_1131].x;\n        let x_1134 : i32 = j;\n        let x_1136 : f32 = a[x_1134].y;\n        let x_1138 : i32 = k;\n        let x_1140 : f32 = b_1[x_1138].z;\n        let x_1143 : f32 = val;\n        let x_1146 : f32 = poly_2.z;\n        poly_2.z = (x_1146 + (((((x_1110 * x_1113) * x_1117) + ((x_1121 * x_1124) * x_1128)) + ((x_1133 * x_1136) * x_1140)) * x_1143));\n        let x_1149 : i32 = i_3;\n        let x_1151 : f32 = a[x_1149].x;\n        let x_1152 : i32 = j;\n        let x_1154 : f32 = a[x_1152].y;\n        let x_1156 : i32 = k;\n        let x_1158 : f32 = a[x_1156].z;\n        let x_1160 : f32 = val;\n        let x_1163 : f32 = poly_2.w;\n        poly_2.w = (x_1163 + (((x_1151 * x_1154) * x_1158) * x_1160));\n\n        continuing {\n          let x_1166 : i32 = i_3;\n          i_3 = (x_1166 + 1i);\n        }\n      }\n\n      continuing {\n        let x_1168 : i32 = j;\n        j = (x_1168 + 1i);\n      }\n    }\n\n    continuing {\n      let x_1170 : i32 = k;\n      k = (x_1170 + 1i);\n    }\n  }\n  let x_1172 : vec4<f32> = poly_2;\n  return x_1172;\n}\n\nfn evaluate_polynomial_vf4_f1_(poly : vec4<f32>, t_1 : f32) -> f32 {\n  return ((((((poly.x * t_1) * t_1) * t_1) + ((poly.y * t_1) * t_1)) + (poly.z * t_1)) + poly.w);\n}\n\nfn solve_quadratic_vf3_f1_2__(poly_1 : vec3<f32>, roots : ptr<function, array<f32, 2u>>) -> bool {\n  var discriminant : f32;\n  var r : vec2<f32>;\n  if ((poly_1.x == 0.0f)) {\n    (*(roots))[0i] = (-(poly_1.z) / poly_1.y);\n    (*(roots))[1i] = (-(poly_1.z) / poly_1.y);\n    return true;\n  }\n  discriminant = ((poly_1.y * poly_1.y) - ((4.0f * poly_1.x) * poly_1.z));\n  let x_1215 : f32 = discriminant;\n  if ((x_1215 < 0.0f)) {\n    return false;\n  }\n  let x_1220 : f32 = discriminant;\n  discriminant = sqrt(x_1220);\n  let x_1226 : f32 = discriminant;\n  let x_1230 : f32 = discriminant;\n  let x_1234 : f32 = poly_1.x;\n  r = ((vec2<f32>((-(poly_1.y) + x_1226), (-(poly_1.y) - x_1230)) * 0.5f) / vec2<f32>(x_1234, x_1234));\n  let x_1238 : f32 = r.x;\n  let x_1240 : f32 = r.y;\n  (*(roots))[0i] = min(x_1238, x_1240);\n  let x_1244 : f32 = r.x;\n  let x_1246 : f32 = r.y;\n  (*(roots))[1i] = max(x_1244, x_1246);\n  return true;\n}\n\nfn marmitt_intersect_vf3_vf3_vf3_f1_8__f1_f1_f1_(vol_eye : vec3<f32>, grid_ray_dir : vec3<f32>, v000_2 : vec3<f32>, vertex_values_1 : array<f32, 8u>, t_prev : f32, t_next : f32, t_hit : ptr<function, f32>) -> bool {\n  var cell_p : vec3<f32>;\n  var t_in : f32;\n  var t_out : f32;\n  var cell_ray_dir : vec3<f32>;\n  var poly_3 : vec4<f32>;\n  var param_16 : array<f32, 8u>;\n  var f_in : f32;\n  var f_out : f32;\n  var roots_1 : array<f32, 2u>;\n  var param_17 : array<f32, 2u>;\n  var f_root0 : f32;\n  var f_root1 : f32;\n  var i_5 : i32;\n  var t_2 : f32;\n  var f_t : f32;\n  var cell_t_hit : f32;\n  var hit_p_1 : vec3<f32>;\n  if ((t_next <= t_prev)) {\n    return false;\n  }\n  var x_1472 : bool;\n  var x_1473 : bool;\n  var x_1504 : bool;\n  var x_1505 : bool;\n  cell_p = (vol_eye + (grid_ray_dir * (t_prev + ((t_next - t_prev) * 0.5f))));\n  t_in = ((-((t_next - t_prev)) * 0.5f) * length(grid_ray_dir));\n  t_out = (((t_next - t_prev) * 0.5f) * length(grid_ray_dir));\n  cell_ray_dir = normalize(grid_ray_dir);\n  let x_1427 : vec3<f32> = cell_p;\n  let x_1428 : vec3<f32> = cell_ray_dir;\n  param_16 = vertex_values_1;\n  let x_1430 : vec4<f32> = compute_polynomial_vf3_vf3_vf3_f1_8__(x_1427, x_1428, v000_2, &(param_16));\n  poly_3 = x_1430;\n  let x_1432 : f32 = x_409.isovalue;\n  let x_1434 : f32 = poly_3.w;\n  poly_3.w = (x_1434 - x_1432);\n  let x_1438 : vec4<f32> = poly_3;\n  let x_1439 : f32 = t_in;\n  let x_1440 : f32 = evaluate_polynomial_vf4_f1_(x_1438, x_1439);\n  f_in = x_1440;\n  let x_1442 : vec4<f32> = poly_3;\n  let x_1443 : f32 = t_out;\n  let x_1444 : f32 = evaluate_polynomial_vf4_f1_(x_1442, x_1443);\n  f_out = x_1444;\n  roots_1 = array<f32, 2u>(0.0f, 0.0f);\n  let x_1449 : f32 = poly_3.x;\n  let x_1453 : f32 = poly_3.y;\n  let x_1456 : f32 = poly_3.z;\n  let x_1459 : bool = solve_quadratic_vf3_f1_2__(vec3<f32>((3.0f * x_1449), (2.0f * x_1453), x_1456), &(param_17));\n  let x_1460 : array<f32, 2u> = param_17;\n  roots_1 = x_1460;\n  if (x_1459) {\n    let x_1464 : f32 = roots_1[0i];\n    let x_1465 : f32 = t_in;\n    let x_1466 : bool = (x_1464 >= x_1465);\n    x_1473 = x_1466;\n    if (x_1466) {\n      let x_1470 : f32 = roots_1[0i];\n      let x_1471 : f32 = t_out;\n      x_1472 = (x_1470 <= x_1471);\n      x_1473 = x_1472;\n    }\n    if (x_1473) {\n      let x_1477 : vec4<f32> = poly_3;\n      let x_1479 : f32 = roots_1[0i];\n      let x_1480 : f32 = evaluate_polynomial_vf4_f1_(x_1477, x_1479);\n      f_root0 = x_1480;\n      let x_1481 : f32 = f_root0;\n      let x_1483 : f32 = f_in;\n      if ((sign(x_1481) == sign(x_1483))) {\n        let x_1489 : f32 = roots_1[0i];\n        t_in = x_1489;\n        let x_1490 : f32 = f_root0;\n        f_in = x_1490;\n      } else {\n        let x_1493 : f32 = roots_1[0i];\n        t_out = x_1493;\n        let x_1494 : f32 = f_root0;\n        f_out = x_1494;\n      }\n    }\n    let x_1496 : f32 = roots_1[1i];\n    let x_1497 : f32 = t_in;\n    let x_1498 : bool = (x_1496 >= x_1497);\n    x_1505 = x_1498;\n    if (x_1498) {\n      let x_1502 : f32 = roots_1[1i];\n      let x_1503 : f32 = t_out;\n      x_1504 = (x_1502 <= x_1503);\n      x_1505 = x_1504;\n    }\n    if (x_1505) {\n      let x_1509 : vec4<f32> = poly_3;\n      let x_1511 : f32 = roots_1[1i];\n      let x_1512 : f32 = evaluate_polynomial_vf4_f1_(x_1509, x_1511);\n      f_root1 = x_1512;\n      let x_1513 : f32 = f_root1;\n      let x_1515 : f32 = f_in;\n      if ((sign(x_1513) == sign(x_1515))) {\n        let x_1521 : f32 = roots_1[1i];\n        t_in = x_1521;\n        let x_1522 : f32 = f_root1;\n        f_in = x_1522;\n      } else {\n        let x_1525 : f32 = roots_1[1i];\n        t_out = x_1525;\n        let x_1526 : f32 = f_root1;\n        f_out = x_1526;\n      }\n    }\n  }\n  let x_1527 : f32 = f_in;\n  let x_1529 : f32 = f_out;\n  if (!((sign(x_1527) == sign(x_1529)))) {\n    i_5 = 0i;\n    loop {\n      let x_1540 : i32 = i_5;\n      if ((x_1540 < 3i)) {\n      } else {\n        break;\n      }\n      let x_1543 : f32 = t_in;\n      let x_1544 : f32 = t_out;\n      let x_1545 : f32 = t_in;\n      let x_1547 : f32 = f_in;\n      let x_1550 : f32 = f_out;\n      let x_1551 : f32 = f_in;\n      t_2 = (x_1543 + (((x_1544 - x_1545) * -(x_1547)) / (x_1550 - x_1551)));\n      let x_1556 : vec4<f32> = poly_3;\n      let x_1557 : f32 = t_2;\n      let x_1558 : f32 = evaluate_polynomial_vf4_f1_(x_1556, x_1557);\n      f_t = x_1558;\n      let x_1559 : f32 = f_t;\n      let x_1561 : f32 = f_in;\n      if ((sign(x_1559) == sign(x_1561))) {\n        let x_1566 : f32 = t_2;\n        t_in = x_1566;\n        let x_1567 : f32 = f_t;\n        f_in = x_1567;\n      } else {\n        let x_1569 : f32 = t_2;\n        t_out = x_1569;\n        let x_1570 : f32 = f_t;\n        f_out = x_1570;\n      }\n\n      continuing {\n        let x_1571 : i32 = i_5;\n        i_5 = (x_1571 + 1i);\n      }\n    }\n    let x_1574 : f32 = t_in;\n    let x_1575 : f32 = t_out;\n    let x_1576 : f32 = t_in;\n    let x_1578 : f32 = f_in;\n    let x_1581 : f32 = f_out;\n    let x_1582 : f32 = f_in;\n    cell_t_hit = (x_1574 + (((x_1575 - x_1576) * -(x_1578)) / (x_1581 - x_1582)));\n    let x_1587 : vec3<f32> = cell_p;\n    let x_1588 : vec3<f32> = cell_ray_dir;\n    let x_1589 : f32 = cell_t_hit;\n    hit_p_1 = (x_1587 + (x_1588 * x_1589));\n    let x_1592 : vec3<f32> = hit_p_1;\n    *(t_hit) = (length((x_1592 - vol_eye)) / length(grid_ray_dir));\n    return true;\n  }\n  return false;\n}\n\nfn grid_iterator_advance_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_(iter_1 : ptr<function, GridIterator>) {\n  let x_263 : f32 = (*(iter_1)).t_max.x;\n  let x_265 : f32 = (*(iter_1)).t_max.y;\n  let x_267 : f32 = (*(iter_1)).t_max.z;\n  (*(iter_1)).t = min(x_263, min(x_265, x_267));\n  let x_272 : f32 = (*(iter_1)).t;\n  let x_274 : f32 = (*(iter_1)).t_max.x;\n  if ((x_272 == x_274)) {\n    let x_280 : i32 = (*(iter_1)).grid_step.x;\n    let x_282 : i32 = (*(iter_1)).cell.x;\n    (*(iter_1)).cell.x = (x_282 + x_280);\n    let x_286 : f32 = (*(iter_1)).t_delta.x;\n    let x_288 : f32 = (*(iter_1)).t_max.x;\n    (*(iter_1)).t_max.x = (x_288 + x_286);\n  } else {\n    let x_293 : f32 = (*(iter_1)).t;\n    let x_295 : f32 = (*(iter_1)).t_max.y;\n    if ((x_293 == x_295)) {\n      let x_300 : i32 = (*(iter_1)).grid_step.y;\n      let x_302 : i32 = (*(iter_1)).cell.y;\n      (*(iter_1)).cell.y = (x_302 + x_300);\n      let x_306 : f32 = (*(iter_1)).t_delta.y;\n      let x_308 : f32 = (*(iter_1)).t_max.y;\n      (*(iter_1)).t_max.y = (x_308 + x_306);\n    } else {\n      let x_313 : i32 = (*(iter_1)).grid_step.z;\n      let x_315 : i32 = (*(iter_1)).cell.z;\n      (*(iter_1)).cell.z = (x_315 + x_313);\n      let x_319 : f32 = (*(iter_1)).t_delta.z;\n      let x_321 : f32 = (*(iter_1)).t_max.z;\n      (*(iter_1)).t_max.z = (x_321 + x_319);\n    }\n  }\n  return;\n}\n\nfn compute_normal_vi3_vf3_f1_8__(v000_1 : vec3<i32>, hit_p : vec3<f32>, vertex_values : array<f32, 8u>) -> vec3<f32> {\n  var N_1 : vec3<f32>;\n  var v111_1 : vec3<f32>;\n  var a_1 : array<vec3<f32>, 2u>;\n  var k_1 : i32;\n  var j_1 : i32;\n  var i_4 : i32;\n  var val_1 : f32;\n  var indexable_12 : array<f32, 8u>;\n  var indexable_13 : array<f32, 2u>;\n  var indexable_14 : array<f32, 2u>;\n  var indexable_15 : array<f32, 2u>;\n  N_1 = vec3<f32>(0.0f, 0.0f, 0.0f);\n  v111_1 = (vec3<f32>(v000_1) + vec3<f32>(1.0f, 1.0f, 1.0f));\n  let x_1297 : vec3<f32> = v111_1;\n  a_1 = array<vec3<f32>, 2u>((x_1297 - hit_p), (hit_p - vec3<f32>(v000_1)));\n  k_1 = 0i;\n  loop {\n    let x_1308 : i32 = k_1;\n    if ((x_1308 < 2i)) {\n    } else {\n      break;\n    }\n    j_1 = 0i;\n    loop {\n      let x_1316 : i32 = j_1;\n      if ((x_1316 < 2i)) {\n      } else {\n        break;\n      }\n      i_4 = 0i;\n      loop {\n        let x_1324 : i32 = i_4;\n        if ((x_1324 < 2i)) {\n        } else {\n          break;\n        }\n        let x_1327 : i32 = i_4;\n        let x_1328 : i32 = j_1;\n        let x_1329 : i32 = k_1;\n        indexable_12 = vertex_values;\n        let x_1336 : f32 = indexable_12[(x_1327 + (2i * (x_1328 + (2i * x_1329))))];\n        val_1 = x_1336;\n        let x_1339 : i32 = i_4;\n        indexable_13 = array<f32, 2u>(-1.0f, 1.0f);\n        let x_1342 : f32 = indexable_13[x_1339];\n        let x_1343 : i32 = j_1;\n        let x_1345 : f32 = a_1[x_1343].y;\n        let x_1347 : i32 = k_1;\n        let x_1349 : f32 = a_1[x_1347].z;\n        let x_1351 : f32 = val_1;\n        let x_1354 : f32 = N_1.x;\n        N_1.x = (x_1354 + (((x_1342 * x_1345) * x_1349) * x_1351));\n        let x_1357 : i32 = j_1;\n        indexable_14 = array<f32, 2u>(-1.0f, 1.0f);\n        let x_1360 : f32 = indexable_14[x_1357];\n        let x_1361 : i32 = i_4;\n        let x_1363 : f32 = a_1[x_1361].x;\n        let x_1365 : i32 = k_1;\n        let x_1367 : f32 = a_1[x_1365].z;\n        let x_1369 : f32 = val_1;\n        let x_1372 : f32 = N_1.y;\n        N_1.y = (x_1372 + (((x_1360 * x_1363) * x_1367) * x_1369));\n        let x_1375 : i32 = k_1;\n        indexable_15 = array<f32, 2u>(-1.0f, 1.0f);\n        let x_1378 : f32 = indexable_15[x_1375];\n        let x_1379 : i32 = i_4;\n        let x_1381 : f32 = a_1[x_1379].x;\n        let x_1383 : i32 = j_1;\n        let x_1385 : f32 = a_1[x_1383].y;\n        let x_1387 : f32 = val_1;\n        let x_1390 : f32 = N_1.z;\n        N_1.z = (x_1390 + (((x_1378 * x_1381) * x_1385) * x_1387));\n\n        continuing {\n          let x_1393 : i32 = i_4;\n          i_4 = (x_1393 + 1i);\n        }\n      }\n\n      continuing {\n        let x_1395 : i32 = j_1;\n        j_1 = (x_1395 + 1i);\n      }\n    }\n\n    continuing {\n      let x_1397 : i32 = k_1;\n      k_1 = (x_1397 + 1i);\n    }\n  }\n  let x_1399 : vec3<f32> = N_1;\n  return normalize(x_1399);\n}\n\nfn shading_vf3_vf3_vf3_vf3_(N : ptr<function, vec3<f32>>, V : ptr<function, vec3<f32>>, L : ptr<function, vec3<f32>>, base_color : ptr<function, vec3<f32>>) -> vec3<f32> {\n  var H : vec3<f32>;\n  var c_1 : vec3<f32>;\n  var temp : f32;\n  let x_1252 : vec3<f32> = *(V);\n  let x_1253 : vec3<f32> = *(L);\n  H = normalize((x_1252 + x_1253));\n  let x_1257 : vec3<f32> = *(base_color);\n  c_1 = (x_1257 * 0.200000003f);\n  let x_1261 : vec3<f32> = *(L);\n  let x_1262 : vec3<f32> = *(N);\n  let x_1266 : vec3<f32> = *(base_color);\n  let x_1268 : vec3<f32> = c_1;\n  c_1 = (x_1268 + (x_1266 * (0.600000024f * clamp(dot(x_1261, x_1262), 0.0f, 1.0f))));\n  let x_1271 : vec3<f32> = H;\n  let x_1272 : vec3<f32> = *(N);\n  temp = clamp(dot(x_1271, x_1272), 0.0f, 1.0f);\n  let x_1276 : f32 = temp;\n  let x_1278 : f32 = temp;\n  let x_1280 : f32 = temp;\n  let x_1282 : f32 = temp;\n  let x_1284 : f32 = temp;\n  let x_1285 : f32 = (((((0.100000001f * x_1276) * x_1278) * x_1280) * x_1282) * x_1284);\n  let x_1286 : vec3<f32> = c_1;\n  c_1 = (x_1286 + vec3<f32>(x_1285, x_1285, x_1285));\n  let x_1289 : vec3<f32> = c_1;\n  return x_1289;\n}\n\nfn pack_color_vf3_(rgb : ptr<function, vec3<f32>>) -> i32 {\n  var rbg256 : vec3<i32>;\n  var c : i32;\n  let x_370 : vec3<f32> = *(rgb);\n  rbg256 = clamp(vec3<i32>((x_370 * 255.0f)), vec3<i32>(0i, 0i, 0i), vec3<i32>(255i, 255i, 255i));\n  c = 0i;\n  let x_379 : i32 = rbg256.x;\n  let x_384 : i32 = c;\n  c = (x_384 | ((x_379 << bitcast<u32>(24i)) & -16777216i));\n  let x_387 : i32 = rbg256.y;\n  let x_392 : i32 = c;\n  c = (x_392 | ((x_387 << bitcast<u32>(16i)) & 16711680i));\n  let x_395 : i32 = rbg256.z;\n  let x_400 : i32 = c;\n  c = (x_400 | ((x_395 << bitcast<u32>(8i)) & 65280i));\n  let x_402 : i32 = c;\n  return x_402;\n}\n\nfn main_1() {\n  var block_dims_5 : vec3<u32>;\n  var n_blocks_4 : vec3<u32>;\n  var block_pos_3 : vec3<u32>;\n  var param_18 : u32;\n  var volume_translation : vec3<f32>;\n  var transformed_eye : vec3<f32>;\n  var vol_eye_1 : vec3<f32>;\n  var chunks : u32;\n  var i_6 : u32;\n  var pixel_coords : vec2<i32>;\n  var color : vec4<f32>;\n  var ray_id : u32;\n  var ray_index : u32;\n  var param_19 : u32;\n  var spec_index : u32;\n  var grid_ray_dir_1 : vec3<f32>;\n  var hit_surface : bool;\n  var hit_p_2 : vec3<f32>;\n  var cell_range : vec2<f32>;\n  var brick_range : vec2<f32>;\n  var param_20 : vec3<f32>;\n  var param_21 : vec3<f32>;\n  var grid_iter_1 : GridIterator;\n  var param_22 : vec3<f32>;\n  var param_23 : vec3<f32>;\n  var param_24 : f32;\n  var param_25 : vec3<i32>;\n  var v000_3 : vec3<i32>;\n  var cell_t_range_1 : vec2<f32>;\n  var param_26 : GridIterator;\n  var param_27 : vec2<f32>;\n  var param_28 : vec3<i32>;\n  var vertex_values_2 : array<f32, 8u>;\n  var param_29 : vec3<u32>;\n  var param_30 : vec3<u32>;\n  var param_31 : array<f32, 8u>;\n  var param_32 : vec2<f32>;\n  var skip_cell : bool;\n  var t_hit_1 : f32;\n  var param_33 : f32;\n  var param_34 : GridIterator;\n  var N_2 : vec3<f32>;\n  var L_1 : vec3<f32>;\n  var V_1 : vec3<f32>;\n  var param_35 : vec3<f32>;\n  var param_36 : vec3<f32>;\n  var param_37 : vec3<f32>;\n  var param_38 : vec3<f32>;\n  var param_39 : vec3<f32>;\n  let x_1601 : u32 = gl_LocalInvocationID.x;\n  if ((x_1601 == 0u)) {\n    let x_1615 : u32 = gl_WorkGroupID.x;\n    let x_1620 : u32 = x_1618.id_offset;\n    let x_1624 : BlockInfo_1 = x_1612.blocks[(x_1615 + x_1620)];\n    block_info.id = x_1624.id;\n    block_info.ray_offset = x_1624.ray_offset;\n    block_info.num_rays = x_1624.num_rays;\n    block_info.lod = x_1624.lod;\n  }\n  workgroupBarrier();\n  let x_1636 : u32 = block_info.id;\n  let x_1637 : vec3<u32> = load_block_u1_(x_1636);\n  block_dims_5 = x_1637;\n  let x_1639 : u32 = gl_WorkGroupID.x;\n  let x_1641 : u32 = x_1618.id_offset;\n  let x_1644 : u32 = x_1618.total_active_blocks;\n  if (((x_1639 + x_1641) >= x_1644)) {\n    return;\n  }\n  let x_1650 : u32 = block_info.num_rays;\n  if ((x_1650 == 0u)) {\n    return;\n  }\n  let x_1657 : vec4<u32> = x_409.padded_dims;\n  n_blocks_4 = (vec3<u32>(x_1657.x, x_1657.y, x_1657.z) / vec3<u32>(4u, 4u, 4u));\n  let x_1663 : u32 = block_info.id;\n  param_18 = x_1663;\n  let x_1664 : vec3<u32> = block_id_to_pos_u1_(&(param_18));\n  block_pos_3 = (x_1664 * vec3<u32>(4u, 4u, 4u));\n  let x_1670 : vec4<f32> = x_409.volume_scale;\n  volume_translation = (vec3<f32>(0.0f, 0.0f, 0.0f) - (vec3<f32>(x_1670.x, x_1670.y, x_1670.z) * 0.5f));\n  let x_1680 : vec4<f32> = x_1678.eye_pos;\n  let x_1682 : vec3<f32> = volume_translation;\n  let x_1685 : vec4<f32> = x_409.volume_scale;\n  transformed_eye = ((vec3<f32>(x_1680.x, x_1680.y, x_1680.z) - x_1682) / vec3<f32>(x_1685.x, x_1685.y, x_1685.z));\n  let x_1689 : vec3<f32> = transformed_eye;\n  let x_1691 : vec4<u32> = x_409.volume_dims;\n  let x_1697 : vec3<u32> = block_pos_3;\n  vol_eye_1 = (((x_1689 * vec3<f32>(vec3<u32>(x_1691.x, x_1691.y, x_1691.z))) - vec3<f32>(0.5f, 0.5f, 0.5f)) - vec3<f32>(x_1697));\n  let x_1702 : u32 = block_info.num_rays;\n  chunks = (x_1702 / 64u);\n  let x_1705 : u32 = block_info.num_rays;\n  if (((x_1705 % 64u) != 0u)) {\n    let x_1710 : u32 = chunks;\n    chunks = (x_1710 + bitcast<u32>(1i));\n  }\n  i_6 = 0u;\n  loop {\n    let x_1718 : u32 = i_6;\n    let x_1719 : u32 = chunks;\n    if ((x_1718 < x_1719)) {\n    } else {\n      break;\n    }\n    pixel_coords = vec2<i32>(-1i, -1i);\n    color = vec4<f32>(1.0f, 1.0f, 1.0f, 1.0f);\n    color.w = 1.0f;\n    let x_1729 : u32 = i_6;\n    let x_1732 : u32 = gl_LocalInvocationID.x;\n    ray_id = ((x_1729 * 64u) + x_1732);\n    let x_1734 : u32 = ray_id;\n    let x_1736 : u32 = block_info.num_rays;\n    if ((x_1734 < x_1736)) {\n      let x_1746 : u32 = block_info.ray_offset;\n      let x_1747 : u32 = ray_id;\n      let x_1750 : u32 = x_1744.ray_ids[(x_1746 + x_1747)];\n      ray_index = x_1750;\n      let x_1752 : u32 = ray_index;\n      param_19 = x_1752;\n      let x_1753 : vec2<u32> = ray_id_to_pos_u1_(&(param_19));\n      pixel_coords = bitcast<vec2<i32>>(x_1753);\n      let x_1761 : u32 = block_info.ray_offset;\n      let x_1762 : u32 = ray_id;\n      let x_1765 : u32 = x_1759.spec_ids[(x_1761 + x_1762)];\n      spec_index = x_1765;\n      let x_1772 : u32 = ray_index;\n      let x_1775 : vec3<f32> = x_1771.rays[x_1772].ray_dir;\n      grid_ray_dir_1 = x_1775;\n      hit_surface = false;\n      hit_p_2 = vec3<f32>(0.0f, 0.0f, 0.0f);\n      cell_range = vec2<f32>(0.0f, 0.0f);\n      let x_1784 : vec3<f32> = vol_eye_1;\n      param_20 = x_1784;\n      let x_1786 : vec3<f32> = grid_ray_dir_1;\n      param_21 = x_1786;\n      let x_1787 : vec2<f32> = intersect_box_vf3_vf3_vf3_vf3_(&(param_20), &(param_21), vec3<f32>(0.0f, 0.0f, 0.0f), vec3<f32>(4.0f, 4.0f, 4.0f));\n      brick_range = x_1787;\n      let x_1789 : f32 = brick_range.y;\n      let x_1791 : f32 = brick_range.x;\n      if ((x_1789 <= x_1791)) {\n        continue;\n      }\n      let x_1798 : f32 = brick_range.x;\n      let x_1801 : vec3<u32> = block_dims_5;\n      let x_1806 : vec3<f32> = vol_eye_1;\n      param_22 = x_1806;\n      let x_1808 : vec3<f32> = grid_ray_dir_1;\n      param_23 = x_1808;\n      param_24 = (x_1798 - 0.001f);\n      param_25 = (bitcast<vec3<i32>>(x_1801) - vec3<i32>(1i, 1i, 1i));\n      let x_1811 : GridIterator = init_grid_iterator_vf3_vf3_f1_vi3_(&(param_22), &(param_23), &(param_24), &(param_25));\n      grid_iter_1 = x_1811;\n      v000_3 = vec3<i32>(0i, 0i, 0i);\n      loop {\n        var x_1851 : bool;\n        var x_1852 : bool;\n        let x_1820 : GridIterator = grid_iter_1;\n        param_26 = x_1820;\n        let x_1823 : bool = grid_iterator_get_cell_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_vf2_vi3_(&(param_26), &(param_27), &(param_28));\n        let x_1824 : GridIterator = param_26;\n        grid_iter_1 = x_1824;\n        let x_1825 : vec2<f32> = param_27;\n        cell_t_range_1 = x_1825;\n        let x_1826 : vec3<i32> = param_28;\n        v000_3 = x_1826;\n        if (x_1823) {\n        } else {\n          break;\n        }\n        let x_1827 : vec3<i32> = v000_3;\n        param_29 = bitcast<vec3<u32>>(x_1827);\n        let x_1832 : vec3<u32> = block_dims_5;\n        param_30 = x_1832;\n        compute_vertex_values_vu3_vu3_f1_8__vf2_(&(param_29), &(param_30), &(param_31), &(param_32));\n        let x_1836 : array<f32, 8u> = param_31;\n        vertex_values_2 = x_1836;\n        let x_1837 : vec2<f32> = param_32;\n        cell_range = x_1837;\n        let x_1840 : f32 = x_409.isovalue;\n        let x_1842 : f32 = cell_range.x;\n        let x_1843 : bool = (x_1840 < x_1842);\n        x_1852 = x_1843;\n        if (!(x_1843)) {\n          let x_1848 : f32 = x_409.isovalue;\n          let x_1850 : f32 = cell_range.y;\n          x_1851 = (x_1848 > x_1850);\n          x_1852 = x_1851;\n        }\n        skip_cell = x_1852;\n        let x_1853 : bool = skip_cell;\n        if (!(x_1853)) {\n          let x_1857 : vec3<f32> = vol_eye_1;\n          let x_1858 : vec3<f32> = grid_ray_dir_1;\n          let x_1859 : vec3<i32> = v000_3;\n          let x_1861 : array<f32, 8u> = vertex_values_2;\n          let x_1863 : f32 = cell_t_range_1.x;\n          let x_1865 : f32 = cell_t_range_1.y;\n          let x_1868 : bool = marmitt_intersect_vf3_vf3_vf3_f1_8__f1_f1_f1_(x_1857, x_1858, vec3<f32>(x_1859), x_1861, x_1863, x_1865, &(param_33));\n          let x_1869 : f32 = param_33;\n          t_hit_1 = x_1869;\n          hit_surface = x_1868;\n          let x_1870 : bool = hit_surface;\n          if (x_1870) {\n            let x_1873 : vec3<f32> = vol_eye_1;\n            let x_1874 : vec3<f32> = grid_ray_dir_1;\n            let x_1875 : f32 = t_hit_1;\n            hit_p_2 = (x_1873 + (x_1874 * x_1875));\n            break;\n          }\n        }\n        let x_1880 : GridIterator = grid_iter_1;\n        param_34 = x_1880;\n        grid_iterator_advance_struct_GridIterator_vi3_vi3_vf3_vi3_vf3_f11_(&(param_34));\n        let x_1882 : GridIterator = param_34;\n        grid_iter_1 = x_1882;\n      }\n      let x_1883 : bool = hit_surface;\n      if (x_1883) {\n        let x_1886 : u32 = ray_index;\n        x_1771.rays[x_1886].t = 340282346638528859811704183484516925440.0f;\n        let x_1890 : vec3<i32> = v000_3;\n        let x_1891 : vec3<f32> = hit_p_2;\n        let x_1892 : array<f32, 8u> = vertex_values_2;\n        let x_1893 : vec3<f32> = compute_normal_vi3_vf3_f1_8__(x_1890, x_1891, x_1892);\n        N_2 = x_1893;\n        let x_1895 : vec3<f32> = grid_ray_dir_1;\n        L_1 = normalize(-(x_1895));\n        let x_1899 : vec3<f32> = grid_ray_dir_1;\n        V_1 = normalize(-(x_1899));\n        let x_1902 : vec3<f32> = N_2;\n        let x_1903 : vec3<f32> = grid_ray_dir_1;\n        if ((dot(x_1902, x_1903) > 0.0f)) {\n          let x_1908 : vec3<f32> = N_2;\n          N_2 = -(x_1908);\n        }\n        let x_1914 : vec3<f32> = N_2;\n        param_35 = x_1914;\n        let x_1916 : vec3<f32> = L_1;\n        param_36 = x_1916;\n        let x_1918 : vec3<f32> = V_1;\n        param_37 = x_1918;\n        param_38 = vec3<f32>(0.300000012f, 0.300000012f, 0.899999976f);\n        let x_1920 : vec3<f32> = shading_vf3_vf3_vf3_vf3_(&(param_35), &(param_36), &(param_37), &(param_38));\n        let x_1921 : vec4<f32> = color;\n        color = vec4<f32>(x_1920.x, x_1920.y, x_1920.z, x_1921.w);\n        let x_1927 : u32 = spec_index;\n        let x_1929 : vec4<f32> = color;\n        param_39 = vec3<f32>(x_1929.x, x_1929.y, x_1929.z);\n        let x_1931 : i32 = pack_color_vf3_(&(param_39));\n        let x_1933 : f32 = t_hit_1;\n        x_1926.ray_rgbz[x_1927] = vec2<f32>(bitcast<f32>(x_1931), x_1933);\n      }\n    }\n\n    continuing {\n      let x_1937 : u32 = i_6;\n      i_6 = (x_1937 + bitcast<u32>(1i));\n    }\n  }\n  return;\n}\n\n@compute @workgroup_size(64i, 1i, 1i)\nfn main(@builtin(local_invocation_id) gl_LocalInvocationID_param : vec3<u32>, @builtin(workgroup_id) gl_WorkGroupID_param : vec3<u32>) {\n  gl_LocalInvocationID = gl_LocalInvocationID_param;\n  gl_WorkGroupID = gl_WorkGroupID_param;\n  main_1();\n}\n`;\n\nconst compute_voxel_range_comp_spv = `struct BlockIDOffset {\n  block_id_offset : u32,\n}\n\nstruct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nalias RTArr = array<vec2<f32>>;\n\nalias RTArr_1 = array<vec2<f32>>;\n\nstruct BlockInformation {\n  block_ranges : RTArr_1,\n}\n\nstruct VoxelInformation {\n  voxel_ranges : RTArr_1,\n}\n\nstruct EmulateUint64 {\n  lo : u32,\n  hi : u32,\n}\n\nalias RTArr_2 = array<EmulateUint64>;\n\nstruct Compressed {\n  compressed : RTArr_2,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(1) @binding(0) var<uniform> x_18 : BlockIDOffset;\n\n@group(0) @binding(1) var<uniform> x_33 : VolumeParams;\n\n@group(0) @binding(2) var<storage, read_write> x_91 : BlockInformation;\n\n@group(2) @binding(0) var<storage, read_write> x_197 : VoxelInformation;\n\n@group(0) @binding(0) var<storage, read_write> x_206 : Compressed;\n\nfn main_1() {\n  var block_index : u32;\n  var total_blocks : u32;\n  var n_blocks : vec3<u32>;\n  var block_pos : vec3<u32>;\n  var cell_range : vec2<f32>;\n  var k : i32;\n  var j : i32;\n  var i : i32;\n  var neighbor : vec3<u32>;\n  var coords : vec3<u32>;\n  var neighbor_id : u32;\n  let x_15 : u32 = gl_GlobalInvocationID.x;\n  let x_23 : u32 = x_18.block_id_offset;\n  block_index = (x_15 + (x_23 * 32u));\n  let x_36 : u32 = x_33.padded_dims.x;\n  let x_39 : u32 = x_33.padded_dims.y;\n  let x_45 : u32 = x_33.padded_dims.z;\n  total_blocks = (((x_36 * x_39) / 64u) * x_45);\n  let x_51 : vec4<u32> = x_33.padded_dims;\n  n_blocks = (vec3<u32>(x_51.x, x_51.y, x_51.z) / vec3<u32>(4u, 4u, 4u));\n  let x_56 : u32 = block_index;\n  let x_57 : u32 = total_blocks;\n  if ((x_56 >= x_57)) {\n    return;\n  }\n  let x_64 : u32 = block_index;\n  let x_66 : u32 = n_blocks.x;\n  block_pos.x = (x_64 % x_66);\n  let x_69 : u32 = block_index;\n  let x_71 : u32 = n_blocks.x;\n  let x_74 : u32 = n_blocks.y;\n  block_pos.y = ((x_69 / x_71) % x_74);\n  let x_77 : u32 = block_index;\n  let x_79 : u32 = n_blocks.x;\n  let x_81 : u32 = n_blocks.y;\n  block_pos.z = (x_77 / (x_79 * x_81));\n  let x_92 : u32 = block_index;\n  let x_95 : vec2<f32> = x_91.block_ranges[x_92];\n  cell_range = x_95;\n  k = 0i;\n  loop {\n    let x_103 : i32 = k;\n    if ((x_103 < 2i)) {\n    } else {\n      break;\n    }\n    j = 0i;\n    loop {\n      let x_112 : i32 = j;\n      if ((x_112 < 2i)) {\n      } else {\n        break;\n      }\n      i = 0i;\n      loop {\n        var x_144 : bool;\n        var x_145 : bool;\n        var x_152 : bool;\n        var x_153 : bool;\n        let x_120 : i32 = i;\n        if ((x_120 < 2i)) {\n        } else {\n          break;\n        }\n        let x_123 : i32 = i;\n        let x_125 : i32 = j;\n        let x_127 : i32 = k;\n        neighbor = vec3<u32>(bitcast<u32>(x_123), bitcast<u32>(x_125), bitcast<u32>(x_127));\n        let x_131 : vec3<u32> = block_pos;\n        let x_132 : vec3<u32> = neighbor;\n        coords = (x_131 + x_132);\n        let x_134 : vec3<u32> = neighbor;\n        let x_138 : bool = all((x_134 == vec3<u32>(0u, 0u, 0u)));\n        x_145 = x_138;\n        if (!(x_138)) {\n          let x_142 : vec3<u32> = coords;\n          x_144 = any((x_142 < vec3<u32>(0u, 0u, 0u)));\n          x_145 = x_144;\n        }\n        x_153 = x_145;\n        if (!(x_145)) {\n          let x_149 : vec3<u32> = coords;\n          let x_150 : vec3<u32> = n_blocks;\n          x_152 = any((x_149 >= x_150));\n          x_153 = x_152;\n        }\n        if (x_153) {\n          continue;\n        }\n        let x_159 : u32 = coords.x;\n        let x_161 : u32 = n_blocks.x;\n        let x_163 : u32 = coords.y;\n        let x_165 : u32 = n_blocks.y;\n        let x_167 : u32 = coords.z;\n        neighbor_id = (x_159 + (x_161 * (x_163 + (x_165 * x_167))));\n        let x_172 : u32 = neighbor_id;\n        let x_175 : f32 = x_91.block_ranges[x_172].x;\n        let x_178 : f32 = cell_range.x;\n        cell_range.x = min(x_175, x_178);\n        let x_181 : u32 = neighbor_id;\n        let x_183 : f32 = x_91.block_ranges[x_181].y;\n        let x_185 : f32 = cell_range.y;\n        cell_range.y = max(x_183, x_185);\n\n        continuing {\n          let x_188 : i32 = i;\n          i = (x_188 + 1i);\n        }\n      }\n\n      continuing {\n        let x_190 : i32 = j;\n        j = (x_190 + 1i);\n      }\n    }\n\n    continuing {\n      let x_192 : i32 = k;\n      k = (x_192 + 1i);\n    }\n  }\n  let x_198 : u32 = block_index;\n  let x_199 : vec2<f32> = cell_range;\n  x_197.voxel_ranges[x_198] = x_199;\n  return;\n}\n\n@compute @workgroup_size(32i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst compute_coarse_cell_range_comp_spv = `struct BlockIDOffset {\n  block_id_offset : u32,\n}\n\nstruct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nalias RTArr = array<vec2<f32>>;\n\nalias RTArr_1 = array<vec2<f32>>;\n\nstruct BrickInformation {\n  voxel_ranges : RTArr_1,\n}\n\nstruct CoarseCellRange {\n  coarse_cell_ranges : RTArr_1,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(1) var<uniform> x_18 : BlockIDOffset;\n\n@group(0) @binding(0) var<uniform> x_33 : VolumeParams;\n\n@group(0) @binding(2) var<storage, read_write> x_119 : BrickInformation;\n\n@group(0) @binding(3) var<storage, read_write> x_210 : CoarseCellRange;\n\nfn main_1() {\n  var coarse_cell_idx : u32;\n  var total_coarse_cells : u32;\n  var n_blocks : vec3<u32>;\n  var n_cells : vec3<u32>;\n  var cell_pos : vec3<u32>;\n  var block_pos : vec3<u32>;\n  var block_idx : u32;\n  var coarse_cell_range : vec2<f32>;\n  var k : i32;\n  var j : i32;\n  var i : i32;\n  var offs : vec3<u32>;\n  var coords : vec3<u32>;\n  var cur_block_idx : u32;\n  let x_15 : u32 = gl_GlobalInvocationID.x;\n  let x_23 : u32 = x_18.block_id_offset;\n  coarse_cell_idx = (x_15 + (x_23 * 32u));\n  let x_36 : u32 = x_33.padded_dims.x;\n  let x_39 : u32 = x_33.padded_dims.y;\n  let x_45 : u32 = x_33.padded_dims.z;\n  total_coarse_cells = (((x_36 * x_39) / 4096u) * x_45);\n  let x_47 : u32 = coarse_cell_idx;\n  let x_48 : u32 = total_coarse_cells;\n  if ((x_47 >= x_48)) {\n    return;\n  }\n  let x_58 : vec4<u32> = x_33.padded_dims;\n  n_blocks = (vec3<u32>(x_58.x, x_58.y, x_58.z) / vec3<u32>(4u, 4u, 4u));\n  let x_64 : vec3<u32> = n_blocks;\n  n_cells = vec3<u32>(ceil((vec3<f32>(x_64) / vec3<f32>(4.0f, 4.0f, 4.0f))));\n  let x_73 : u32 = coarse_cell_idx;\n  let x_75 : u32 = n_cells.x;\n  cell_pos.x = (x_73 % x_75);\n  let x_78 : u32 = coarse_cell_idx;\n  let x_80 : u32 = n_cells.x;\n  let x_83 : u32 = n_cells.y;\n  cell_pos.y = ((x_78 / x_80) % x_83);\n  let x_86 : u32 = coarse_cell_idx;\n  let x_88 : u32 = n_cells.x;\n  let x_90 : u32 = n_cells.y;\n  cell_pos.z = (x_86 / (x_88 * x_90));\n  let x_95 : vec3<u32> = cell_pos;\n  block_pos = (x_95 * vec3<u32>(4u, 4u, 4u));\n  let x_100 : u32 = block_pos.x;\n  let x_102 : u32 = n_blocks.x;\n  let x_104 : u32 = block_pos.y;\n  let x_106 : u32 = n_blocks.y;\n  let x_108 : u32 = block_pos.z;\n  block_idx = (x_100 + (x_102 * (x_104 + (x_106 * x_108))));\n  let x_120 : u32 = block_idx;\n  let x_123 : vec2<f32> = x_119.voxel_ranges[x_120];\n  coarse_cell_range = x_123;\n  k = 0i;\n  loop {\n    let x_131 : i32 = k;\n    if ((x_131 < 4i)) {\n    } else {\n      break;\n    }\n    j = 0i;\n    loop {\n      let x_140 : i32 = j;\n      if ((x_140 < 4i)) {\n      } else {\n        break;\n      }\n      i = 0i;\n      loop {\n        let x_148 : i32 = i;\n        if ((x_148 < 4i)) {\n        } else {\n          break;\n        }\n        let x_151 : i32 = i;\n        let x_153 : i32 = j;\n        let x_155 : i32 = k;\n        offs = vec3<u32>(bitcast<u32>(x_151), bitcast<u32>(x_153), bitcast<u32>(x_155));\n        let x_159 : vec3<u32> = block_pos;\n        let x_160 : vec3<u32> = offs;\n        coords = (x_159 + x_160);\n        let x_162 : vec3<u32> = coords;\n        let x_163 : vec3<u32> = n_blocks;\n        if (any((x_162 >= x_163))) {\n          continue;\n        }\n        let x_172 : u32 = coords.x;\n        let x_174 : u32 = n_blocks.x;\n        let x_176 : u32 = coords.y;\n        let x_178 : u32 = n_blocks.y;\n        let x_180 : u32 = coords.z;\n        cur_block_idx = (x_172 + (x_174 * (x_176 + (x_178 * x_180))));\n        let x_185 : u32 = cur_block_idx;\n        let x_188 : f32 = x_119.voxel_ranges[x_185].x;\n        let x_191 : f32 = coarse_cell_range.x;\n        coarse_cell_range.x = min(x_188, x_191);\n        let x_194 : u32 = cur_block_idx;\n        let x_196 : f32 = x_119.voxel_ranges[x_194].y;\n        let x_198 : f32 = coarse_cell_range.y;\n        coarse_cell_range.y = max(x_196, x_198);\n\n        continuing {\n          let x_201 : i32 = i;\n          i = (x_201 + 1i);\n        }\n      }\n\n      continuing {\n        let x_203 : i32 = j;\n        j = (x_203 + 1i);\n      }\n    }\n\n    continuing {\n      let x_205 : i32 = k;\n      k = (x_205 + 1i);\n    }\n  }\n  let x_211 : u32 = coarse_cell_idx;\n  let x_212 : vec2<f32> = coarse_cell_range;\n  x_210.coarse_cell_ranges[x_211] = x_212;\n  return;\n}\n\n@compute @workgroup_size(32i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst reset_speculative_ids_comp_spv = `struct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nalias RTArr = array<u32>;\n\nalias RTArr_1 = array<u32>;\n\nstruct RayIDs {\n  ray_ids : RTArr_1,\n}\n\nalias RTArr_2 = array<vec2<f32>>;\n\nstruct RayRGBZ {\n  ray_rgbz : RTArr_2,\n}\n\nstruct RayBlockIDs {\n  block_ids : RTArr_1,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<uniform> x_19 : VolumeParams;\n\n@group(0) @binding(1) var<storage, read_write> x_44 : RayIDs;\n\n@group(0) @binding(2) var<storage, read_write> x_53 : RayRGBZ;\n\n@group(0) @binding(3) var<storage, read_write> x_63 : RayBlockIDs;\n\nfn main_1() {\n  var ray_index : u32;\n  let x_13 : u32 = gl_GlobalInvocationID.x;\n  let x_24 : u32 = x_19.image_width;\n  if ((x_13 >= x_24)) {\n    return;\n  }\n  let x_33 : u32 = gl_GlobalInvocationID.x;\n  let x_36 : u32 = gl_GlobalInvocationID.y;\n  let x_38 : u32 = x_19.image_width;\n  ray_index = (x_33 + (x_36 * x_38));\n  let x_46 : u32 = ray_index;\n  x_44.ray_ids[x_46] = 4294967295u;\n  let x_54 : u32 = ray_index;\n  x_53.ray_rgbz[x_54] = vec2<f32>(bitcast<f32>(0i), 340282346638528859811704183484516925440.0f);\n  let x_64 : u32 = ray_index;\n  x_63.block_ids[x_64] = 4294967295u;\n  return;\n}\n\n@compute @workgroup_size(32i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst depth_composite_comp_spv = `struct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nstruct ViewParams {\n  proj_view : mat4x4<f32>,\n  eye_pos : vec4<f32>,\n  eye_dir : vec4<f32>,\n  near_plane : f32,\n  current_pass_index : u32,\n  speculation_count : u32,\n}\n\nalias RTArr = array<u32>;\n\nstruct RayIDs {\n  ray_ids : RTArr,\n}\n\nalias RTArr_1 = array<vec2<f32>>;\n\nstruct RayRGBZ {\n  ray_rgbz : RTArr_1,\n}\n\nstruct RayInfo {\n  ray_dir : vec3<f32>,\n  t : f32,\n}\n\nalias RTArr_2 = array<RayInfo>;\n\nstruct RayInformation {\n  rays : RTArr_2,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(4) var<uniform> x_59 : VolumeParams;\n\n@group(0) @binding(0) var<uniform> x_72 : ViewParams;\n\n@group(0) @binding(1) var<storage, read_write> x_95 : RayIDs;\n\n@group(0) @binding(2) var<storage, read_write> x_143 : RayRGBZ;\n\n@group(0) @binding(3) var render_target : texture_storage_2d<rgba8unorm, write>;\n\n@group(1) @binding(0) var<storage, read_write> x_201 : RayInformation;\n\nfn unpack_color_i1_(rgb8 : ptr<function, i32>) -> vec3<f32> {\n  var rgb : vec3<f32>;\n  rgb = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_18 : i32 = *(rgb8);\n  rgb.x = (f32(((x_18 >> bitcast<u32>(24i)) & 255i)) / 255.0f);\n  let x_30 : i32 = *(rgb8);\n  rgb.y = (f32(((x_30 >> bitcast<u32>(16i)) & 255i)) / 255.0f);\n  let x_38 : i32 = *(rgb8);\n  rgb.z = (f32(((x_38 >> bitcast<u32>(8i)) & 255i)) / 255.0f);\n  let x_46 : vec3<f32> = rgb;\n  return x_46;\n}\n\nfn main_1() {\n  var spec_index : u32;\n  var ray_index : u32;\n  var pixel_coords : vec2<i32>;\n  var color : vec4<f32>;\n  var i : i32;\n  var param : i32;\n  let x_54 : u32 = gl_GlobalInvocationID.x;\n  let x_63 : u32 = x_59.image_width;\n  if ((x_54 >= x_63)) {\n    return;\n  }\n  let x_74 : u32 = x_72.speculation_count;\n  if ((x_74 > 1u)) {\n    let x_81 : u32 = gl_GlobalInvocationID.x;\n    let x_83 : u32 = gl_GlobalInvocationID.y;\n    let x_85 : u32 = x_59.image_width;\n    let x_89 : u32 = x_72.speculation_count;\n    spec_index = ((x_81 + (x_83 * x_85)) * x_89);\n    let x_97 : u32 = spec_index;\n    let x_99 : u32 = x_95.ray_ids[x_97];\n    ray_index = x_99;\n  } else {\n    let x_102 : u32 = gl_GlobalInvocationID.x;\n    let x_104 : u32 = gl_GlobalInvocationID.y;\n    let x_106 : u32 = x_59.image_width;\n    ray_index = (x_102 + (x_104 * x_106));\n    let x_109 : u32 = ray_index;\n    spec_index = x_109;\n  }\n  let x_113 : u32 = ray_index;\n  let x_115 : u32 = x_59.image_width;\n  let x_118 : u32 = ray_index;\n  let x_120 : u32 = x_59.image_width;\n  pixel_coords = vec2<i32>(bitcast<i32>((x_113 % x_115)), bitcast<i32>((x_118 / x_120)));\n  color = vec4<f32>(0.0f, 0.0f, 0.0f, 340282346638528859811704183484516925440.0f);\n  i = 0i;\n  loop {\n    let x_134 : i32 = i;\n    let x_137 : u32 = x_72.speculation_count;\n    if ((bitcast<u32>(x_134) < x_137)) {\n    } else {\n      break;\n    }\n    let x_144 : u32 = spec_index;\n    let x_145 : i32 = i;\n    let x_150 : f32 = x_143.ray_rgbz[(x_144 + bitcast<u32>(x_145))].y;\n    let x_153 : f32 = color.w;\n    if ((x_150 < x_153)) {\n      let x_157 : u32 = spec_index;\n      let x_158 : i32 = i;\n      let x_162 : f32 = x_143.ray_rgbz[(x_157 + bitcast<u32>(x_158))].x;\n      param = bitcast<i32>(x_162);\n      let x_165 : vec3<f32> = unpack_color_i1_(&(param));\n      let x_166 : vec4<f32> = color;\n      color = vec4<f32>(x_165.x, x_165.y, x_165.z, x_166.w);\n      let x_168 : u32 = spec_index;\n      let x_169 : i32 = i;\n      let x_173 : f32 = x_143.ray_rgbz[(x_168 + bitcast<u32>(x_169))].y;\n      color.w = x_173;\n    }\n\n    continuing {\n      let x_175 : i32 = i;\n      i = (x_175 + 1i);\n    }\n  }\n  let x_179 : f32 = color.w;\n  if (!((x_179 == 340282346638528859811704183484516925440.0f))) {\n    let x_187 : vec2<i32> = pixel_coords;\n    let x_188 : vec4<f32> = color;\n    let x_189 : vec3<f32> = vec3<f32>(x_188.x, x_188.y, x_188.z);\n    textureStore(render_target, x_187, vec4<f32>(x_189.x, x_189.y, x_189.z, 1.0f));\n  }\n  return;\n}\n\n@compute @workgroup_size(32i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst mark_ray_active_comp_spv = `struct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nalias RTArr = array<u32>;\n\nstruct RayActive {\n  ray_active : RTArr,\n}\n\nstruct RayInfo {\n  ray_dir : vec3<f32>,\n  t : f32,\n}\n\nalias RTArr_1 = array<RayInfo>;\n\nstruct RayInformation {\n  rays : RTArr_1,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<uniform> x_19 : VolumeParams;\n\n@group(0) @binding(2) var<storage, read_write> x_44 : RayActive;\n\n@group(0) @binding(1) var<storage, read_write> x_52 : RayInformation;\n\nfn main_1() {\n  var ray_index : u32;\n  let x_13 : u32 = gl_GlobalInvocationID.x;\n  let x_24 : u32 = x_19.image_width;\n  if ((x_13 >= x_24)) {\n    return;\n  }\n  let x_33 : u32 = gl_GlobalInvocationID.x;\n  let x_36 : u32 = gl_GlobalInvocationID.y;\n  let x_38 : u32 = x_19.image_width;\n  ray_index = (x_33 + (x_36 * x_38));\n  let x_46 : u32 = ray_index;\n  let x_53 : u32 = ray_index;\n  let x_57 : f32 = x_52.rays[x_53].t;\n  x_44.ray_active[x_46] = bitcast<u32>(select(0i, 1i, !((x_57 == 340282346638528859811704183484516925440.0f))));\n  return;\n}\n\n@compute @workgroup_size(32i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst color_active_rays_comp_spv = `struct VolumeParams {\n  volume_dims : vec4<u32>,\n  padded_dims : vec4<u32>,\n  volume_scale : vec4<f32>,\n  max_bits : u32,\n  isovalue : f32,\n  image_width : u32,\n}\n\nalias RTArr = array<u32>;\n\nstruct RayActive {\n  ray_active : RTArr,\n}\n\nvar<private> gl_GlobalInvocationID : vec3<u32>;\n\n@group(0) @binding(0) var<uniform> x_19 : VolumeParams;\n\n@group(0) @binding(1) var<storage, read_write> x_44 : RayActive;\n\n@group(0) @binding(2) var render_target_copy : texture_2d<f32>;\n\n@group(0) @binding(3) var render_target : texture_storage_2d<rgba8unorm, write>;\n\nfn main_1() {\n  var ray_index : u32;\n  var pixel_coords : vec2<i32>;\n  var color : vec4<f32>;\n  var pixel_coords_1 : vec2<i32>;\n  var color_1 : vec4<f32>;\n  let x_13 : u32 = gl_GlobalInvocationID.x;\n  let x_24 : u32 = x_19.image_width;\n  if ((x_13 >= x_24)) {\n    return;\n  }\n  let x_33 : u32 = gl_GlobalInvocationID.x;\n  let x_36 : u32 = gl_GlobalInvocationID.y;\n  let x_38 : u32 = x_19.image_width;\n  ray_index = (x_33 + (x_36 * x_38));\n  let x_46 : u32 = ray_index;\n  let x_48 : u32 = x_44.ray_active[x_46];\n  if ((x_48 == 1u)) {\n    let x_55 : u32 = ray_index;\n    let x_57 : u32 = x_19.image_width;\n    let x_60 : u32 = ray_index;\n    let x_62 : u32 = x_19.image_width;\n    pixel_coords = vec2<i32>(bitcast<i32>((x_55 % x_57)), bitcast<i32>((x_60 / x_62)));\n    let x_72 : vec2<i32> = pixel_coords;\n    let x_73 : vec4<f32> = textureLoad(render_target_copy, x_72, 0i);\n    color = x_73;\n    let x_76 : vec2<i32> = pixel_coords;\n    textureStore(render_target, x_76, vec4<f32>(1.0f, 0.0f, 0.0f, 1.0f));\n  } else {\n    let x_82 : u32 = ray_index;\n    let x_84 : u32 = x_19.image_width;\n    let x_87 : u32 = ray_index;\n    let x_89 : u32 = x_19.image_width;\n    pixel_coords_1 = vec2<i32>(bitcast<i32>((x_82 % x_84)), bitcast<i32>((x_87 / x_89)));\n    let x_95 : vec2<i32> = pixel_coords_1;\n    let x_96 : vec4<f32> = textureLoad(render_target_copy, x_95, 0i);\n    color_1 = x_96;\n    let x_99 : f32 = color_1.x;\n    if ((x_99 == 1.0f)) {\n      let x_104 : vec2<i32> = pixel_coords_1;\n      textureStore(render_target, x_104, vec4<f32>(1.0f, 1.0f, 1.0f, 1.0f));\n    }\n  }\n  return;\n}\n\n@compute @workgroup_size(32i, 1i, 1i)\nfn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>) {\n  gl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  main_1();\n}\n`;\n\nconst mark_block_active_wgsl_spv = `/*\n// #include \"util.glsl\"\n*/\n\nconst UINT_MAX: u32 = 0xffffffffu;\nconst FLT_MAX: f32 = 3.402823466e+38;\n\nalias float2 = vec2<f32>;\nalias float3 = vec3<f32>;\nalias float4 = vec4<f32>;\nalias uint2 = vec2<u32>;\nalias uint3 = vec3<u32>;\nalias uint4 = vec4<u32>;\n\nstruct RayInfo {\n    ray_dir: float3,\n    // block_id: u32,\n    t: f32,\n    // t_next: f32,\n    // For WGSL we need to pad the struct up to 32 bytes so it matches\n    // the GLSL struct alignment/padding rules we had before\n    // @size(8) pad: f32\n};\n\n/*\nlayout(local_size_x = 8, local_size_y = 1, local_size_z = 1) in;\n*/\n/*\nlayout(set = 0, binding = 0, std140) uniform VolumeParams\n{\n    uvec4 volume_dims;\n    uvec4 padded_dims;\n    vec4 volume_scale;\n    uint max_bits;\n    float isovalue;\n    uint image_width;\n};\n*/\nstruct VolumeParams {\n  volume_dims: uint4,\n  padded_dims: uint4,\n  volume_scale: float4,\n  max_bits: u32,\n  isovalue: f32,\n  image_width: u32,\n}\n\n@group(0) @binding(0) var<uniform> volume_params : VolumeParams;\n\n/*\nlayout(set = 0, binding = 1, std140) uniform LOD\n{\n    uint LOD_threshold;\n};\n*/\nstruct LOD {\n    threshold: f32,\n}\n@group(0) @binding(1) var<uniform> lod_threshold : LOD;\n\n/*\nlayout(set = 0, binding = 2, std140) uniform ViewParams\n{\n    mat4 proj_view;\n    vec4 eye_pos;\n    vec4 eye_dir;\n    float near_plane;\n    uint current_pass_index;\n};\n*/\nstruct ViewParams {\n  proj_view: mat4x4<f32>,\n  eye_pos: float4,\n  eye_dir: float4,\n  near_plane : f32,\n  current_pass_index: u32,\n}\n@group(0) @binding(2) var<uniform> view_params : ViewParams;\n\n/*\nlayout(set = 0, binding = 3, std430) buffer BlockActive\n{\n    uint block_active[];\n};\n*/\n// TODO: Is this valid WGSL? Try compiling with Tint\n@group(0) @binding(3) var<storage, read_write> block_active : array<u32>;\n\n/*\nlayout(set = 0, binding = 5, std430) buffer RayInformation\n{\n    RayInfo rays[];\n};\n*/\n@group(0) @binding(4) var<storage, read_write> rays : array<RayInfo>;\n\n/*\nlayout(set = 0, binding = 6, std430) buffer BlockVisible\n{\n    uint block_visible[];\n};\n*/\n@group(0) @binding(5) var<storage, read_write> block_visible : array<atomic<u32>>;\n@group(0) @binding(6) var<storage, read_write> block_ids : array<u32>;\n\n\n//uniform layout(set = 1, binding = 0, rgba8) writeonly image2D render_target;\n@group(1) @binding(0) var render_target : texture_storage_2d<rgba8unorm, write>;\n\nfn block_id_to_pos(id: u32) -> uint3 {\n    let n_blocks = volume_params.padded_dims.xyz / uint3(4u);\n    return uint3(id % n_blocks.x,\n            (id / n_blocks.x) % n_blocks.y,\n            id / (n_blocks.x * n_blocks.y));\n}\n\nfn compute_block_id(block_pos: uint3) -> u32\n{\n    let n_blocks = volume_params.padded_dims.xyz / uint3(4u);\n    return block_pos.x + n_blocks.x * (block_pos.y + n_blocks.y * block_pos.z);\n}\n\n@compute @workgroup_size(32, 1, 1)\nfn main(@builtin(global_invocation_id) g_invocation_id : vec3<u32>) {\n    if (g_invocation_id.x >= volume_params.image_width) {\n        return;\n    }\n\n    let ray_index = g_invocation_id.x + g_invocation_id.y * volume_params.image_width;\n\n    let block_id = block_ids[ray_index];\n    if (block_id == UINT_MAX) {\n        return;\n    }\n    let block_pos = block_id_to_pos(block_id);\n\n    block_active[block_id] = 1u;\n    //block_visible[block_id] = 1;\n    let already_marked = atomicMax(&block_visible[block_id], 1u);\n\n    // Count this ray for the block (this is now done in count_block_rays.wgsl\n    //uint num_rays = atomicAdd(block_num_rays[block_id], uint(1)) + 1;\n    //let num_rays = atomicAdd(&block_num_rays[block_id], 1u) + 1u;\n\n    // Mark this ray's block's neighbors to the positive side as active\n    // These blocks must be decompressed for neighbor data, but this ray\n    // doesn't need to process them.\n    if (already_marked == 0) {\n        let n_blocks = volume_params.padded_dims.xyz / uint3(4u);\n        for (var k = 0u; k < 2u; k += 1u) {\n            for (var j = 0u; j < 2u; j += 1u) {\n                for (var i = 0u; i < 2u; i += 1u) {\n                    let neighbor = uint3(i, j, k);\n                    let coords = block_pos + neighbor;\n                    if (all(neighbor == uint3(0u)) || any(coords < uint3(0u)) || any(coords >= n_blocks)) {\n                        continue;\n                    }\n                    let neighbor_id = compute_block_id(coords);\n                    block_active[neighbor_id] = 1u;\n                }               \n            }\n        }\n    }\n}\n`;\nconst count_block_rays_wgsl_spv = `/*\n// #include \"util.glsl\"\n*/\n\nconst UINT_MAX: u32 = 0xffffffffu;\nconst FLT_MAX: f32 = 3.402823466e+38;\n\nalias float2 = vec2<f32>;\nalias float3 = vec3<f32>;\nalias float4 = vec4<f32>;\nalias uint2 = vec2<u32>;\nalias uint3 = vec3<u32>;\nalias uint4 = vec4<u32>;\n\nstruct VolumeParams {\n  volume_dims: uint4,\n  padded_dims: uint4,\n  volume_scale: float4,\n  max_bits: u32,\n  isovalue: f32,\n  image_width: u32,\n}\n\n@group(0) @binding(0) var<uniform> volume_params : VolumeParams;\n\n@group(0) @binding(1) var<storage, read_write> block_num_rays : array<atomic<u32>>;\n\n@group(0) @binding(2) var<storage, read_write> ray_block_ids : array<u32>;\n\n@group(0) @binding(3) var<storage, read_write> block_compact_offsets : array<u32>;\n\n\n@compute @workgroup_size(32, 1, 1)\nfn main(@builtin(global_invocation_id) g_invocation_id : vec3<u32>) {\n    if (g_invocation_id.x >= volume_params.image_width) {\n        return;\n    }\n\n    let ray_index = g_invocation_id.x + g_invocation_id.y * volume_params.image_width;\n\n    let block_id = ray_block_ids[ray_index];\n    if (block_id == UINT_MAX) {\n        return;\n    }\n\n    // Count this ray for the block\n    let block_index = block_compact_offsets[block_id];\n    atomicAdd(&block_num_rays[block_index], 1u);\n}\n\n`;\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/embedded_shaders.js?");

/***/ }),

/***/ "./src/exclusive_scan.js":
/*!*******************************!*\
  !*** ./src/exclusive_scan.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ExclusiveScanPipeline\": () => (/* binding */ ExclusiveScanPipeline),\n/* harmony export */   \"alignTo\": () => (/* binding */ alignTo)\n/* harmony export */ });\n/* harmony import */ var _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./embedded_shaders */ \"./src/embedded_shaders.js\");\n\n\nvar alignTo = function(val, align) {\n    return Math.floor((val + align - 1) / align) * align;\n};\n\n// Serial scan for validation\nvar serialExclusiveScan = function(array, output) {\n    output[0] = 0;\n    for (var i = 1; i < array.length; ++i) {\n        output[i] = array[i - 1] + output[i - 1];\n    }\n    return output[array.length - 1] + array[array.length - 1];\n};\n\nvar ExclusiveScanPipeline = function(device) {\n    this.device = device;\n    // Each thread in a work group is responsible for 2 elements\n    this.workGroupSize = _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize / 2;\n    // The max size which can be scanned by a single batch without carry in/out\n    this.maxScanSize = _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize * _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize;\n    console.log(`Block size: ${_embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize}, max scan size: ${this.maxScanSize}`);\n\n    // Buffer to clear the block sums for each new scan\n    var clearBlocks = device.createBuffer({\n        size: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        mappedAtCreation: true,\n    });\n    new Uint32Array(clearBlocks.getMappedRange()).fill(0);\n    clearBlocks.unmap();\n    this.clearBuf = clearBlocks;\n\n    this.scanBlocksLayout = device.createBindGroupLayout({\n        entries: [\n            {binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n\n    this.scanBlockResultsLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n\n    this.scanBlocksPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [this.scanBlocksLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.prefix_sum_comp_spv}),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.scanBlockResultsPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [this.scanBlockResultsLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.block_prefix_sum_comp_spv}),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.addBlockSumsPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [this.scanBlocksLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.add_block_sums_comp_spv}),\n            entryPoint: \"main\",\n        },\n    });\n};\n\nExclusiveScanPipeline.prototype.getAlignedSize = function(size) {\n    return alignTo(size, _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize);\n};\n\n// TODO: refactor to have this return a prepared scanner object?\n// Then the pipelines and bind group layouts can be re-used and shared between the scanners\nExclusiveScanPipeline.prototype.prepareInput = function(cpuArray) {\n    var alignedSize = alignTo(cpuArray.length, _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize);\n\n    // Upload input and pad to block size elements\n    var inputBuf = this.device.createBuffer({\n        size: alignedSize * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n    });\n    new Uint32Array(inputBuf.getMappedRange()).set(cpuArray);\n    inputBuf.unmap();\n\n    return new ExclusiveScanner(this, inputBuf, alignedSize, cpuArray.length);\n};\n\nExclusiveScanPipeline.prototype.prepareGPUInput = function(gpuBuffer, alignedSize) {\n    if (this.getAlignedSize(alignedSize) != alignedSize) {\n        alert(\"Error: GPU input must be aligned to getAlignedSize\");\n    }\n\n    return new ExclusiveScanner(this, gpuBuffer, alignedSize);\n};\n\nvar ExclusiveScanner = function(scanPipeline, gpuBuffer, alignedSize) {\n    this.scanPipeline = scanPipeline;\n    this.inputSize = alignedSize;\n    this.inputBuf = gpuBuffer;\n\n    this.readbackBuf = scanPipeline.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n\n    // Block sum buffer\n    var blockSumBuf = scanPipeline.device.createBuffer({\n        size: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n    });\n    new Uint32Array(blockSumBuf.getMappedRange()).fill(0);\n    blockSumBuf.unmap();\n    this.blockSumBuf = blockSumBuf;\n\n    var carryBuf = scanPipeline.device.createBuffer({\n        size: 8,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n    });\n    new Uint32Array(carryBuf.getMappedRange()).fill(0);\n    carryBuf.unmap();\n    this.carryBuf = carryBuf;\n\n    // Can't copy from a buffer to itself so we need an intermediate to move the carry\n    this.carryIntermediateBuf = scanPipeline.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    this.scanBlockResultsBindGroup = scanPipeline.device.createBindGroup({\n        layout: this.scanPipeline.scanBlockResultsLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: blockSumBuf,\n                },\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: carryBuf,\n                },\n            },\n        ],\n    });\n};\n\nExclusiveScanner.prototype.scan = async function(dataSize) {\n    // If the data size we're scanning within the larger input array has changed,\n    // we just need to re-record the scan commands\n    var numChunks = Math.ceil(dataSize / this.scanPipeline.maxScanSize);\n    this.offsets = new Uint32Array(numChunks);\n    for (var i = 0; i < numChunks; ++i) {\n        this.offsets.set([i * this.scanPipeline.maxScanSize * 4], i);\n    }\n\n    // Scan through the data in chunks, updating carry in/out at the end to carry\n    // over the results of the previous chunks\n    var commandEncoder = this.scanPipeline.device.createCommandEncoder();\n\n    // Clear the carry buffer and the readback sum entry if it's not scan size aligned\n    commandEncoder.copyBufferToBuffer(this.scanPipeline.clearBuf, 0, this.carryBuf, 0, 8);\n    for (var i = 0; i < numChunks; ++i) {\n        var nWorkGroups =\n            Math.min((this.inputSize - i * this.scanPipeline.maxScanSize) / _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize,\n                     _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize);\n\n        var scanBlockBG = null;\n        if (nWorkGroups === _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize) {\n            scanBlockBG = this.scanPipeline.device.createBindGroup({\n                layout: this.scanPipeline.scanBlocksLayout,\n                entries: [\n                    {\n                        binding: 0,\n                        resource: {\n                            buffer: this.inputBuf,\n                            size: Math.min(this.scanPipeline.maxScanSize, this.inputSize) * 4,\n                            offset: this.offsets[i],\n                        },\n                    },\n                    {\n                        binding: 1,\n                        resource: {\n                            buffer: this.blockSumBuf,\n                        },\n                    },\n                ],\n            });\n        } else {\n            // Bind groups for processing the remainder if the aligned size isn't\n            // an even multiple of the max scan size\n            scanBlockBG = this.scanPipeline.device.createBindGroup({\n                layout: this.scanPipeline.scanBlocksLayout,\n                entries: [\n                    {\n                        binding: 0,\n                        resource: {\n                            buffer: this.inputBuf,\n                            size: (this.inputSize % this.scanPipeline.maxScanSize) * 4,\n                            offset: this.offsets[i],\n                        },\n                    },\n                    {\n                        binding: 1,\n                        resource: {\n                            buffer: this.blockSumBuf,\n                        },\n                    },\n                ],\n            });\n        }\n\n        // Clear the previous block sums\n        commandEncoder.copyBufferToBuffer(\n            this.scanPipeline.clearBuf, 0, this.blockSumBuf, 0, _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.ScanBlockSize * 4);\n\n        var computePass = commandEncoder.beginComputePass();\n\n        computePass.setPipeline(this.scanPipeline.scanBlocksPipeline);\n        computePass.setBindGroup(0, scanBlockBG);\n        computePass.dispatchWorkgroups(nWorkGroups, 1, 1);\n\n        computePass.setPipeline(this.scanPipeline.scanBlockResultsPipeline);\n        computePass.setBindGroup(0, this.scanBlockResultsBindGroup);\n        computePass.dispatchWorkgroups(1, 1, 1);\n\n        computePass.setPipeline(this.scanPipeline.addBlockSumsPipeline);\n        computePass.setBindGroup(0, scanBlockBG);\n        computePass.dispatchWorkgroups(nWorkGroups, 1, 1);\n\n        computePass.end();\n\n        // Update the carry in value for the next chunk, copy carry out to carry in\n        commandEncoder.copyBufferToBuffer(this.carryBuf, 4, this.carryIntermediateBuf, 0, 4);\n        commandEncoder.copyBufferToBuffer(this.carryIntermediateBuf, 0, this.carryBuf, 0, 4);\n    }\n    var commandBuffer = commandEncoder.finish();\n\n    // We need to clear a different element in the input buf for the last item if the data size\n    // shrinks\n    if (dataSize < this.inputSize) {\n        var commandEncoder = this.scanPipeline.device.createCommandEncoder();\n        commandEncoder.copyBufferToBuffer(\n            this.scanPipeline.clearBuf, 0, this.inputBuf, dataSize * 4, 4);\n        this.scanPipeline.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    this.scanPipeline.device.queue.submit([commandBuffer]);\n\n    // Readback the the last element to return the total sum as well\n    var commandEncoder = this.scanPipeline.device.createCommandEncoder();\n    if (dataSize < this.inputSize) {\n        commandEncoder.copyBufferToBuffer(this.inputBuf, dataSize * 4, this.readbackBuf, 0, 4);\n    } else {\n        commandEncoder.copyBufferToBuffer(this.carryBuf, 4, this.readbackBuf, 0, 4);\n    }\n    this.scanPipeline.device.queue.submit([commandEncoder.finish()]);\n\n    await this.readbackBuf.mapAsync(GPUMapMode.READ);\n    var mapping = new Uint32Array(this.readbackBuf.getMappedRange());\n    var sum = mapping[0];\n    this.readbackBuf.unmap();\n\n    return sum;\n};\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/exclusive_scan.js?");

/***/ }),

/***/ "./src/inference.js":
/*!**************************!*\
  !*** ./src/inference.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cleanRecurrentState\": () => (/* binding */ cleanRecurrentState),\n/* harmony export */   \"getImageTensorFromPath\": () => (/* binding */ getImageTensorFromPath),\n/* harmony export */   \"imageDataToTensor\": () => (/* binding */ imageDataToTensor),\n/* harmony export */   \"runInference\": () => (/* binding */ runInference)\n/* harmony export */ });\n/* harmony import */ var jimp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jimp */ \"./node_modules/jimp/browser/lib/jimp.js\");\n/* harmony import */ var jimp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jimp__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var onnxruntime_web_webgpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! onnxruntime-web/webgpu */ \"./node_modules/onnxruntime-web/dist/ort.webgpu.min.mjs\");\n\r\n\r\n// import * as ort from \"onnxruntime-web\"; \r\nvar recurrentState = false;\r\n\r\nfunction cleanRecurrentState() {\r\n    recurrentState = false;\r\n}\r\n\r\nasync function runInference(session, preprocessedData, width, height) {\r\n    // Get start time to calculate inference time.\r\n    // create feeds with the input name from model export and the preprocessed data.\r\n    const feeds = {};\r\n    const architecture = [32, 64, 64, 80];\r\n    feeds[session.inputNames[0]] = preprocessedData;\r\n    for (var i = 0; i < session.inputNames.length - 1; i++) {\r\n        if (recurrentState) {\r\n            feeds[session.inputNames[i + 1]] = recurrentState[i];\r\n        } else {\r\n            var w = width / 2**i;\r\n            var h = height / 2**i;\r\n            feeds[session.inputNames[session.inputNames.length - i - 1]] = new onnxruntime_web_webgpu__WEBPACK_IMPORTED_MODULE_1__.Tensor(\"float32\", \r\n                new Float32Array(architecture[i] * w * h), \r\n                [1, architecture[i], h, w]\r\n            );\r\n        }\r\n    }\r\n    const start = new Date();  \r\n    const outputData = await session.run(feeds);\r\n    const results = outputData[session.outputNames[0]].data;\r\n    recurrentState = [\r\n        outputData[session.outputNames[3]],\r\n        outputData[session.outputNames[4]],\r\n        outputData[session.outputNames[5]],\r\n        outputData[session.outputNames[6]]\r\n    ];\r\n    const end = new Date();\r\n    const inferenceTime = Math.round(end.getTime() - start.getTime());\r\n  \r\n    return [results, inferenceTime];\r\n}\r\n\r\nasync function getImageTensorFromPath(path, dims) {\r\n    // 1. load the image  \r\n    var image = await loadImageFromPath(path, dims[2], dims[3]);\r\n    // 2. convert to tensor\r\n    var imageTensor = imageDataToTensor(image, dims);\r\n    // 3. return the tensor\r\n    return imageTensor;\r\n  }\r\n  \r\n  async function loadImageFromPath(path, width, height) {\r\n    // Use Jimp to load the image and resize it.\r\n    var imageData = await Jimp.read(path).then((imageBuffer) => {\r\n      return imageBuffer.resize(width, height);\r\n    });\r\n  \r\n    return imageData;\r\n  }\r\n  \r\n function imageDataToTensor(image, dims) {\r\n    // 1. Get buffer data from image and create R, G, and B arrays.\r\n    // var imageBufferData = image.bitmap.data;\r\n    var imageBufferData = image;\r\n    const [redArray, greenArray, blueArray] = new Array(new Array(), new Array(), new Array());\r\n  \r\n    // 2. Loop through the image buffer and extract the R, G, and B channels\r\n    for (let i = 0; i < imageBufferData.length; i += 4) {\r\n      redArray.push(imageBufferData[i]);\r\n      greenArray.push(imageBufferData[i + 1]);\r\n      blueArray.push(imageBufferData[i + 2]);\r\n      // skip data[i + 3] to filter out the alpha channel\r\n    }\r\n  \r\n    // 3. Concatenate RGB to transpose [224, 224, 3] -> [3, 224, 224] to a number array\r\n    const transposedData = redArray.concat(greenArray).concat(blueArray);\r\n  \r\n    // 4. convert to float32\r\n    let i, l = transposedData.length; // length, we need this for the loop\r\n    const float32Data = new Float32Array(dims[1] * dims[2] * dims[3]);\r\n    for (i = 0; i < l; i++) {\r\n      float32Data[i] = transposedData[i] / 255.0; // convert to float\r\n    }\r\n    // 5. create the tensor object from onnxruntime-web.\r\n    const inputTensor = new onnxruntime_web_webgpu__WEBPACK_IMPORTED_MODULE_1__.Tensor(\"float32\", float32Data, dims);\r\n    return inputTensor;\r\n  }\r\n  \r\n  \r\n  \r\n\r\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/inference.js?");

/***/ }),

/***/ "./src/lru_cache.js":
/*!**************************!*\
  !*** ./src/lru_cache.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LRUCache\": () => (/* binding */ LRUCache)\n/* harmony export */ });\n/* harmony import */ var _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./embedded_shaders */ \"./src/embedded_shaders.js\");\n/* harmony import */ var _exclusive_scan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exclusive_scan */ \"./src/exclusive_scan.js\");\n/* harmony import */ var _radix_sort_by_key__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radix_sort_by_key */ \"./src/radix_sort_by_key.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n// Create the LRU cache and set an initial size for the cache\n// If more data is requested to store in the cache than it can fit, it will\n// be grown to accomadate it\n\n\n\n\n\nvar LRUCache = function (\n    device, scanPipeline, streamCompact, initialSize, elementSize, totalElements) {\n    this.device = device;\n    this.scanPipeline = scanPipeline;\n    this.streamCompact = streamCompact;\n\n    this.totalElements = totalElements;\n\n    // Round up to the local size of 32 for the cache processing kernels\n    this.alignedTotalElements = (0,_exclusive_scan__WEBPACK_IMPORTED_MODULE_1__.alignTo)(totalElements, 32);\n    this.cacheSize = (0,_exclusive_scan__WEBPACK_IMPORTED_MODULE_1__.alignTo)(initialSize, 32);\n    this.elementSize = elementSize;\n    this.numNewItems = 0;\n    this.maxDispatchSize = device.limits.maxComputeWorkgroupsPerDimension;\n\n    this.sorter = new _radix_sort_by_key__WEBPACK_IMPORTED_MODULE_2__.RadixSorter(this.device);\n\n    // For each element, track if it's in the cache, and if so where\n    var buf = this.device.createBuffer({\n        size: this.alignedTotalElements * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n    });\n    new Int32Array(buf.getMappedRange()).fill(-1);\n    buf.unmap();\n    this.cachedItemSlots = buf;\n\n    // For each element, if it needs to be added to the cache. This buffer\n    // will be 1/0 per total element which could be cached so we can see\n    // how many need to be added\n    var buf = this.device.createBuffer({\n        size: this.alignedTotalElements * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        mappedAtCreation: true,\n    });\n    new Uint32Array(buf.getMappedRange()).fill(0);\n    buf.unmap();\n    this.needsCaching = buf;\n\n    this.needsCachingOffsets = this.device.createBuffer({\n        size: this.scanPipeline.getAlignedSize(this.alignedTotalElements) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n\n    // The age of each slot\n    var buf = this.device.createBuffer({\n        size: this.cacheSize * 4 * 3,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n    });\n    var m = new Int32Array(buf.getMappedRange());\n    for (var i = 0; i < this.cacheSize; ++i) {\n        m[i * 3] = 2 + i;   // For slot age\n        m[i * 3 + 1] = 1;   // For slot availability\n        m[i * 3 + 2] = -1;  // For slot ID\n    }\n    buf.unmap();\n    this.slotData = buf;\n\n    this.slotAvailableOffsets = this.device.createBuffer({\n        size: this.scanPipeline.getAlignedSize(this.cacheSize) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // A temp buffer to hold the available slot IDs for compaction\n    this.slotAvailableForCompact = this.device.createBuffer({\n        size: this.cacheSize * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    this.slotAvailableIDs = this.device.createBuffer({\n        size: this.cacheSize * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    // Buffer used to pass the previous cache size to lru_cache_init.comp\n    this.cacheSizeBuf = this.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n\n    // The actual cached data\n    this.cache = this.device.createBuffer({\n        size: this.cacheSize * elementSize,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n\n    this.scanNeededSlots = this.scanPipeline.prepareGPUInput(\n        this.needsCachingOffsets, this.scanPipeline.getAlignedSize(this.totalElements));\n\n    this.slotAvailableScanner = this.scanPipeline.prepareGPUInput(\n        this.slotAvailableOffsets, this.scanPipeline.getAlignedSize(this.cacheSize));\n\n    this.lruCacheBGLayout = this.device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n\n    this.lruCacheBG = this.device.createBindGroup({\n        layout: this.lruCacheBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: this.cachedItemSlots,\n                },\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: this.slotAvailableIDs,\n                },\n            },\n            {\n                binding: 2,\n                resource: {\n                    buffer: this.slotData,\n                },\n            },\n        ],\n    });\n\n    this.markNewItemsBGLayout = this.device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"read-only-storage\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n\n    this.cacheUpdateBGLayout = this.device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n\n    this.singleUniformBGLayout = this.device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n        ],\n    });\n    this.cacheInitBG = this.device.createBindGroup({\n        layout: this.singleUniformBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: this.cacheSizeBuf,\n                },\n            },\n        ],\n    });\n\n    this.pushConstantsBGLayout = this.device.createBindGroupLayout({\n        entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n                hasDynamicOffset: true,\n                type: \"uniform\",\n            }\n        }]\n    });\n\n    this.ageCacheSlotsPipeline = this.device.createComputePipeline({\n        layout: this.device.createPipelineLayout({\n            bindGroupLayouts: [this.lruCacheBGLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.lru_cache_age_slots_comp_spv}),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.markNewItemsPipeline = this.device.createComputePipeline({\n        layout: this.device.createPipelineLayout({\n            bindGroupLayouts:\n                [this.lruCacheBGLayout, this.markNewItemsBGLayout, this.pushConstantsBGLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.lru_cache_mark_new_items_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.cacheInitPipeline = this.device.createComputePipeline({\n        layout: this.device.createPipelineLayout({\n            bindGroupLayouts: [this.lruCacheBGLayout, this.singleUniformBGLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.lru_cache_init_comp_spv}),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.cacheUpdatePipeline = this.device.createComputePipeline({\n        layout: this.device.createPipelineLayout({\n            // The last BG layout passes the number of new items\n            bindGroupLayouts:\n                [this.lruCacheBGLayout, this.cacheUpdateBGLayout, this.singleUniformBGLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.lru_cache_update_comp_spv}),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.copyAvailableSlotAgePipeline = this.device.createComputePipeline({\n        layout: this.device.createPipelineLayout({\n            bindGroupLayouts:\n                [this.lruCacheBGLayout, this.cacheUpdateBGLayout, this.singleUniformBGLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.lru_copy_available_slot_age_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.outputSlotAvailableBG = this.device.createBindGroup({\n        layout: this.cacheUpdateBGLayout,\n        entries: [{\n            binding: 0,\n            resource: {\n                buffer: this.slotAvailableOffsets,\n            }\n        }]\n    });\n\n    this.outputSlotAvailableForCompact = this.device.createBindGroup({\n        layout: this.cacheUpdateBGLayout,\n        entries: [{\n            binding: 0,\n            resource: {\n                buffer: this.slotAvailableForCompact,\n            }\n        }]\n    });\n\n    this.extractSlotAvailablePipeline = this.device.createComputePipeline({\n        layout: this.device.createPipelineLayout({\n            bindGroupLayouts: [this.lruCacheBGLayout, this.cacheUpdateBGLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.lru_cache_extract_slot_available_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n};\n\n// Update the cache based on the externally updated \"needsCaching\" list\n// Items which need to stay in the cache should be marked as needs caching,\n// regardless of whether they are currently cached.\n// Returns the number of new items which need to be decompressed\n// and their IDs\nLRUCache.prototype.update = async function (itemNeeded, perfTracker) {\n    if (!(itemNeeded instanceof GPUBuffer)) {\n        alert(\"itemNeeded info must be a GPUbuffer\");\n    }\n    perfTracker[\"lru\"] = {};\n\n    var markNewItemsBG = this.device.createBindGroup({\n        layout: this.markNewItemsBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: itemNeeded,\n                },\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: this.needsCaching,\n                },\n            },\n        ],\n    });\n\n    // Update the old cache size UBO so we know where to start initializing the data\n    var uploadBuf = this.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.COPY_SRC,\n        mappedAtCreation: true,\n    });\n    new Uint32Array(uploadBuf.getMappedRange()).set([this.cacheSize]);\n    uploadBuf.unmap();\n\n    var start = performance.now();\n    // Pass through the needs caching buffer to see which items need caching\n    // and are in the cache to unmark them, and which items no longer need\n    // caching but are in the cache with age > 2 to mark their slot available.\n    var commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyBufferToBuffer(uploadBuf, 0, this.cacheSizeBuf, 0, 4);\n\n    var pass = commandEncoder.beginComputePass();\n\n    /*\n    console.log(`LRU: cacheSize = ${this.cacheSize}, totalElements = ${\n        this.totalElements}, aligned total = ${this.alignedTotalElements}`);\n        */\n\n    // Age all slots in the cache\n    pass.setPipeline(this.ageCacheSlotsPipeline);\n    pass.setBindGroup(0, this.lruCacheBG);\n    pass.dispatchWorkgroups(this.cacheSize / 64, 1, 1);\n\n    // For testing purposes\n    /*\n    pass.end();\n    var start = performance.now();\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n    var end = performance.now();\n    console.log(`LRU: Age cache slots took ${end - start}ms`);\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass();\n    */\n\n    {\n        var totalWorkGroups = this.alignedTotalElements / 32;\n        var pushConstants = (0,_util__WEBPACK_IMPORTED_MODULE_3__.buildPushConstantsBuffer)(this.device, totalWorkGroups);\n        var pushConstantsBG = this.device.createBindGroup({\n            layout: this.pushConstantsBGLayout,\n            entries: [{\n                binding: 0,\n                resource: {\n                    buffer: pushConstants.gpuBuffer,\n                    size: 8,\n                }\n            }]\n        });\n\n        pass.setPipeline(this.markNewItemsPipeline);\n        pass.setBindGroup(0, this.lruCacheBG);\n        pass.setBindGroup(1, markNewItemsBG);\n        for (var i = 0; i < pushConstants.nOffsets; ++i) {\n            pass.setBindGroup(2, pushConstantsBG, pushConstants.dynamicOffsets, i, 1);\n            pass.dispatchWorkgroups(pushConstants.dispatchSizes[i], 1, 1);\n        }\n    }\n    // For testing purposes\n    /*\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    var start = performance.now();\n    await this.device.queue.onSubmittedWorkDone();\n    var end = performance.now();\n    console.log(`LRU: Mark new items took ${end - start}ms`);\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass();\n    pass.setBindGroup(0, this.lruCacheBG);\n    */\n\n    // We need a kernel to copy the slotAvailable member out of the structs instead of using\n    // copyBufferToBuffer, since it's stored AoS to reduce our buffer use\n    pass.setPipeline(this.extractSlotAvailablePipeline);\n    pass.setBindGroup(1, this.outputSlotAvailableBG);\n    pass.dispatchWorkgroups(this.cacheSize / 64, 1, 1);\n\n    pass.end();\n    commandEncoder.copyBufferToBuffer(\n        this.needsCaching, 0, this.needsCachingOffsets, 0, this.totalElements * 4);\n\n    this.device.queue.submit([commandEncoder.finish()]);\n    // var start = performance.now()\n    await this.device.queue.onSubmittedWorkDone();\n    var end = performance.now();\n    // console.log(`LRU: Extract slots available took ${end - start}ms`);\n    perfTracker[\"lru\"][\"markNewItems_ms\"] = end - start;\n\n    uploadBuf.destroy();\n\n    // Scan the needsCaching buffer to get a count of which items need caching\n    // and the available slot offset that they'll be assigned\n    // The scan output will need to be written to a separate buffer so I can compact,\n    // or I can just merge the compact of both together (like a multi-compact step)\n    // where we compact both the slot offset assignments and the item for that\n    // new slot together in one step, since the offset to write to in both\n    // arrays is the same (the output of the scan on needsCaching)\n    // This doesn't really need changes to do a multi-compact, because we can just pass\n    // the same compact offset buffer twice\n    var start = performance.now();\n    var numNewItems = await this.scanNeededSlots.scan(this.totalElements);\n    var end = performance.now();\n    // console.log(`LRU: Scan needed slots took ${end - start}ms`);\n    perfTracker[\"lru\"][\"scanNeededSlots_ms\"] = end - start;\n    perfTracker[\"lru\"][\"nNewItems\"] = numNewItems;\n\n    // console.log(`LRU: num new items ${numNewItems}`);\n    if (numNewItems == 0) {\n        return [0, undefined];\n    }\n\n    // Compact the IDs of the elements we need into a list of new elements we'll add\n    var newItemIDs = this.device.createBuffer({\n        size: numNewItems * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    var start = performance.now();\n    await this.streamCompact.compactActiveIDs(\n        this.totalElements, this.needsCaching, this.needsCachingOffsets, newItemIDs);\n    var end = performance.now();\n    // console.log(`Compact new item ids took ${end - start}ms`);\n    perfTracker[\"lru\"][\"compactNewItems_ms\"] = end - start;\n\n    // Scan the slotAvailable buffer to get a count of the slots we currently\n    // have available, based on the items we can evict from the cache. This scan\n    // should output to the slotAvailableIDs buffer\n    var start = performance.now();\n    var numSlotsAvailable = await this.slotAvailableScanner.scan(this.cacheSize);\n    var end = performance.now();\n    // console.log(`LRU: Scan slots available took ${end - start}ms`);\n    perfTracker[\"lru\"][\"scanSlotsAvailable_ms\"] = end - start;\n    perfTracker[\"lru\"][\"nSlotsAvailable\"] = numSlotsAvailable;\n\n    // If there aren't enough slots to hold the new items we need to cache,\n    // we have to grow the cache: expand ages, slotAvailable, slotAvailableOffsets,\n    // slotAvailableIDs, cache to the new size and copy in the old data.\n    // Then run a pass over the slotAvailable buffer to mark the slots as available\n    if (numSlotsAvailable < numNewItems) {\n        var startGrow = performance.now();\n\n        // We don't need to preserve these buffer's contents so release them first to free\n        // space\n        this.slotAvailableIDs.destroy();\n        this.slotAvailableOffsets.destroy();\n        this.slotAvailableForCompact.destroy();\n\n        var newSize =\n            Math.min(this.cacheSize + Math.ceil((numNewItems - numSlotsAvailable) * 1.5),\n                this.totalElements);\n        newSize = (0,_exclusive_scan__WEBPACK_IMPORTED_MODULE_1__.alignTo)(newSize, 64);\n\n        var slotData = this.device.createBuffer({\n            size: newSize * 4 * 3,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n        var cache = this.device.createBuffer({\n            size: newSize * this.elementSize,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n        });\n\n        this.slotAvailableForCompact = this.device.createBuffer({\n            size: newSize * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n\n        this.slotAvailableIDs = this.device.createBuffer({\n            size: newSize * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n\n        // Update the bindgroups\n        this.lruCacheBG = this.device.createBindGroup({\n            layout: this.lruCacheBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.cachedItemSlots,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.slotAvailableIDs,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: slotData,\n                    },\n                },\n            ],\n        });\n\n        this.outputSlotAvailableForCompact = this.device.createBindGroup({\n            layout: this.cacheUpdateBGLayout,\n            entries: [{\n                binding: 0,\n                resource: {\n                    buffer: this.slotAvailableForCompact,\n                }\n            }]\n        });\n\n        var commandEncoder = this.device.createCommandEncoder();\n\n        // Initialize the new parts of the buffers\n        var pass = commandEncoder.beginComputePass();\n        pass.setPipeline(this.cacheInitPipeline);\n        pass.setBindGroup(0, this.lruCacheBG);\n        pass.setBindGroup(1, this.cacheInitBG);\n        // Probably needs to chunk for very large volumes\n        pass.dispatchWorkgroups((newSize - this.cacheSize) / 64, 1, 1);\n        pass.end();\n\n        // Copy in the old contents of the buffers to the new ones\n        commandEncoder.copyBufferToBuffer(\n            this.slotData, 0, slotData, 0, this.cacheSize * 4 * 3);\n        commandEncoder.copyBufferToBuffer(\n            this.cache, 0, cache, 0, this.cacheSize * this.elementSize);\n\n        this.device.queue.submit([commandEncoder.finish()]);\n        await this.device.queue.onSubmittedWorkDone();\n\n        this.slotData.destroy();\n        this.slotData = slotData;\n\n        this.cache.destroy();\n        this.cache = cache;\n\n        // Update the slot available offsets data and re-scan it to compute for our larger\n        // cache size\n        this.slotAvailableOffsets = this.device.createBuffer({\n            size: this.scanPipeline.getAlignedSize(newSize) * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n\n        this.outputSlotAvailableBG = this.device.createBindGroup({\n            layout: this.cacheUpdateBGLayout,\n            entries: [{\n                binding: 0,\n                resource: {\n                    buffer: this.slotAvailableOffsets,\n                }\n            }]\n        });\n\n        var commandEncoder = this.device.createCommandEncoder();\n\n        var pass = commandEncoder.beginComputePass()\n        // We need a kernel to copy the slotAvailable member out of the structs instead of\n        // using copyBufferToBuffer, since it's stored AoS to reduce our buffer use\n        pass.setPipeline(this.extractSlotAvailablePipeline);\n        pass.setBindGroup(0, this.lruCacheBG);\n        pass.setBindGroup(1, this.outputSlotAvailableBG);\n        pass.dispatchWorkgroups(newSize / 64, 1, 1);\n        pass.end();\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        // Update available slot IDs w/ a new scan result\n        this.slotAvailableScanner = this.scanPipeline.prepareGPUInput(\n            this.slotAvailableOffsets, this.scanPipeline.getAlignedSize(newSize));\n\n        await this.device.queue.onSubmittedWorkDone();\n        var end = performance.now();\n        // console.log(`cache resize took ${end - startGrow}ms`);\n\n        var start = performance.now();\n        numSlotsAvailable = await this.slotAvailableScanner.scan(newSize);\n        var end = performance.now();\n        // console.log(`LRU: Resize and scan new cache took ${end - startGrow}ms`);\n\n        perfTracker[\"lru\"][\"growCache_ms\"] = end - startGrow;\n        this.cacheSize = newSize;\n    }\n    this.displayNumSlotsAvailable = numSlotsAvailable - numNewItems;\n\n    // Compact the slot IDs to get the slots we'll assign to the new\n    // data which needs to be cached, and fill those out in the cached item slots\n    // For the items which are evicted from the cache by assigning their slot\n    // to another item, we have to mark that they're no longer cached\n    var start = performance.now();\n\n    // We need a kernel to copy the slotAvailable member out of the structs into a temp array\n    // for use by stream compact. Not as great for perf, but a bit lazy here ideally we can\n    // undo this buffer use reduction once the limits API is added.\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass()\n    pass.setPipeline(this.extractSlotAvailablePipeline);\n    pass.setBindGroup(0, this.lruCacheBG);\n    pass.setBindGroup(1, this.outputSlotAvailableForCompact);\n    // Probably needs to chunk for very large volumes\n    pass.dispatchWorkgroups(this.cacheSize / 64, 1, 1);\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    // I don't think we need an await here since it's all on the same queue\n    // await this.device.queue.onSubmittedWorkDone();\n\n    await this.streamCompact.compactActiveIDs(this.cacheSize,\n        this.slotAvailableForCompact,\n        this.slotAvailableOffsets,\n        this.slotAvailableIDs);\n    var end = performance.now();\n    // console.log(`LRU: Compact available slot IDs took ${end - start}ms`);\n    perfTracker[\"lru\"][\"compactAvailableSlots_ms\"] = end - start;\n\n    var start = performance.now();\n    // Sort the available slots by their age\n    var slotKeys = this.device.createBuffer({\n        size: this.sorter.getAlignedSize(numSlotsAvailable) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    var sortedIDs = this.device.createBuffer({\n        size: this.sorter.getAlignedSize(numSlotsAvailable) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n\n    var outputAgeBG = this.device.createBindGroup({\n        layout: this.cacheUpdateBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: slotKeys,\n                },\n            },\n        ],\n    });\n\n    var numSlotsAvailableBuf = this.device.createBuffer(\n        {size: 4, usage: GPUBufferUsage.UNIFORM, mappedAtCreation: true});\n    {\n        var uploadArray = new Uint32Array(numSlotsAvailableBuf.getMappedRange());\n        uploadArray[0] = numSlotsAvailable;\n        numSlotsAvailableBuf.unmap();\n    }\n\n    var outputAgeBGSize = this.device.createBindGroup({\n        layout: this.singleUniformBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: numSlotsAvailableBuf,\n                },\n            },\n        ],\n    });\n\n    // Note: Bit of trick/hack, we only sort the number of entries we need since the\n    // sort implementation needs improvement. This helps the LRU cache update cost\n    // scale with the number of new items instead of the cache size, at the cost of making\n    // it not quite guaranteed that the oldest items are always evicted first.\n    var numItemsToSort = numNewItems;\n    // console.log(`LRU: numNewItems = ${numNewItems}, numSlotsAvailable =\n    // ${numSlotsAvailable}`);\n    var commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyBufferToBuffer(\n        this.slotAvailableIDs, 0, sortedIDs, 0, numSlotsAvailable * 4);\n    // Run pass to copy the slot ages over\n    var pass = commandEncoder.beginComputePass();\n    pass.setPipeline(this.copyAvailableSlotAgePipeline);\n    pass.setBindGroup(0, this.lruCacheBG);\n    pass.setBindGroup(1, outputAgeBG);\n    pass.setBindGroup(2, outputAgeBGSize);\n    pass.dispatchWorkgroups(Math.ceil(numSlotsAvailable / 64), 1, 1);\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n    var end = performance.now();\n    // console.log(`LRU: Prep key/value pairs for sort: ${end - start}ms`);\n    perfTracker[\"lru\"][\"prepKeyValue_ms\"] = end - start;\n\n    var start = performance.now();\n    await this.sorter.sort(slotKeys, sortedIDs, numItemsToSort, true);\n    var end = performance.now();\n    // console.log(`LRU: Sorting ${numItemsToSort} ages/slots took ${end - start}ms`);\n    perfTracker[\"lru\"][\"totalSortTime_ms\"] = end - start;\n\n    // Update the bindgroup\n    var sortedSlotsBG = this.device.createBindGroup({\n        layout: this.lruCacheBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: this.cachedItemSlots,\n                },\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: sortedIDs,\n                },\n            },\n            {\n                binding: 2,\n                resource: {\n                    buffer: this.slotData,\n                },\n            },\n        ],\n    });\n\n    var cacheUpdateBG = this.device.createBindGroup({\n        layout: this.cacheUpdateBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: newItemIDs,\n                },\n            },\n        ],\n    });\n\n    var numNewItemsBuf = this.device.createBuffer(\n        {size: 4, usage: GPUBufferUsage.UNIFORM, mappedAtCreation: true});\n    {\n        var uploadArray = new Uint32Array(numNewItemsBuf.getMappedRange());\n        uploadArray[0] = numNewItems;\n        numNewItemsBuf.unmap();\n    }\n\n    var numNewItemsBG = this.device.createBindGroup({\n        layout: this.singleUniformBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: numNewItemsBuf,\n                },\n            },\n        ],\n    });\n\n    var start = performance.now();\n    // Update the slot item IDs with the new items which will be stored in the cache\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass();\n    pass.setPipeline(this.cacheUpdatePipeline);\n    pass.setBindGroup(0, sortedSlotsBG);\n    pass.setBindGroup(1, cacheUpdateBG);\n    pass.setBindGroup(2, numNewItemsBG);\n    // TODO: Probably needs to chunk for large volumes\n    pass.dispatchWorkgroups(Math.ceil(numNewItems / 64), 1, 1);\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n    var end = performance.now();\n    // console.log(`LRU: Writing new item slots took ${end - start}ms`);\n    perfTracker[\"lru\"][\"writeNewItems_ms\"] = end - start;\n\n    slotKeys.destroy();\n    sortedIDs.destroy();\n\n    // console.log(\"------\");\n    // Return the list of blocks which need to be decompressed into the cache\n    // The location to write them is found in cachedItemSlots[itemID]\n    return [numNewItems, newItemIDs];\n};\n\n// Reset the cache to clear items and force them to be decompressed again for benchmarking\nLRUCache.prototype.reset = async function () {\n    // We just run the same init pipeline used when we grow the cache but\n    // just say the cache size is 0 when we run it to clear the whole thing\n    var uploadBuf = this.device.createBuffer({\n        size: 8,\n        usage: GPUBufferUsage.COPY_SRC,\n        mappedAtCreation: true,\n    });\n    new Uint32Array(uploadBuf.getMappedRange()).set([0, this.cacheSize]);\n    uploadBuf.unmap();\n\n    var commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyBufferToBuffer(uploadBuf, 0, this.cacheSizeBuf, 0, 4);\n    var pass = commandEncoder.beginComputePass();\n    pass.setPipeline(this.cacheInitPipeline);\n    pass.setBindGroup(0, this.lruCacheBG);\n    pass.setBindGroup(1, this.cacheInitBG);\n    pass.dispatchWorkgroups(this.cacheSize / 64, 1, 1);\n    pass.end();\n\n    // Also need to clear the cached item slots array, just copy the slot item\n    // ID array over it, which is also filled with -1\n    var buf = this.device.createBuffer({\n        size: this.cacheSize * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n        mappedAtCreation: true,\n    });\n    new Int32Array(buf.getMappedRange()).fill(-1);\n    buf.unmap();\n    var negativeBuffer = buf;\n    var numCopies = Math.ceil(this.totalElements / this.cacheSize);\n    for (var i = 0; i < numCopies; ++i) {\n        var copySize = Math.min(this.totalElements - i * this.cacheSize, this.cacheSize);\n        commandEncoder.copyBufferToBuffer(\n            negativeBuffer, 0, this.cachedItemSlots, i * this.cacheSize * 4, copySize * 4);\n    }\n\n    // Copy back over the original cache size to the cache size buffer\n    commandEncoder.copyBufferToBuffer(uploadBuf, 4, this.cacheSizeBuf, 0, 4);\n\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n\n    uploadBuf.destroy();\n};\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/lru_cache.js?");

/***/ }),

/***/ "./src/radix_sort_by_key.js":
/*!**********************************!*\
  !*** ./src/radix_sort_by_key.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RadixSorter\": () => (/* binding */ RadixSorter)\n/* harmony export */ });\n/* harmony import */ var _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./embedded_shaders */ \"./src/embedded_shaders.js\");\n\n\n\nvar RadixSorter = function(device) {\n    this.device = device;\n\n    this.bgLayout = this.device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n        ],\n    });\n\n    this.radixSortBGLayout = this.device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n\n    this.mergeBGLayout = this.device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n\n    this.numWorkGroupsBGLayout = this.device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n        ],\n    });\n\n    this.reverseBGLayout = this.device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n\n    this.sortPipeline = this.device.createComputePipeline({\n        layout: this.device.createPipelineLayout({\n            bindGroupLayouts: [this.bgLayout, this.radixSortBGLayout],\n        }),\n        compute: {\n            module: this.device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.radix_sort_chunk_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.mergePipeline = this.device.createComputePipeline({\n        layout: this.device.createPipelineLayout({\n            bindGroupLayouts: [\n                this.bgLayout,\n                this.mergeBGLayout,\n                this.numWorkGroupsBGLayout,\n            ],\n        }),\n        compute: {\n            module: this.device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.merge_sorted_chunks_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.reversePipeline = this.device.createComputePipeline({\n        layout: this.device.createPipelineLayout({\n            bindGroupLayouts: [this.bgLayout, this.reverseBGLayout],\n        }),\n        compute: {\n            module: this.device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.reverse_buffer_comp_spv}),\n            entryPoint: \"main\",\n        },\n    });\n};\n\nvar nextPow2 = function(x) {\n    var a = x - 1;\n    a |= a >> 1;\n    a |= a >> 2;\n    a |= a >> 4;\n    a |= a >> 8;\n    a |= a >> 16;\n    return a + 1;\n};\n\nRadixSorter.prototype.getAlignedSize = function(size) {\n    var chunkCount = nextPow2(Math.ceil(size / _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.SortChunkSize));\n    return chunkCount * _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.SortChunkSize;\n};\n\n// Input buffers are assumed to be of size \"alignedSize\"\nRadixSorter.prototype.sort = async function(keys, values, size, reverse) {\n    // Has to be a pow2 * chunkSize elements, since we do log_2 merge steps up\n    var chunkCount = nextPow2(Math.ceil(size / _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.SortChunkSize));\n    var alignedSize = chunkCount * _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.SortChunkSize;\n    var numMergeSteps = Math.log2(chunkCount);\n    if (chunkCount > 65535) {\n        alert(`Sort got ${chunkCount} blocks, more than max 65535! Try reducing start spec count.`);\n    }\n\n    var buffers = {\n        keys: keys,\n        values: values,\n    };\n\n    var scratch = {\n        keys: this.device.createBuffer({\n            size: alignedSize * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        }),\n        values: this.device.createBuffer({\n            size: alignedSize * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        }),\n    };\n\n    var arrayInfoBuf = this.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_SRC,\n        mappedAtCreation: true,\n    });\n    new Uint32Array(arrayInfoBuf.getMappedRange()).set([size]);\n    arrayInfoBuf.unmap();\n\n    // We'll send the workgroup count through a UBO w/ dynamic offset, so we need\n    // to obey the dynamic offset alignment rules as well\n    var numWorkGroupsBuf = this.device.createBuffer({\n        size: Math.max(numMergeSteps, 1) * 256,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_SRC,\n        mappedAtCreation: true,\n    });\n    {\n        var upload = new Uint32Array(numWorkGroupsBuf.getMappedRange());\n        for (var i = 0; i < numMergeSteps; ++i) {\n            upload[i * 64] = chunkCount / (2 << i);\n        }\n    }\n    numWorkGroupsBuf.unmap();\n\n    var infoBindGroup = this.device.createBindGroup({\n        layout: this.bgLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: arrayInfoBuf,\n                },\n            },\n        ],\n    });\n\n    var radixSortBG = this.device.createBindGroup({\n        layout: this.radixSortBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: buffers.keys,\n                },\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: buffers.values,\n                },\n            },\n        ],\n    });\n\n    var mergeBindGroups = [\n        this.device.createBindGroup({\n            layout: this.mergeBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: buffers.keys,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: buffers.values,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: scratch.keys,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: scratch.values,\n                    },\n                },\n            ],\n        }),\n        this.device.createBindGroup({\n            layout: this.mergeBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: scratch.keys,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: scratch.values,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: buffers.keys,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: buffers.values,\n                    },\n                },\n            ],\n        }),\n    ];\n\n    var reverseBG = this.device.createBindGroup({\n        layout: this.reverseBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: numMergeSteps % 2 == 0 ? buffers.values : scratch.values,\n                },\n            },\n        ],\n    });\n\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass();\n    pass.setPipeline(this.sortPipeline);\n    pass.setBindGroup(0, infoBindGroup);\n    pass.setBindGroup(1, radixSortBG);\n    pass.dispatchWorkgroups(chunkCount, 1, 1);\n    pass.end();\n\n    // Merge the chunks up\n    var pass = commandEncoder.beginComputePass();\n    pass.setPipeline(this.mergePipeline);\n    pass.setBindGroup(0, infoBindGroup);\n    for (var i = 0; i < numMergeSteps; ++i) {\n        var numWorkGroupsBG = this.device.createBindGroup({\n            layout: this.numWorkGroupsBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: numWorkGroupsBuf,\n                        size: 4,\n                        offset: i * 256,\n                    },\n                },\n            ],\n        });\n        pass.setBindGroup(1, mergeBindGroups[i % 2]);\n        pass.setBindGroup(2, numWorkGroupsBG);\n        pass.dispatchWorkgroups(chunkCount / (2 << i), 1, 1);\n    }\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    var commandEncoder = this.device.createCommandEncoder();\n    if (reverse) {\n        var pass = commandEncoder.beginComputePass();\n        pass.setPipeline(this.reversePipeline);\n        pass.setBindGroup(0, infoBindGroup);\n        pass.setBindGroup(1, reverseBG);\n        pass.dispatchWorkgroups(Math.ceil(chunkCount / 2), 1, 1);\n        pass.end();\n    }\n\n    var readbackOffset = reverse ? alignedSize - size : 0;\n    // Copy the sorted real data to the start of the buffer\n    if (numMergeSteps % 2 == 0) {\n        commandEncoder.copyBufferToBuffer(\n            buffers.values, readbackOffset * 4, scratch.values, 0, size * 4);\n        commandEncoder.copyBufferToBuffer(scratch.values, 0, buffers.values, 0, size * 4);\n    } else {\n        commandEncoder.copyBufferToBuffer(\n            scratch.values, readbackOffset * 4, buffers.values, 0, size * 4);\n    }\n\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n\n    scratch.keys.destroy();\n    scratch.values.destroy();\n    arrayInfoBuf.destroy();\n    numWorkGroupsBuf.destroy();\n};\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/radix_sort_by_key.js?");

/***/ }),

/***/ "./src/run_benchmark.js":
/*!******************************!*\
  !*** ./src/run_benchmark.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CameraOrbitBenchmark\": () => (/* binding */ CameraOrbitBenchmark),\n/* harmony export */   \"ManualSingleBenchmark\": () => (/* binding */ ManualSingleBenchmark),\n/* harmony export */   \"NestedBenchmark\": () => (/* binding */ NestedBenchmark),\n/* harmony export */   \"RandomIsovalueBenchmark\": () => (/* binding */ RandomIsovalueBenchmark),\n/* harmony export */   \"RotateBenchmark\": () => (/* binding */ RotateBenchmark),\n/* harmony export */   \"SweepIsovalueBenchmark\": () => (/* binding */ SweepIsovalueBenchmark),\n/* harmony export */   \"generateBenchmarkConfigurations\": () => (/* binding */ generateBenchmarkConfigurations)\n/* harmony export */ });\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/vec3.js\");\n/* harmony import */ var _volumes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./volumes */ \"./src/volumes.js\");\n\n\nconst benchmarkIterations = 10;\nconst cameraIterations = 10;\nconst rotateIterations = 10;\n\nvar RandomIsovalueBenchmark = function (isovalueSlider, range) {\n    this.name = \"random\";\n    this.iteration = 0;\n    this.isovalueSlider = isovalueSlider;\n    this.range = range;\n    this.numIterations = benchmarkIterations;\n};\n\nRandomIsovalueBenchmark.prototype.run = function () {\n    if (this.iteration == this.numIterations) {\n        return false;\n    }\n    var range = this.range[1] - this.range[0];\n    this.isovalueSlider.value = Math.random() * range + this.range[0];\n    this.iteration += 1;\n    return true;\n};\n\nRandomIsovalueBenchmark.prototype.reset = function () {\n    this.iteration = 0;\n};\n\nvar SweepIsovalueBenchmark = function (isovalueSlider, range, sweepUp) {\n    this.iteration = 0;\n    this.isovalueSlider = isovalueSlider;\n    this.range = range;\n    this.sweepUp = sweepUp;\n    this.numIterations = benchmarkIterations;\n    if (this.sweepUp) {\n        this.name = \"sweepUp\";\n        this.currentValue = range[0];\n    } else {\n        this.name = \"sweepDown\";\n        this.currentValue = range[1];\n    }\n};\n\nSweepIsovalueBenchmark.prototype.run = function () {\n    if (this.iteration == this.numIterations) {\n        return false;\n    }\n    var step = (this.range[1] - this.range[0]) / benchmarkIterations;\n    if (this.sweepUp) {\n        this.currentValue += step;\n    } else {\n        this.currentValue -= step;\n    }\n    this.isovalueSlider.value = this.currentValue;\n    this.iteration += 1;\n    return true;\n};\n\n// ManualSingleBenchmark just re-runs whatever current isovalue we have picked\nvar ManualSingleBenchmark = function () {\n    this.done = false;\n    this.name = \"manualSingle\";\n};\n\nManualSingleBenchmark.prototype.run = function () {\n    if (this.done) {\n        return false;\n    }\n    this.done = true;\n    return true;\n};\n\nManualSingleBenchmark.prototype.reset = function () {\n    this.done = false;\n};\n\nSweepIsovalueBenchmark.prototype.reset = function () {\n    this.iteration = 0;\n};\n\nvar CameraOrbitBenchmark = function (radius) {\n    this.iteration = 0;\n    this.name = \"cameraOrbit\";\n    this.numIterations = cameraIterations;\n    this.radius = radius;\n};\n\nCameraOrbitBenchmark.prototype.run = function () {\n    if (this.iteration == this.numIterations) {\n        return false;\n    }\n    const increment = Math.PI * (3.0 - Math.sqrt(5.0));\n    const offset = 2.0 / this.numIterations;\n\n    var y = ((this.iteration * offset) - 1.0) + offset / 2.0;\n    const r = Math.sqrt(1.0 - y * y);\n    const phi = this.iteration * increment;\n    var x = r * Math.cos(phi);\n    var z = r * Math.sin(phi);\n\n    x *= this.radius;\n    y *= this.radius;\n    z *= this.radius;\n\n    this.currentPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), x, y, z);\n    this.iteration += 1;\n\n    return true;\n};\n\nCameraOrbitBenchmark.prototype.reset = function () {\n    this.iteration = 0;\n};\n\nvar RotateBenchmark = function (radius, width, height) {\n    this.iteration = 0;\n    this.name = \"rotate\";\n    this.numIterations = rotateIterations;\n    this.radius = radius;\n    this.width = width;\n    this.height = height;\n    this.renderID = Date.now().toString().slice(-6);\n\n    var theta = Math.random() * 2 * Math.PI; // Azimuthal angle\n    var phi = Math.acos(2 * Math.random() - 1); // Polar angle\n    var x = radius * Math.sin(phi) * Math.cos(theta);\n    var y = radius * Math.sin(phi) * Math.sin(theta);\n    var z = radius * Math.cos(phi);\n    this.startPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), x, y, z);\n\n    this.startX = Math.random() * this.width;\n    this.startY = Math.random() * this.height;\n    this.currentX = this.startX;\n    this.currentY = this.startY;\n    this.endX = Math.random() * this.width;\n    this.endY = Math.random() * this.height;\n};\n\nRotateBenchmark.prototype.run = function () {\n    if (this.iteration == this.numIterations) {\n        return false;\n    }\n    this.lastX = this.currentX;\n    this.lastY = this.currentY;\n    const t = this.iteration / (this.numIterations - 1);\n    this.currentX = this.startX + t * (this.endX - this.startX);\n    this.currentY = this.startY + t * (this.endY - this.startY);\n    this.iteration += 1;\n    return true;\n};\n\nRotateBenchmark.prototype.reset = function () {\n    this.renderID = Date.now().toString().slice(-6);\n    this.iteration = 0;\n    var theta = Math.random() * 2 * Math.PI; // Azimuthal angle\n    var phi = Math.acos(2 * Math.random() - 1); // Polar angle\n    var x = this.radius * Math.sin(phi) * Math.cos(theta);\n    var y = this.radius * Math.sin(phi) * Math.sin(theta);\n    var z = this.radius * Math.cos(phi);\n    this.startPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), x, y, z);\n\n    this.startX = Math.random() * this.width;\n    this.startY = Math.random() * this.height;\n    this.currentX = this.startX;\n    this.currentY = this.startY;\n    this.endX = Math.random() * this.width;\n    this.endY = Math.random() * this.height;\n};\n\nvar NestedBenchmark = function (outerLoop, innerLoop) {\n    this.name = outerLoop.name + \"-\" + innerLoop.name;\n    this.outerLoop = outerLoop;\n    this.innerLoop = innerLoop;\n    this.iteration = 0;\n};\n\nNestedBenchmark.prototype.run = function () {\n    if (this.iteration == 0) {\n        this.outerLoop.run();\n    }\n    if (!this.innerLoop.run()) {\n        if (!this.outerLoop.run()) {\n            return false;\n        }\n        this.innerLoop.reset();\n        this.innerLoop.run();\n    }\n    this.iteration += 1;\n    return true;\n}\n\n// Generate the list of benchmark configurations\n// we're going to run in autobenchmark mode\nfunction generateBenchmarkConfigurations() {\n    // Do we really need to go up to ssc 8? Probably just on the 3080\n    const startSpecCounts = [1, 2];//, 4, 8];\n    //const resolutions = [\"1080\", \"720\", \"360\"];\n    const resolutions = [\"720\"]//, \"360\"];\n    const imageCompleteness = [1.0];\n    const datasets = [\n        \"skull\",\n        \"tacc_turbulence\",\n        \"magnetic\",\n        \"kingsnake\",\n        \"chameleon\",\n        \"beechnut\",\n        \"miranda\",\n        \"jicf_q\",\n        \"dns_large\",\n        \"richtmyer_meshkov\"\n    ];\n    const radii = [1.0, 1.5];\n    const infer = false;\n\n    let benchmarks = [];\n    for (const d of datasets) {\n        for (const ic of imageCompleteness) {\n            for (const r of resolutions) {\n                for (const ssc of startSpecCounts) {\n                    for (const rad of radii) {\n                        benchmarks.push({\n                            dataset: d,\n                            imageCompleteness: ic,\n                            resolution: r,\n                            startSpecCount: ssc,\n                            radius: rad,\n                            infer: infer\n                        });\n                    }\n                }\n            }\n        }\n    }\n    return benchmarks;\n}\n\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/run_benchmark.js?");

/***/ }),

/***/ "./src/stream_compact.js":
/*!*******************************!*\
  !*** ./src/stream_compact.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StreamCompact\": () => (/* binding */ StreamCompact)\n/* harmony export */ });\n/* harmony import */ var _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./embedded_shaders */ \"./src/embedded_shaders.js\");\n\nvar StreamCompact = function(device) {\n    this.device = device;\n\n    // Not sure how to query this limit, assuming this size based on OpenGL\n    // In a less naive implementation doing some block-based implementation w/\n    // larger group sizes might be better as well\n    // We also need to make sure the offset we'll end up using for the\n    // dynamic offsets is aligned to 256 bytes. We're offsetting into arrays\n    // of uint32, so determine the max dispatch size we should use for each\n    // individual aligned chunk\n    this.maxDispatchSize = Math.floor(65535 / 256) * 256;\n\n    this.streamCompactBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n    this.streamCompactPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [this.streamCompactBGLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.stream_compact_comp_spv}),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.dataBGLayout = device.createBindGroupLayout({\n        entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n                type: \"storage\",\n            }\n        }]\n    });\n    this.streamCompactDataPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout(\n            {bindGroupLayouts: [this.streamCompactBGLayout, this.dataBGLayout]}),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_0__.stream_compact_data_comp_spv}),\n            entryPoint: \"main\",\n        }\n    });\n};\n\nStreamCompact.prototype.compactActiveIDs =\n    async function(numElements, isActiveBuffer, offsetsBuffer, outputBuffer) {\n    // No push constants in the API? This is really a hassle to hack together\n    // because I also have to obey (at least Dawn's rule is it part of the spec?)\n    // that the dynamic offsets be 256b aligned\n    // Please add push constants!\n    var numChunks = Math.ceil(numElements / this.maxDispatchSize);\n    var compactPassOffset = this.device.createBuffer({\n        size: numChunks * 256,\n        usage: GPUBufferUsage.UNIFORM,\n        mappedAtCreation: true,\n    });\n    {\n        var map = new Uint32Array(compactPassOffset.getMappedRange());\n        for (var i = 0; i < numChunks; ++i) {\n            map[i * 64] = i * this.maxDispatchSize;\n        }\n        compactPassOffset.unmap();\n    }\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass();\n    pass.setPipeline(this.streamCompactPipeline);\n    for (var i = 0; i < numChunks; ++i) {\n        var numWorkGroups =\n            Math.min(numElements - i * this.maxDispatchSize, this.maxDispatchSize);\n        var offset = i * this.maxDispatchSize * 4;\n        // Have to create bind groups here because dynamic offsets are not allowed\n        // for security\n        // TODO: Was this re-enabled?\n        var streamCompactBG = null;\n        if (numWorkGroups === this.maxDispatchSize) {\n            streamCompactBG = this.device.createBindGroup({\n                layout: this.streamCompactBGLayout,\n                entries: [\n                    {\n                        binding: 0,\n                        resource: {\n                            buffer: isActiveBuffer,\n                            size: 4 * Math.min(numElements, this.maxDispatchSize),\n                            offset: offset,\n                        },\n                    },\n                    {\n                        binding: 1,\n                        resource: {\n                            buffer: offsetsBuffer,\n                            size: 4 * Math.min(numElements, this.maxDispatchSize),\n                            offset: offset,\n                        },\n                    },\n                    {\n                        binding: 2,\n                        resource: {\n                            buffer: compactPassOffset,\n                            size: 4,\n                            offset: i * 256,\n                        },\n                    },\n                    {\n                        binding: 3,\n                        resource: {\n                            buffer: outputBuffer,\n                        },\n                    },\n                ],\n            });\n        } else {\n            streamCompactBG = this.device.createBindGroup({\n                layout: this.streamCompactBGLayout,\n                entries: [\n                    {\n                        binding: 0,\n                        resource: {\n                            buffer: isActiveBuffer,\n                            size: 4 * (numElements % this.maxDispatchSize),\n                            offset: offset,\n                        },\n                    },\n                    {\n                        binding: 1,\n                        resource: {\n                            buffer: offsetsBuffer,\n                            size: 4 * (numElements % this.maxDispatchSize),\n                            offset: offset,\n                        },\n                    },\n                    {\n                        binding: 2,\n                        resource: {\n                            buffer: compactPassOffset,\n                            size: 4,\n                            offset: i * 256,\n                        },\n                    },\n                    {\n                        binding: 3,\n                        resource: {\n                            buffer: outputBuffer,\n                        },\n                    },\n                ],\n            });\n        }\n        pass.setBindGroup(0, streamCompactBG);\n        pass.dispatchWorkgroups(Math.ceil(numWorkGroups / 8), 1, 1);\n    }\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n};\n\nStreamCompact.prototype.compactActive =\n    async function(numElements, isActiveBuffer, offsetsBuffer, dataBuffer, outputBuffer) {\n    // No push constants in the API? This is really a hassle to hack together\n    // because I also have to obey (at least Dawn's rule is it part of the spec?)\n    // that the dynamic offsets be 256b aligned\n    // Please add push constants!\n    var numChunks = Math.ceil(numElements / this.maxDispatchSize);\n    var compactPassOffset = this.device.createBuffer({\n        size: numChunks * 256,\n        usage: GPUBufferUsage.UNIFORM,\n        mappedAtCreation: true,\n    });\n    {\n        var map = new Uint32Array(compactPassOffset.getMappedRange());\n        for (var i = 0; i < numChunks; ++i) {\n            map[i * 64] = i * this.maxDispatchSize;\n        }\n        compactPassOffset.unmap();\n    }\n\n    var dataBG = this.device.createBindGroup(\n        {layout: this.dataBGLayout, entries: [{binding: 0, resource: {buffer: dataBuffer}}]});\n\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass();\n    pass.setPipeline(this.streamCompactDataPipeline);\n    for (var i = 0; i < numChunks; ++i) {\n        var numWorkGroups =\n            Math.min(numElements - i * this.maxDispatchSize, this.maxDispatchSize);\n\n        // Have to create bind groups here because dynamic offsets are not allowed\n        var streamCompactBG = this.device.createBindGroup({\n            layout: this.streamCompactBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: isActiveBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: offsetsBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: compactPassOffset,\n                        size: 4,\n                        offset: i * 256,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: outputBuffer,\n                    },\n                },\n            ],\n        });\n        pass.setBindGroup(0, streamCompactBG);\n        pass.setBindGroup(1, dataBG);\n        pass.dispatchWorkgroups(Math.ceil(numWorkGroups / 8), 1, 1);\n    }\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n};\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/stream_compact.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildPushConstantsBuffer\": () => (/* binding */ buildPushConstantsBuffer)\n/* harmony export */ });\n// Generate the work group ID offset buffer and the dynamic offset buffer to use for chunking\n// up a large compute dispatch. The start of the push constants data will be:\n// {\n//      u32: global work group id offset\n//      u32: totalWorkGroups\n//      ...: up to 248 bytes additional data (if any) from the pushConstants parameter,\n//           passed as an ArrayBuffer or TypedArray\n// }\n// ID offset (u32),\nfunction buildPushConstantsBuffer(device, totalWorkGroups, pushConstants)\n{\n    var dynamicOffsets = [];\n    var dispatchSizes = [];\n\n    var numDynamicOffsets =\n        Math.ceil(totalWorkGroups / device.limits.maxComputeWorkgroupsPerDimension);\n    var idOffsetsBuffer = device.createBuffer({\n        size: 256 * numDynamicOffsets,\n        usage: GPUBufferUsage.UNIFORM,\n        mappedAtCreation: true,\n    });\n    {\n        var pushConstantsView = null;\n        if (pushConstants) {\n            var pc = pushConstants;\n            if (pushConstants.buffer) {\n                pc = pushConstants.buffer;\n            }\n            if (pc.byteLength > 248) {\n                console.log(`Error: push constants can be at most 248 bytes`);\n            }\n            pushConstantsView = new Uint8Array(pc);\n        }\n        var mapping = idOffsetsBuffer.getMappedRange();\n        for (var i = 0; i < numDynamicOffsets; ++i) {\n            dynamicOffsets.push(i * 256);\n\n            if (i + 1 < numDynamicOffsets) {\n                dispatchSizes.push(device.limits.maxComputeWorkgroupsPerDimension);\n            } else {\n                dispatchSizes.push(totalWorkGroups %\n                                   device.limits.maxComputeWorkgroupsPerDimension);\n            }\n\n            // Write the push constants data\n            var u32view = new Uint32Array(mapping, i * 256, 2);\n            u32view[0] = device.limits.maxComputeWorkgroupsPerDimension * i;\n            u32view[1] = totalWorkGroups;\n\n            // Copy in any additional push constants data if provided\n            if (pushConstantsView) {\n                var u8view = new Uint8Array(mapping, i * 256 + 8, 248);\n                u8view.set(pushConstantsView);\n            }\n        }\n        idOffsetsBuffer.unmap();\n    }\n    dynamicOffsets = new Uint32Array(dynamicOffsets);\n\n    return {\n        nOffsets: numDynamicOffsets,\n        gpuBuffer: idOffsetsBuffer,\n        dynamicOffsets: dynamicOffsets,\n        dispatchSizes: dispatchSizes,\n    };\n}\n\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/util.js?");

/***/ }),

/***/ "./src/volume_raycaster.js":
/*!*********************************!*\
  !*** ./src/volume_raycaster.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VolumeRaycaster\": () => (/* binding */ VolumeRaycaster)\n/* harmony export */ });\n/* harmony import */ var _exclusive_scan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exclusive_scan */ \"./src/exclusive_scan.js\");\n/* harmony import */ var _stream_compact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stream_compact */ \"./src/stream_compact.js\");\n/* harmony import */ var _radix_sort_by_key__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radix_sort_by_key */ \"./src/radix_sort_by_key.js\");\n/* harmony import */ var _lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lru_cache */ \"./src/lru_cache.js\");\n/* harmony import */ var _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./embedded_shaders */ \"./src/embedded_shaders.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n\n\n\n\n\n\nvar VolumeRaycaster = function(\n    device, width, height, recordVisibleBlocksUI, enableSpeculationUI, startSpecCount) {\n    this.device = device;\n    this.scanPipeline = new _exclusive_scan__WEBPACK_IMPORTED_MODULE_0__.ExclusiveScanPipeline(device);\n    this.streamCompact = new _stream_compact__WEBPACK_IMPORTED_MODULE_1__.StreamCompact(device);\n    // Number of blocks visible for the current pass\n    this.numVisibleBlocks = 0;\n    // Number of blocks decompressed for the current pass\n    this.newDecompressed = 0;\n\n    this.renderComplete = false;\n\n    this.width = width;\n    this.height = height;\n    this.startSpecCount = startSpecCount;\n\n    // Record visible blocks will optionally track the total % of blocks that were active or\n    // visible while rendering the surface. This is just needed to provide this statistic for\n    // the paper and is computed on the host by just reading back the blockVisible buffer and\n    // or'ing it with the previous pass's one to accumulate the total block visible list\n    // without double-counting\n    this.recordVisibleBlocksUI = recordVisibleBlocksUI;\n\n    // For testing/demo/benchmarking of enable/disable speculation\n    this.enableSpeculationUI = enableSpeculationUI;\n\n    // Each pass appends its performance stats to the perfStats array,\n    // this is reset for each new isovalue\n    this.perfStats = [];\n\n    // Max dispatch size for more computationally heavy kernels\n    // which might hit TDR on lower power devices\n    this.maxDispatchSize = device.limits.maxComputeWorkgroupsPerDimension;\n\n    this.computeBlockRangeBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n    this.pushConstantS1B0DynamicLayout = device.createBindGroupLayout({\n        entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {type: \"uniform\", hasDynamicOffset: true}\n        }]\n    });\n    this.computeBlockRangePipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts:\n                [this.computeBlockRangeBGLayout, this.pushConstantS1B0DynamicLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.zfp_compute_block_range_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.computeVoxelRangeBGLayout = device.createBindGroupLayout({\n        entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n                type: \"storage\",\n            }\n        }]\n    });\n    this.computeVoxelRangePipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [\n                this.computeBlockRangeBGLayout,\n                this.pushConstantS1B0DynamicLayout,\n                this.computeVoxelRangeBGLayout\n            ]\n        }),\n        compute: {\n            module: device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.compute_voxel_range_comp_spv,\n            }),\n            entryPoint: \"main\",\n        }\n    });\n\n    this.computeCoarseCellRangeBGLayout = device.createBindGroupLayout({\n        entries: [\n            {binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {type: \"uniform\", hasDynamicOffset: true}\n            },\n            {binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}}\n        ]\n    });\n    this.computeCoarseCellRangePipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout(\n            {bindGroupLayouts: [this.computeCoarseCellRangeBGLayout]}),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.compute_coarse_cell_range_comp_spv}),\n            entryPoint: \"main\"\n        }\n    });\n\n    this.decompressBlocksBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 4,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n    this.ub1binding0BGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n        ],\n    });\n\n    this.decompressBlocksPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [\n                this.decompressBlocksBGLayout,\n                this.ub1binding0BGLayout,\n            ],\n        }),\n        compute: {\n            module: device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.zfp_decompress_block_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n\n    // Set up compute initial rays pipeline\n    this.viewParamBuf = device.createBuffer({\n        // mat4, 2 vec4's, a float, 2 uint + some extra to align\n        size: 32 * 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n\n    // We'll need a max of width * height RayInfo structs in the buffer,\n    // so just allocate it once up front\n    this.rayInformationBuffer = device.createBuffer({\n        size: this.width * this.height * 16,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    // We need width * height RayIDs for speculation,\n    // with ray indices repeated as speculation occurs\n    this.speculativeRayIDBuffer = device.createBuffer({\n        size: this.width * this.height * this.startSpecCount * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    this.rayRGBZBuffer = device.createBuffer({\n        size: this.width * this.height * this.startSpecCount * 2 * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    // Each ray stores 2 iterator states, the coarse one followed by the fine one.\n    // Each state is 32b\n    this.gridIteratorBuffer = device.createBuffer({\n        size: this.width * this.height * 8 * 4,\n        usage: GPUBufferUsage.STORAGE,\n    });\n\n    this.resetRaysBGLayout = device.createBindGroupLayout({\n        entries: [\n            {binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n            {binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}}\n        ]\n    });\n\n    this.resetRaysPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [\n                this.resetRaysBGLayout,\n            ],\n        }),\n        compute: {\n            module: device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.reset_rays_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.computeInitialRaysBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.VERTEX,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.FRAGMENT,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.FRAGMENT,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n\n    // Specify vertex data for compute initial rays\n    this.dataBuf = device.createBuffer({\n        size: 12 * 3 * 3 * 4,\n        usage: GPUBufferUsage.VERTEX,\n        mappedAtCreation: true,\n    });\n    new Float32Array(this.dataBuf.getMappedRange()).set([\n        1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1,\n        1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1,\n        0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1,\n        0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0,\n    ]);\n    this.dataBuf.unmap();\n\n    // Setup render outputs\n    var renderTargetFormat = \"rgba8unorm\";\n    this.renderTarget = this.device.createTexture({\n        size: [this.width, this.height, 1],\n        format: renderTargetFormat,\n        usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING |\n                   GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST\n    });\n    this.renderTargetCopy = this.device.createTexture({\n        size: [this.width, this.height, 1],\n        format: renderTargetFormat,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST\n    });\n\n    this.renderTargetDebugBGLayout = this.device.createBindGroupLayout({\n        entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            storageTexture: {access: \"write-only\", format: renderTargetFormat}\n        }]\n    });\n    this.renderTargetDebugBG = this.device.createBindGroup({\n        layout: this.renderTargetDebugBGLayout,\n        entries: [{binding: 0, resource: this.renderTarget.createView()}]\n    });\n\n    this.initialRaysPipeline = device.createRenderPipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [this.computeInitialRaysBGLayout],\n        }),\n        vertex: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.compute_initial_rays_vert_spv}),\n            entryPoint: \"main\",\n            buffers: [\n                {\n                    arrayStride: 3 * 4,\n                    attributes: [\n                        {\n                            format: \"float32x3\",\n                            offset: 0,\n                            shaderLocation: 0,\n                        },\n                    ],\n                },\n            ],\n        },\n        fragment: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.compute_initial_rays_frag_spv}),\n            entryPoint: \"main\",\n            targets: [\n                {\n                    format: renderTargetFormat,\n                    writeMask: 0,\n                },\n            ],\n        },\n        primitive: {\n            topology: 'triangle-list',\n            cullMode: \"front\",\n        }\n    });\n\n    this.initialRaysPassDesc = {\n        colorAttachments: [\n            {\n                view: this.renderTarget.createView(),\n                loadOp: \"clear\",\n                clearValue: [1.0, 1.0, 1.0, 1],\n                storeOp: \"store\"\n            },\n        ]\n    };\n\n    this.depthCompositeBGLayout = device.createBindGroupLayout({\n        entries: [\n            {binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n            {binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                storageTexture: {access: \"write-only\", format: renderTargetFormat}\n            },\n            {binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n        ]\n    });\n    this.depthCompositeBG1Layout = device.createBindGroupLayout({\n        entries: [{binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}}]\n    });\n\n    this.depthCompositePipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [this.depthCompositeBGLayout, this.depthCompositeBG1Layout],\n        }),\n        compute: {\n            module: device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.depth_composite_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.resetSpeculativeIDsBGLayout = device.createBindGroupLayout({\n        entries: [\n            {binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n            {binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n        ]\n    });\n\n    this.resetSpeculativeIDsPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [\n                this.resetSpeculativeIDsBGLayout,\n            ],\n        }),\n        compute: {\n            module: device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.reset_speculative_ids_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.macroTraverseBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                // Also pass the render target for debugging\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                storageTexture: {access: \"write-only\", format: renderTargetFormat}\n            },\n            {\n                binding: 4,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 5,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 6,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 7,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            }\n        ],\n    });\n    this.macroTraverseRangesBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            }\n        ]\n    });\n\n    this.macroTraversePipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [this.macroTraverseBGLayout, this.macroTraverseRangesBGLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({\n                code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.macro_traverse_comp_spv,\n            }),\n            entryPoint: \"main\",\n        },\n    });\n\n    this.resetBlockActiveBGLayout = device.createBindGroupLayout({\n        entries: [\n            {binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n            {binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}}\n        ]\n    });\n    this.resetBlockActivePipeline = device.createComputePipeline({\n        layout:\n            device.createPipelineLayout({bindGroupLayouts: [this.resetBlockActiveBGLayout]}),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.reset_block_active_comp_spv}),\n            entryPoint: \"main\"\n        }\n    });\n\n    this.resetBlockNumRaysBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {type: \"uniform\", hasDynamicOffset: true}\n            },\n            {binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}}\n        ]\n    });\n    this.resetBlockNumRaysPipeline = device.createComputePipeline({\n        layout:\n            device.createPipelineLayout({bindGroupLayouts: [this.resetBlockNumRaysBGLayout]}),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.reset_block_num_rays_comp_spv}),\n            entryPoint: \"main\"\n        }\n    });\n\n    this.LODThresholdBuf = device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n\n    this.markBlockActiveBGLayout = device.createBindGroupLayout({\n        entries: [\n            {binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n            {binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n            {binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n            {binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 6, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n        ]\n    });\n    this.markBlockActivePipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [this.markBlockActiveBGLayout, this.renderTargetDebugBGLayout]\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.mark_block_active_wgsl_spv}),\n            entryPoint: \"main\"\n        }\n    });\n\n    this.countBlockRaysBGLayout = device.createBindGroupLayout({\n        entries: [\n            {binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n            {binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n        ]\n    });\n    this.countBlockRaysPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [this.countBlockRaysBGLayout],\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.count_block_rays_wgsl_spv}),\n            entryPoint: \"main\"\n        }\n    });\n\n    this.debugViewBlockRayCountsBGLayout = device.createBindGroupLayout({\n        entries: [\n            {binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"uniform\"}},\n            {binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: {type: \"storage\"}},\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                storageTexture: {access: \"write-only\", format: renderTargetFormat}\n            }\n        ]\n    });\n    this.debugViewBlockRayCountsPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout(\n            {bindGroupLayouts: [this.debugViewBlockRayCountsBGLayout]}),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.debug_view_rays_per_block_comp_spv}),\n            entryPoint: \"main\"\n        }\n    });\n\n    // Intermediate buffers for sorting ray IDs using their block ID as the key\n    this.radixSorter = new _radix_sort_by_key__WEBPACK_IMPORTED_MODULE_2__.RadixSorter(device);\n    this.rayIDBuffer = device.createBuffer({\n        size: this.radixSorter.getAlignedSize(this.width * this.height * this.startSpecCount) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    this.compactSpeculativeIDBuffer = device.createBuffer({\n        size: this.radixSorter.getAlignedSize(this.width * this.height * this.startSpecCount) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    this.rayBlockIDBuffer = device.createBuffer({\n        size: this.radixSorter.getAlignedSize(this.width * this.height * this.startSpecCount) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    this.compactRayBlockIDBuffer = device.createBuffer({\n        size: this.radixSorter.getAlignedSize(this.width * this.height * this.startSpecCount) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    this.rayActiveBuffer = device.createBuffer({\n        size: this.width * this.height * this.startSpecCount * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    this.rayActiveCompactOffsetBuffer = device.createBuffer({\n        size: this.scanPipeline.getAlignedSize(this.width * this.height * this.startSpecCount) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    this.rayAfterActiveBuffer = device.createBuffer({\n        size: this.width * this.height * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    this.speculativeRayOffsetBuffer = device.createBuffer({\n        size: this.scanPipeline.getAlignedSize(this.width * this.height) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    this.scanRayActive = this.scanPipeline.prepareGPUInput(\n        this.rayActiveCompactOffsetBuffer,\n        this.scanPipeline.getAlignedSize(this.width * this.height * this.startSpecCount));\n    this.scanRayAfterActive = this.scanPipeline.prepareGPUInput(\n        this.speculativeRayOffsetBuffer,\n        this.scanPipeline.getAlignedSize(this.width * this.height));\n\n    this.writeRayAndBlockIDBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n    this.writeRayAndBlockIDPipeline = device.createComputePipeline({\n        layout:\n            device.createPipelineLayout({bindGroupLayouts: [this.writeRayAndBlockIDBGLayout]}),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.write_ray_and_block_id_comp_spv}),\n            entryPoint: \"main\",\n        }\n    });\n\n    this.markRayActiveBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ],\n    });\n    this.markRayActivePipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({bindGroupLayouts: [this.markRayActiveBGLayout]}),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.mark_ray_active_comp_spv}),\n            entryPoint: \"main\",\n        }\n    });\n\n    this.colorActiveRaysBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                texture: { viewDimension: \"2d\" }\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                storageTexture: { access: \"write-only\", format: renderTargetFormat }\n            },\n        ]\n    });\n    this.colorActiveRaysPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({bindGroupLayouts: [this.colorActiveRaysBGLayout]}),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.color_active_rays_comp_spv}),\n            entryPoint: \"main\",\n        }\n    });\n\n    this.combineBlockInformationBGLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 4,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            }\n        ]\n    });\n    this.combineBlockInformationPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts:\n                [this.combineBlockInformationBGLayout, this.pushConstantS1B0DynamicLayout]\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.combine_block_information_comp_spv}),\n            entryPoint: \"main\"\n        }\n    });\n\n    this.rtBlocksPipelineBG0Layout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ]\n    });\n    this.rtBlocksPipelineBG1Layout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"uniform\",\n                }\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 4,\n                visibility: GPUShaderStage.COMPUTE,\n                storageTexture: {access: \"write-only\", format: renderTargetFormat}\n            },\n            {\n                binding: 5,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n            {\n                binding: 6,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: \"storage\",\n                }\n            },\n        ]\n    });\n\n    this.raytraceBlocksPipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [\n                this.rtBlocksPipelineBG0Layout,\n                this.rtBlocksPipelineBG1Layout,\n                this.pushConstantS1B0DynamicLayout\n            ]\n        }),\n        compute: {\n            module: device.createShaderModule({code: _embedded_shaders__WEBPACK_IMPORTED_MODULE_4__.raytrace_active_block_comp_spv}),\n            entryPoint: \"main\"\n        }\n    });\n};\n\nVolumeRaycaster.prototype.setCompressedVolume =\n    async function(volume, compressionRate, volumeDims, volumeScale) {\n    // Upload the volume\n    this.volumeDims = volumeDims;\n    this.paddedDims = [\n        (0,_exclusive_scan__WEBPACK_IMPORTED_MODULE_0__.alignTo)(volumeDims[0], 4),\n        (0,_exclusive_scan__WEBPACK_IMPORTED_MODULE_0__.alignTo)(volumeDims[1], 4),\n        (0,_exclusive_scan__WEBPACK_IMPORTED_MODULE_0__.alignTo)(volumeDims[2], 4),\n    ];\n    this.blockGridDims =\n        [this.paddedDims[0] / 4, this.paddedDims[1] / 4, this.paddedDims[2] / 4];\n    this.totalBlocks = (this.paddedDims[0] * this.paddedDims[1] * this.paddedDims[2]) / 64;\n\n    this.coarseGridDims = [\n        (0,_exclusive_scan__WEBPACK_IMPORTED_MODULE_0__.alignTo)(this.blockGridDims[0], 4) / 4,\n        (0,_exclusive_scan__WEBPACK_IMPORTED_MODULE_0__.alignTo)(this.blockGridDims[1], 4) / 4,\n        (0,_exclusive_scan__WEBPACK_IMPORTED_MODULE_0__.alignTo)(this.blockGridDims[2], 4) / 4,\n    ];\n    this.totalCoarseCells =\n        (this.coarseGridDims[0] * this.coarseGridDims[1] * this.coarseGridDims[2]);\n\n    const groupThreadCount = 32;\n    this.numWorkGroups = Math.ceil(this.totalBlocks / groupThreadCount);\n    var cacheInitialSize = Math.ceil(this.totalBlocks * 0.01);\n\n    this.lruCache = new _lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache(this.device,\n                                 this.scanPipeline,\n                                 this.streamCompact,\n                                 cacheInitialSize,\n                                 64 * 4,\n                                 this.totalBlocks);\n\n    this.volumeInfoBuffer = this.device.createBuffer({\n        size: 16 * 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n    });\n    {\n        var mapping = this.volumeInfoBuffer.getMappedRange();\n        var maxBits = (1 << (2 * 3)) * compressionRate;\n        var buf = new Uint32Array(mapping);\n        buf.set(volumeDims);\n        buf.set(this.paddedDims, 4);\n        buf.set([maxBits], 12);\n        buf.set([this.width], 14);\n\n        var buf = new Float32Array(mapping);\n        buf.set(volumeScale, 8);\n    }\n    this.volumeInfoBuffer.unmap();\n\n    var compressedBuffer = this.device.createBuffer({\n        size: (0,_exclusive_scan__WEBPACK_IMPORTED_MODULE_0__.alignTo)(volume.byteLength, 4),\n        usage: GPUBufferUsage.STORAGE,\n        mappedAtCreation: true,\n    });\n    new Uint8Array(compressedBuffer.getMappedRange()).set(volume);\n    compressedBuffer.unmap();\n    this.compressedBuffer = compressedBuffer;\n\n    this.uploadIsovalueBuf = this.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,\n    });\n\n    this.uploadLODBuf = this.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,\n    });\n\n    await this.computeBlockRanges();\n\n    this.blockVisibleBuffer = this.device.createBuffer(\n        {size: 4 * this.totalBlocks, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC});\n\n    // Buffers for use when compacting down IDs of the active blocks\n    // TODO: could do a bit better and filter neighbor blocks out too by just marking\n    // visible blocks in a separate buffer (i.e., ones a ray is immediately in).\n    // This set will include neighbors for now\n    this.blockVisibleCompactOffsetBuffer = this.device.createBuffer({\n        size: 4 * this.scanPipeline.getAlignedSize(this.totalBlocks),\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n    });\n\n    // blockActive and blockVisibleCompactOffsetBuffer can alias each other as they are used at\n    // different times in the pipeline\n    this.blockActiveBuffer = this.blockVisibleCompactOffsetBuffer;\n\n    this.scanBlockVisibleOffsets =\n        this.scanPipeline.prepareGPUInput(this.blockVisibleCompactOffsetBuffer,\n                                          this.scanPipeline.getAlignedSize(this.totalBlocks));\n\n    this.resetRaysBG = this.device.createBindGroup({\n        layout: this.resetRaysBGLayout,\n        entries: [\n            {binding: 0, resource: {buffer: this.rayInformationBuffer}},\n            {binding: 1, resource: {buffer: this.volumeInfoBuffer}},\n            {binding: 2, resource: {buffer: this.rayBlockIDBuffer}},\n            {binding: 3, resource: {buffer: this.viewParamBuf}}\n        ]\n    });\n\n    this.resetSpeculativeIDsBG = this.device.createBindGroup({\n        layout: this.resetSpeculativeIDsBGLayout,\n        entries: [\n            {binding: 0, resource: {buffer: this.volumeInfoBuffer}},\n            {binding: 1, resource: {buffer: this.speculativeRayIDBuffer}},\n            {binding: 2, resource: {buffer: this.rayRGBZBuffer}},\n            {binding: 3, resource: {buffer: this.rayBlockIDBuffer}},\n        ]\n    });\n\n    this.depthCompositeBG = this.device.createBindGroup({\n        layout: this.depthCompositeBGLayout,\n        entries: [\n            {binding: 0, resource: {buffer: this.viewParamBuf}},\n            {binding: 1, resource: {buffer: this.speculativeRayIDBuffer}},\n            {binding: 2, resource: {buffer: this.rayRGBZBuffer}},\n            {binding: 3, resource: this.renderTarget.createView()},\n            {binding: 4, resource: {buffer: this.volumeInfoBuffer}},\n        ]\n    });\n\n    this.depthCompositeBG1 = this.device.createBindGroup({\n        layout: this.depthCompositeBG1Layout,\n        entries: [\n            {binding: 0, resource: {buffer: this.rayInformationBuffer}},\n        ]\n    });\n\n    // this.initSpeculativeIDsBG = this.device.createBindGroup({\n    //     layout: this.initSpeculativeIDsBGLayout,\n    //     entries: [\n    //         {binding: 0, resource: {buffer: this.volumeInfoBuffer}},\n    //         {binding: 1, resource: {buffer: this.viewParamBuf}},\n    //         {binding: 2, resource: {buffer: this.speculativeIDBuffer}},\n    //         {binding: 3, resource: {buffer: this.speculativeRayOffsetBuffer}},\n    //     ]\n    // });\n\n    this.initialRaysBindGroup = this.device.createBindGroup({\n        layout: this.computeInitialRaysBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: this.viewParamBuf,\n                },\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: this.rayInformationBuffer,\n                },\n            },\n            {\n                binding: 2,\n                resource: {\n                    buffer: this.volumeInfoBuffer,\n                },\n            },\n            {\n                binding: 3,\n                resource: {\n                    buffer: this.rayBlockIDBuffer,\n                },\n            },\n        ],\n    });\n\n    this.macroTraverseBindGroup = this.device.createBindGroup({\n        layout: this.macroTraverseBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: this.volumeInfoBuffer,\n                },\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: this.viewParamBuf,\n                },\n            },\n            {\n                binding: 2,\n                resource: {\n                    buffer: this.rayInformationBuffer,\n                },\n            },\n            {binding: 3, resource: this.renderTarget.createView()},\n            {\n                binding: 4,\n                resource: {\n                    buffer: this.gridIteratorBuffer,\n                },\n            },\n            {\n                binding: 5,\n                resource: {\n                    buffer: this.speculativeRayIDBuffer,\n                },\n            },\n            {\n                binding: 6,\n                resource: {\n                    buffer: this.speculativeRayOffsetBuffer,\n                },\n            },\n            {\n                binding: 7,\n                resource: {\n                    buffer: this.rayBlockIDBuffer,\n                }\n            }\n        ],\n    });\n\n    this.resetBlockActiveBG = this.device.createBindGroup({\n        layout: this.resetBlockActiveBGLayout,\n        entries: [\n            {binding: 0, resource: {buffer: this.volumeInfoBuffer}},\n            {binding: 1, resource: {buffer: this.blockActiveBuffer}},\n            {binding: 2, resource: {buffer: this.blockVisibleBuffer}},\n        ]\n    });\n\n    this.markBlockActiveBG = this.device.createBindGroup({\n        layout: this.markBlockActiveBGLayout,\n        entries: [\n            {binding: 0, resource: {buffer: this.volumeInfoBuffer}},\n            {binding: 1, resource: {buffer: this.LODThresholdBuf}},\n            {binding: 2, resource: {buffer: this.viewParamBuf}},\n            {binding: 3, resource: {buffer: this.blockActiveBuffer}},\n            {binding: 4, resource: {buffer: this.rayInformationBuffer}},\n            {binding: 5, resource: {buffer: this.blockVisibleBuffer}},\n            {binding: 6, resource: {buffer: this.rayBlockIDBuffer}},\n        ]\n    });\n\n    this.writeRayAndBlockIDBG = this.device.createBindGroup({\n        layout: this.writeRayAndBlockIDBGLayout,\n        entries: [\n            {binding: 0, resource: {buffer: this.volumeInfoBuffer}},\n            {binding: 1, resource: {buffer: this.rayBlockIDBuffer}},\n            {binding: 2, resource: {buffer: this.rayActiveBuffer}},\n        ]\n    });\n\n    this.markRayActiveBG = this.device.createBindGroup({\n        layout: this.markRayActiveBGLayout,\n        entries: [\n            {binding: 0, resource: {buffer: this.volumeInfoBuffer}},\n            {binding: 1, resource: {buffer: this.rayInformationBuffer}},\n            {binding: 2, resource: {buffer: this.rayAfterActiveBuffer}},\n        ]\n    });\n    this.colorActiveRaysBG = this.device.createBindGroup({\n        layout: this.colorActiveRaysBGLayout,\n        entries: [\n            {binding: 0, resource: {buffer: this.volumeInfoBuffer}},\n            {binding: 1, resource: {buffer: this.rayAfterActiveBuffer}},\n            {binding: 2, resource: this.renderTargetCopy.createView()},\n            {binding: 3, resource: this.renderTarget.createView()}\n        ]\n    });\n};\n\nVolumeRaycaster.prototype.getMemoryStats = function() {\n    // Data from this object\n    var memUse = {\n        units: \"bytes\",\n        mc: {\n            compressedData: this.compressedBuffer.size,\n            voxelRanges: this.voxelRangesBuffer.size,\n            coarseCellRanges: this.coarseCellRangesBuffer.size,\n\n            // Every app will have view params, we can ignore it\n            // viewParam: this.viewParamBuf.size,\n            rays: this.rayInformationBuffer.size,\n            rayPixelIDs: this.speculativeRayIDBuffer.size,\n            sortedRayIDs: this.rayIDBuffer.size,\n            compactPixelIDs: this.compactSpeculativeIDBuffer.size,\n            rayBlockIDs: this.rayBlockIDBuffer.size,\n            compactRayBlockIDs: this.compactRayBlockIDBuffer.size,\n            rayActive: this.rayActiveBuffer.size,\n            rayActiveCompactOffsets: this.rayActiveCompactOffsetBuffer.size,\n            speculativeRayOffsets: this.speculativeRayOffsetBuffer.size,\n            rayRGBZ: this.rayRGBZBuffer.size,\n\n            gridIteratorState: this.gridIteratorBuffer.size,\n\n            // block active aliases blockVisibleCompactOffsetBuffer because they aren't needed\n            // at the same time in the pipeline\n            // blockActive: this.blockActiveBuffer.size,\n            blockVisible: this.blockVisibleBuffer.size,\n            // This is really based on block visible, not active\n            blockVisibleCompactOffsets: this.blockVisibleCompactOffsetBuffer.size,\n            blockNumRays: this.blockNumRaysBuffer ? this.blockNumRaysBuffer.size : 0,\n            blockRayOffsets: this.blockRayOffsetBuffer ? this.blockRayOffsetBuffer.size : 0,\n            visibleBlockIDs: this.visibleBlockIDBuffer ? this.visibleBlockIDBuffer.size : 0,\n\n            // Ignoring the combined block info buffer since this came from a binding count\n            // limitation in WebGPU which I think has been addressed, we just haven't updated\n            // the code, and it's just # active block size\n\n            // combinedBlockInformation: this.combinedBlockInformationBuffer.size,\n\n            // I think we can also ignore the cube vertices\n            // cubeVertices: this.dataBuf.size\n        },\n        cache: {\n            cache: this.lruCache.cacheSize * this.lruCache.elementSize,\n            cachedItemSlots: this.lruCache.totalElements * 4,\n            needsCaching: this.lruCache.totalElements * 4,\n            needsCachingOffsets:\n                this.scanPipeline.getAlignedSize(this.lruCache.totalElements) * 4,\n            slotAge: this.lruCache.cacheSize * 4,\n            slotAvailable: this.lruCache.cacheSize * 4,\n            slotAvailableOffsets:\n                this.scanPipeline.getAlignedSize(this.lruCache.cacheSize) * 4,\n            slotAvailableIDs: this.lruCache.cacheSize * 4,\n            slotItemIDs: this.lruCache.cacheSize * 4,\n            cacheSizeBuf: 4,\n        },\n    };\n    return memUse;\n};\n\nVolumeRaycaster.prototype.reportMemoryUse = function() {\n    var formatBytes = function(count) {\n        const giga = 1000000000;\n        const mega = 1000000;\n        const kilo = 1000;\n        if (count > giga) {\n            return (count / giga).toFixed(2) + \" GB\";\n        } else if (count > mega) {\n            return (count / mega).toFixed(2) + \" MB\";\n        } else if (count > kilo) {\n            return (count / kilo).toFixed(2) + \" KB\";\n        }\n        return count + \" B\";\n    };\n\n    var memUse = this.getMemoryStats();\n\n    var totalMem = 0;\n    var rcText = \"Raycaster Data:<ul>\";\n    for (const prop in memUse.mc) {\n        totalMem += memUse.mc[prop];\n        rcText += \"<li>\" + prop + \": \" + formatBytes(memUse.mc[prop]) + \"</li>\";\n    }\n    rcText += \"</ul>\";\n\n    var cacheText = \"LRU Cache Data:<ul>\";\n    for (const prop in memUse.cache) {\n        totalMem += memUse.cache[prop];\n        cacheText += \"<li>\" + prop + \": \" + formatBytes(memUse.cache[prop]) + \"</li>\";\n    }\n    cacheText += \"</ul>\";\n    return [rcText, cacheText, formatBytes(totalMem), memUse];\n};\n\nVolumeRaycaster.prototype.computeBlockRanges = async function() {\n    // Note: this could be done by the server for us, but for this prototype\n    // it's a bit easier to just do it here\n    // Decompress each block and compute its value range, output to the blockRangesBuffer\n    // BlockRangesBuffer = purely the ZFP block range\n    // TODO: We don't need to keep this buffer long term actually\n    var blockRangesBuffer = this.device.createBuffer({\n        size: this.totalBlocks * 2 * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    // VoxelRangesBuffer = block range + neighbor cells for the dual grid\n    this.voxelRangesBuffer = this.device.createBuffer({\n        size: this.totalBlocks * 2 * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    // CoarseCellRanges = 4^3 blocks of ZFP blocks, including neighbor\n    this.coarseCellRangesBuffer = this.device.createBuffer({\n        size: this.totalCoarseCells * 2 * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    var bindGroup = this.device.createBindGroup({\n        layout: this.computeBlockRangeBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: this.compressedBuffer,\n                }\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: this.volumeInfoBuffer,\n                }\n            },\n            {\n                binding: 2,\n                resource: {\n                    buffer: blockRangesBuffer,\n                }\n            }\n        ]\n    });\n    this.voxelBindGroup = this.device.createBindGroup({\n        layout: this.computeVoxelRangeBGLayout,\n        entries: [{\n            binding: 0,\n            resource: {\n                buffer: this.voxelRangesBuffer,\n            }\n        }]\n    });\n\n    this.macroTraverseRangesBG = this.device.createBindGroup({\n        layout: this.macroTraverseRangesBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: this.voxelRangesBuffer,\n                },\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: this.coarseCellRangesBuffer,\n                }\n            }\n        ]\n\n    });\n\n    const groupThreadCount = 32;\n    var totalWorkGroups = Math.ceil(this.totalBlocks / groupThreadCount);\n\n    var pushConstants = (0,_util__WEBPACK_IMPORTED_MODULE_5__.buildPushConstantsBuffer)(this.device, totalWorkGroups);\n\n    var blockIDOffsetBG = this.device.createBindGroup({\n        layout: this.pushConstantS1B0DynamicLayout,\n        entries: [{binding: 0, resource: {buffer: pushConstants.gpuBuffer, size: 4}}]\n    });\n\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass();\n\n    // Decompress each block and compute its range\n    pass.setPipeline(this.computeBlockRangePipeline);\n    pass.setBindGroup(0, bindGroup);\n    for (var i = 0; i < pushConstants.nOffsets; ++i) {\n        pass.setBindGroup(1, blockIDOffsetBG, pushConstants.dynamicOffsets, i, 1);\n        pass.dispatchWorkgroups(pushConstants.dispatchSizes[i], 1, 1);\n    }\n    pass.end();\n\n    // Compute each block's range including its neighbors\n    var pass = commandEncoder.beginComputePass();\n    pass.setPipeline(this.computeVoxelRangePipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.setBindGroup(2, this.voxelBindGroup);\n    for (var i = 0; i < pushConstants.nOffsets; ++i) {\n        pass.setBindGroup(1, blockIDOffsetBG, pushConstants.dynamicOffsets, i, 1);\n        pass.dispatchWorkgroups(pushConstants.dispatchSizes[i], 1, 1);\n    }\n    pass.end();\n\n    var pass = commandEncoder.beginComputePass();\n    // Enqueue pass to compute the coarse cell ranges\n    var totalWorkGroupsCoarseCell = Math.ceil(this.totalCoarseCells / groupThreadCount);\n    var coarsePushConstants = (0,_util__WEBPACK_IMPORTED_MODULE_5__.buildPushConstantsBuffer)(this.device, totalWorkGroupsCoarseCell);\n    var coarseRangeBG = this.device.createBindGroup({\n        layout: this.computeCoarseCellRangeBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: this.volumeInfoBuffer,\n                }\n            },\n            {binding: 1, resource: {buffer: coarsePushConstants.gpuBuffer, size: 4}},\n            {binding: 2, resource: {buffer: this.voxelRangesBuffer}},\n            {binding: 3, resource: {buffer: this.coarseCellRangesBuffer}}\n        ]\n    });\n    pass.setPipeline(this.computeCoarseCellRangePipeline);\n    for (var i = 0; i < coarsePushConstants.nOffsets; ++i) {\n        pass.setBindGroup(0, coarseRangeBG, coarsePushConstants.dynamicOffsets, i, 1);\n        pass.dispatchWorkgroups(coarsePushConstants.dispatchSizes[i], 1, 1);\n    }\n\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n\n    /*\n    {\n        var dbgBuffer = this.device.createBuffer({\n            size: blockRangesBuffer.size,\n            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n        });\n\n        var commandEncoder = this.device.createCommandEncoder();\n        commandEncoder.copyBufferToBuffer(blockRangesBuffer, 0, dbgBuffer, 0, dbgBuffer.size);\n        this.device.queue.submit([commandEncoder.finish()]);\n        await this.device.queue.onSubmittedWorkDone();\n\n        await dbgBuffer.mapAsync(GPUMapMode.READ);\n\n        var debugVals = new Float32Array(dbgBuffer.getMappedRange());\n\n        for (var i = 0; i < 3; i++) {\n            var blob = new Blob(['[' + debugVals.slice(i * debugVals.length / 3, (i + 1) * debugVals.length / 3).toString() + ']'], {type: \"text/plain\"});\n            saveAs(blob, `blockRanges-${i}.json`);\n        }\n\n        var valRange = [Infinity, -Infinity];\n\n        for (var i = 0; i < debugVals.length; ++i) {\n            valRange[0] = Math.min(valRange[0], debugVals[i]);\n            valRange[1] = Math.max(valRange[1], debugVals[i]);\n        }\n        console.log(`value range = ${valRange}`);\n\n\n        dbgBuffer.unmap();\n    }\n    */\n};\n\n// Progressively compute the surface, returns true when rendering is complete\nVolumeRaycaster.prototype.renderSurface = async function(\n    isovalue, LODThreshold, viewParamUpload, renderParamsChanged, eyePos, eyeDir, upDir) {\n    this.passPerfStats = {};\n\n    if (this.renderComplete && !renderParamsChanged) {\n        return this.renderComplete;\n    }\n    console.log(\"===== Rendering Surface =======\");\n    var startPass = performance.now();\n\n    if (renderParamsChanged) {\n        this.numVisibleBlocks = 0;\n        this.newDecompressed = 0;\n\n        this.totalPassTime = 0;\n        this.numPasses = 0;\n        this.renderID = Date.now().toString().slice(-6);\n        this.imageCompleteness = 0;\n        this.speculationCount = this.startSpecCount;\n        this.speculationEnabled = this.enableSpeculationUI.checked;\n\n        this.surfacePerfStats = [];\n\n        this.recordVisibleBlocks = this.recordVisibleBlocksUI.checked;\n        this.recordBlockActiveList = null;\n        this.recordBlockVisibleList = null;\n        if (this.recordVisibleBlocks) {\n            console.log(\n                `WARNING: Recording active/visible block statistics may effect performance!`);\n            this.recordBlockActiveList = new Uint8Array(this.totalBlocks).fill(0);\n            this.recordBlockVisibleList = new Uint8Array(this.totalBlocks).fill(0);\n        }\n\n        // Upload the isovalue\n        await this.uploadIsovalueBuf.mapAsync(GPUMapMode.WRITE);\n        new Float32Array(this.uploadIsovalueBuf.getMappedRange()).set([isovalue]);\n        this.uploadIsovalueBuf.unmap();\n\n        // Upload new LOD threshold\n        var commandEncoder = this.device.createCommandEncoder();\n        await this.uploadLODBuf.mapAsync(GPUMapMode.WRITE);\n        new Uint32Array(this.uploadLODBuf.getMappedRange()).set([LODThreshold]);\n        this.uploadLODBuf.unmap();\n        commandEncoder.copyBufferToBuffer(this.uploadLODBuf, 0, this.LODThresholdBuf, 0, 4);\n\n        // We need to reset the speculation count\n        var uploadSpeculationCount = this.device.createBuffer(\n            {size: 4, usage: GPUBufferUsage.COPY_SRC, mappedAtCreation: true});\n        new Uint32Array(uploadSpeculationCount.getMappedRange()).set([0]);\n        uploadSpeculationCount.unmap();\n        commandEncoder.copyBufferToBuffer(\n            uploadSpeculationCount, 0, this.viewParamBuf, (16 + 8 + 1 + 1) * 4, 4);\n\n        // Reset active blocks for the new viewpoint/isovalue to allow eviction of old blocks\n        var pass = commandEncoder.beginComputePass();\n        pass.setPipeline(this.resetBlockActivePipeline);\n        pass.setBindGroup(0, this.resetBlockActiveBG);\n        pass.dispatchWorkgroups(Math.ceil(this.blockGridDims[0] / 8),\n                                this.blockGridDims[1],\n                                this.blockGridDims[2]);\n        pass.end();\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        var start = performance.now();\n        await this.computeInitialRays(viewParamUpload);\n        var end = performance.now();\n        this.passPerfStats[\"computeInitialRays_ms\"] = end - start;\n        this.passPerfStats[\"totalBlocks\"] = this.totalBlocks;\n        this.passPerfStats[\"volumeDims\"] = this.volumeDims;\n        this.passPerfStats[\"imageSize\"] = [this.width, this.height];\n        this.passPerfStats[\"nPixels\"] = this.width * this.height;\n        this.passPerfStats[\"startSpecCount\"] = this.startSpecCount;\n\n        // Save camera info as well for reproducibility\n        this.passPerfStats[\"eyePos\"] = [eyePos[0], eyePos[1], eyePos[2]];\n        this.passPerfStats[\"eyeDir\"] = [eyeDir[0], eyeDir[1], eyeDir[2]];\n        this.passPerfStats[\"upDir\"] = [upDir[0], upDir[1], upDir[2]];\n\n        var start = performance.now();\n        await this.macroTraverse();\n        var end = performance.now();\n        this.passPerfStats[\"initialMacroTraverse_ms\"] = end - start;\n\n        start = performance.now();\n        var commandEncoder = this.device.createCommandEncoder();\n        var pass = commandEncoder.beginComputePass();\n        pass.setPipeline(this.markRayActivePipeline);\n        pass.setBindGroup(0, this.markRayActiveBG);\n        pass.dispatchWorkgroups(Math.ceil(this.width / 32), this.height, 1);\n        pass.end();\n        // We scan the speculativeRayOffsetBuffer, so copy the ray active information over\n        commandEncoder.copyBufferToBuffer(this.rayAfterActiveBuffer,\n                                          0,\n                                          this.speculativeRayOffsetBuffer,\n                                          0,\n                                          this.width * this.height * 4);\n        this.device.queue.submit([commandEncoder.finish()]);\n        numRaysActive = await this.scanRayAfterActive.scan(this.width * this.height);\n        end = performance.now();\n        this.passPerfStats[\"countInitialActiveRays_ms\"] = end - start;\n        this.passPerfStats[\"initialRaysActive\"] = numRaysActive;\n        console.log(\"Starting rays active: \" + numRaysActive);\n\n        var commandEncoder = this.device.createCommandEncoder();\n        if (this.speculationEnabled) {\n            this.speculationCount =\n                Math.min(Math.floor(this.width * this.height * this.startSpecCount / numRaysActive), 64);\n        } else {\n            this.speculationCount = this.startSpecCount;\n        }\n        console.log(`First pass speculation count is ${this.speculationCount}`);\n        var uploadSpeculationCount = this.device.createBuffer(\n            {size: 4, usage: GPUBufferUsage.COPY_SRC, mappedAtCreation: true});\n        new Uint32Array(uploadSpeculationCount.getMappedRange()).set([\n            this.speculationCount\n        ]);\n        uploadSpeculationCount.unmap();\n        commandEncoder.copyBufferToBuffer(\n            uploadSpeculationCount, 0, this.viewParamBuf, (16 + 8 + 1 + 1) * 4, 4);\n        this.device.queue.submit([commandEncoder.finish()]);\n    }\n    console.log(`++++ Surface pass ${this.numPasses} ++++`);\n    this.passPerfStats[\"passID\"] = this.numPasses;\n    this.passPerfStats[\"speculationCount\"] = this.speculationCount;\n    this.passPerfStats[\"isovalue\"] = isovalue;\n\n    var startPass = performance.now();\n\n    // Reset the number of blocks visible/active each pass to reduce memory usage and skip\n    // computing on inactive blocks\n    {\n        var commandEncoder = this.device.createCommandEncoder();\n        var pass = commandEncoder.beginComputePass();\n        pass.setPipeline(this.resetBlockActivePipeline);\n        pass.setBindGroup(0, this.resetBlockActiveBG);\n        pass.dispatchWorkgroups(Math.ceil(this.blockGridDims[0] / 8),\n                                this.blockGridDims[1],\n                                this.blockGridDims[2]);\n        pass.end();\n        this.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    var start = performance.now();\n    await this.macroTraverse();\n    var end = performance.now();\n    console.log(`Macro Traverse: ${end - start}ms`);\n    this.passPerfStats[\"macroTraverse_ms\"] = end - start;\n\n    start = performance.now();\n    await this.markActiveBlocks();\n    end = performance.now();\n    console.log(`Mark Active Blocks: ${end - start}ms`);\n    this.passPerfStats[\"markActiveBlocks_ms\"] = end - start;\n\n    // Decompress any new blocks needed for the pass\n    start = performance.now();\n    // TODO: PAss the passPerfStats through to the LRU Cache so it can write stats to it\n    var [nBlocksToDecompress, decompressBlockIDs] =\n        await this.lruCache.update(this.blockActiveBuffer, this.passPerfStats);\n    end = performance.now();\n    console.log(`LRU: ${end - start}ms`);\n    this.passPerfStats[\"lruCacheUpdate_ms\"] = end - start;\n    this.passPerfStats[\"nBlocksToDecompress\"] = nBlocksToDecompress;\n\n    this.newDecompressed = nBlocksToDecompress;\n    if (nBlocksToDecompress != 0) {\n        // console.log(`Will decompress ${nBlocksToDecompress} blocks`);\n        start = performance.now();\n        await this.decompressBlocks(nBlocksToDecompress, decompressBlockIDs);\n        end = performance.now();\n        console.log(`Decompress: ${end - start}ms`);\n        this.passPerfStats[\"decompressBlocks_ms\"] = end - start;\n    }\n\n    // Now at this step we can do the block id compaction, compute # blocks visible\n    var numVisibleBlocks = await this.compactVisibleBlockIDs();\n    // this.numVisibleBlocks is just for displaying the value in the UI\n    this.numVisibleBlocks = numVisibleBlocks;\n    this.passPerfStats[\"nVisibleBlocks\"] = numVisibleBlocks;\n    var numRaysActive = 0;\n    if (numVisibleBlocks > 0) {\n        start = performance.now();\n        // Then run a pass to write the compacted blockNumRays and blockRayOffsets instead of #\n        // block buffers\n        numRaysActive = await this.computeBlockRayOffsets(numVisibleBlocks);\n        end = performance.now();\n        this.passPerfStats[\"computeBlockRayOffsets_ms\"] = end - start;\n        this.passPerfStats[\"nRaysActive\"] = numRaysActive;\n        // console.log(`Ray active and offsets: ${end - start}ms`);\n        console.log(`numRaysActive = ${numRaysActive}`);\n        if (numRaysActive > 0) {\n            start = performance.now();\n            await this.sortActiveRaysByBlock(numRaysActive);\n            end = performance.now();\n            this.passPerfStats[\"sortActiveRaysByBlock_ms\"] = end - start;\n            console.log(`Sort active rays by block: ${end - start}ms`);\n\n            start = performance.now();\n            await this.raytraceVisibleBlocks(numVisibleBlocks);\n            end = performance.now();\n            this.passPerfStats[\"raytraceVisibleBlocks_ms\"] = end - start;\n            console.log(`Raytrace blocks: ${end - start}ms`);\n\n            start = performance.now();\n            var commandEncoder = this.device.createCommandEncoder();\n            var pass = commandEncoder.beginComputePass();\n            pass.setPipeline(this.depthCompositePipeline);\n            pass.setBindGroup(0, this.depthCompositeBG);\n            pass.setBindGroup(1, this.depthCompositeBG1);\n            pass.dispatchWorkgroups(\n                Math.ceil(this.width / 32), Math.ceil(this.height * this.startSpecCount / this.speculationCount), 1);\n            pass.end();\n            this.device.queue.submit([commandEncoder.finish()]);\n            await this.device.queue.onSubmittedWorkDone();\n            end = performance.now();\n            this.passPerfStats[\"depthComposite_ms\"] = end - start;\n\n            start = performance.now();\n            var commandEncoder = this.device.createCommandEncoder();\n            var pass = commandEncoder.beginComputePass();\n            pass.setPipeline(this.markRayActivePipeline);\n            pass.setBindGroup(0, this.markRayActiveBG);\n            pass.dispatchWorkgroups(Math.ceil(this.width / 32), this.height, 1);\n            pass.end();\n            // We scan the speculativeRayOffsetBuffer, so copy the ray active information over\n            commandEncoder.copyBufferToBuffer(this.rayAfterActiveBuffer,\n                                              0,\n                                              this.speculativeRayOffsetBuffer,\n                                              0,\n                                              this.width * this.height * 4);\n            this.device.queue.submit([commandEncoder.finish()]);\n        \n            // if (document.getElementById(\"outputImages\").checked) {\n            //     var rayAfterActiveReadback = this.device.createBuffer({\n            //         size: this.width * this.height * 4,\n            //         usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n            //     });\n            //     var commandEncoder = this.device.createCommandEncoder();\n\n            //     commandEncoder.copyBufferToBuffer(\n            //         this.rayAfterActiveBuffer, 0, rayAfterActiveReadback, 0, rayAfterActiveReadback.size);\n            //     this.device.queue.submit([commandEncoder.finish()]);\n            //     await this.device.queue.onSubmittedWorkDone();\n        \n            //     await rayAfterActiveReadback.mapAsync(GPUMapMode.READ);\n \n            //     var rayAfterActive = new Uint32Array(rayAfterActiveReadback.getMappedRange());\n                \n            //     var outCanvas = document.getElementById('out-canvas');\n            //     var context = outCanvas.getContext('2d');\n            //     var imgData = context.createImageData(outCanvas.width, outCanvas.height);\n            //     for (var i = 0; i < this.width * this.height; i++) {\n            //         imgData.data[i * 4] = rayAfterActive[i] * 255;\n            //         imgData.data[i * 4 + 1] = rayAfterActive[i] * 255;\n            //         imgData.data[i * 4 + 2] = rayAfterActive[i] * 255;\n            //         imgData.data[i * 4 + 3] = 255;\n            //     }\n            //     context.putImageData(imgData, 0, 0);\n            //     var numPasses = this.numPasses + 1;\n            //     var renderID = this.renderID;\n            //     outCanvas.toBlob(function(b) {\n            //         saveAs(b, `${renderID}_activeMask_pass${numPasses}.png`);\n            //     }, \"image/png\");\n            //     rayAfterActiveReadback.unmap();\n            //     rayAfterActiveReadback.destroy();\n            // }\n\n            numRaysActive = await this.scanRayAfterActive.scan(this.width * this.height);\n            end = performance.now();\n            this.passPerfStats[\"countRemainingActiveRays_ms\"] = end - start;\n            this.passPerfStats[\"endPassRaysActive\"] = numRaysActive;\n\n            if (document.getElementById(\"colorActive\").checked) {\n                var commandEncoder = this.device.createCommandEncoder();\n                commandEncoder.copyTextureToTexture(\n                    { texture: this.renderTarget}, \n                    { texture: this.renderTargetCopy},\n                    { width: this.width, height: this.height, depthOrArrayLayers: 1 });\n                var pass = commandEncoder.beginComputePass();\n                pass.setPipeline(this.colorActiveRaysPipeline);\n                pass.setBindGroup(0, this.colorActiveRaysBG);\n                pass.dispatchWorkgroups(Math.ceil(this.width / 32), this.height, 1);\n                pass.end();\n                this.device.queue.submit([commandEncoder.finish()]);\n            }\n\n            end = performance.now();\n            console.log(`PASS TOOK: ${end - startPass}ms`);\n            // console.log(`num rays active after raytracing: ${numRaysActive}`);\n\n            if (this.speculationEnabled) {\n                var commandEncoder = this.device.createCommandEncoder();\n                this.speculationCount =\n                    Math.min(Math.floor(this.width * this.height * this.startSpecCount / numRaysActive), 64);\n                // console.log(`Next pass speculation count is ${this.speculationCount}`);\n                var uploadSpeculationCount = this.device.createBuffer(\n                    {size: 4, usage: GPUBufferUsage.COPY_SRC, mappedAtCreation: true});\n                new Uint32Array(uploadSpeculationCount.getMappedRange()).set([\n                    this.speculationCount\n                ]);\n                uploadSpeculationCount.unmap();\n                commandEncoder.copyBufferToBuffer(\n                    uploadSpeculationCount, 0, this.viewParamBuf, (16 + 8 + 1 + 1) * 4, 4);\n                this.device.queue.submit([commandEncoder.finish()]);\n                await this.device.queue.onSubmittedWorkDone();\n                console.log(`End pass rays active: ${numRaysActive}`);\n                console.log(`Next pass speculation count: ${this.speculationCount}`);     \n            }\n            console.log(`++++++++++`);\n        }\n    } else {\n        this.passPerfStats[\"nRaysActive\"] = numRaysActive;\n        this.passPerfStats[\"endPassRaysActive\"] = numRaysActive;\n    }\n    var endPass = performance.now();\n    this.passPerfStats[\"totalPassTime_ms\"] = endPass - startPass;\n    this.passPerfStats[\"memory\"] = this.getMemoryStats();\n    this.surfacePerfStats.push(this.passPerfStats);\n\n    console.log(\"=============\");\n    this.totalPassTime += endPass - startPass;\n    this.numPasses += 1;\n    //}\n    this.renderComplete = numRaysActive == 0;\n    this.imageCompleteness = (this.width * this.height - numRaysActive) / (this.width * this.height);\n    this.passPerfStats[\"imageCompleteness\"] = this.imageCompleteness;\n    this.passPerfStats[\"imageCompletenessThreshold\"] = parseFloat(document.getElementById(\"completenessThreshold\").value);\n    if ( this.imageCompleteness >= parseFloat(document.getElementById(\"completenessThreshold\").value)) { \n        console.log(`Render complete with image completeness: ${this.imageCompleteness}`)\n        this.renderComplete = true;        \n    }\n    if (this.renderComplete) {\n        if (this.recordVisibleBlocks) {\n            var nTotalBlocksActive = 0;\n            var nTotalBlocksVisible = 0;\n            for (var i = 0; i < this.totalBlocks; ++i) {\n                if (this.recordBlockActiveList[i] != 0) {\n                    ++nTotalBlocksActive;\n                }\n                if (this.recordBlockVisibleList[i] != 0) {\n                    ++nTotalBlocksVisible;\n                }\n            }\n            console.log(`Total blocks active: ${nTotalBlocksActive} (${\n                nTotalBlocksActive / this.totalBlocks * 100})`);\n            console.log(`Total blocks visible: ${nTotalBlocksVisible} (${\n                nTotalBlocksVisible / this.totalBlocks * 100})`);\n            this.passPerfStats[\"nTotalBlocksActive\"] = nTotalBlocksActive;\n            this.passPerfStats[\"nTotalBlocksVisible\"] = nTotalBlocksVisible;\n        }\n        console.log(`Avg time per pass ${this.totalPassTime / this.numPasses}ms`);\n        console.log(this.passPerfStats);\n    }\n    return this.renderComplete;\n};\n\n// Reset the rays and compute the initial set of rays that intersect the volume\n// Rays that miss the volume will have:\n// dir = vec3(0)\n// block_id = UINT_MAX\n// t = FLT_MAX\n//\n// Rays that hit the volume will have valid directions and t values\nVolumeRaycaster.prototype.computeInitialRays = async function(viewParamUpload) {\n    var commandEncoder = this.device.createCommandEncoder();\n\n    commandEncoder.copyBufferToBuffer(\n        viewParamUpload, 0, this.viewParamBuf, 0, (16 + 8 + 1) * 4);\n\n    var resetRaysPass = commandEncoder.beginComputePass(this.resetRaysPipeline);\n    resetRaysPass.setBindGroup(0, this.resetRaysBG);\n    resetRaysPass.setPipeline(this.resetRaysPipeline);\n    resetRaysPass.dispatchWorkgroups(Math.ceil(this.width / 8), this.height, 1);\n    resetRaysPass.end();\n\n    var initialRaysPass = commandEncoder.beginRenderPass(this.initialRaysPassDesc);\n\n    initialRaysPass.setPipeline(this.initialRaysPipeline);\n    initialRaysPass.setVertexBuffer(0, this.dataBuf);\n    initialRaysPass.setBindGroup(0, this.initialRaysBindGroup);\n    initialRaysPass.draw(12 * 3, 1, 0, 0);\n\n    initialRaysPass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n};\n\n// Step the active rays forward in the macrocell grid, updating block_id and t.\n// Rays that exit the volume will have block_id = UINT_MAX and t = FLT_MAX\nVolumeRaycaster.prototype.macroTraverse = async function() {\n    // TODO: Would it be worth doing a scan and compact to find just the IDs of the currently\n    // active rays? then only advancing them? We'll do that anyways so it would tell us when\n    // we're done too (no rays active)\n    var commandEncoder = this.device.createCommandEncoder();\n\n    // Reset speculative IDs buffer (here for now but could be moved)\n    var resetSpecIDsPass = commandEncoder.beginComputePass();\n    resetSpecIDsPass.setBindGroup(0, this.resetSpeculativeIDsBG);\n    resetSpecIDsPass.setPipeline(this.resetSpeculativeIDsPipeline);\n    resetSpecIDsPass.dispatchWorkgroups(Math.ceil(this.width / 32), this.height * this.startSpecCount, 1);\n    resetSpecIDsPass.end();\n\n    // Update the current pass index\n    var uploadPassIndex = this.device.createBuffer(\n        {size: 4, usage: GPUBufferUsage.COPY_SRC, mappedAtCreation: true});\n    new Int32Array(uploadPassIndex.getMappedRange()).set([this.numPasses]);\n    uploadPassIndex.unmap();\n\n    commandEncoder.copyBufferToBuffer(this.uploadIsovalueBuf, 0, this.volumeInfoBuffer, 52, 4);\n    commandEncoder.copyBufferToBuffer(\n        uploadPassIndex, 0, this.viewParamBuf, (16 + 8 + 1) * 4, 4);\n\n    var pass = commandEncoder.beginComputePass();\n\n    pass.setPipeline(this.macroTraversePipeline);\n    pass.setBindGroup(0, this.macroTraverseBindGroup);\n    pass.setBindGroup(1, this.macroTraverseRangesBG);\n    pass.dispatchWorkgroups(Math.ceil(this.width / 64), this.height, 1);\n\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n\n    // Log speculative ray IDs buffer\n    // var readbackSpeculativeIDBuffer = this.device.createBuffer({\n    //     size: this.speculativeRayIDBuffer.size,\n    //     usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n    // });\n    // var commandEncoder = this.device.createCommandEncoder();\n    // commandEncoder.copyBufferToBuffer(\n    //     this.speculativeRayIDBuffer, 0, readbackSpeculativeIDBuffer, 0,\n    //     this.speculativeRayIDBuffer.size);\n    // this.device.queue.submit([commandEncoder.finish()]);\n    // await this.device.queue.onSubmittedWorkDone();\n    // await readbackSpeculativeIDBuffer.mapAsync(GPUMapMode.READ);\n    // var specIDs = new Uint32Array(readbackSpeculativeIDBuffer.getMappedRange());\n    // console.log(specIDs);\n\n    uploadPassIndex.destroy();\n};\n\n// Mark the active and visible blocks for the current viewpoint/isovalue and count the # of\n// rays that we need to process for each block\nVolumeRaycaster.prototype.markActiveBlocks = async function() {\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass();\n\n    // Compute which blocks are active and how many rays each has\n    pass.setPipeline(this.markBlockActivePipeline);\n    pass.setBindGroup(0, this.markBlockActiveBG);\n    pass.setBindGroup(1, this.renderTargetDebugBG);\n    pass.dispatchWorkgroups(Math.ceil(this.width / 32), this.height * this.startSpecCount, 1);\n\n    pass.end();\n\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n\n    if (this.recordVisibleBlocks) {\n        var activeReadback = this.device.createBuffer({\n            size: 4 * this.totalBlocks,\n            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n        });\n        var visibleReadback = this.device.createBuffer({\n            size: 4 * this.totalBlocks,\n            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n        });\n\n        var commandEncoder = this.device.createCommandEncoder();\n        commandEncoder.copyBufferToBuffer(\n            this.blockActiveBuffer, 0, activeReadback, 0, activeReadback.size);\n        commandEncoder.copyBufferToBuffer(\n            this.blockVisibleBuffer, 0, visibleReadback, 0, visibleReadback.size);\n        this.device.queue.submit([commandEncoder.finish()]);\n        await this.device.queue.onSubmittedWorkDone();\n\n        await activeReadback.mapAsync(GPUMapMode.READ);\n        await visibleReadback.mapAsync(GPUMapMode.READ);\n\n        var nActiveBlocks = 0;\n\n        var blockActive = new Uint32Array(activeReadback.getMappedRange());\n        var blockVisible = new Uint32Array(visibleReadback.getMappedRange());\n        for (var i = 0; i < this.totalBlocks; ++i) {\n            if (blockActive[i]) {\n                ++nActiveBlocks;\n            }\n            this.recordBlockActiveList[i] |= blockActive[i];\n            this.recordBlockVisibleList[i] |= blockVisible[i];\n        }\n        this.passPerfStats[\"nActiveBlocks\"] = nActiveBlocks;\n\n        activeReadback.unmap();\n        visibleReadback.unmap();\n\n        activeReadback.destroy();\n        visibleReadback.destroy();\n    }\n};\n\n// Compute the number of visible blocks and compact their IDs. Also produces an offset buffer\n// mapping from original block index -> compacted location\n// - visibleBlockIDBuffer: compact list of active block IDs (visible block IDs)\n// - blockVisibleCompactOffsets: mapping from block ID to compacted location\nVolumeRaycaster.prototype.compactVisibleBlockIDs = async function() {\n    var start = performance.now();\n    // Populate the ray ID, ray block ID and ray active buffers\n    var commandEncoder = this.device.createCommandEncoder();\n\n    // We scan the active block buffer to produce offsets for compacting active block IDs\n    // down This will let us reduce the dispatch size of the ray tracing step to just active\n    // blocks\n    commandEncoder.copyBufferToBuffer(this.blockVisibleBuffer,\n                                      0,\n                                      this.blockVisibleCompactOffsetBuffer,\n                                      0,\n                                      this.totalBlocks * 4);\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    // Compact the visible block IDs down\n    var numVisibleBlocks = await this.scanBlockVisibleOffsets.scan(this.totalBlocks);\n    if (numVisibleBlocks === 0) {\n        return numVisibleBlocks;\n    }\n\n    this.visibleBlockIDBuffer = this.device.createBuffer({\n        size: 4 * numVisibleBlocks,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n    });\n\n    await this.streamCompact.compactActiveIDs(this.totalBlocks,\n                                              this.blockVisibleBuffer,\n                                              this.blockVisibleCompactOffsetBuffer,\n                                              this.visibleBlockIDBuffer);\n    var end = performance.now();\n    console.log(`compactVisibleBlockIDs: ${end - start}ms`);\n\n    return numVisibleBlocks;\n};\n\n// Compute the number of visible rays per block, scan the blockNumRaysBuffer storing the output\n// in blockRayOffsetBuffer and return the number of active rays.\nVolumeRaycaster.prototype.computeBlockRayOffsets = async function(numVisibleBlocks) {\n    this.blockNumRaysBuffer = this.device.createBuffer({\n        size: 4 * numVisibleBlocks,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n    });\n\n    // Scan result buffer for the block ray offsets (computed by scanning the result in\n    // blockNumRaysBuffer)\n    this.blockRayOffsetBuffer = this.device.createBuffer({\n        size: 4 * this.scanPipeline.getAlignedSize(numVisibleBlocks),\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n    });\n    this.scanBlockRayOffsets = this.scanPipeline.prepareGPUInput(\n        this.blockRayOffsetBuffer, this.scanPipeline.getAlignedSize(numVisibleBlocks));\n\n    var countBlockRaysBG = this.device.createBindGroup({\n        layout: this.countBlockRaysBGLayout,\n        entries: [\n            {binding: 0, resource: {buffer: this.volumeInfoBuffer}},\n            {binding: 1, resource: {buffer: this.blockNumRaysBuffer}},\n            {binding: 2, resource: {buffer: this.rayBlockIDBuffer}},\n            {binding: 3, resource: {buffer: this.blockVisibleCompactOffsetBuffer}},\n        ]\n    });\n\n    // Now here we can run a compute pass to compute # of rays per block, this is image size\n    // dispatch so no need to chunk it\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass();\n    pass.setPipeline(this.countBlockRaysPipeline);\n    pass.setBindGroup(0, countBlockRaysBG);\n    pass.dispatchWorkgroups(Math.ceil(this.width / 32), this.height * this.startSpecCount, 1);\n    pass.end();\n\n    commandEncoder.copyBufferToBuffer(this.blockNumRaysBuffer,\n                                      0,\n                                      this.blockRayOffsetBuffer,\n                                      0,\n                                      this.blockNumRaysBuffer.size);\n    await this.device.queue.submit([commandEncoder.finish()]);\n\n    return await this.scanBlockRayOffsets.scan(numVisibleBlocks);\n};\n\n// Sort the active ray IDs by their block ID in ascending order (inactive rays will be at the\n// end).\nVolumeRaycaster.prototype.sortActiveRaysByBlock = async function(numRaysActive) {\n    // Populate the ray ID, ray block ID and ray active buffers\n    var commandEncoder = this.device.createCommandEncoder();\n    var pass = commandEncoder.beginComputePass()\n    pass.setPipeline(this.writeRayAndBlockIDPipeline);\n    pass.setBindGroup(0, this.writeRayAndBlockIDBG);\n    pass.dispatchWorkgroups(Math.ceil(this.width / 8), this.height * this.startSpecCount, 1);\n    pass.end();\n\n    // We scan the rayActiveCompactOffsetBuffer, so copy the ray active information over\n    commandEncoder.copyBufferToBuffer(this.rayActiveBuffer,\n                                      0,\n                                      this.rayActiveCompactOffsetBuffer,\n                                      0,\n                                      this.width * this.height * this.startSpecCount * 4);\n\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    // Scan the active ray buffer and compact the active ray IDs before we sort\n    // so that the sort doesn't have to process such a large number of items\n    // TODO: This is not matching numRaysActive?\n    var nactive = await this.scanRayActive.scan(this.width * this.height * this.startSpecCount);\n    // Should match numRaysActive, sanity check here\n    if (numRaysActive != nactive) {\n        console.log(`nactive ${nactive} doesn't match numRaysActive ${numRaysActive}!?`);\n    }\n    var startCompacts = performance.now();\n    // Compact the active ray IDs and their block IDs down\n    await this.streamCompact.compactActive(this.width * this.height * this.startSpecCount,\n                                           this.rayActiveBuffer,\n                                           this.rayActiveCompactOffsetBuffer,\n                                           this.speculativeRayIDBuffer,\n                                           this.rayIDBuffer);\n\n    await this.streamCompact.compactActiveIDs(this.width * this.height * this.startSpecCount,\n                                              this.rayActiveBuffer,\n                                              this.rayActiveCompactOffsetBuffer,\n                                              this.compactSpeculativeIDBuffer);\n\n    await this.streamCompact.compactActive(this.width * this.height * this.startSpecCount,\n                                           this.rayActiveBuffer,\n                                           this.rayActiveCompactOffsetBuffer,\n                                           this.rayBlockIDBuffer,\n                                           this.compactRayBlockIDBuffer);\n\n    var endCompacts = performance.now();\n    console.log(`sortActiveRaysByBlock: Compacts ${endCompacts - startCompacts}ms`);\n\n    var compactRayBlockIDBufferCopy = this.device.createBuffer({\n        size: this.radixSorter.getAlignedSize(this.compactRayBlockIDBuffer.size / 4) * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n    });\n    var commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyBufferToBuffer(this.compactRayBlockIDBuffer,\n                                      0,\n                                      compactRayBlockIDBufferCopy,\n                                      0,\n                                      this.compactRayBlockIDBuffer.size);\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n\n    var start = performance.now();\n    // Sort active ray IDs by their block ID\n    await this.radixSorter.sort(\n        this.compactRayBlockIDBuffer, this.rayIDBuffer, numRaysActive, false);\n    await this.radixSorter.sort(\n        compactRayBlockIDBufferCopy, this.compactSpeculativeIDBuffer, numRaysActive, false);\n    var end = performance.now();\n    console.log(`sortActiveRaysByBlock: Sort rays by blocks: ${end - start}ms`);\n};\n\nVolumeRaycaster.prototype.raytraceVisibleBlocks = async function(numVisibleBlocks) {\n    /*\n    console.log(\n        `Raytracing ${numVisibleBlocks} blocks, speculation count = ${this.speculationCount}`);\n        */\n\n    // Must recreate each time b/c cache buffer will grow\n    var rtBlocksPipelineBG0 = this.device.createBindGroup({\n        layout: this.rtBlocksPipelineBG0Layout,\n        entries: [\n            {binding: 0, resource: {buffer: this.volumeInfoBuffer}},\n            {binding: 1, resource: {buffer: this.lruCache.cache}},\n            {binding: 2, resource: {buffer: this.lruCache.cachedItemSlots}},\n        ]\n    });\n\n    this.combinedBlockInformationBuffer = this.device.createBuffer(\n        {size: numVisibleBlocks * 4 * 4, usage: GPUBufferUsage.STORAGE});\n\n    this.rtBlocksPipelineBG1 = this.device.createBindGroup({\n        layout: this.rtBlocksPipelineBG1Layout,\n        entries: [\n            {binding: 0, resource: {buffer: this.viewParamBuf}},\n            {binding: 1, resource: {buffer: this.rayInformationBuffer}},\n            {binding: 2, resource: {buffer: this.rayIDBuffer}},\n            {binding: 3, resource: {buffer: this.combinedBlockInformationBuffer}},\n            {binding: 4, resource: this.renderTarget.createView()},\n            {binding: 5, resource: {buffer: this.compactSpeculativeIDBuffer}},\n            {binding: 6, resource: {buffer: this.rayRGBZBuffer}},\n        ]\n    });\n\n    this.combineBlockInformationBG = this.device.createBindGroup({\n        layout: this.combineBlockInformationBGLayout,\n        entries: [\n            {binding: 0, resource: {buffer: this.combinedBlockInformationBuffer}},\n            {binding: 1, resource: {buffer: this.visibleBlockIDBuffer}},\n            {binding: 2, resource: {buffer: this.blockRayOffsetBuffer}},\n            {binding: 3, resource: {buffer: this.blockNumRaysBuffer}},\n            {binding: 4, resource: {buffer: this.blockActiveBuffer}},\n        ]\n    });\n\n    var commandEncoder = this.device.createCommandEncoder();\n    {\n        const groupThreadCount = 64;\n        const totalWorkGroups = Math.ceil(numVisibleBlocks / groupThreadCount);\n\n        var pushConstants = (0,_util__WEBPACK_IMPORTED_MODULE_5__.buildPushConstantsBuffer)(\n            this.device, totalWorkGroups, new Uint32Array([numVisibleBlocks]));\n\n        var blockIDOffsetBG = this.device.createBindGroup({\n            layout: this.pushConstantS1B0DynamicLayout,\n            entries: [{binding: 0, resource: {buffer: pushConstants.gpuBuffer, size: 12}}]\n        });\n\n        var pass = commandEncoder.beginComputePass();\n        // First make the combined block information buffer (to fit in 6 storage buffers)\n        // The limit will be bumped up to 8 so we could remove this piece in a bit once\n        // the change lands in Chromium\n        pass.setPipeline(this.combineBlockInformationPipeline);\n        pass.setBindGroup(0, this.combineBlockInformationBG);\n        for (var i = 0; i < pushConstants.nOffsets; ++i) {\n            pass.setBindGroup(1, blockIDOffsetBG, pushConstants.dynamicOffsets, i, 1);\n            pass.dispatchWorkgroups(pushConstants.dispatchSizes[i], 1, 1);\n        }\n        pass.end();\n    }\n\n    {\n        var pushConstants = (0,_util__WEBPACK_IMPORTED_MODULE_5__.buildPushConstantsBuffer)(this.device, numVisibleBlocks);\n\n        var blockIDOffsetBG = this.device.createBindGroup({\n            layout: this.pushConstantS1B0DynamicLayout,\n            entries: [{binding: 0, resource: {buffer: pushConstants.gpuBuffer, size: 8}}]\n        });\n\n        var pass = commandEncoder.beginComputePass();\n        // TODO: Might be worth for data sets where many blocks\n        // project to a lot of pixels to split up the dispatches,\n        // and do multiple dispatch indirect for the blocks touching\n        // many pixels so that we don't serialize so badly on them, while\n        // still doing a single dispatch for all blocks touching <= 64 pixels\n        // since that will be most of the blocks, especially for large data.\n        pass.setPipeline(this.raytraceBlocksPipeline);\n        pass.setBindGroup(0, rtBlocksPipelineBG0);\n        pass.setBindGroup(1, this.rtBlocksPipelineBG1);\n        for (var i = 0; i < pushConstants.nOffsets; ++i) {\n            pass.setBindGroup(2, blockIDOffsetBG, pushConstants.dynamicOffsets, i, 1);\n            pass.dispatchWorkgroups(pushConstants.dispatchSizes[i], 1, 1);\n        }\n        pass.end();\n    }\n\n    this.device.queue.submit([commandEncoder.finish()]);\n    await this.device.queue.onSubmittedWorkDone();\n};\n\nVolumeRaycaster.prototype.decompressBlocks =\n    async function(nBlocksToDecompress, decompressBlockIDs) {\n    var decompressBlocksBG = this.device.createBindGroup({\n        layout: this.decompressBlocksBGLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: this.compressedBuffer,\n                },\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: this.volumeInfoBuffer,\n                },\n            },\n            {\n                binding: 2,\n                resource: {\n                    buffer: this.lruCache.cache,\n                },\n            },\n            {\n                binding: 3,\n                resource: {\n                    buffer: decompressBlockIDs,\n                },\n            },\n            {\n                binding: 4,\n                resource: {\n                    buffer: this.lruCache.cachedItemSlots,\n                },\n            },\n        ],\n    });\n\n    var workGroupCount = Math.ceil(nBlocksToDecompress / 64.0);\n    var numChunks = Math.ceil(workGroupCount / this.maxDispatchSize);\n    var dispatchChunkOffsetsBuf = this.device.createBuffer({\n        size: numChunks * 256,\n        usage: GPUBufferUsage.UNIFORM,\n        mappedAtCreation: true,\n    });\n    var map = new Uint32Array(dispatchChunkOffsetsBuf.getMappedRange());\n    for (var i = 0; i < numChunks; ++i) {\n        map[i * 64] = i * this.maxDispatchSize;\n        map[i * 64 + 1] = nBlocksToDecompress;\n    }\n    dispatchChunkOffsetsBuf.unmap();\n\n    // We execute these chunks in separate submissions to avoid having them\n    // execute all at once and trigger a TDR if we're decompressing a large amount of data\n    for (var i = 0; i < numChunks; ++i) {\n        var numWorkGroups =\n            Math.min(workGroupCount - i * this.maxDispatchSize, this.maxDispatchSize);\n        var commandEncoder = this.device.createCommandEncoder();\n        var pass = commandEncoder.beginComputePass();\n        pass.setPipeline(this.decompressBlocksPipeline);\n        pass.setBindGroup(0, decompressBlocksBG);\n        // Have to create bind group here because dynamic offsets are not allowed\n        var decompressBlocksStartOffsetBG = this.device.createBindGroup({\n            layout: this.ub1binding0BGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: dispatchChunkOffsetsBuf,\n                        size: 8,\n                        offset: i * 256,\n                    },\n                },\n            ],\n        });\n        pass.setBindGroup(1, decompressBlocksStartOffsetBG);\n        pass.dispatchWorkgroups(Math.ceil(numWorkGroups), 1, 1);\n        pass.end();\n        this.device.queue.submit([commandEncoder.finish()]);\n    }\n    await this.device.queue.onSubmittedWorkDone();\n    dispatchChunkOffsetsBuf.destroy();\n};\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/volume_raycaster.js?");

/***/ }),

/***/ "./src/volumes.js":
/*!************************!*\
  !*** ./src/volumes.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"datasets\": () => (/* binding */ datasets),\n/* harmony export */   \"getVolumeDimensions\": () => (/* binding */ getVolumeDimensions)\n/* harmony export */ });\nvar datasets = {\n    plane_x: {\n        compressionRate: 2,\n        name: \"plane_x_32x32x32_float32.gen.crate2\",\n        range: [0, 1],\n        scale: [1, 1, 1],\n    },\n    sphere: {\n        compressionRate: 2,\n        name: \"sphere_32x32x32_float32.gen.crate2\",\n        range: [0, 1],\n        scale: [1, 1, 1],\n    },\n    quarter_sphere: {\n        compressionRate: 2,\n        name: \"quarter_sphere_32x32x32_float32.gen.crate2\",\n        range: [0, 1],\n        scale: [1, 1, 1],\n    },\n    wavelet: {\n        compressionRate: 2,\n        name: \"wavelet_32x32x32_float32.gen.crate2\",\n        range: [-3, 3],\n        scale: [1, 1, 1],\n    },\n    fuel: {\n        compressionRate: 4,\n        name: \"fuel_64x64x64_uint8.raw.crate4\",\n        range: [10, 255],\n        scale: [1, 1, 1],\n    },\n    aneurism: {\n        compressionRate: 4,\n        name: \"vertebra_512x512x512_uint16.raw.crate4\",\n        range: [550, 2100],\n        scale: [1, 1, 1],\n    },\n    duct: {\n        compressionRate: 2,\n        name: \"duct_193x194x1000_float32.raw.crate2\",\n        range: [0, 4],\n        scale: [1, 1, 1000 / 193],\n        step: 4 / 100\n    },\n    stagbeetle: {\n        compressionRate: 2,\n        name: \"stag_beetle_832x832x494_uint16.raw.crate2\",\n        range: [100, 4096],\n        scale: [1, 1, 1],\n        step: 1.0 / 4096,\n    },\n    foot: {\n        compressionRate: 2,\n        name: \"foot_256x256x256_uint8.raw.crate2\",\n        range: [10, 255],\n        scale: [1, 1, 1],\n    },\n    backpack: {\n        compressionRate: 4,\n        name: \"backpack_512x512x373_uint16.raw.crate4\",\n        range: [200, 4000],\n        scale: [1, 1, 1],\n        step: 1.0 / 3800.0,\n    },\n    // For benchmarks:\n    tacc_turbulence: {\n        compressionRate: 2,\n        name: \"tacc_turbulence_256x256x256_float32.raw.crate2\",\n        range: [1, 10],\n        scale: [1, 1, 1],\n        step: 10 / 100,\n    },\n    skull: {\n        compressionRate: 2,\n        name: \"skull_256x256x256_uint8.raw.crate2\",\n        // range: [10, 255],\n        range: [40, 140],\n        scale: [1, 1, 1],\n    },\n    magnetic: {\n        compressionRate: 4,\n        name: \"magnetic_reconnection_512x512x512_float32.raw.crate4\",\n        range: [0.1, 3.5],\n        scale: [1, 1, 1],\n        step: 1.0 / 8192,\n    },\n    kingsnake: {\n        compressionRate: 2,\n        name: \"kingsnake_1024x1024x795_uint8.raw.crate2\",\n        range: [100, 150],\n        scale: [1, 1, 1],\n    },\n    chameleon: {\n        compressionRate: 2,\n        name: \"chameleon_1024x1024x1080_uint16.raw.crate2\",\n        range: [11000, 33000],\n        scale: [1, 1, 1],\n        step: 1.0 / 8192,\n    },\n    beechnut: {\n        compressionRate: 1,\n        name: \"beechnut_1024x1024x1546_uint16.raw.crate1\",\n        range: [13200, 17000],\n        scale: [1, 1, 1],\n        step: (17000 - 13200) / 100.0,\n    },\n    miranda: {\n        compressionRate: 4,\n        name: \"miranda_1024x1024x1024_float32.raw.crate4\",\n        range: [1.05, 2.9],\n        scale: [1, 1, 1],\n        step: 1.0 / 8192,\n    },\n    jicf_q: {\n        compressionRate: 2,\n        name: \"jicf_q_1408x1080x1100_float32.raw.crate2\",\n        range: [-1, 1],\n        scale: [1, 1, 1],\n        step: 6 / 100\n    },\n    truss: {\n        compressionRate: 2,\n        name: \"synthetic_truss_with_five_defects_1200x1200x1200_float32.raw.crate2\",\n        range: [0, 0.01],\n        scale: [1, 1, 1],\n    },\n    dns_large: {\n        compressionRate: 2,\n        name: \"dns_1920x1440x288_float64.raw.crate2\",\n        range: [0.75, 1.15],\n        scale: [1, 1440 / 1920, 288 / 1920],\n        step: 1.0 / 8192,\n    },\n    richtmyer_meshkov: {\n        compressionRate: 1,\n        name: \"richtmyer_meshkov_2048x2048x1920_uint8.raw.crate1\",\n        range: [40, 190],\n        scale: [1, 1, 1920.0 / 2048.0],\n        step: 1.0,\n    },\n};\n\n\nvar getVolumeDimensions = function(filename) {\n    var fileRegex = /(\\w+)_(\\d+)x(\\d+)x(\\d+)_(\\w+)\\.*/;\n    var m = filename.match(fileRegex);\n    return [parseInt(m[2]), parseInt(m[3]), parseInt(m[4])];\n};\n\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/volumes.js?");

/***/ }),

/***/ "./src/webgl-util.js":
/*!***************************!*\
  !*** ./src/webgl-util.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArcballCamera\": () => (/* binding */ ArcballCamera),\n/* harmony export */   \"Controller\": () => (/* binding */ Controller)\n/* harmony export */ });\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/vec4.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/mat4.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/vec3.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/mat3.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/quat.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/vec2.js\");\n\n\n// Compute the view frustum in world space from the provided\n// column major projection * view matrix\nvar Frustum = function (projView) {\n  var rows = [gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create()];\n  for (var i = 0; i < rows.length; ++i) {\n    rows[i] = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(\n      rows[i],\n      projView[i],\n      projView[4 + i],\n      projView[8 + i],\n      projView[12 + i]\n    );\n  }\n\n  this.planes = [\n    // -x plane\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.add(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), rows[3], rows[0]),\n    // +x plane\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), rows[3], rows[0]),\n    // -y plane\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.add(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), rows[3], rows[1]),\n    // +y plane\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), rows[3], rows[1]),\n    // -z plane\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.add(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), rows[3], rows[2]),\n    // +z plane\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), rows[3], rows[2]),\n  ];\n\n  // Normalize the planes\n  for (var i = 0; i < this.planes.length; ++i) {\n    var s =\n      1.0 /\n      Math.sqrt(\n        this.planes[i][0] * this.planes[i][0] +\n          this.planes[i][1] * this.planes[i][1] +\n          this.planes[i][2] * this.planes[i][2]\n      );\n    this.planes[i][0] *= s;\n    this.planes[i][1] *= s;\n    this.planes[i][2] *= s;\n    this.planes[i][3] *= s;\n  }\n\n  // Compute the frustum points as well\n  var invProjView = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.invert(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), projView);\n  this.points = [\n    // x_l, y_l, z_l\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), -1, -1, -1, 1),\n    // x_h, y_l, z_l\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), 1, -1, -1, 1),\n    // x_l, y_h, z_l\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), -1, 1, -1, 1),\n    // x_h, y_h, z_l\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), 1, 1, -1, 1),\n    // x_l, y_l, z_h\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), -1, -1, 1, 1),\n    // x_h, y_l, z_h\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), 1, -1, 1, 1),\n    // x_l, y_h, z_h\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), -1, 1, 1, 1),\n    // x_h, y_h, z_h\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), 1, 1, 1, 1),\n  ];\n  for (var i = 0; i < 8; ++i) {\n    this.points[i] = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.transformMat4(\n      this.points[i],\n      this.points[i],\n      invProjView\n    );\n    this.points[i][0] /= this.points[i][3];\n    this.points[i][1] /= this.points[i][3];\n    this.points[i][2] /= this.points[i][3];\n    this.points[i][3] = 1.0;\n  }\n};\n\n// Check if the box is contained in the Frustum\n// The box should be [x_lower, y_lower, z_lower, x_upper, y_upper, z_upper]\n// This is done using Inigo Quilez's approach to help with large\n// bounds: https://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm\nFrustum.prototype.containsBox = function (box) {\n  // Test the box against each plane\n  var vec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create();\n  var out = 0;\n  for (var i = 0; i < this.planes.length; ++i) {\n    out = 0;\n    // x_l, y_l, z_l\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(vec, box[0], box[1], box[2], 1.0);\n    out += gl_matrix__WEBPACK_IMPORTED_MODULE_0__.dot(this.planes[i], vec) < 0.0 ? 1 : 0;\n    // x_h, y_l, z_l\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(vec, box[3], box[1], box[2], 1.0);\n    out += gl_matrix__WEBPACK_IMPORTED_MODULE_0__.dot(this.planes[i], vec) < 0.0 ? 1 : 0;\n    // x_l, y_h, z_l\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(vec, box[0], box[4], box[2], 1.0);\n    out += gl_matrix__WEBPACK_IMPORTED_MODULE_0__.dot(this.planes[i], vec) < 0.0 ? 1 : 0;\n    // x_h, y_h, z_l\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(vec, box[3], box[4], box[2], 1.0);\n    out += gl_matrix__WEBPACK_IMPORTED_MODULE_0__.dot(this.planes[i], vec) < 0.0 ? 1 : 0;\n    // x_l, y_l, z_h\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(vec, box[0], box[1], box[5], 1.0);\n    out += gl_matrix__WEBPACK_IMPORTED_MODULE_0__.dot(this.planes[i], vec) < 0.0 ? 1 : 0;\n    // x_h, y_l, z_h\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(vec, box[3], box[1], box[5], 1.0);\n    out += gl_matrix__WEBPACK_IMPORTED_MODULE_0__.dot(this.planes[i], vec) < 0.0 ? 1 : 0;\n    // x_l, y_h, z_h\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(vec, box[0], box[4], box[5], 1.0);\n    out += gl_matrix__WEBPACK_IMPORTED_MODULE_0__.dot(this.planes[i], vec) < 0.0 ? 1 : 0;\n    // x_h, y_h, z_h\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(vec, box[3], box[4], box[5], 1.0);\n    out += gl_matrix__WEBPACK_IMPORTED_MODULE_0__.dot(this.planes[i], vec) < 0.0 ? 1 : 0;\n\n    if (out == 8) {\n      return false;\n    }\n  }\n\n  // Test the frustum against the box\n  out = 0;\n  for (var i = 0; i < 8; ++i) {\n    out += this.points[i][0] > box[3] ? 1 : 0;\n  }\n  if (out == 8) {\n    return false;\n  }\n\n  out = 0;\n  for (var i = 0; i < 8; ++i) {\n    out += this.points[i][0] < box[0] ? 1 : 0;\n  }\n  if (out == 8) {\n    return false;\n  }\n\n  out = 0;\n  for (var i = 0; i < 8; ++i) {\n    out += this.points[i][1] > box[4] ? 1 : 0;\n  }\n  if (out == 8) {\n    return false;\n  }\n\n  out = 0;\n  for (var i = 0; i < 8; ++i) {\n    out += this.points[i][1] < box[1] ? 1 : 0;\n  }\n  if (out == 8) {\n    return false;\n  }\n\n  out = 0;\n  for (var i = 0; i < 8; ++i) {\n    out += this.points[i][2] > box[5] ? 1 : 0;\n  }\n  if (out == 8) {\n    return false;\n  }\n\n  out = 0;\n  for (var i = 0; i < 8; ++i) {\n    out += this.points[i][2] < box[2] ? 1 : 0;\n  }\n  if (out == 8) {\n    return false;\n  }\n  return true;\n};\n\nvar Shader = function (gl, vertexSrc, fragmentSrc) {\n  var self = this;\n  this.program = compileShader(gl, vertexSrc, fragmentSrc);\n\n  var regexUniform = /uniform[^;]+[ ](\\w+);/g;\n  var matchUniformName = /uniform[^;]+[ ](\\w+);/;\n\n  this.uniforms = {};\n\n  var vertexUnifs = vertexSrc.match(regexUniform);\n  var fragUnifs = fragmentSrc.match(regexUniform);\n\n  if (vertexUnifs) {\n    vertexUnifs.forEach(function (unif) {\n      var m = unif.match(matchUniformName);\n      self.uniforms[m[1]] = -1;\n    });\n  }\n  if (fragUnifs) {\n    fragUnifs.forEach(function (unif) {\n      var m = unif.match(matchUniformName);\n      self.uniforms[m[1]] = -1;\n    });\n  }\n\n  for (var unif in this.uniforms) {\n    this.uniforms[unif] = gl.getUniformLocation(this.program, unif);\n  }\n};\n\nShader.prototype.use = function (gl) {\n  gl.useProgram(this.program);\n};\n\n// Compile and link the shaders vert and frag. vert and frag should contain\n// the shader source code for the vertex and fragment shaders respectively\n// Returns the compiled and linked program, or null if compilation or linking failed\nvar compileShader = function (gl, vert, frag) {\n  var vs = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(vs, vert);\n  gl.compileShader(vs);\n  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n    alert(\"Vertex shader failed to compile, see console for log\");\n    console.log(gl.getShaderInfoLog(vs));\n    return null;\n  }\n\n  var fs = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fs, frag);\n  gl.compileShader(fs);\n  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n    alert(\"Fragment shader failed to compile, see console for log\");\n    console.log(gl.getShaderInfoLog(fs));\n    return null;\n  }\n\n  var program = gl.createProgram();\n  gl.attachShader(program, vs);\n  gl.attachShader(program, fs);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    alert(\"Shader failed to link, see console for log\");\n    console.log(gl.getProgramInfoLog(program));\n    return null;\n  }\n  return program;\n};\n\nvar getGLExtension = function (gl, ext) {\n  if (!gl.getExtension(ext)) {\n    alert(\"Missing \" + ext + \" WebGL extension\");\n    return false;\n  }\n  return true;\n};\n\n/* The arcball camera will be placed at the position 'eye', rotating\n * around the point 'center', with the up vector 'up'. 'screenDims'\n * should be the dimensions of the canvas or region taking mouse input\n * so the mouse positions can be normalized into [-1, 1] from the pixel\n * coordinates.\n */\nvar ArcballCamera = function (eye, center, up, zoomSpeed, screenDims) {\n  var veye = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(), eye[0], eye[1], eye[2]);\n  var vcenter = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(), center[0], center[1], center[2]);\n  var vup = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(), up[0], up[1], up[2]);\n  gl_matrix__WEBPACK_IMPORTED_MODULE_2__.normalize(vup, vup);\n\n  var zAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(), vcenter, veye);\n  var viewDist = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.len(zAxis);\n  gl_matrix__WEBPACK_IMPORTED_MODULE_2__.normalize(zAxis, zAxis);\n\n  var xAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(), zAxis, vup);\n  gl_matrix__WEBPACK_IMPORTED_MODULE_2__.normalize(xAxis, xAxis);\n\n  var yAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(), xAxis, zAxis);\n  gl_matrix__WEBPACK_IMPORTED_MODULE_2__.normalize(yAxis, yAxis);\n\n  gl_matrix__WEBPACK_IMPORTED_MODULE_2__.cross(xAxis, zAxis, yAxis);\n  gl_matrix__WEBPACK_IMPORTED_MODULE_2__.normalize(xAxis, xAxis);\n\n  this.zoomSpeed = zoomSpeed;\n  this.invScreen = [1.0 / screenDims[0], 1.0 / screenDims[1]];\n\n  this.centerTranslation = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromTranslation(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), center);\n  gl_matrix__WEBPACK_IMPORTED_MODULE_1__.invert(this.centerTranslation, this.centerTranslation);\n\n  var vt = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(), 0, 0, -1.0 * viewDist);\n  this.translation = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromTranslation(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), vt);\n\n  var rotMat = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.fromValues(\n    xAxis[0],\n    xAxis[1],\n    xAxis[2],\n    yAxis[0],\n    yAxis[1],\n    yAxis[2],\n    -zAxis[0],\n    -zAxis[1],\n    -zAxis[2]\n  );\n  gl_matrix__WEBPACK_IMPORTED_MODULE_3__.transpose(rotMat, rotMat);\n  this.rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_4__.fromMat3(gl_matrix__WEBPACK_IMPORTED_MODULE_4__.create(), rotMat);\n  gl_matrix__WEBPACK_IMPORTED_MODULE_4__.normalize(this.rotation, this.rotation);\n\n  this.camera = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();\n  this.invCamera = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();\n  this.updateCameraMatrix();\n};\n\nArcballCamera.prototype.rotate = function (prevMouse, curMouse) {\n  var mPrev = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.set(\n    gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create(),\n    clamp(prevMouse[0] * 2.0 * this.invScreen[0] - 1.0, -1.0, 1.0),\n    clamp(1.0 - prevMouse[1] * 2.0 * this.invScreen[1], -1.0, 1.0)\n  );\n\n  var mCur = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.set(\n    gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create(),\n    clamp(curMouse[0] * 2.0 * this.invScreen[0] - 1.0, -1.0, 1.0),\n    clamp(1.0 - curMouse[1] * 2.0 * this.invScreen[1], -1.0, 1.0)\n  );\n\n  var mPrevBall = screenToArcball(mPrev);\n  var mCurBall = screenToArcball(mCur);\n  // rotation = curBall * prevBall * rotation\n  this.rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_4__.mul(this.rotation, mPrevBall, this.rotation);\n  this.rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_4__.mul(this.rotation, mCurBall, this.rotation);\n\n  this.updateCameraMatrix();\n};\n\nArcballCamera.prototype.zoom = function (amount) {\n  var vt = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.set(\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(),\n    0.0,\n    0.0,\n    amount * this.invScreen[1] * this.zoomSpeed\n  );\n  var t = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromTranslation(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), vt);\n  this.translation = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.mul(this.translation, t, this.translation);\n  if (this.translation[14] >= -0.2) {\n    this.translation[14] = -0.2;\n  }\n  this.updateCameraMatrix();\n};\n\nArcballCamera.prototype.pan = function (mouseDelta) {\n  var delta = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(\n    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(),\n    mouseDelta[0] * this.invScreen[0] * Math.abs(this.translation[14]),\n    mouseDelta[1] * this.invScreen[1] * Math.abs(this.translation[14]),\n    0,\n    0\n  );\n  var worldDelta = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), delta, this.invCamera);\n  var translation = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromTranslation(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), worldDelta);\n  this.centerTranslation = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.mul(\n    this.centerTranslation,\n    translation,\n    this.centerTranslation\n  );\n  this.updateCameraMatrix();\n};\n\nArcballCamera.prototype.updateCameraMatrix = function () {\n  // camera = translation * rotation * centerTranslation\n  var rotMat = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromQuat(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), this.rotation);\n  this.camera = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.mul(this.camera, rotMat, this.centerTranslation);\n  this.camera = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.mul(this.camera, this.translation, this.camera);\n  this.invCamera = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.invert(this.invCamera, this.camera);\n};\n\nArcballCamera.prototype.eyePos = function () {\n  return [this.invCamera[12], this.invCamera[13], this.invCamera[14]];\n};\n\nArcballCamera.prototype.eyeDir = function () {\n  var dir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), 0.0, 0.0, -1.0, 0.0);\n  dir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.transformMat4(dir, dir, this.invCamera);\n  dir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.normalize(dir, dir);\n  return [dir[0], dir[1], dir[2]];\n};\n\nArcballCamera.prototype.upDir = function () {\n  var dir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create(), 0.0, 1.0, 0.0, 0.0);\n  dir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.transformMat4(dir, dir, this.invCamera);\n  dir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.normalize(dir, dir);\n  return [dir[0], dir[1], dir[2]];\n};\n\nvar screenToArcball = function (p) {\n  var dist = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.dot(p, p);\n  if (dist <= 1.0) {\n    return gl_matrix__WEBPACK_IMPORTED_MODULE_4__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_4__.create(), p[0], p[1], Math.sqrt(1.0 - dist), 0);\n  } else {\n    var unitP = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create(), p);\n    // cgmath is w, x, y, z\n    // glmatrix is x, y, z, w\n    return gl_matrix__WEBPACK_IMPORTED_MODULE_4__.set(gl_matrix__WEBPACK_IMPORTED_MODULE_4__.create(), unitP[0], unitP[1], 0, 0);\n  }\n};\nvar clamp = function (a, min, max) {\n  return a < min ? min : a > max ? max : a;\n};\n\nvar pointDist = function (a, b) {\n  var v = [b[0] - a[0], b[1] - a[1]];\n  return Math.sqrt(Math.pow(v[0], 2.0) + Math.pow(v[1], 2.0));\n};\n\nvar Buffer = function (capacity, dtype) {\n  this.len = 0;\n  this.capacity = capacity;\n  if (dtype == \"uint8\") {\n    this.buffer = new Uint8Array(capacity);\n  } else if (dtype == \"int8\") {\n    this.buffer = new Int8Array(capacity);\n  } else if (dtype == \"uint16\") {\n    this.buffer = new Uint16Array(capacity);\n  } else if (dtype == \"int16\") {\n    this.buffer = new Int16Array(capacity);\n  } else if (dtype == \"uint32\") {\n    this.buffer = new Uint32Array(capacity);\n  } else if (dtype == \"int32\") {\n    this.buffer = new Int32Array(capacity);\n  } else if (dtype == \"float32\") {\n    this.buffer = new Float32Array(capacity);\n  } else if (dtype == \"float64\") {\n    this.buffer = new Float64Array(capacity);\n  } else {\n    console.log(\"ERROR: unsupported type \" + dtype);\n  }\n};\n\nBuffer.prototype.append = function (buf) {\n  if (this.len + buf.length >= this.capacity) {\n    var newCap = Math.floor(\n      Math.max(this.capacity * 1.5),\n      this.len + buf.length\n    );\n    var tmp = new this.buffer.constructor(newCap);\n    tmp.set(this.buffer);\n\n    this.capacity = newCap;\n    this.buffer = tmp;\n  }\n  this.buffer.set(buf, this.len);\n  this.len += buf.length;\n};\n\nBuffer.prototype.clear = function () {\n  this.len = 0;\n};\n\nBuffer.prototype.stride = function () {\n  return this.buffer.BYTES_PER_ELEMENT;\n};\n\nBuffer.prototype.view = function (offset, length) {\n  return new this.buffer.constructor(this.buffer.buffer, offset, length);\n};\n\n// Various utilities that don't really fit anywhere else\n\n// Parse the hex string to RGB values in [0, 255]\nvar hexToRGB = function (hex) {\n  var val = parseInt(hex.substr(1), 16);\n  var r = (val >> 16) & 255;\n  var g = (val >> 8) & 255;\n  var b = val & 255;\n  return [r, g, b];\n};\n\n// Parse the hex string to RGB values in [0, 1]\nvar hexToRGBf = function (hex) {\n  var c = hexToRGB(hex);\n  return [c[0] / 255.0, c[1] / 255.0, c[2] / 255.0];\n};\n\n/* The controller can register callbacks for various events on a canvas:\n *\n * mousemove: function(prevMouse, curMouse, evt)\n *     receives both regular mouse events, and single-finger drags (sent as a left-click),\n *\n * press: function(curMouse, evt)\n *     receives mouse click and touch start events\n *\n * wheel: function(amount)\n *     mouse wheel scrolling\n *\n * pinch: function(amount)\n *     two finger pinch, receives the distance change between the fingers\n *\n * twoFingerDrag: function(dragVector)\n *     two finger drag, receives the drag movement amount\n */\nvar Controller = function () {\n  this.mousemove = null;\n  this.press = null;\n  this.wheel = null;\n  this.twoFingerDrag = null;\n  this.pinch = null;\n};\n\nController.prototype.registerForCanvas = function (canvas) {\n  var prevMouse = null;\n  var mouseState = [false, false];\n  var self = this;\n  canvas.addEventListener(\"mousemove\", function (evt) {\n    evt.preventDefault();\n    var rect = canvas.getBoundingClientRect();\n    var curMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n    if (!prevMouse) {\n      prevMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n    } else if (self.mousemove) {\n      self.mousemove(prevMouse, curMouse, evt);\n    }\n    prevMouse = curMouse;\n  });\n\n  canvas.addEventListener(\"mousedown\", function (evt) {\n    evt.preventDefault();\n    var rect = canvas.getBoundingClientRect();\n    var curMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n    if (self.press) {\n      self.press(curMouse, evt);\n    }\n  });\n\n  canvas.addEventListener(\"wheel\", function (evt) {\n    evt.preventDefault();\n    if (self.wheel) {\n      self.wheel(-evt.deltaY);\n    }\n  });\n\n  canvas.oncontextmenu = function (evt) {\n    evt.preventDefault();\n  };\n\n  var touches = {};\n  canvas.addEventListener(\"touchstart\", function (evt) {\n    var rect = canvas.getBoundingClientRect();\n    evt.preventDefault();\n    for (var i = 0; i < evt.changedTouches.length; ++i) {\n      var t = evt.changedTouches[i];\n      touches[t.identifier] = [t.clientX - rect.left, t.clientY - rect.top];\n      if (evt.changedTouches.length == 1 && self.press) {\n        self.press(touches[t.identifier], evt);\n      }\n    }\n  });\n\n  canvas.addEventListener(\"touchmove\", function (evt) {\n    evt.preventDefault();\n    var rect = canvas.getBoundingClientRect();\n    var numTouches = Object.keys(touches).length;\n    // Single finger to rotate the camera\n    if (numTouches == 1) {\n      if (self.mousemove) {\n        var t = evt.changedTouches[0];\n        var prevTouch = touches[t.identifier];\n        var curTouch = [t.clientX - rect.left, t.clientY - rect.top];\n        evt.buttons = 1;\n        self.mousemove(prevTouch, curTouch, evt);\n      }\n    } else {\n      var curTouches = {};\n      for (var i = 0; i < evt.changedTouches.length; ++i) {\n        var t = evt.changedTouches[i];\n        curTouches[t.identifier] = [\n          t.clientX - rect.left,\n          t.clientY - rect.top,\n        ];\n      }\n\n      // If some touches didn't change make sure we have them in\n      // our curTouches list to compute the pinch distance\n      // Also get the old touch points to compute the distance here\n      var oldTouches = [];\n      for (t in touches) {\n        if (!(t in curTouches)) {\n          curTouches[t] = touches[t];\n        }\n        oldTouches.push(touches[t]);\n      }\n\n      var newTouches = [];\n      for (t in curTouches) {\n        newTouches.push(curTouches[t]);\n      }\n\n      // Determine if the user is pinching or panning\n      var motionVectors = [\n        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.set(\n          gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create(),\n          newTouches[0][0] - oldTouches[0][0],\n          newTouches[0][1] - oldTouches[0][1]\n        ),\n        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.set(\n          gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create(),\n          newTouches[1][0] - oldTouches[1][0],\n          newTouches[1][1] - oldTouches[1][1]\n        ),\n      ];\n      var motionDirs = [gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create()];\n      gl_matrix__WEBPACK_IMPORTED_MODULE_5__.normalize(motionDirs[0], motionVectors[0]);\n      gl_matrix__WEBPACK_IMPORTED_MODULE_5__.normalize(motionDirs[1], motionVectors[1]);\n\n      var pinchAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.set(\n        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create(),\n        oldTouches[1][0] - oldTouches[0][0],\n        oldTouches[1][1] - oldTouches[0][1]\n      );\n      gl_matrix__WEBPACK_IMPORTED_MODULE_5__.normalize(pinchAxis, pinchAxis);\n\n      var panAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.lerp(\n        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create(),\n        motionVectors[0],\n        motionVectors[1],\n        0.5\n      );\n      gl_matrix__WEBPACK_IMPORTED_MODULE_5__.normalize(panAxis, panAxis);\n\n      var pinchMotion = [\n        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.dot(pinchAxis, motionDirs[0]),\n        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.dot(pinchAxis, motionDirs[1]),\n      ];\n      var panMotion = [\n        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.dot(panAxis, motionDirs[0]),\n        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.dot(panAxis, motionDirs[1]),\n      ];\n\n      // If we're primarily moving along the pinching axis and in the opposite direction with\n      // the fingers, then the user is zooming.\n      // Otherwise, if the fingers are moving along the same direction they're panning\n      if (\n        self.pinch &&\n        Math.abs(pinchMotion[0]) > 0.5 &&\n        Math.abs(pinchMotion[1]) > 0.5 &&\n        Math.sign(pinchMotion[0]) != Math.sign(pinchMotion[1])\n      ) {\n        // Pinch distance change for zooming\n        var oldDist = pointDist(oldTouches[0], oldTouches[1]);\n        var newDist = pointDist(newTouches[0], newTouches[1]);\n        self.pinch(newDist - oldDist);\n      } else if (\n        self.twoFingerDrag &&\n        Math.abs(panMotion[0]) > 0.5 &&\n        Math.abs(panMotion[1]) > 0.5 &&\n        Math.sign(panMotion[0]) == Math.sign(panMotion[1])\n      ) {\n        // Pan by the average motion of the two fingers\n        var panAmount = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.lerp(\n          gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create(),\n          motionVectors[0],\n          motionVectors[1],\n          0.5\n        );\n        panAmount[1] = -panAmount[1];\n        self.twoFingerDrag(panAmount);\n      }\n    }\n\n    // Update the existing list of touches with the current positions\n    for (var i = 0; i < evt.changedTouches.length; ++i) {\n      var t = evt.changedTouches[i];\n      touches[t.identifier] = [t.clientX - rect.left, t.clientY - rect.top];\n    }\n  });\n\n  var touchEnd = function (evt) {\n    evt.preventDefault();\n    for (var i = 0; i < evt.changedTouches.length; ++i) {\n      var t = evt.changedTouches[i];\n      delete touches[t.identifier];\n    }\n  };\n  canvas.addEventListener(\"touchcancel\", touchEnd);\n  canvas.addEventListener(\"touchend\", touchEnd);\n};\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./src/webgl-util.js?");

/***/ }),

/***/ "./node_modules/onnxruntime-web/dist/ort.webgpu.min.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.min.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InferenceSession\": () => (/* binding */ Qa),\n/* harmony export */   \"TRACE\": () => (/* binding */ vt),\n/* harmony export */   \"TRACE_FUNC_BEGIN\": () => (/* binding */ ve),\n/* harmony export */   \"TRACE_FUNC_END\": () => (/* binding */ he),\n/* harmony export */   \"Tensor\": () => (/* binding */ de),\n/* harmony export */   \"TrainingSession\": () => (/* binding */ Ja),\n/* harmony export */   \"default\": () => (/* binding */ h$),\n/* harmony export */   \"env\": () => (/* binding */ j),\n/* harmony export */   \"registerBackend\": () => (/* binding */ We)\n/* harmony export */ });\n/*!\n * ONNX Runtime Web v1.19.0-dev.20240531-67bc9438d7\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar lr=Object.defineProperty;var Fa=Object.getOwnPropertyDescriptor;var Ka=Object.getOwnPropertyNames;var ja=Object.prototype.hasOwnProperty;var cr=(e=>typeof require<\"u\"?require:typeof Proxy<\"u\"?new Proxy(e,{get:(t,r)=>(typeof require<\"u\"?require:t)[r]}):e)(function(e){if(typeof require<\"u\")return require.apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var E=(e,t)=>()=>(e&&(t=e(e=0)),t);var ht=(e,t)=>{for(var r in t)lr(e,r,{get:t[r],enumerable:!0})},Za=(e,t,r,n)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let o of Ka(t))!ja.call(e,o)&&o!==r&&lr(e,o,{get:()=>t[o],enumerable:!(n=Fa(t,o))||n.enumerable});return e};var pr=e=>Za(lr({},\"__esModule\",{value:!0}),e);var gt,Ne,We,Ya,yt,bt=E(()=>{\"use strict\";gt=new Map,Ne=[],We=(e,t,r)=>{if(t&&typeof t.init==\"function\"&&typeof t.createInferenceSessionHandler==\"function\"){let n=gt.get(e);if(n===void 0)gt.set(e,{backend:t,priority:r});else{if(n.priority>r)return;if(n.priority===r&&n.backend!==t)throw new Error(`cannot register backend \"${e}\" using priority ${r}`)}if(r>=0){let o=Ne.indexOf(e);o!==-1&&Ne.splice(o,1);for(let i=0;i<Ne.length;i++)if(gt.get(Ne[i]).priority<=r){Ne.splice(i,0,e);return}Ne.push(e)}return}throw new TypeError(\"not a valid backend\")},Ya=async e=>{let t=gt.get(e);if(!t)return\"backend not found.\";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(n){return r||(t.error=`${n}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},yt=async e=>{let t=e.executionProviders||[],r=t.map(u=>typeof u==\"string\"?u:u.name),n=r.length===0?Ne:r,o,i=[],s=new Set;for(let u of n){let d=await Ya(u);typeof d==\"string\"?i.push({name:u,err:d}):(o||(o=d),o===d&&s.add(u))}if(!o)throw new Error(`no available backend found. ERR: ${i.map(u=>`[${u.name}] ${u.err}`).join(\", \")}`);for(let{name:u,err:d}of i)r.includes(u)&&console.warn(`removing requested execution provider \"${u}\" from session options because it is not available: ${d}`);let a=t.filter(u=>s.has(typeof u==\"string\"?u:u.name));return[o,new Proxy(e,{get:(u,d)=>d===\"executionProviders\"?a:Reflect.get(u,d)})]}});var on=E(()=>{\"use strict\";bt()});var sn,an=E(()=>{\"use strict\";sn=\"1.19.0-dev.20240521-068bb3d5ee\"});var un,$e,mr=E(()=>{\"use strict\";an();un=\"warning\",$e={wasm:{},webgl:{},webgpu:{},versions:{common:sn},set logLevel(e){if(e!==void 0){if(typeof e!=\"string\"||[\"verbose\",\"info\",\"warning\",\"error\",\"fatal\"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);un=e}},get logLevel(){return un}};Object.defineProperty($e,\"logLevel\",{enumerable:!0})});var j,dn=E(()=>{\"use strict\";mr();j=$e});var ln,cn,pn=E(()=>{\"use strict\";ln=(e,t)=>{let r=typeof document<\"u\"?document.createElement(\"canvas\"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let n=r.getContext(\"2d\");if(n!=null){let o,i;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],i=e.dims[3]):(o=e.dims[3],i=e.dims[2]);let s=t?.format!==void 0?t.format:\"RGB\",a=t?.norm,u,d;a===void 0||a.mean===void 0?u=[255,255,255,255]:typeof a.mean==\"number\"?u=[a.mean,a.mean,a.mean,a.mean]:(u=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(u[3]=a.mean[3])),a===void 0||a.bias===void 0?d=[0,0,0,0]:typeof a.bias==\"number\"?d=[a.bias,a.bias,a.bias,a.bias]:(d=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(d[3]=a.bias[3]));let c=i*o,l=0,p=c,f=c*2,m=-1;s===\"RGBA\"?(l=0,p=c,f=c*2,m=c*3):s===\"RGB\"?(l=0,p=c,f=c*2):s===\"RBG\"&&(l=0,f=c,p=c*2);for(let h=0;h<i;h++)for(let b=0;b<o;b++){let y=(e.data[l++]-d[0])*u[0],g=(e.data[p++]-d[1])*u[1],w=(e.data[f++]-d[2])*u[2],$=m===-1?255:(e.data[m++]-d[3])*u[3];n.fillStyle=\"rgba(\"+y+\",\"+g+\",\"+w+\",\"+$+\")\",n.fillRect(b,h,1,1)}if(\"toDataURL\"in r)return r.toDataURL();throw new Error(\"toDataURL is not supported\")}else throw new Error(\"Can not access image data\")},cn=(e,t)=>{let r=typeof document<\"u\"?document.createElement(\"canvas\").getContext(\"2d\"):new OffscreenCanvas(1,1).getContext(\"2d\"),n;if(r!=null){let o,i,s;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],i=e.dims[1],s=e.dims[3]):(o=e.dims[3],i=e.dims[2],s=e.dims[1]);let a=t!==void 0&&t.format!==void 0?t.format:\"RGB\",u=t?.norm,d,c;u===void 0||u.mean===void 0?d=[255,255,255,255]:typeof u.mean==\"number\"?d=[u.mean,u.mean,u.mean,u.mean]:(d=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(d[3]=u.mean[3])),u===void 0||u.bias===void 0?c=[0,0,0,0]:typeof u.bias==\"number\"?c=[u.bias,u.bias,u.bias,u.bias]:(c=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(c[3]=u.bias[3]));let l=i*o;if(t!==void 0&&(t.format!==void 0&&s===4&&t.format!==\"RGBA\"||s===3&&t.format!==\"RGB\"&&t.format!==\"BGR\"))throw new Error(\"Tensor format doesn't match input tensor dims\");let p=4,f=0,m=1,h=2,b=3,y=0,g=l,w=l*2,$=-1;a===\"RGBA\"?(y=0,g=l,w=l*2,$=l*3):a===\"RGB\"?(y=0,g=l,w=l*2):a===\"RBG\"&&(y=0,w=l,g=l*2),n=r.createImageData(o,i);for(let v=0;v<i*o;f+=p,m+=p,h+=p,b+=p,v++)n.data[f]=(e.data[y++]-c[0])*d[0],n.data[m]=(e.data[g++]-c[1])*d[1],n.data[h]=(e.data[w++]-c[2])*d[2],n.data[b]=$===-1?255:(e.data[$++]-c[3])*d[3]}else throw new Error(\"Can not access image data\");return n}});var fr,mn,fn,hn,gn,yn=E(()=>{\"use strict\";wt();fr=(e,t)=>{if(e===void 0)throw new Error(\"Image buffer must be defined\");if(t.height===void 0||t.width===void 0)throw new Error(\"Image height and width must be defined\");if(t.tensorLayout===\"NHWC\")throw new Error(\"NHWC Tensor layout is not supported yet\");let{height:r,width:n}=t,o=t.norm??{mean:255,bias:0},i,s;typeof o.mean==\"number\"?i=[o.mean,o.mean,o.mean,o.mean]:i=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias==\"number\"?s=[o.bias,o.bias,o.bias,o.bias]:s=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let a=t.format!==void 0?t.format:\"RGBA\",u=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:\"RGB\",d=r*n,c=u===\"RGBA\"?new Float32Array(d*4):new Float32Array(d*3),l=4,p=0,f=1,m=2,h=3,b=0,y=d,g=d*2,w=-1;a===\"RGB\"&&(l=3,p=0,f=1,m=2,h=-1),u===\"RGBA\"?w=d*3:u===\"RBG\"?(b=0,g=d,y=d*2):u===\"BGR\"&&(g=0,y=d,b=d*2);for(let v=0;v<d;v++,p+=l,m+=l,f+=l,h+=l)c[b++]=(e[p]+s[0])/i[0],c[y++]=(e[f]+s[1])/i[1],c[g++]=(e[m]+s[2])/i[2],w!==-1&&h!==-1&&(c[w++]=(e[h]+s[3])/i[3]);return u===\"RGBA\"?new pe(\"float32\",c,[1,4,r,n]):new pe(\"float32\",c,[1,3,r,n])},mn=async(e,t)=>{let r=typeof HTMLImageElement<\"u\"&&e instanceof HTMLImageElement,n=typeof ImageData<\"u\"&&e instanceof ImageData,o=typeof ImageBitmap<\"u\"&&e instanceof ImageBitmap,i=typeof e==\"string\",s,a=t??{},u=()=>{if(typeof document<\"u\")return document.createElement(\"canvas\");if(typeof OffscreenCanvas<\"u\")return new OffscreenCanvas(1,1);throw new Error(\"Canvas is not supported\")},d=c=>c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext(\"2d\"):null;if(r){let c=u();c.width=e.width,c.height=e.height;let l=d(c);if(l!=null){let p=e.height,f=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(p=t.resizedHeight,f=t.resizedWidth),t!==void 0){if(a=t,t.tensorFormat!==void 0)throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");a.tensorFormat=\"RGBA\",a.height=p,a.width=f}else a.tensorFormat=\"RGBA\",a.height=p,a.width=f;l.drawImage(e,0,0),s=l.getImageData(0,0,f,p).data}else throw new Error(\"Can not access image data\")}else if(n){let c,l;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(c=t.resizedHeight,l=t.resizedWidth):(c=e.height,l=e.width),t!==void 0&&(a=t),a.format=\"RGBA\",a.height=c,a.width=l,t!==void 0){let p=u();p.width=l,p.height=c;let f=d(p);if(f!=null)f.putImageData(e,0,0),s=f.getImageData(0,0,l,c).data;else throw new Error(\"Can not access image data\")}else s=e.data}else if(o){if(t===void 0)throw new Error(\"Please provide image config with format for Imagebitmap\");let c=u();c.width=e.width,c.height=e.height;let l=d(c);if(l!=null){let p=e.height,f=e.width;return l.drawImage(e,0,0,f,p),s=l.getImageData(0,0,f,p).data,a.height=p,a.width=f,fr(s,a)}else throw new Error(\"Can not access image data\")}else{if(i)return new Promise((c,l)=>{let p=u(),f=d(p);if(!e||!f)return l();let m=new Image;m.crossOrigin=\"Anonymous\",m.src=e,m.onload=()=>{p.width=m.width,p.height=m.height,f.drawImage(m,0,0,p.width,p.height);let h=f.getImageData(0,0,p.width,p.height);a.height=p.height,a.width=p.width,c(fr(h.data,a))}});throw new Error(\"Input data provided is not supported - aborted tensor creation\")}if(s!==void 0)return fr(s,a);throw new Error(\"Input data provided is not supported - aborted tensor creation\")},fn=(e,t)=>{let{width:r,height:n,download:o,dispose:i}=t,s=[1,n,r,4];return new pe({location:\"texture\",type:\"float32\",texture:e,dims:s,download:o,dispose:i})},hn=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:i}=t;return new pe({location:\"gpu-buffer\",type:r??\"float32\",gpuBuffer:e,dims:n,download:o,dispose:i})},gn=(e,t,r)=>new pe({location:\"cpu-pinned\",type:e,data:t,dims:r??[t.length]})});var Ge,nt,bn,wn,$n=E(()=>{\"use strict\";Ge=new Map([[\"float32\",Float32Array],[\"uint8\",Uint8Array],[\"int8\",Int8Array],[\"uint16\",Uint16Array],[\"int16\",Int16Array],[\"int32\",Int32Array],[\"bool\",Uint8Array],[\"float64\",Float64Array],[\"uint32\",Uint32Array]]),nt=new Map([[Float32Array,\"float32\"],[Uint8Array,\"uint8\"],[Int8Array,\"int8\"],[Uint16Array,\"uint16\"],[Int16Array,\"int16\"],[Int32Array,\"int32\"],[Float64Array,\"float64\"],[Uint32Array,\"uint32\"]]),bn=!1,wn=()=>{if(!bn){bn=!0;let e=typeof BigInt64Array<\"u\"&&BigInt64Array.from,t=typeof BigUint64Array<\"u\"&&BigUint64Array.from,r=typeof Float16Array<\"u\"&&Float16Array.from;e&&(Ge.set(\"int64\",BigInt64Array),nt.set(BigInt64Array,\"int64\")),t&&(Ge.set(\"uint64\",BigUint64Array),nt.set(BigUint64Array,\"uint64\")),r?(Ge.set(\"float16\",Float16Array),nt.set(Float16Array,\"float16\")):Ge.set(\"float16\",Uint16Array)}}});var vn,_n,Sn=E(()=>{\"use strict\";wt();vn=e=>{let t=1;for(let r=0;r<e.length;r++){let n=e[r];if(typeof n!=\"number\"||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},_n=(e,t)=>{switch(e.location){case\"cpu\":return new pe(e.type,e.data,t);case\"cpu-pinned\":return new pe({location:\"cpu-pinned\",data:e.data,type:e.type,dims:t});case\"texture\":return new pe({location:\"texture\",texture:e.texture,type:e.type,dims:t});case\"gpu-buffer\":return new pe({location:\"gpu-buffer\",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var pe,wt=E(()=>{\"use strict\";pn();yn();$n();Sn();pe=class{constructor(t,r,n){wn();let o,i;if(typeof t==\"object\"&&\"location\"in t)switch(this.dataLocation=t.location,o=t.type,i=t.dims,t.location){case\"cpu-pinned\":{let a=Ge.get(o);if(!a)throw new TypeError(`unsupported type \"${o}\" to create tensor from pinned buffer`);if(!(t.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=t.data;break}case\"texture\":{if(o!==\"float32\")throw new TypeError(`unsupported type \"${o}\" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case\"gpu-buffer\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint8\"&&o!==\"bool\")throw new TypeError(`unsupported type \"${o}\" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,u;if(typeof t==\"string\")if(o=t,u=n,t===\"string\"){if(!Array.isArray(r))throw new TypeError(\"A string tensor's data must be a string array.\");a=r}else{let d=Ge.get(t);if(d===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t===\"float16\"&&d===Uint16Array)throw new TypeError(\"Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.\");t===\"uint64\"||t===\"int64\"?a=d.from(r,BigInt):a=d.from(r)}else if(r instanceof d)a=r;else throw new TypeError(`A ${o} tensor's data must be type of ${d}`)}else if(u=r,Array.isArray(t)){if(t.length===0)throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");let d=typeof t[0];if(d===\"string\")o=\"string\",a=t;else if(d===\"boolean\")o=\"bool\",a=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${d}.`)}else{let d=nt.get(t.constructor);if(d===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=d,a=t}if(u===void 0)u=[a.length];else if(!Array.isArray(u))throw new TypeError(\"A tensor's dims must be a number array\");i=u,this.cpuData=a,this.dataLocation=\"cpu\"}let s=vn(i);if(this.cpuData&&s!==this.cpuData.length)throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=i,this.size=s}static async fromImage(t,r){return mn(t,r)}static fromTexture(t,r){return fn(t,r)}static fromGpuBuffer(t,r){return hn(t,r)}static fromPinnedBuffer(t,r,n){return gn(t,r,n)}toDataURL(t){return ln(this,t)}toImageData(t){return cn(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error(\"The data is not stored as a WebGL texture.\");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error(\"The data is not stored as a WebGPU buffer.\");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case\"cpu\":case\"cpu-pinned\":return this.data;case\"texture\":case\"gpu-buffer\":{if(!this.downloader)throw new Error(\"The current tensor is not created with a specified data downloader.\");if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation=\"cpu\",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation=\"none\"}ensureValid(){if(this.dataLocation===\"none\")throw new Error(\"The tensor is disposed.\")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");return _n(this,t)}}});var de,$t=E(()=>{\"use strict\";wt();de=pe});var vt,xn,ve,he,hr=E(()=>{\"use strict\";mr();vt=(e,t)=>{(typeof $e.trace>\"u\"?!$e.wasm.trace:!$e.trace)||console.timeStamp(`${e}::ORT::${t}`)},xn=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],n=!1;for(let o=0;o<r.length;o++){if(n&&!r[o].includes(\"TRACE_FUNC\")){let i=`FUNC_${e}::${r[o].trim().split(\" \")[1]}`;t&&(i+=`::${t}`),vt(\"CPU\",i);return}r[o].includes(\"TRACE_FUNC\")&&(n=!0)}},ve=e=>{(typeof $e.trace>\"u\"?!$e.wasm.trace:!$e.trace)||xn(\"BEGIN\",e)},he=e=>{(typeof $e.trace>\"u\"?!$e.wasm.trace:!$e.trace)||xn(\"END\",e)}});var _t,In=E(()=>{\"use strict\";bt();$t();hr();_t=class e{constructor(t){this.handler=t}async run(t,r,n){ve();let o={},i={};if(typeof t!=\"object\"||t===null||t instanceof de||Array.isArray(t))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let s=!0;if(typeof r==\"object\"){if(r===null)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(r instanceof de)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(r)){if(r.length===0)throw new TypeError(\"'fetches' cannot be an empty array.\");s=!1;for(let d of r){if(typeof d!=\"string\")throw new TypeError(\"'fetches' must be a string array or an object.\");if(this.outputNames.indexOf(d)===-1)throw new RangeError(`'fetches' contains invalid output name: ${d}.`);o[d]=null}if(typeof n==\"object\"&&n!==null)i=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else{let d=!1,c=Object.getOwnPropertyNames(r);for(let l of this.outputNames)if(c.indexOf(l)!==-1){let p=r[l];(p===null||p instanceof de)&&(d=!0,s=!1,o[l]=p)}if(d){if(typeof n==\"object\"&&n!==null)i=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else i=r}}else if(typeof r<\"u\")throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(let d of this.inputNames)if(typeof t[d]>\"u\")throw new Error(`input '${d}' is missing in 'feeds'.`);if(s)for(let d of this.outputNames)o[d]=null;let a=await this.handler.run(t,o,i),u={};for(let d in a)if(Object.hasOwnProperty.call(a,d)){let c=a[d];c instanceof de?u[d]=c:u[d]=new de(c.type,c.data,c.dims)}return he(),u}async release(){return this.handler.dispose()}static async create(t,r,n,o){ve();let i,s={};if(typeof t==\"string\"){if(i=t,typeof r==\"object\"&&r!==null)s=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof Uint8Array){if(i=t,typeof r==\"object\"&&r!==null)s=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<\"u\"&&t instanceof SharedArrayBuffer){let c=t,l=0,p=t.byteLength;if(typeof r==\"object\"&&r!==null)s=r;else if(typeof r==\"number\"){if(l=r,!Number.isSafeInteger(l))throw new RangeError(\"'byteOffset' must be an integer.\");if(l<0||l>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(p=t.byteLength-l,typeof n==\"number\"){if(p=n,!Number.isSafeInteger(p))throw new RangeError(\"'byteLength' must be an integer.\");if(p<=0||l+p>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-l}].`);if(typeof o==\"object\"&&o!==null)s=o;else if(typeof o<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(typeof n<\"u\")throw new TypeError(\"'byteLength' must be a number.\")}else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\");i=new Uint8Array(c,l,p)}else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");let[a,u]=await yt(s),d=await a.createInferenceSessionHandler(i,u);return he(),new e(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Qa,Tn=E(()=>{\"use strict\";In();Qa=_t});var Cn=E(()=>{\"use strict\"});var An=E(()=>{\"use strict\"});var En=E(()=>{\"use strict\"});var kn=E(()=>{\"use strict\"});var Xa,St,Pn=E(()=>{\"use strict\";bt();$t();Xa=\"Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.\",St=class e{constructor(t,r,n){this.handler=t,this.hasOptimizerModel=r,this.hasEvalModel=n}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error(\"This training session has no evalModel loaded.\")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error(\"This training session has no evalModel loaded.\")}static async create(t,r){let n=t.evalModel||\"\",o=t.optimizerModel||\"\",i=r||{},[s,a]=await yt(i);if(s.createTrainingSessionHandler){let u=await s.createTrainingSessionHandler(t.checkpointState,t.trainModel,n,o,a);return new e(u,!!t.optimizerModel,!!t.evalModel)}else throw new Error(Xa)}typeNarrowingForRunStep(t,r,n,o,i){let s={},a={};if(typeof n!=\"object\"||n===null||n instanceof de||Array.isArray(n))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let u=!0;if(typeof o==\"object\"){if(o===null)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(o instanceof de)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(o)){if(o.length===0)throw new TypeError(\"'fetches' cannot be an empty array.\");u=!1;for(let d of o){if(typeof d!=\"string\")throw new TypeError(\"'fetches' must be a string array or an object.\");if(r.indexOf(d)===-1)throw new RangeError(`'fetches' contains invalid output name: ${d}.`);s[d]=null}if(typeof i==\"object\"&&i!==null)a=i;else if(typeof i<\"u\")throw new TypeError(\"'options' must be an object.\")}else{let d=!1,c=Object.getOwnPropertyNames(o);for(let l of r)if(c.indexOf(l)!==-1){let p=o[l];(p===null||p instanceof de)&&(d=!0,u=!1,s[l]=p)}if(d){if(typeof i==\"object\"&&i!==null)a=i;else if(typeof i<\"u\")throw new TypeError(\"'options' must be an object.\")}else a=o}}else if(typeof o<\"u\")throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(let d of t)if(typeof n[d]>\"u\")throw new Error(`input '${d}' is missing in 'feeds'.`);if(u)for(let d of r)s[d]=null;return[s,a]}convertHandlerReturnTypeToMapOfTensors(t){let r={};for(let n in t)if(Object.hasOwnProperty.call(t,n)){let o=t[n];o instanceof de?r[n]=o:r[n]=new de(o.type,o.data,o.dims)}return r}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(t,r,n){let[o,i]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,t,r,n),s=await this.handler.runTrainStep(t,o,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(t){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(t||{});else throw new Error(\"This TrainingSession has no OptimizerModel loaded.\")}async runEvalStep(t,r,n){if(this.hasEvalModel){let[o,i]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,t,r,n),s=await this.handler.runEvalStep(t,o,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error(\"This TrainingSession has no EvalModel loaded.\")}async getParametersSize(t=!0){return this.handler.getParametersSize(t)}async loadParametersBuffer(t,r=!0){let n=await this.getParametersSize(r);if(t.length!==4*n)throw new Error(\"Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.\");return this.handler.loadParametersBuffer(t,r)}async getContiguousParameters(t=!0){return this.handler.getContiguousParameters(t)}async release(){return this.handler.dispose()}}});var Ja,zn=E(()=>{\"use strict\";Pn();Ja=St});var gr={};ht(gr,{InferenceSession:()=>Qa,TRACE:()=>vt,TRACE_FUNC_BEGIN:()=>ve,TRACE_FUNC_END:()=>he,Tensor:()=>de,TrainingSession:()=>Ja,env:()=>j,registerBackend:()=>We});var _e=E(()=>{\"use strict\";on();dn();Tn();$t();Cn();An();hr();En();kn();zn()});var xt=E(()=>{\"use strict\"});var Rn={};ht(Rn,{default:()=>eu});var Bn,Dn,eu,Mn=E(()=>{\"use strict\";yr();Le();ot();Bn=\"ort-wasm-proxy-worker\",Dn=globalThis.self?.name===Bn;Dn&&(self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case\"init-wasm\":It(r.wasm).then(()=>{Tt(r).then(()=>{postMessage({type:t})},n=>{postMessage({type:t,err:n})})},n=>{postMessage({type:t,err:n})});break;case\"init-ep\":{let{epName:n,env:o}=r;Ct(o,n).then(()=>{postMessage({type:t})},i=>{postMessage({type:t,err:i})});break}case\"copy-from\":{let{buffer:n}=r,o=it(n);postMessage({type:t,out:o});break}case\"create\":{let{model:n,options:o}=r;At(n,o).then(i=>{postMessage({type:t,out:i})},i=>{postMessage({type:t,err:i})});break}case\"release\":Et(r),postMessage({type:t});break;case\"run\":{let{sessionId:n,inputIndices:o,inputs:i,outputIndices:s,options:a}=r;kt(n,o,i,s,new Array(s.length).fill(null),a).then(u=>{u.some(d=>d[3]!==\"cpu\")?postMessage({type:t,err:\"Proxy does not support non-cpu tensor location.\"}):postMessage({type:t,out:u},zt([...i,...u]))},u=>{postMessage({type:t,err:u})});break}case\"end-profiling\":Pt(r),postMessage({type:t});break;default:}}catch(n){postMessage({type:t,err:n})}});eu=Dn?null:e=>new Worker(e??Se,{type:\"module\",name:Bn})});var Se,tu,Vn,ru,nu,Nn,ou,Un,Wn,Gn,ot=E(()=>{\"use strict\";xt();Se= false?0:\"file:///mnt/c/Users/ldyke/webpack-prog-iso/node_modules/onnxruntime-web/dist/ort.webgpu.min.mjs\"??(0),tu= false||typeof location>\"u\"?void 0:location.origin,Vn=(e,t)=>{try{let r=t??Se;return(r?new URL(e,r):new URL(e)).origin===tu}catch{return!1}},ru=(e,t)=>{let r=t??Se;try{return(r?new URL(e,r):new URL(e)).href}catch{return}},nu=(e,t)=>`${t??\"./\"}${e}`,Nn=async e=>{let r=await(await fetch(e,{credentials:\"same-origin\"})).blob();return URL.createObjectURL(r)},ou=async e=>(await import(/*webpackIgnore:true*/e)).default,Un=(Mn(),pr(Rn)).default,Wn=async()=>{if(!Se)throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");if(Vn(Se))return[void 0,Un()];let e=await Nn(Se);return[e,Un(e)]},Gn=async(e,t,r)=>{let n=\"ort-wasm-simd-threaded.jsep.mjs\",o=e??ru(n,t),i= true&&r&&o&&!Vn(o,t),s=i?await Nn(o):o??nu(n,t);return[i?s:void 0,await ou(s)]}});var br,wr,Ot,Ln,iu,su,It,oe,Le=E(()=>{\"use strict\";ot();wr=!1,Ot=!1,Ln=!1,iu=()=>{if(typeof SharedArrayBuffer>\"u\")return!1;try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},su=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},It=async e=>{if(wr)return Promise.resolve();if(Ot)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(Ln)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");Ot=!0;let t=e.initTimeout,r=e.numThreads;if(!su())throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");let n=iu();r>1&&!n&&(typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+r+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"),e.numThreads=r=1);let o=e.wasmPaths,i=typeof o==\"string\"?o:void 0,s=o?.mjs,a=s?.href??s,u=o?.wasm,d=u?.href??u,[c,l]=await Gn(a,i,r>1),p=!1,f=[];if(t>0&&f.push(new Promise(m=>{setTimeout(()=>{p=!0,m()},t)})),f.push(new Promise((m,h)=>{l({numThreads:r,locateFile:(y,g)=>d??(i??g)+y}).then(y=>{Ot=!1,wr=!0,br=y,m(),c&&URL.revokeObjectURL(c)},y=>{Ot=!1,Ln=!0,h(y)})})),await Promise.race(f),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},oe=()=>{if(wr&&br)return br;throw new Error(\"WebAssembly is not initialized yet.\")}});var ie,st,te,Bt=E(()=>{\"use strict\";Le();ie=(e,t)=>{let r=oe(),n=r.lengthBytesUTF8(e)+1,o=r._malloc(n);return r.stringToUTF8(e,o,n),t.push(o),o},st=(e,t,r,n)=>{if(typeof e==\"object\"&&e!==null){if(r.has(e))throw new Error(\"Circular reference in options\");r.add(e)}Object.entries(e).forEach(([o,i])=>{let s=t?t+o:o;if(typeof i==\"object\")st(i,s+\".\",r,n);else if(typeof i==\"string\"||typeof i==\"number\")n(s,i.toString());else if(typeof i==\"boolean\")n(s,i?\"1\":\"0\");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},te=e=>{let t=oe(),r=t.stackSave();try{let n=t.stackAlloc(8);t._OrtGetLastError(n,n+4);let o=t.HEAP32[n/4],i=t.HEAPU32[n/4+1],s=i?t.UTF8ToString(i):\"\";throw new Error(`${e} ERROR_CODE: ${o}, ERROR_MESSAGE: ${s}`)}finally{t.stackRestore(r)}}});var Hn,qn=E(()=>{\"use strict\";Le();Bt();Hn=e=>{let t=oe(),r=0,n=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof e.logSeverityLevel!=\"number\"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!=\"number\"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let i=0;return e?.tag!==void 0&&(i=ie(e.tag,n)),r=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,i),r===0&&te(\"Can't create run options.\"),e?.extra!==void 0&&st(e.extra,\"\",new WeakSet,(s,a)=>{let u=ie(s,n),d=ie(a,n);t._OrtAddRunConfigEntry(r,u,d)!==0&&te(`Can't set a run config entry: ${s} - ${a}.`)}),[r,n]}catch(i){throw r!==0&&t._OrtReleaseRunOptions(r),n.forEach(s=>t._free(s)),i}}});var au,uu,du,lu,Fn,Kn=E(()=>{\"use strict\";Le();Bt();au=e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},uu=e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},du=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some(r=>(typeof r==\"string\"?r:r.name)===\"webgpu\")&&(e.enableMemPattern=!1)},lu=(e,t,r)=>{for(let n of t){let o=typeof n==\"string\"?n:n.name;switch(o){case\"webnn\":if(o=\"WEBNN\",typeof n!=\"string\"){let s=n;if(s?.deviceType){let a=ie(\"deviceType\",r),u=ie(s.deviceType,r);oe()._OrtAddSessionConfigEntry(e,a,u)!==0&&te(`Can't set a session config entry: 'deviceType' - ${s.deviceType}.`)}if(s?.numThreads){let a=s.numThreads;(typeof a!=\"number\"||!Number.isInteger(a)||a<0)&&(a=0);let u=ie(\"numThreads\",r),d=ie(a.toString(),r);oe()._OrtAddSessionConfigEntry(e,u,d)!==0&&te(`Can't set a session config entry: 'numThreads' - ${s.numThreads}.`)}if(s?.powerPreference){let a=ie(\"powerPreference\",r),u=ie(s.powerPreference,r);oe()._OrtAddSessionConfigEntry(e,a,u)!==0&&te(`Can't set a session config entry: 'powerPreference' - ${s.powerPreference}.`)}}break;case\"webgpu\":if(o=\"JS\",typeof n!=\"string\"){let s=n;if(s?.preferredLayout){if(s.preferredLayout!==\"NCHW\"&&s.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let a=ie(\"preferredLayout\",r),u=ie(s.preferredLayout,r);oe()._OrtAddSessionConfigEntry(e,a,u)!==0&&te(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${o}`)}let i=ie(o,r);oe()._OrtAppendExecutionProvider(e,i)!==0&&te(`Can't append execution provider: ${o}.`)}},Fn=e=>{let t=oe(),r=0,n=[],o=e||{};du(o);try{let i=au(o.graphOptimizationLevel??\"all\"),s=uu(o.executionMode??\"sequential\"),a=typeof o.logId==\"string\"?ie(o.logId,n):0,u=o.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let d=o.logVerbosityLevel??0;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log verbosity level is not valid: ${d}`);let c=typeof o.optimizedModelFilePath==\"string\"?ie(o.optimizedModelFilePath,n):0;if(r=t._OrtCreateSessionOptions(i,!!o.enableCpuMemArena,!!o.enableMemPattern,s,!!o.enableProfiling,0,a,u,d,c),r===0&&te(\"Can't create session options.\"),o.executionProviders&&lu(r,o.executionProviders,n),o.enableGraphCapture!==void 0){if(typeof o.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);let l=ie(\"enableGraphCapture\",n),p=ie(o.enableGraphCapture.toString(),n);t._OrtAddSessionConfigEntry(r,l,p)!==0&&te(`Can't set a session config entry: 'enableGraphCapture' - ${o.enableGraphCapture}.`)}if(o.freeDimensionOverrides)for(let[l,p]of Object.entries(o.freeDimensionOverrides)){if(typeof l!=\"string\")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof p!=\"number\"||!Number.isInteger(p)||p<0)throw new Error(`free dimension override value must be a non-negative integer: ${p}`);let f=ie(l,n);t._OrtAddFreeDimensionOverride(r,f,p)!==0&&te(`Can't set a free dimension override: ${l} - ${p}.`)}return o.extra!==void 0&&st(o.extra,\"\",new WeakSet,(l,p)=>{let f=ie(l,n),m=ie(p,n);t._OrtAddSessionConfigEntry(r,f,m)!==0&&te(`Can't set a session config entry: ${l} - ${p}.`)}),[r,n]}catch(i){throw r!==0&&t._OrtReleaseSessionOptions(r),n.forEach(s=>t._free(s)),i}}});var $r,Re,qe,Dt,at,Rt,vr,R=E(()=>{\"use strict\";$r=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Re=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${e}`)}},qe=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Dt=e=>{switch(e){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},at=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Rt=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint8\"||e===\"bool\",vr=e=>{switch(e){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var ut,_r=E(()=>{\"use strict\";xt();ut=async e=>{if(typeof e==\"string\")if(false){}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get(\"Content-Length\"),n=r?parseInt(r,10):0;if(n<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let o=t.body.getReader(),i;try{i=new ArrayBuffer(n)}catch(a){if(a instanceof RangeError){let u=Math.ceil(n/65536);i=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw a}let s=0;for(;;){let{done:a,value:u}=await o.read();if(a)break;let d=u.byteLength;new Uint8Array(i,s,d).set(u),s+=d}return new Uint8Array(i,0,n)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var cu,pu,jn,Zn,Yn,mu,re,Me=E(()=>{\"use strict\";R();cu=[\"V\",\"I\",\"W\",\"E\",\"F\"],pu=(e,t)=>{console.log(`[${cu[e]},${new Date().toISOString()}]${t}`)},Yn=(e,t)=>{jn=e,Zn=t},mu=(e,t)=>{let r=at(e),n=at(jn);r>=n&&pu(r,typeof t==\"function\"?t():t)},re=(...e)=>{Zn&&mu(...e)}});var Qn,Xn=E(()=>{\"use strict\";R();Qn=(e,t)=>new(Dt(t))(e)});var Mt=E(()=>{\"use strict\"});var Jn,Sr,xr,fu,hu,eo,Tr,Ir,ro,no=E(()=>{\"use strict\";Me();Mt();Jn=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Sr=[],xr=e=>Math.ceil(e/16)*16,fu=e=>{for(let t=0;t<Sr.length;t++){let r=Sr[t];if(e<=r)return r}return Math.ceil(e/16)*16},hu=1,eo=()=>hu++,Tr=async(e,t,r,n)=>{let o=xr(r),i=e.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=e.getCommandEncoder();e.endComputePass(),s.copyBufferToBuffer(t,0,i,0,o),e.flush(),await i.mapAsync(GPUMapMode.READ);let a=i.getMappedRange();if(n){let u=n();return u.set(new Uint8Array(a,0,r)),u}else return new Uint8Array(a.slice(0,r))}finally{i.destroy()}},Ir=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map;for(let[r]of Jn)Sr.push(r),this.freeBuffers.set(r,[]),this.freeUniformBuffers.set(r,[])}upload(t,r){let n=r.buffer,o=r.byteOffset,i=r.byteLength,s=xr(i),a=this.storageCache.get(t);if(!a)throw new Error(\"gpu data for uploading does not exist\");if(a.originalSize!==i)throw new Error(`inconsistent data size. gpu data size=${a.originalSize}, data size=${i}`);let u=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),d=u.getMappedRange();new Uint8Array(d).set(new Uint8Array(n,o,i)),u.unmap();let c=this.backend.getCommandEncoder();this.backend.endComputePass(),c.copyBufferToBuffer(u,0,a.gpuData.buffer,0,s),re(\"verbose\",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(u)}memcpy(t,r){let n=this.storageCache.get(t);if(!n)throw new Error(\"source gpu data for memcpy does not exist\");let o=this.storageCache.get(r);if(!o)throw new Error(\"destination gpu data for memcpy does not exist\");if(n.originalSize!==o.originalSize)throw new Error(\"inconsistent source and destination gpu data size\");let i=xr(n.originalSize),s=this.backend.getCommandEncoder();this.backend.endComputePass(),s.copyBufferToBuffer(n.gpuData.buffer,0,o.gpuData.buffer,0,i)}registerExternalBuffer(t,r,n){let o;if(n){if(o=this.externalBuffers.get(n),o===void 0)throw new Error(\"previous buffer is not registered\");if(t===n)return re(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, buffer is the same, skip.`),o;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`);this.externalBuffers.delete(n)}else o=eo();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,o),re(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, registered.`),o}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),re(\"verbose\",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=fu(t),o,i=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,s=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||s){let d=(i?this.freeBuffers:this.freeUniformBuffers).get(n);d?d.length>0?o=d.pop():o=this.backend.device.createBuffer({size:n,usage:r}):o=this.backend.device.createBuffer({size:n,usage:r})}else o=this.backend.device.createBuffer({size:n,usage:r});let a={id:eo(),type:0,buffer:o};return this.storageCache.set(a.id,{gpuData:a,originalSize:t}),re(\"verbose\",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${a.id}`),a}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error(\"releasing data does not exist\");return re(\"verbose\",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let n=this.storageCache.get(t);if(!n)throw new Error(\"data does not exist\");await Tr(this.backend,n.gpuData.buffer,n.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus===\"default\"){for(let t of this.buffersPending){let r=Jn.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(t.size)||[];r===void 0||n.length>=r?t.destroy():n.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(t.size)||[];r===void 0||n.length>=r?t.destroy():n.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let r of this.buffersPending)t.push(r);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(t){let r=this.capturedPendingBuffers.get(t);r&&(r.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(t))}},ro=(...e)=>new Ir(...e)});var Cr,U,ae=E(()=>{\"use strict\";Cr=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(\";\")),this.key}},U=e=>new Cr(e)});var Ar,ke,_,Fe,Ut,Vt,Nt,L=E(()=>{\"use strict\";Ar=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},ke=class{static calcShape(t,r,n=!1){let o=t.length,i=r.length;if(o===0)return r;if(i===0)return t;let s=Math.max(t.length,r.length),a=new Array(s);if(n){if(o<2||i<2)return;let u=Ar.calcMatMulShape([t[o-2],t[o-1]],[r[i-2],r[i-1]]);if(u===void 0)return;[a[s-2],a[s-1]]=u}for(let u=n?3:1;u<=s;u++){let d=o-u<0?1:t[o-u],c=i-u<0?1:r[i-u];if(d!==c&&d>1&&c>1)return;let l=Math.max(d,c);if(d&&c)a[s-u]=Math.max(d,c);else{if(l>1)return;a[s-u]=0}}return a}static isValidBroadcast(t,r){let n=t.length,o=r.length;if(n>o)return!1;for(let i=1;i<=n;i++)if(t[n-i]!==1&&t[n-i]!==r[o-i])return!1;return!0}},_=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,r=4){let n=t.length;if(n===0)return[];let o=new Array(n),i=n-1;for(;i>=0;){if(t[i]%r===0){o[i]=t[i]/r;break}if(r%t[i]!==0)throw new Error(\"cannot convert shape\");o[i]=1,r/=t[i],i--}for(i--;i>=0;i--)o[i]=t[i];return o}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,n){let o=1;for(let i=r;i<n;i++){if(t[i]<0)throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains negative values in them.\");o*=t[i]}return o}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let n=new Array(r);n[r-1]=1,n[r-2]=t[r-1];for(let o=r-3;o>=0;--o)n[o]=n[o+1]*t[o+1];return n}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error(\"unsupported axis for this operation.\");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(n=>this.normalizeAxis(n,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(n=>t[n]):t.slice().reverse()}static padShape(t,r){let n=t.length;return t.map((o,i)=>o+r[i]+r[i+n])}static areEqual(t,r){return t.length!==r.length?!1:t.every((n,o)=>n===r[o])}},Fe=class e{static adjustPoolAttributes(t,r,n,o,i,s){if(!t&&n.length!==r.length-2)throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");if(t)for(let a=0;a<r.length-2;a++)a>=n.length?n.push(r[a+2]):n[a]=r[a+2];for(let a=0;a<n.length;a++)if(a<o.length){if(o[a]<0)throw new Error(\"strides should be greater than or equal to 1\")}else o.push(1);for(let a=0;a<n.length;a++)if(a<i.length){if(i[a]<0)throw new Error(\"dilations should be greater than or equal to 1\")}else i.push(1);for(let a=0;a<n.length*2;a++)if(a<s.length){if(s[a]<0)throw new Error(\"pad should be greater than or equal to 1\")}else s.push(0);for(let a=0;a<n.length;a++){if(n[a]<=0)throw new Error(\"kernel shapes need to be greater than 0\");if(s[a]>=n[a]||s[a+n.length]>=n[a])throw new Error(\"pads should be smaller than kernel\")}}static adjustPadsBasedOnAutoPad(t,r,n,o,i,s,a){if(a){if(i.length!==2*(t.length-2))throw new Error(\"length of pads should be twice the length of data dimensions\");if(r.length!==t.length-2)throw new Error(\"length of strides should be the length of data dimensions\");if(o.length!==t.length-2)throw new Error(\"length of kernel shapes should be the length of data dimensions\");for(let u=0;u<t.length-2;u++)e.adjustPadAndReturnShape(t[u+(s?1:2)],r[u],n[u],o[u],i,u,u+t.length-2,a)}}static computePoolOutputShape(t,r,n,o,i,s,a){if(r.length<=0)throw new Error(\"input shape must be of size greater than 0\");let u=[r[0],r[1]];return e.computeShapeHelper(t,r,u,n,o,i,s,a),u}static computeConvOutputShape(t,r,n,o,i,s,a){if(t.length<=0||r.length<=0)throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");let u=[t[0],r[0]];return e.computeShapeHelper(!1,t,u,n,o,i,s,a),u}static computeShapeHelper(t,r,n,o,i,s,a,u){if(t)for(let d=0;d<r.length-2;d++)n.push(1);else for(let d=0;d<r.length-2;d++)n.push(e.adjustPadAndReturnShape(r[d+2],o[d],i[d],s[d],a,d,d+r.length-2,u))}static adjustPadAndReturnShape(t,r,n,o,i,s,a,u){let d=n*(o-1)+1;if(u&&u!==\"NOTSET\")switch(u){case\"VALID\":return i[s]=0,i[a]=0,Math.floor((t-d)/r+1);case\"SAME_LOWER\":case\"SAME_UPPER\":if(n!==1)throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");{let l=((t+r-1)/r-1)*r+o-t;return i[s]=Math.floor(u===\"SAME_LOWER\"?(l+1)/2:l/2),i[a]=l-i[s],Math.floor((t+l-o)/r+1)}default:throw new Error(\"Unsupported AutoPad type\")}else return Math.floor((t+i[s]+i[a]-d)/r+1)}},Ut=class{static getShapeOfGemmResult(t,r,n,o,i){if(t.length!==2||n.length!==2)throw new Error(\"shape need to be of size 2\");let s,a,u;r?(s=t[1],a=t[0]):(s=t[0],a=t[1]);let d=-1;if(o?(u=n[0],d=1):(u=n[1],d=0),n[d]!==a)throw new Error(\"dimension mismatch\");if(s<=0||u<=0||a<=0)throw new Error(\"invalid shape specified\");if(i&&!ke.isValidBroadcast(i,[s,u]))throw new Error(\"gemm: invalid bias shape for broadcast\");return[s,u,a]}},Vt=-34028234663852886e22,Nt=34028234663852886e22});var Ke,kr,X,le,k,ee,Ue,je,Te,D,Pr,S,A,Wt,Er,oo,Je,W=E(()=>{\"use strict\";R();L();Ke=64,kr=(e,t)=>{if(t===3)throw new Error(\"vec3 has same alignment as vec4, use vec4 instead\");switch(e){case 10:return t>1?`vec${t}<f16>`:\"f16\";case 1:return t>1?`vec${t}<f32>`:\"f32\";case 6:return t>1?`vec${t}<i32>`:\"i32\";case 12:return t>1?`vec${t}<u32>`:\"u32\";case 7:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"i32\"];case 13:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"u32\"];case 9:if(t!==4)throw new Error(\"bool must be vec4\");return[\"u32\",\"vec4<bool>\"];default:throw new Error(`Unknown data type: ${e}`)}},X=(e,t=1)=>{let r=kr(e,t);return typeof r==\"string\"?r:r[0]},le=(e,t=1)=>{let r=kr(e,t);return typeof r==\"string\"?r:r[1]},k=(...e)=>{let t=[];return e.forEach(r=>{r.length!==0&&t.push({type:12,data:r},{type:12,data:_.computeStrides(r)})}),t},ee=e=>e%4===0?4:e%2===0?2:1,Ue=(e=\"f32\",t,r=\"0\")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,je=(e,t,r)=>e===\"f32\"?r:t===1?`f32(${r})`:`vec${t}<f32>(${r})`,Te=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,D=(e,t,r,n)=>e.startsWith(\"uniforms.\")&&r>4?typeof t==\"string\"?n===\"f16\"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:n===\"f16\"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,Pr=(e,t,r,n,o)=>{let i=typeof r==\"number\",s=i?r:r.length,a=[...new Array(s).keys()],u=s<2?\"u32\":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,d=kr(t,o),c=typeof d==\"string\"?d:d[1],l=typeof d==\"string\"?d:d[0],p={indices:u,value:c,storage:l,tensor:t},f=C=>typeof C==\"string\"?C:`${C}u`,m={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},h=i?\"uniforms.\":\"\",b=`${h}${e}_shape`,y=`${h}${e}_strides`,g=\"\";for(let C=0;C<s-1;C++)g+=`\n    let dim${C} = current / ${D(y,C,s)};\n    let rest${C} = current % ${D(y,C,s)};\n    indices[${C}] = dim${C};\n    current = rest${C};\n    `;g+=`indices[${s-1}] = current;`;let w=s<2?\"\":`\n  fn o2i_${e}(offset: u32) -> ${p.indices} {\n    var indices: ${p.indices};\n    var current = offset;\n    ${g}\n    return indices;\n  }`,$=C=>(m.offsetToIndices=!0,s<2?C:`o2i_${e}(${C})`),v=[];if(s>=2)for(let C=s-1;C>=0;C--)v.push(`${D(y,C,s)} * (indices[${C}])`);let x=s<2?\"\":`\n  fn i2o_${e}(indices: ${p.indices}) -> u32 {\n    return ${v.join(\"+\")};\n  }`,T=C=>(m.indicesToOffset=!0,s<2?C:`i2o_${e}(${C})`),I=(...C)=>s===0?\"0u\":`${p.indices}(${C.map(f).join(\",\")})`,z=(C,B)=>s<2?`${C}`:`${D(C,B,s)}`,P=(C,B,F)=>s<2?`${C}=${F};`:`${D(C,B,s)}=${F};`,G={},J=(C,B)=>{m.broadcastedIndicesToOffset=!0;let F=`${B.name}broadcastedIndicesTo${e}Offset`;if(F in G)return`${F}(${C})`;let Ie=[];for(let fe=s-1;fe>=0;fe--){let ue=B.indicesGet(\"outputIndices\",fe+B.rank-s);Ie.push(`${z(y,fe)} * (${ue} % ${z(b,fe)})`)}return G[F]=`fn ${F}(outputIndices: ${B.type.indices}) -> u32 {\n             return ${Ie.length>0?Ie.join(\"+\"):\"0u\"};\n           }`,`${F}(${C})`},ne=(C,B)=>(()=>{if(p.storage===p.value)return`${e}[${C}]=${B};`;if(p.storage===\"vec2<u32>\"&&p.value===\"i32\")return`${e}[${C}]=vec2<u32>(u32(${B}), select(0u, 0xFFFFFFFFu, ${B} < 0));`;if(p.storage===\"vec2<u32>\"&&p.value===\"u32\")return`${e}[${C}]=vec2<u32>(u32(${B}), 0u);`;if(p.storage===\"u32\"&&p.value===\"vec4<bool>\")return`${e}[${C}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${B}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),Q=C=>(()=>{if(p.storage===p.value)return`${e}[${C}]`;if(p.storage===\"vec2<u32>\"&&p.value===\"i32\")return`i32(${e}[${C}].x)`;if(p.storage===\"vec2<u32>\"&&p.value===\"u32\")return`u32(${e}[${C}].x)`;if(p.storage===\"u32\"&&p.value===\"vec4<bool>\")return`vec4<bool>(bool(${e}[${C}] & 0xFFu), bool(${e}[${C}] & 0xFF00u), bool(${e}[${C}] & 0xFF0000u), bool(${e}[${C}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),se=s<2?\"\":`\n  fn get_${e}ByIndices(indices: ${p.indices}) -> ${c} {\n    return ${Q(`i2o_${e}(indices)`)};\n  }`,O=s<2?\"\":(()=>{let C=a.map(F=>`d${F}: u32`).join(\", \"),B=a.map(F=>`d${F}`).join(\", \");return`\n  fn get_${e}(${C}) -> ${c} {\n    return get_${e}ByIndices(${I(B)});\n  }`})(),Y=(...C)=>{if(C.length!==s)throw new Error(`indices length must be ${s}`);let B=C.map(f).join(\",\");return s===0?Q(\"0u\"):s===1?Q(B[0]):(m.get=!0,m.getByIndices=!0,m.indicesToOffset=!0,`get_${e}(${B})`)},K=C=>s<2?Q(C):(m.getByIndices=!0,m.indicesToOffset=!0,`get_${e}ByIndices(${C})`),q=s<2?\"\":`\n  fn set_${e}ByIndices(indices: ${p.indices}, value: ${c}) {\n    ${ne(`i2o_${e}(indices)`,\"value\")}\n  }`,M=s<2?\"\":(()=>{let C=a.map(F=>`d${F}: u32`).join(\", \"),B=a.map(F=>`d${F}`).join(\", \");return`\n  fn set_${e}(${C}, value: ${c}) {\n    set_${e}ByIndices(${I(B)}, value);\n  }`})();return{impl:()=>{let C=[],B=!1;return m.offsetToIndices&&(C.push(w),B=!0),m.indicesToOffset&&(C.push(x),B=!0),m.broadcastedIndicesToOffset&&(Object.values(G).forEach(F=>C.push(F)),B=!0),m.set&&(C.push(M),B=!0),m.setByIndices&&(C.push(q),B=!0),m.get&&(C.push(O),B=!0),m.getByIndices&&(C.push(se),B=!0),!i&&B&&C.unshift(`const ${b} = ${p.indices}(${r.join(\",\")});`,`const ${y} = ${p.indices}(${_.computeStrides(r).join(\",\")});`),C.join(`\n`)},type:p,offsetToIndices:$,indicesToOffset:T,broadcastedIndicesToOffset:J,indices:I,indicesGet:z,indicesSet:P,set:(...C)=>{if(C.length!==s+1)throw new Error(`indices length must be ${s}`);let B=C[s];if(typeof B!=\"string\")throw new Error(\"value must be string\");let F=C.slice(0,s).map(f).join(\",\");return s===0?ne(\"0u\",B):s===1?ne(F[0],B):(m.set=!0,m.setByIndices=!0,m.indicesToOffset=!0,`set_${e}(${F}, ${B})`)},setByOffset:ne,setByIndices:(C,B)=>s<2?ne(C,B):(m.setByIndices=!0,m.indicesToOffset=!0,`set_${e}ByIndices(${C}, ${B});`),get:Y,getByOffset:Q,getByIndices:K,usage:n,name:e,strides:y,shape:b,rank:s}},S=(e,t,r,n=1)=>Pr(e,t,r,\"input\",n),A=(e,t,r,n=1)=>Pr(e,t,r,\"output\",n),Wt=(e,t,r,n=1)=>Pr(e,t,r,\"internal\",n),Er=class{constructor(t,r){this.normalizedDispatchGroup=t;this.limits=r;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t==\"number\"?`${t}u`:t}) { return; }`}mainStart(t=Ke){let r=typeof t==\"number\"?t:t[0],n=typeof t==\"number\"?1:t[1],o=typeof t==\"number\"?1:t[2];if(r>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||o>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(r*n*o>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,s=i?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,a=i?\"let global_idx = global_id.x; let local_idx = local_id.x;\":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*n*o}u + local_idx;`;return`@compute @workgroup_size(${r}, ${n}, ${o})\n  fn main(${s}) {\n    ${a}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.shape.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}),t.strides.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.strides.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}))}declareVariable(t,r){if(t.usage===\"internal\")throw new Error(\"cannot use internal variable with declareVariable(). use registerInternalVariables() instead.\");this.variables.push(t),this.appendVariableUniforms(t);let n=t.usage===\"input\"?\"read\":\"read_write\",o=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${n}> ${t.name}: array<${o}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!==\"internal\")throw new Error(\"cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.\");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,n=1){return this.uniforms.push({name:t,type:r,length:n}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return\"\";let t=[];for(let{name:r,type:n,length:o}of this.uniforms)if(o&&o>4)n===\"f16\"?t.push(`@align(16) ${r}:array<mat2x4<${n}>, ${Math.ceil(o/8)}>`):t.push(`${r}:array<vec4<${n}>, ${Math.ceil(o/4)}>`);else{let i=o==null||o===1?n:`vec${o}<${n}>`;t.push(`${r}:${i}`)}return`\n      struct Uniforms { ${t.join(\", \")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=r=>[12,10,1,6][[\"u32\",\"f16\",\"f32\",\"i32\"].indexOf(r)];return this.uniforms.map(r=>[t(r.type),r.length??1])}},oo=(e,t)=>new Er(e,t),Je=(e,t)=>{let r=e.length,n=[];for(let o=0;o<r;o++){let i=r-1-o,s=e[i]||1;(t[t.length-1-o]||1)>1&&s===1&&n.unshift(i)}return n}});var gu,io,yu,bu,ge,so,ao,Ze=E(()=>{\"use strict\";R();L();ae();W();gu=e=>{if(!e||e.length!==1)throw new Error(\"Transpose requires 1 input.\")},io=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,yu=(e,t)=>_.sortBasedOnPerm(e,io(e.length,t)),bu=(e,t,r,n)=>{let o=[];o.push(`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let i=0;i<t;++i)o.push(r.indicesSet(\"a\",e[i],`i[${i}]`));return o.push(\"return a;}\"),o.join(`\n`)},ge=(e,t)=>{let r=e.dataType,n=e.dims.length,o=io(n,t),i=yu(e.dims,o),s=A(\"output\",r,i.length),a=S(\"a\",r,n),u;if(o.length===2&&o[0]===1&&o[1]===0){let d=s.type.value,c=[16,16,1];u=l=>`\n  ${l.registerUniform(\"output_size\",\"u32\").declareVariables(a,s)}\n  var<workgroup> tile : array<array<${d}, ${c[0]+1}>, ${c[0]}>;\n  ${l.mainStart(c)}\n    var x = workgroup_id.x * ${c[0]}u + local_id.x;\n    var y = workgroup_id.y * ${c[0]}u + local_id.y;\n    let width = uniforms.output_shape[0];\n    let height = uniforms.output_shape[1];\n    if (x < width && y < height) {\n      tile[local_id.y][local_id.x] = ${a.getByOffset(\"y * width + x\")};\n    }\n    workgroupBarrier();\n    x = workgroup_id.y * ${c[0]}u + local_id.x;\n    y = workgroup_id.x * ${c[0]}u + local_id.y;\n    if (x < height && y < width) {\n      ${s.setByOffset(\"y * height + x\",\"tile[local_id.x][local_id.y]\")}\n    }\n  }`}else u=d=>`\n  ${d.registerUniform(\"output_size\",\"u32\").declareVariables(a,s)}\n\n  ${bu(o,n,a,s)}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${s.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${s.setByOffset(\"global_idx\",a.getByIndices(\"aIndices\"))}\n  }`;return{name:\"Transpose\",shaderCache:{hint:`${t}`,inputDependencies:[\"rank\"]},getRunData:d=>{let c=_.size(i);return{outputs:[{dims:i,dataType:d[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:12,data:c},...k(d[0].dims,i)]}},getShaderSource:u}},so=(e,t)=>{gu(e.inputs),e.compute(ge(e.inputs[0],t.perm))},ao=e=>U({perm:e.perm})});var wu,$u,vu,_u,Su,xu,Iu,Tu,Cu,Au,Pe,uo,lo,co,po,mo,fo,ho,go,yo,bo,wo=E(()=>{\"use strict\";R();L();W();Gt();Ze();wu={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate * candidate\",logSumExp:\"bestValue + exp(candidate)\",l1:\"bestValue + abs(candidate)\",l2:\"bestValue + candidate * candidate\",logSum:\"bestValue + candidate\"},$u={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate\",logSumExp:\"bestValue + candidate\",l1:\"bestValue + candidate\",l2:\"bestValue + candidate\",logSum:\"bestValue + candidate\"},vu={max:\"_A[offset]\",min:\"_A[offset]\",mean:\"0\",sum:\"0\",prod:\"1\",sumSquare:\"0\",logSumExp:\"0\",l1:\"0\",l2:\"0\",logSum:\"0\"},_u={max:\"bestValue\",min:\"bestValue\",sum:\"bestValue\",prod:\"bestValue\",sumSquare:\"bestValue\",logSumExp:\"log(bestValue)\",l1:\"bestValue\",l2:\"sqrt(bestValue)\",logSum:\"log(bestValue)\"},Su=(e,t)=>{let r=[];for(let n=t-e;n<t;++n)r.push(n);return r},xu=(e,t)=>{let r=[],n=e.length;for(let i=0;i<n;i++)t.indexOf(i)===-1&&r.push(e[i]);let o=t.map(i=>e[i]);return[r,o]},Iu=(e,t)=>{let r=e.length+t.length,n=[],o=0;for(let i=0;i<r;i++)t.indexOf(i)===-1?n.push(e[o++]):n.push(1);return n},Tu=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},Cu=(e,t)=>{let r=[];if(!Tu(e,t)){for(let n=0;n<t;++n)e.indexOf(n)===-1&&r.push(n);e.forEach(n=>r.push(n))}return r},Au=(e,t,r,n,o,i,s)=>{let a=r[0].dims,u=_.size(i),d=_.size(s),c=S(\"_A\",r[0].dataType,a),l=A(\"output\",o,i),p=32,f=`\n          var<workgroup> aBestValues : array<f32, ${p}>;\n       `;return{name:e,shaderCache:t,getShaderSource:h=>`\n        ${h.registerUniform(\"reduceSize\",\"u32\").declareVariables(c,l)}\n        ${f}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${h.mainStart(p)}\n\n          let outputIndex = global_idx / ${p};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${vu[n]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${p}) {\n           let candidate = f32(${c.getByOffset(\"offset + k\")});\n           bestValue = ${wu[n]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${p}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${$u[n]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${l.setByOffset(\"outputIndex\",`${n===\"mean\"?`${l.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${l.type.storage}(${_u[n]})`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:i,dataType:o}],dispatchGroup:{x:u},programUniforms:[{type:12,data:d}]})}},Pe=(e,t,r,n)=>{let o=e.inputs.length===1?r:zr(e.inputs,r),i=o.axes;i.length===0&&!o.noopWithEmptyAxes&&(i=e.inputs[0].dims.map((f,m)=>m));let s=_.normalizeAxes(i,e.inputs[0].dims.length),a=s,u=e.inputs[0],d=Cu(a,e.inputs[0].dims.length);d.length>0&&(u=e.compute(ge(e.inputs[0],d),{inputs:[0],outputs:[-1]})[0],a=Su(a.length,u.dims.length));let[c,l]=xu(u.dims,a),p=c;o.keepDims&&(p=Iu(c,s)),e.compute(Au(t,{hint:o.cacheKey,inputDependencies:[\"type\"]},[u],n,e.inputs[0].dataType,p,l),{inputs:[u]})},uo=(e,t)=>{Pe(e,\"ReduceMeanShared\",t,\"mean\")},lo=(e,t)=>{Pe(e,\"ReduceL1Shared\",t,\"l1\")},co=(e,t)=>{Pe(e,\"ReduceL2Shared\",t,\"l2\")},po=(e,t)=>{Pe(e,\"ReduceLogSumExpShared\",t,\"logSumExp\")},mo=(e,t)=>{Pe(e,\"ReduceMaxShared\",t,\"max\")},fo=(e,t)=>{Pe(e,\"ReduceMinShared\",t,\"min\")},ho=(e,t)=>{Pe(e,\"ReduceProdShared\",t,\"prod\")},go=(e,t)=>{Pe(e,\"ReduceSumShared\",t,\"sum\")},yo=(e,t)=>{Pe(e,\"ReduceSumSquareShared\",t,\"sumSquare\")},bo=(e,t)=>{Pe(e,\"ReduceLogSumShared\",t,\"logSum\")}});var ze,Eu,Lt,zr,Oe,ku,Pu,zu,Ou,Bu,Du,Ru,Mu,Uu,Vu,Be,$o,vo,_o,So,xo,Io,To,Co,Ao,Eo,Gt=E(()=>{\"use strict\";R();L();ae();W();wo();ze=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"Reduce op requires 1 or 2 inputs.\");if(e.length===2&&e[1].dims.length!==1)throw new Error(\"Invalid axes input dims.\")},Eu=e=>[\"\",\"\",`var value = ${e.getByIndices(\"input_indices\")};`,\"\"],Lt=(e,t,r,n,o,i,s=!1,a=!1)=>{let u=[],d=r[0].dims,c=d.length,l=_.normalizeAxes(o,c),p=!a&&l.length===0;d.forEach((b,y)=>{p||l.indexOf(y)>=0?s&&u.push(1):u.push(b)});let f=u.length,m=_.size(u);return{name:e,shaderCache:t,getShaderSource:b=>{let y=[],g=S(\"_A\",r[0].dataType,c),w=A(\"output\",i,f),$=n(g,w,l),v=$[2];for(let x=0,T=0;x<c;x++)p||l.indexOf(x)>=0?(s&&T++,v=`for(var j${x}: u32 = 0; j${x} < ${d[x]}; j${x}++) {\n                  ${$[2].includes(\"last_index\")?`let last_index = j${x};`:\"\"}\n                  ${g.indicesSet(\"input_indices\",x,`j${x}`)}\n                  ${v}\n                }`):(y.push(`${g.indicesSet(\"input_indices\",x,w.indicesGet(\"output_indices\",T))};`),T++);return`\n\n        ${b.registerUniform(\"output_size\",\"u32\").declareVariables(g,w)}\n\n        ${b.mainStart()}\n          ${b.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          var input_indices: ${g.type.indices};\n          let output_indices = ${w.offsetToIndices(\"global_idx\")};\n\n          ${y.join(`\n`)}\n          ${$[0]}       // init ops for reduce max/min\n          ${$[1]}\n          ${v}\n          ${$[3]}\n          ${$.length===4?w.setByOffset(\"global_idx\",\"value\"):$.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...k(d,u)]})}},zr=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),U({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Oe=(e,t,r,n)=>{let o=e.inputs,i=o.length===1?r:zr(o,r);e.compute(Lt(t,{hint:i.cacheKey,inputDependencies:[\"rank\"]},[o[0]],i.noopWithEmptyAxes&&i.axes.length===0?Eu:n,i.axes,o[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},ku=(e,t)=>{ze(e.inputs),Oe(e,\"ReduceLogSum\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${n.getByIndices(\"input_indices\")};`,\"value = log(value);\"])},Pu=(e,t)=>{ze(e.inputs),Oe(e,\"ReduceL1\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += abs(${n.getByIndices(\"input_indices\")});`,\"\"])},zu=(e,t)=>{ze(e.inputs),Oe(e,\"ReduceL2\",t,(n,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${n.getByIndices(\"input_indices\")}; value += (t * t);`,\"value = sqrt(value);\"])},Ou=(e,t)=>{ze(e.inputs),Oe(e,\"ReduceLogSumExp\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += exp(${n.getByIndices(\"input_indices\")});`,\"value = log(value);\"])},Bu=(e,t)=>{ze(e.inputs),Oe(e,\"ReduceMax\",t,(n,o,i)=>{let s=[];for(let a=0;a<n.rank;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(n.indicesSet(\"input_indices\",a,0));return[`${s.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};`,`value = max(value, ${n.getByIndices(\"input_indices\")});`,\"\"]})},Du=(e,t)=>{ze(e.inputs),Oe(e,\"ReduceMean\",t,(n,o,i)=>{let s=1;for(let a=0;a<n.rank;a++)(i.indexOf(a)>=0||i.length===0)&&(s*=e.inputs[0].dims[a]);return[\"var sum = f32(0);\",\"\",`sum += f32(${n.getByIndices(\"input_indices\")});`,`let value = ${o.type.value}(sum / ${s});`]})},Ru=(e,t)=>{ze(e.inputs),Oe(e,\"ReduceMin\",t,(n,o,i)=>{let s=[];for(let a=0;a<n.rank;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(`input_indices[${a}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};`,`value = min(value, ${n.getByIndices(\"input_indices\")});`,\"\"]})},Mu=(e,t)=>{ze(e.inputs),Oe(e,\"ReduceProd\",t,(n,o)=>[`var value = ${o.type.storage}(1);`,\"\",`value *= ${n.getByIndices(\"input_indices\")};`,\"\"])},Uu=(e,t)=>{ze(e.inputs),Oe(e,\"ReduceSum\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${n.getByIndices(\"input_indices\")};`,\"\"])},Vu=(e,t)=>{ze(e.inputs),Oe(e,\"ReduceSumSquare\",t,(n,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${n.getByIndices(\"input_indices\")}; value += t * t;`,\"\"])},Be=(e,t,r)=>{if(t.length===0)return r;let n=1,o=1;for(let i=0;i<t.length;i++)t.indexOf(i)===-1?n*=e[i]:o*=e[i];return o<32&&n>1024},$o=(e,t)=>{Be(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Du(e,t):uo(e,t)},vo=(e,t)=>{Be(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Pu(e,t):lo(e,t)},_o=(e,t)=>{Be(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?zu(e,t):co(e,t)},So=(e,t)=>{Be(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ou(e,t):po(e,t)},xo=(e,t)=>{Be(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Bu(e,t):mo(e,t)},Io=(e,t)=>{Be(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ru(e,t):fo(e,t)},To=(e,t)=>{Be(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Mu(e,t):ho(e,t)},Co=(e,t)=>{Be(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Uu(e,t):go(e,t)},Ao=(e,t)=>{Be(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Vu(e,t):yo(e,t)},Eo=(e,t)=>{Be(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ku(e,t):bo(e,t)}});var ko,Po,zo,Or,Oo=E(()=>{\"use strict\";R();ae();Gt();ko=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"ArgMinMaxOp op requires 1 or 2 inputs.\");if(e[0].dataType!==1)throw new Error(\"Invalid input type.\")},Po=(e,t)=>{ko(e.inputs);let r=(n,o,i)=>{let s=[];for(let a=0;a<n.rank;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(`input_indices[${a}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${n.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\"<=\":\"<\"} value) {\n         value = ${n.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Lt(\"ArgMin\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},zo=(e,t)=>{ko(e.inputs);let r=(n,o,i)=>{let s=[];for(let a=0;a<n.rank;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(`input_indices[${a}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${n.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\">=\":\">\"} value) {\n         value = ${n.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Lt(\"argMax\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Or=e=>U(e)});var Nu,Wu,Gu,Lu,et,Hu,Bo,Ht=E(()=>{\"use strict\";R();Mt();W();Nu=(e,t)=>{let r=e[0],n=e[1],o=e[2],i=e[3],s=e[4],a=e[5];if(s&&a)throw new Error(\"Attention cannot have both past and relative_position_bias\");if(r.dims.length!==3)throw new Error('Input \"input\" must have 3 dimensions');let u=r.dims[0],d=r.dims[1],c=r.dims[2];if(o.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimensions');if(n.dims.length!==2)throw new Error('Input \"weights\" is expected to have 2 dimensions');if(n.dims[0]!==c)throw new Error(\"Input 1 dimension 0 should have same length as dimension 2 of input 0\");if(o.dims[0]!==n.dims[1])throw new Error('Input \"bias\" dimension 0 should have same length as dimension 1 of input \"weights\"');let l=o.dims[0]/3,p=l,f=p;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error(\"qkv_hidden_sizes attribute should have 3 elements\");for(let w of t.qkvHiddenSizes)if(w%t.numHeads!==0)throw new Error(\"qkv_hidden_sizes should be divisible by num_heads\");l=t.qkvHiddenSizes[0],p=t.qkvHiddenSizes[1],f=t.qkvHiddenSizes[2]}let m=d;if(l!==p)throw new Error(\"qkv_hidden_sizes first element should be same as the second\");if(o.dims[0]!==l+p+f)throw new Error('Input \"bias\" dimension 0 should have same length as sum of Q/K/V hidden sizes');let h=0;if(s){if(p!==f)throw new Error('Input \"past\" expect k_hidden_size == v_hidden_size');if(s.dims.length!==5)throw new Error('Input \"past\" must have 5 dimensions');if(s.dims[0]!==2)throw new Error('Input \"past\" first dimension must be 2');if(s.dims[1]!==u)throw new Error('Input \"past\" second dimension must be batch_size');if(s.dims[2]!==t.numHeads)throw new Error('Input \"past\" third dimension must be num_heads');if(s.dims[4]!==p/t.numHeads)throw new Error('Input \"past\" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(h=s.dims[3])}let b=m+h,y=-1,g=0;if(i)throw new Error(\"Mask not supported\");if(s)throw new Error(\"past is not supported\");return{batchSize:u,sequenceLength:d,pastSequenceLength:h,kvSequenceLength:m,totalSequenceLength:b,maxSequenceLength:y,inputHiddenSize:c,hiddenSize:l,vHiddenSize:f,headSize:Math.floor(l/t.numHeads),vHeadSize:Math.floor(f/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:g,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Wu=(e,t,r,n)=>{let o=ee(n),i=64,s=n/o;s<i?i=1:s/8<64&&(i=Math.ceil(s/8));let a=Math.ceil(n/o/i),u=[{type:t.dataType,data:1/n},{type:12,data:s},{type:12,data:a}],d=X(t.dataType,o),c=le(1,o),l=p=>{let f=A(\"x\",t.dataType,t.dims,o),h=[{name:\"d_inv\",type:le(t.dataType)},{name:\"d_comp\",type:\"u32\"},{name:\"elements_per_thread\",type:\"u32\"}];return`\n  var<workgroup> thread_max: array<f32, ${i}>;\n  var<workgroup> thread_sum: array<f32, ${i}>;\n  ${p.registerUniforms(h).declareVariables(f)}\n  ${p.mainStart([i,1,1])}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = workgroup_id.x * uniforms.d_comp + local_offset;\n\n    var thread_max_vector = ${c}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n      thread_max_vector = max(${c}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(o){case 1:return\"thread_max_vector\";case 2:return\"max(thread_max_vector.x, thread_max_vector.y)\";case 4:return\"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))\";default:throw new Error(`Unsupported components: ${o}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${i}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${c}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n      sum_vector += exp(${c}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(o){case 1:return\"sum_vector\";case 2:return\"sum_vector.x + sum_vector.y\";case 4:return\"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w\";default:throw new Error(`Unsupported components: ${o}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${i}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n        x[offset + i] = ${f.type.value}(uniforms.d_inv);\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n        var f32input = ${c}(x[offset + i]);\n        x[offset + i] = ${f.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n  }`};return{name:\"AttentionProbsSoftmax\",shaderCache:{hint:`${i};${d};${o}`},getShaderSource:l,getRunData:()=>({outputs:[],dispatchGroup:{x:r},programUniforms:u})}},Gu=(e,t,r,n,o,i,s,a)=>{let u=a+i.kvSequenceLength,d=[i.batchSize,i.numHeads,i.sequenceLength,u],c=i.kvNumHeads===void 0&&e.outputCount>1,l=c?[i.batchSize,i.numHeads,u,i.headSize]:void 0,p=s.scale===0?1/Math.sqrt(i.headSize):s.scale,f=ee(i.headSize),m=i.headSize/f,h=12,b={x:Math.ceil(u/h),y:Math.ceil(i.sequenceLength/h),z:i.batchSize*i.numHeads},y=[{type:12,data:i.sequenceLength},{type:12,data:m},{type:12,data:u},{type:12,data:i.numHeads},{type:1,data:p},{type:12,data:a},{type:12,data:i.kvSequenceLength}],g=[\"type\",\"type\"];n&&g.push(\"type\"),o&&g.push(\"type\");let w=[{dims:d,dataType:t.dataType,gpuDataType:0}];c&&w.push({dims:l,dataType:t.dataType,gpuDataType:0});let $=v=>{let x=S(\"q\",t.dataType,t.dims,f),T=S(\"key\",r.dataType,r.dims,f),I=[x,T];if(n){let ne=S(\"past_key\",n.dataType,n.dims,f);I.push(ne)}o&&I.push(S(\"relative_position_bias\",o.dataType,o.dims));let z=A(\"output\",t.dataType,d),P=[z];c&&P.push(A(\"present_key\",t.dataType,l,f));let G=le(1,f),J=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"}];return`\n  const TILE_SIZE = ${h}u;\n\n  var<workgroup> tileQ: array<${x.type.storage}, ${h*h}>;\n  var<workgroup> tileK: array<${x.type.storage}, ${h*h}>;\n  ${v.registerUniforms(J).declareVariables(...I,...P)}\n  ${v.mainStart([h,h,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;\n    ${(()=>n&&c?`\n    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx;\n    let pastKeyOffset = uniforms.past_sequence_length * uniforms.K * headIdx;`:`\n    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;`)()}\n    ${c?\"let presentKeyOffset = headIdx * uniforms.N * uniforms.K;\":\"\"}\n    var value = ${G}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${(()=>n&&c?`\n              if (n + local_id.y < uniforms.past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else {\n                tileK[idx] =\n                         key[kOffset + (n + local_id.y - uniforms.past_sequence_length) * uniforms.K + w + local_id.x];\n              }`:\"tileK[idx] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];\")()}\n      ${c?\"present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\":\"\"}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n        value += ${G}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * uniforms.M * uniforms.N;\n    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(f){case 1:return\"value\";case 2:return\"value.x + value.y\";case 4:return\"value.x + value.y + value.z + value.w\";default:throw new Error(`Unsupported components: ${f}`)}})()};\n        output[outputIdx] = ${z.type.value} (sum * uniforms.alpha) + ${o?\"relative_position_bias[outputIdx]\":\"0.0\"};\n    }\n  }`};return{name:\"AttentionProbs\",shaderCache:{hint:`${f};${o!==void 0};${n!==void 0};${e.outputCount}`,inputDependencies:g},getRunData:()=>({outputs:w,dispatchGroup:b,programUniforms:y}),getShaderSource:$}},Lu=(e,t,r,n,o,i)=>{let s=i+o.kvSequenceLength,a=o.nReps?o.nReps:1,u=o.vHiddenSize*a,d=o.kvNumHeads==null&&e.outputCount>1,c=d?[o.batchSize,o.numHeads,s,o.headSize]:void 0,l=[o.batchSize,o.sequenceLength,u],p=12,f={x:Math.ceil(o.vHeadSize/p),y:Math.ceil(o.sequenceLength/p),z:o.batchSize*o.numHeads},m=[{type:12,data:o.sequenceLength},{type:12,data:s},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:u},{type:12,data:i},{type:12,data:o.kvSequenceLength}],h=n?[\"type\",\"type\",\"type\"]:[\"type\",\"type\"],b=[{dims:l,dataType:t.dataType,gpuDataType:0}];d&&b.push({dims:c,dataType:t.dataType,gpuDataType:0});let y=g=>{let w=S(\"probs\",t.dataType,t.dims),$=S(\"v\",r.dataType,r.dims),v=[w,$];n&&v.push(S(\"past_value\",n.dataType,n.dims));let T=[A(\"output\",t.dataType,l)];d&&T.push(A(\"present_value\",t.dataType,c));let I=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"v_hidden_size\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"}];return`\n  const TILE_SIZE = ${p}u;\n  var<workgroup> tileQ: array<${w.type.value}, ${p*p}>;\n  var<workgroup> tileK: array<${w.type.value}, ${p*p}>;\n  ${g.registerUniforms(I).declareVariables(...v,...T)}\n  ${g.mainStart([p,p,1])}\n   let headIdx = workgroup_id.z;\n   let m = global_id.y;\n   let n = global_id.x;\n\n   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;\n   ${(()=>n&&d?`\n    let pastValueOffset = headIdx * uniforms.N * uniforms.past_sequence_length + n;\n    let vOffset = headIdx * uniforms.N * uniforms.kv_sequence_length + n;\n      `:`\n   let offsetB = headIdx * uniforms.N * uniforms.K + n;\n            `)()}\n    ${d?\"let presentValueOffset = headIdx * uniforms.N * uniforms.K + n;\":\"\"}\n   var value = ${w.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${(()=>n&&d?`\n        if (w + local_id.y < uniforms.past_sequence_length) {\n          tileK[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else {\n          tileK[idx] = v[vOffset + (w + local_id.y - uniforms.past_sequence_length) * uniforms.N];\n        }\n      `:`\n        tileK[idx] = v[offsetB + (w + local_id.y) * uniforms.N];\n      `)()}\n        ${d?\"present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileK[idx];\":\"\"}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + currentBatchHeadNumber * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`};return{name:\"AttentionScore\",shaderCache:{hint:`${n!==void 0};${e.outputCount}`,inputDependencies:h},getRunData:()=>({outputs:b,dispatchGroup:f,programUniforms:m}),getShaderSource:y}},et=(e,t,r,n,o,i,s,a,u,d,c)=>{let l=e.outputCount,p=d.kvNumHeads!==void 0||l>1?d.pastSequenceLength:0,f=p+d.kvSequenceLength,m=d.kvNumHeads===void 0&&l>1&&s?[t,r,s]:[t,r];u&&m.push(u);let h=e.compute(Gu(e,t,r,l>1?s:void 0,u,d,c,p),{inputs:m,outputs:d.kvNumHeads===void 0&&l>1?[-1,1]:[-1]})[0];e.compute(Wu(e,h,d.batchSize*d.numHeads*d.sequenceLength,f),{inputs:[h],outputs:[]});let b=d.kvNumHeads===void 0&&l>1&&a?[h,n,a]:[h,n];e.compute(Lu(e,h,n,l>1&&a?a:void 0,d,p),{inputs:b,outputs:d.kvNumHeads===void 0&&l>1?[0,2]:[0]})},Hu=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],n=t.sequenceLength,o=t.inputHiddenSize,i=t.headSize,s=12,a={x:Math.ceil(t.headSize/s),y:Math.ceil(t.sequenceLength/s),z:t.batchSize*t.numHeads},u=[e.inputs[0],e.inputs[1],e.inputs[2]],d=[{type:12,data:n},{type:12,data:o},{type:12,data:i},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],c=l=>{let p=A(\"output_q\",u[0].dataType,r),f=A(\"output_k\",u[0].dataType,r),m=A(\"output_v\",u[0].dataType,r),h=S(\"input\",u[0].dataType,u[0].dims),b=S(\"weight\",u[1].dataType,u[1].dims),y=S(\"bias\",u[2].dataType,u[2].dims),g=h.type.storage,w=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"ldb\",type:\"u32\"}];return`\n  const TILE_SIZE = ${s}u;\n  var<workgroup> tileInput: array<${g}, ${s*s}>;\n  var<workgroup> tileWeightQ: array<${g}, ${s*s}>;\n  var<workgroup> tileWeightK: array<${g}, ${s*s}>;\n  var<workgroup> tileWeightV: array<${g}, ${s*s}>;\n  ${l.registerUniforms(w).declareVariables(h,b,y,p,f,m)}\n  ${l.mainStart([s,s,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${g}(0);\n    var valueK = ${g}(0);\n    var valueV = ${g}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:\"AttentionPrepare\",shaderCache:{inputDependencies:[\"type\",\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:a,programUniforms:d}),getShaderSource:c},{inputs:u,outputs:[-1,-1,-1]})},Bo=(e,t)=>{let r=Nu(e.inputs,t),[n,o,i]=Hu(e,r);return et(e,n,o,i,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var qu,Fu,Ku,Do,Ro=E(()=>{\"use strict\";_e();R();L();ae();W();qu=(e,t)=>{if(!e||e.length!==5)throw new Error(\"BatchNormalization requires 5 inputs\");let r=(n,o,i)=>{let s=o.length;if(s!==n.length)throw new Error(`${i}: num dimensions != ${s}`);o.forEach((a,u)=>{if(a!==n[u])throw new Error(`${i}: dim[${u}] do not match`)})};if(e[0].dims.length>1){let n=t.format===\"NHWC\"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,n,\"Invalid input scale\"),r(e[2].dims,n,\"Invalid input B\"),r(e[3].dims,n,\"Invalid input mean\"),r(e[4].dims,n,\"Invalid input var\")}else r(e[1].dims,[1],\"Invalid input scale\"),r(e[2].dims,[1],\"Invalid input B\"),r(e[3].dims,[1],\"Invalid input mean\"),r(e[4].dims,[1],\"Invalid input var\")},Fu=(e,t)=>{let{epsilon:r,spatial:n,format:o}=t,i=e[0].dims,s=n?ee(i[i.length-1]):1,a=o===\"NHWC\"&&i.length>1?s:1,u=_.size(i)/s,d=n,c=d?i.length:i,l=S(\"x\",e[0].dataType,e[0].dims,s),p=S(\"scale\",e[1].dataType,e[1].dims,a),f=S(\"bias\",e[2].dataType,e[2].dims,a),m=S(\"inputMean\",e[3].dataType,e[3].dims,a),h=S(\"inputVar\",e[4].dataType,e[4].dims,a),b=A(\"y\",e[0].dataType,c,s),y=()=>{let w=\"\";if(n)w=`let cOffset = ${i.length===1?\"0u\":o===\"NHWC\"?`outputIndices[${i.length-1}] / ${s}`:\"outputIndices[1]\"};`;else if(o===\"NCHW\")w=`\n            ${b.indicesSet(\"outputIndices\",\"0\",\"0\")}\n            let cOffset = ${b.indicesToOffset(\"outputIndices\")};`;else{w=`var cIndices = ${p.type.indices}(0);\n                       cIndices[0] = outputIndices[${i.length-1}];`;for(let $=1;$<p.rank;$++)w+=`cIndices[${$}] = outputIndices[${$}];`;w+=`let cOffset = ${p.indicesToOffset(\"cIndices\")};`}return w},g=w=>`\n  const epsilon = ${r};\n  ${w.registerUniform(\"outputSize\",\"u32\").declareVariables(l,p,f,m,h,b)}\n  ${w.mainStart()}\n  ${w.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n    var outputIndices = ${b.offsetToIndices(`global_idx * ${s}`)};\n    ${y()}\n    let scale = ${p.getByOffset(\"cOffset\")};\n    let bias = ${f.getByOffset(\"cOffset\")};\n    let inputMean = ${m.getByOffset(\"cOffset\")};\n    let inputVar = ${h.getByOffset(\"cOffset\")};\n    let x = ${l.getByOffset(\"global_idx\")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${b.setByOffset(\"global_idx\",\"value\")}\n  }`;return{name:\"BatchNormalization\",shaderCache:{hint:`${t.epsilon}_${t.format}_${n}_${s}`,inputDependencies:d?[\"rank\",\"type\",\"type\",\"type\",\"type\"]:void 0},getShaderSource:g,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d?[{type:12,data:u},...k(i)]:[{type:12,data:u}]})}},Ku=e=>U(e),Do=(e,t)=>{let{inputs:r,outputCount:n}=e,o=Ku({...t,outputCount:n});if(j.webgpu.validateInputContent&&qu(r,o),t.trainingMode)throw new Error(\"BatchNormalization trainingMode is not supported yet.\");e.compute(Fu(r,o))}});var ju,Zu,Mo,Uo=E(()=>{\"use strict\";L();W();ju=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![320,640,1280].includes(e[0].dims[2]))throw new Error(\"number of channels should be 320, 640 or 1280\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Zu=e=>{let t=e[0].dims,r=e[0].dims[2],n=_.size(t)/4,o=e[0].dataType,i=S(\"input\",o,t,4),s=S(\"bias\",o,[r],4),a=S(\"residual\",o,t,4),u=A(\"output\",o,t,4);return{name:\"BiasAdd\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:c=>`\n  const channels = ${r}u / 4;\n  ${c.declareVariables(i,s,a,u)}\n\n  ${c.mainStart()}\n    ${c.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let value = ${i.getByOffset(\"global_idx\")}\n      + ${s.getByOffset(\"global_idx % channels\")} + ${a.getByOffset(\"global_idx\")};\n    ${u.setByOffset(\"global_idx\",\"value\")}\n  }`}},Mo=e=>{ju(e.inputs),e.compute(Zu(e.inputs))}});var Yu,Z,Vo,No,Wo,Go,Lo,Ho,qo,Fo,Ko,Qu,jo,Zo,Yo,Qo,qt,Xo,Ft,Jo,ei,ti,ri,ni,oi,ii,si,ai,ui,di,li,ci,pi,mi,fi,hi,gi,Br,Dr,yi,bi,wi,Kt=E(()=>{\"use strict\";R();L();ae();W();Yu=(e,t,r,n,o,i)=>{let s=Math.ceil(t/4),a=\"\";typeof o==\"string\"?a=`${o}(a)`:a=o(\"a\");let u=S(\"inputData\",r,[s],4),d=A(\"outputData\",n,[s],4);return`\n      ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(u,d)}\n\n  ${i??\"\"}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n\n    let a = ${u.getByOffset(\"global_idx\")};\n    ${d.setByOffset(\"global_idx\",a)}\n  }`},Z=(e,t,r,n,o,i=e.dataType)=>({name:t,shaderCache:{hint:o,inputDependencies:[\"type\"]},getShaderSource:s=>Yu(s,_.size(e.dims),e.dataType,i,r,n),getRunData:s=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(_.size(s[0].dims)/64/4)},programUniforms:[{type:12,data:Math.ceil(_.size(e.dims)/4)}]})}),Vo=e=>{e.compute(Z(e.inputs[0],\"Abs\",\"abs\"))},No=e=>{e.compute(Z(e.inputs[0],\"Acos\",\"acos\"))},Wo=e=>{e.compute(Z(e.inputs[0],\"Acosh\",\"acosh\"))},Go=e=>{e.compute(Z(e.inputs[0],\"Asin\",\"asin\"))},Lo=e=>{e.compute(Z(e.inputs[0],\"Asinh\",\"asinh\"))},Ho=e=>{e.compute(Z(e.inputs[0],\"Atan\",\"atan\"))},qo=e=>{e.compute(Z(e.inputs[0],\"Atanh\",\"atanh\"))},Fo=e=>U(e),Ko=(e,t)=>{let r;switch(t.to){case 10:r=\"vec4<f16>\";break;case 1:r=\"vec4<f32>\";break;case 12:r=\"vec4<u32>\";break;case 6:r=\"vec4<i32>\";break;case 9:r=\"vec4<bool>\";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Z(e.inputs[0],\"Cast\",r,void 0,t.cacheKey,t.to))},Qu=e=>{let t=e.length>=2&&e[1].data!==0?e[1].getFloat32Array()[0]:Vt,r=e.length>=3&&e[2].data!==0?e[2].getFloat32Array()[0]:Nt;return U({min:t,max:r})},jo=(e,t)=>{let r=e.inputs.length===1?t:Qu(e.inputs),n=le(e.inputs[0].dataType);e.compute(Z(e.inputs[0],\"Clip\",o=>`clamp(${o}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${n}> = vec4(${n}(${r.min}));\n    const clip_max_: vec4<${n}> = vec4(${n}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},Zo=e=>{e.compute(Z(e.inputs[0],\"Ceil\",\"ceil\"))},Yo=e=>{e.compute(Z(e.inputs[0],\"Cos\",\"cos\"))},Qo=e=>{e.compute(Z(e.inputs[0],\"Cosh\",\"cosh\"))},qt=e=>U(e),Xo=(e,t)=>{let r=le(e.inputs[0].dataType);e.compute(Z(e.inputs[0],\"Elu\",n=>`elu_vf32(${n})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Ft=(e=\"f32\")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Jo=e=>{let t=le(e.inputs[0].dataType);e.compute(Z(e.inputs[0],\"Erf\",r=>`erf_vf32(${r})`,Ft(t)))},ei=e=>{e.compute(Z(e.inputs[0],\"Exp\",\"exp\"))},ti=e=>{e.compute(Z(e.inputs[0],\"Floor\",\"floor\"))},ri=e=>{let t=le(e.inputs[0].dataType);e.compute(Z(e.inputs[0],\"Gelu\",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Ft(t)))},ni=(e,t)=>{let r=le(e.inputs[0].dataType);e.compute(Z(e.inputs[0],\"LeakyRelu\",n=>`select(leaky_relu_alpha_ * ${n}, ${n}, ${n} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},oi=e=>{e.compute(Z(e.inputs[0],\"Not\",t=>`!${t}`))},ii=e=>{e.compute(Z(e.inputs[0],\"Neg\",t=>`-${t}`))},si=e=>{e.compute(Z(e.inputs[0],\"Reciprocal\",t=>`1.0/${t}`))},ai=e=>{let t=le(e.inputs[0].dataType);e.compute(Z(e.inputs[0],\"Relu\",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},ui=e=>{e.compute(Z(e.inputs[0],\"Sigmoid\",t=>`(1.0 / (1.0 + exp(-${t})))`))},di=e=>U(e),li=(e,t)=>{let r=le(e.inputs[0].dataType);e.compute(Z(e.inputs[0],\"HardSigmoid\",n=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${n} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},ci=e=>{e.compute(Z(e.inputs[0],\"Sin\",\"sin\"))},pi=e=>{e.compute(Z(e.inputs[0],\"Sinh\",\"sinh\"))},mi=e=>{e.compute(Z(e.inputs[0],\"Sqrt\",\"sqrt\"))},fi=e=>{e.compute(Z(e.inputs[0],\"Tan\",\"tan\"))},hi=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,gi=e=>{e.compute(Z(e.inputs[0],\"Tanh\",hi))},Br=(e=\"f32\")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${hi(\"v\")};\n}\n`,Dr=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,yi=e=>{let t=le(e.inputs[0].dataType);e.compute(Z(e.inputs[0],\"FastGelu\",Dr,Br(t),void 0,e.inputs[0].dataType))},bi=(e,t)=>{let r=le(e.inputs[0].dataType);return e.compute(Z(e.inputs[0],\"ThresholdedRelu\",n=>`select(vec4<${r}>(0.0), ${n}, ${n} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},wi=e=>{e.compute(Z(e.inputs[0],\"Log\",\"log\"))}});var Xu,Ju,vi,_i=E(()=>{\"use strict\";L();W();Kt();Xu=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error(\"hidden state should be 2560, 5120 or 10240\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Ju=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=S(\"input\",e[0].dataType,e[0].dims,4),n=S(\"bias\",e[0].dataType,[e[0].dims[2]],4),o=A(\"output\",e[0].dataType,t,4),i=_.size(t)/4,s=X(e[0].dataType);return{name:\"BiasSplitGelu\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:u=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${u.declareVariables(r,n,o)}\n\n  ${Ft(s)}\n\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${o.setByOffset(\"global_idx\",\"valueLeft * geluRight\")}\n  }`}},vi=e=>{Xu(e.inputs),e.compute(Ju(e.inputs))}});var ed,td,De,Si,xi,Ii,Ti,Ci,Ai,Ei,ki,Pi,zi,Oi=E(()=>{\"use strict\";R();L();W();ed=(e,t,r,n,o,i,s,a,u,d,c,l)=>{let p,f;typeof a==\"string\"?p=f=(g,w)=>`${a}((${g}),(${w}))`:typeof a==\"function\"?p=f=a:(p=a.scalar,f=a.vector);let m=A(\"outputData\",c,n.length,4),h=S(\"aData\",u,t.length,4),b=S(\"bData\",d,r.length,4),y;if(o)if(i){let g=_.size(t)===1,w=_.size(r)===1,$=t.length>0&&t[t.length-1]%4===0,v=r.length>0&&r[r.length-1]%4===0;g||w?y=m.setByOffset(\"global_idx\",f(g?`${h.type.value}(${h.getByOffset(\"0\")}.x)`:h.getByOffset(\"global_idx\"),w?`${b.type.value}(${b.getByOffset(\"0\")}.x)`:b.getByOffset(\"global_idx\"))):y=`\n            let outputIndices = ${m.offsetToIndices(\"global_idx * 4u\")};\n            let offsetA = ${h.broadcastedIndicesToOffset(\"outputIndices\",m)};\n            let offsetB = ${b.broadcastedIndicesToOffset(\"outputIndices\",m)};\n            ${m.setByOffset(\"global_idx\",f(s||$?h.getByOffset(\"offsetA / 4u\"):`${h.type.value}(${h.getByOffset(\"offsetA / 4u\")}[offsetA % 4u])`,s||v?b.getByOffset(\"offsetB / 4u\"):`${b.type.value}(${b.getByOffset(\"offsetB / 4u\")}[offsetB % 4u])`))}\n          `}else y=m.setByOffset(\"global_idx\",f(h.getByOffset(\"global_idx\"),b.getByOffset(\"global_idx\")));else{if(!i)throw new Error(\"no necessary to use scalar implementation for element-wise binary op implementation.\");let g=(w,$,v=\"\")=>{let x=`aData[indexA${$}][componentA${$}]`,T=`bData[indexB${$}][componentB${$}]`;return`\n            let outputIndices${$} = ${m.offsetToIndices(`global_idx * 4u + ${$}u`)};\n            let offsetA${$} = ${h.broadcastedIndicesToOffset(`outputIndices${$}`,m)};\n            let offsetB${$} = ${b.broadcastedIndicesToOffset(`outputIndices${$}`,m)};\n            let indexA${$} = offsetA${$} / 4u;\n            let indexB${$} = offsetB${$} / 4u;\n            let componentA${$} = offsetA${$} % 4u;\n            let componentB${$} = offsetB${$} % 4u;\n            ${w}[${$}] = ${v}(${p(x,T)});\n          `};c===9?y=`\n            var data = vec4<u32>(0);\n            ${g(\"data\",0,\"u32\")}\n            ${g(\"data\",1,\"u32\")}\n            ${g(\"data\",2,\"u32\")}\n            ${g(\"data\",3,\"u32\")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:y=`\n            ${g(\"outputData[global_idx]\",0)}\n            ${g(\"outputData[global_idx]\",1)}\n            ${g(\"outputData[global_idx]\",2)}\n            ${g(\"outputData[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(h,b,m)}\n\n        ${l??\"\"}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${y}\n      }`},td=(e,t,r,n,o,i,s=r.dataType)=>{let a=!_.areEqual(r.dims,n.dims),u=r.dims,d=_.size(r.dims),c=!1,l=!1,p=[a];if(a){let f=ke.calcShape(r.dims,n.dims,!1);if(!f)throw new Error(\"Can't perform binary op on the given tensors\");u=f,d=_.size(u);let m=_.size(r.dims)===1,h=_.size(n.dims)===1,b=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,y=n.dims.length>0&&n.dims[n.dims.length-1]%4===0;p.push(m),p.push(h),p.push(b),p.push(y);let g=1;for(let w=1;w<u.length;w++){let $=r.dims[r.dims.length-w]??1,v=n.dims[n.dims.length-w]??1;if($===v)g*=$;else break}g%4===0?(l=!0,c=!0):(m||h||b||y)&&(c=!0)}else c=!0;return p.push(c),{name:e,shaderCache:{hint:t+p.map(f=>f.toString()).join(\"_\"),inputDependencies:[\"rank\",\"rank\"]},getShaderSource:f=>ed(f,r.dims,n.dims,u,c,a,l,o,r.dataType,n.dataType,s,i),getRunData:()=>({outputs:[{dims:u,dataType:s}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:Math.ceil(_.size(u)/4)},...k(r.dims,n.dims,u)]})}},De=(e,t,r,n,o,i)=>{e.compute(td(t,o??\"\",e.inputs[0],e.inputs[1],r,n,i))},Si=e=>{De(e,\"Add\",(t,r)=>`${t}+${r}`)},xi=e=>{De(e,\"Div\",(t,r)=>`${t}/${r}`)},Ii=e=>{De(e,\"Equal\",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Ti=e=>{De(e,\"Mul\",(t,r)=>`${t}*${r}`)},Ci=e=>{let t=S(\"input\",e.inputs[0].dataType,e.inputs[0].dims).type.value;De(e,\"Pow\",{scalar:(n,o)=>`pow_custom(${n},${o})`,vector:(n,o)=>`pow_vector_custom(${n},${o})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t===\"i32\"?\"round\":\"\"}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Ai=e=>{De(e,\"Sub\",(t,r)=>`${t}-${r}`)},Ei=e=>{De(e,\"Greater\",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},ki=e=>{De(e,\"Less\",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Pi=e=>{De(e,\"GreaterOrEqual\",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},zi=e=>{De(e,\"LessOrEqual\",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var nd,od,id,sd,Bi,Di,Ri=E(()=>{\"use strict\";R();L();ae();W();nd=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");let r=0,n=e[r],o=n.dataType,i=n.dims.length;e.forEach((s,a)=>{if(a!==r){if(s.dataType!==o)throw new Error(\"input tensors should be one type\");if(s.dims.length!==i)throw new Error(\"input tensors should have the same shape\");s.dims.forEach((u,d)=>{if(d!==t&&u!==n.dims[d])throw new Error(\"non concat dimensions must match\")})}})},od=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,id=(e,t)=>{let r=e.length,n=[];for(let o=0;o<r;++o){let i=t.setByOffset(\"global_idx\",e[o].getByIndices(\"indices\"));r===1?n.push(i):o===0?n.push(`if (inputIndex == ${o}u) { ${i} }`):o===r-1?n.push(`else { ${i} }`):n.push(`else if (inputIndex == ${o}) { ${i} }`)}return n.join(`\n`)},sd=(e,t,r,n)=>{let o=_.size(r),i=new Array(e.length),s=new Array(e.length),a=0,u=[],d=[],c=[{type:12,data:o}];for(let h=0;h<e.length;++h)a+=e[h].dims[t],i[h]=a,d.push(e[h].dims.length),s[h]=S(`input${h}`,n,d[h]),u.push(\"rank\"),c.push({type:12,data:i[h]});for(let h=0;h<e.length;++h)c.push(...k(e[h].dims));c.push(...k(r));let l=A(\"output\",n,r.length),p=l.indicesGet(\"indices\",t),f=Array.from(Array(i.length).keys()).map(h=>`uniforms.sizeInConcatAxis${h}`).join(\",\"),m=h=>`\n\n  ${(()=>{h.registerUniform(\"outputSize\",\"u32\");for(let b=0;b<e.length;b++)h.registerUniform(`sizeInConcatAxis${b}`,\"u32\");return h.declareVariables(...s,l)})()}\n\n  ${od(i.length,f)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n    var indices = ${l.offsetToIndices(\"global_idx\")};\n\n    let inputIndex = calculateInputIndex(${p});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${i.length}u>(${f});\n      ${p} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${id(s,l)}\n  }`;return{name:\"Concat\",shaderCache:{hint:`${t}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:r,dataType:n}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:c}),getShaderSource:m}},Bi=(e,t)=>{let r=e.inputs,n=r[0].dims,o=_.normalizeAxis(t.axis,n.length);nd(r,o);let i=n.slice();i[o]=r.reduce((a,u)=>a+(u.dims.length>o?u.dims[o]:0),0);let s=r.filter(a=>_.size(a.dims)>0);e.compute(sd(s,o,i,r[0].dataType),{inputs:s})},Di=e=>U({axis:e.axis})});var Ce,Ae,Ee,jt,Ve=E(()=>{\"use strict\";R();L();Ce=(e,t,r=\"f32\")=>{switch(e.activation){case\"Relu\":return`value = max(value, ${t}(0.0));`;case\"Sigmoid\":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case\"Clip\":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case\"HardSigmoid\":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case\"LeakyRelu\":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case\"\":return\"\";default:throw new Error(`Unsupported activation ${e.activation}`)}},Ae=(e,t)=>{e.activation===\"Clip\"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation===\"HardSigmoid\"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation===\"LeakyRelu\"&&t.push({type:1,data:e.alpha})},Ee=(e,t)=>{e.activation===\"Clip\"?t.push({name:\"clip_max\",type:\"f32\"},{name:\"clip_min\",type:\"f32\"}):e.activation===\"HardSigmoid\"?t.push({name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}):e.activation===\"LeakyRelu\"&&t.push({name:\"alpha\",type:\"f32\"})},jt=e=>{let t=e?.activation||\"\";if(t===\"HardSigmoid\"){let[r,n]=e?.activation_params||[.2,.5];return{activation:t,alpha:r,beta:n}}else if(t===\"Clip\"){let[r,n]=e?.activation_params||[Vt,Nt];return{activation:t,clipMax:n,clipMin:r}}else if(t===\"LeakyRelu\"){let[r]=e?.activation_params||[.01];return{activation:t,alpha:r}}return{activation:t}}});var ce,Zt,Yt=E(()=>{\"use strict\";ce=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Zt=e=>`\n      ${e?\"value = value + getBiasByOutputCoords(coords);\":\"\"}\n      `});var Qt,Rr=E(()=>{\"use strict\";Qt=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var ad,ud,dt,Mi,dd,lt,ld,Xt,ct=E(()=>{\"use strict\";R();L();W();Ve();Yt();ad=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `,ud=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?\"\":\"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];\"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached3[i] + acc[i];\"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached.w + acc[i];\"}\n        }`,dt=(e,t,r=\"f32\",n,o=!1,i=32,s=!1,a=32)=>{let u=t[1]*e[1],d=t[0]*e[0],c=o?u:i,l=o?i:u,p=c/t[0],f=i/t[1];if(!((o&&p===4&&e[1]===4||!o&&(p===3||p===4))&&c%t[0]===0&&i%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${p} must be 3 or 4.\n  tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${p}<${r}>, ${c/p}>, ${l}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${d/e[0]}>, ${i}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${p};\nconst tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${s?\"0\":\"i32(globalId.z)\"};\n  ${n?`let batchIndices = ${n.offsetToIndices(\"u32(batch)\")};`:\"\"}\n  let globalRowStart = i32(workgroupId.y) * ${u};\n\n  let num_tiles = ${s?`${Math.ceil(a/i)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n  var kStart = ${s?`i32(globalId.z) * ${a}`:\"0\"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${f};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${ad(o,n)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${n?\", batchIndices\":\"\"});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${p===3?\"\":\"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];\"}\n\n          ${ud(o,p)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Mi=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?\", batchIndices\":\"\"});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?\", batchIndices\":\"\"});\n            `,dd=e=>e?\"let ACached = mm_Asub[k][tileRow + innerRow];\":\"let ACached = mm_Asub[tileRow + innerRow][k];\",lt=(e,t,r=\"f32\",n,o=!1,i=32,s=!1,a=32,u=!1)=>{let d=e[1]*t[1],c=e[0]*t[0],l=o?d:i,p=o?i:d;if(!(p%t[1]===0&&l%t[0]===0&&i%t[1]===0))throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let f=p/t[1],m=l/t[0],h=i/t[1],b=u?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${d};\n    let globalColStart = i32(workgroupId.x) * ${c};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {\n          ${Mi(o,n)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${n?\", batchIndices\":\"\"});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${d};\n\nlet tileRowA = i32(localId.y) * ${f};\nlet tileColA = i32(localId.x) * ${m};\nlet tileRowB = i32(localId.y) * ${h};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${m}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Mi(o,n)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${n?\", batchIndices\":\"\"});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${dd(o)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${l}>, ${p}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${c}>, ${i}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${s?\"0\":\"i32(globalId.z)\"};\n    ${n?`let batchIndices = ${n.offsetToIndices(\"u32(batch)\")};`:\"\"}\n    let num_tiles = ${s?`${Math.ceil(a/i)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n    var kStart = ${s?`i32(globalId.z) * ${a}`:\"0\"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${b}\n  }\n`},ld=(e,t,r,n,o,i=!1)=>{let[s,a,u]=o,[d,c,l,p]=n,f=Je(s,u),m=Je(a,u),h=X(n[0].type.tensor),b=()=>{let w=c.rank,$=d.rank,v=`var aIndices: ${c.type.indices};`;for(let x=w-2-1,T=$-1;x>=0;x--,T--)v+=`\naIndices[${x}] = ${$>1?`batchIndices[${T}]`:\"batchIndices\"};`;return f.forEach(x=>{v+=`\naIndices[${x}] = 0;`}),v+=`\naIndices[${w-2}] = u32(row);\n                   aIndices[${w-1}] = u32(colIn);`,v},y=()=>{let w=l.rank,$=d.rank,v=`var bIndices: ${l.type.indices};`;for(let x=w-2-1,T=$-1;x>=0;x--,T--)v+=`\nbIndices[${x}] = ${$>1?`batchIndices[${T}]`:\"batchIndices\"};`;return m.forEach(x=>{v+=`\nbIndices[${x}] = 0;`}),v+=`\nbIndices[${w-2}] = u32(row);\n                   bIndices[${w-1}] = u32(colIn);`,v};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${d.type.indices}) -> ${ce(e,h)} {\n      var value = ${ce(e,h)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        ${b()}\n        value = ${c.getByIndices(\"aIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${d.type.indices}) -> ${ce(e,h)} {\n      var value = ${ce(e,h)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        ${y()}\n        value = ${l.getByIndices(\"bIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${ce(e,h)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${i?\"bias[colIn]\":`${ce(e,h)}(bias[row])`};`:\"\"}\n        ${r}\n        ${p.setByIndices(\"vec3<u32>(coords)\",\"value\")}\n      }\n    }\n    `},Xt=(e,t,r,n,o=!1)=>{let i=e[0].dims,s=e[1].dims,a=i.slice(0,-2),u=s.slice(0,-2),d=n?n.slice(0,-2):r.slice(0,-2),c=_.size(d),l=i[i.length-2],p=i[i.length-1],f=s[s.length-1],m=p%4===0&&f%4===0,h=l<=8?[4,1,1]:[4,4,1],b=[8,8,1],y=[Math.ceil(f/b[0]/h[0]),Math.ceil(l/b[1]/h[1]),Math.ceil(c/b[2]/h[2])],g=m?4:1,w=[...a,l,p/g],$=w.length,v=[...u,p,f/g],x=v.length,T=[c,l,f/g],I=[{type:6,data:l},{type:6,data:f},{type:6,data:p}];Ae(t,I),I.push(...k(d,w,v));let z=[\"rank\",\"rank\"],P=e.length>2;P&&(I.push(...k(e[2].dims)),z.push(\"rank\")),I.push(...k(T));let G=J=>{let ne=d.length,Q=Wt(\"batchDims\",e[0].dataType,ne,1),se=X(e[0].dataType),O=S(\"a\",e[0].dataType,$,g),Y=S(\"b\",e[1].dataType,x,g),K=A(\"result\",e[0].dataType,T.length,g),q=[O,Y];if(P){let C=o?g:1;q.push(S(\"bias\",e[2].dataType,e[2].dims.length,C))}let M=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"}];Ee(t,M);let H=X(K.type.tensor),V=Ce(t,K.type.value,H),me=ld(g,P,V,[Q,O,Y,K],[a,u,d],o);return`\n  ${J.registerUniforms(M).registerInternalVariables(Q).declareVariables(...q,K)}\n  ${me}\n  ${m?dt(h,b,se,Q):lt(h,b,se,Q)}\n                   `};return{name:\"MatMul\",shaderCache:{hint:`${h};${t.activation};${m};${o}`,inputDependencies:z},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:y[0],y:y[1],z:y[2]},programUniforms:I}),getShaderSource:G}}});var cd,Ui,Vi=E(()=>{\"use strict\";R();Me();W();Ve();Yt();Rr();ct();cd=(e,t,r,n,o=!1,i,s=4,a=4,u=4,d=\"f32\")=>{let c=P=>{switch(P){case 1:return\"resData = x[xIndex];\";case 3:return`resData = vec3<${d}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return\"resData = x[xIndex / 4];\";default:throw new Error(`innerElementSize ${P} is not supported.`)}},l=P=>{switch(P){case 1:return\"return w[row * i32(uniforms.w_shape[3]) + colIn];\";case 4:return\"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];\";default:throw new Error(`innerElementSize ${P} is not supported.`)}},p=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,f=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,m=e?\"i32(uniforms.x_shape[1])\":\"i32(uniforms.x_shape[2])\",h=e?\"i32(uniforms.x_shape[2])\":\"i32(uniforms.x_shape[3])\",b=e?\"row\":\"col\",y=e?\"col\":\"row\",g=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n    let outRow = ${b} / outWidth;\n    let outCol = ${b} % outWidth;\n\n    let WRow = ${y} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${y} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${y} % inChannels;\n    var resData = ${ce(s,d)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${m} && xCol >= 0 && xCol < ${h}) {\n      ${p}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${c(s)}\n    }\n    return resData;`,w=e?t&&n?`\n    let col = colIn * ${s};\n    ${g}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${g}\n    }\n    return ${ce(s,d)}(0.0);`:n&&r?`\n    let col = colIn * ${s};\n    ${g}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${g}\n    }\n    return ${ce(s,d)}(0.0);`,$=`${l(a)}`,v=ce(u,d),x=e?ce(s,d):ce(a,d),T=e?ce(a,d):ce(s,d),I=Ce(i,v,d);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${x} {\n      ${e?w:$}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${T} {\n      ${e?$:w}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${v}) {\n      let col = colIn * ${u};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n      ${f}\n      ${Zt(o)}\n      ${I}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Ui=(e,t,r,n,o,i,s,a)=>{let u=t.format===\"NHWC\",d=u?e[0].dims[3]:e[0].dims[1],c=r[0],l=u?r[2]:r[3],p=u?r[1]:r[2],f=u?r[3]:r[1],m=u&&(d%4===0||d%3===0)&&f%4===0,h=u?f:l*p,b=u?l*p:f,y=[8,8,1],g=n<=8?[4,1,1]:[4,4,1],w=[Math.ceil(h/y[0]/g[0]),Math.ceil(b/y[1]/g[1]),Math.ceil(c/y[2]/g[2])];re(\"verbose\",()=>`[conv2d_mm_webgpu] dispatch = ${w}`);let $=m?u&&d%4!==0?3:4:1,v=y[1]*g[1],x=y[0]*g[0],T=Math.max(y[0]*$,y[1]),I=n%v===0,z=o%x===0,P=i%T===0,G=m?[$,4,4]:[1,1,1],J=[{type:6,data:n},{type:6,data:o},{type:6,data:i},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Ae(t,J),J.push(...k(e[0].dims,e[1].dims));let ne=[\"rank\",\"rank\"];s&&(J.push(...k(e[2].dims)),ne.push(\"rank\")),J.push(...k(r));let Q=se=>{let O=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"},{name:\"pad\",type:\"i32\",length:2},{name:\"stride\",type:\"i32\",length:2},{name:\"dilation\",type:\"i32\",length:2}];Ee(t,O);let Y=m?4:1,K=X(e[0].dataType),q=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${m?`vec4<${K}>`:K}) {\n        result[flatIndex] = ${m?`vec4<${K}>`:K}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${m?`vec4<${K}>`:K}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${m?\"/ 4\":\"\"}, value);\n      }`,M=S(\"x\",e[0].dataType,e[0].dims.length,$===3?1:$),H=S(\"w\",e[1].dataType,e[1].dims.length,Y),V=[M,H],me=A(\"result\",e[0].dataType,r.length,Y);if(s){let C=S(\"bias\",e[2].dataType,e[2].dims.length,Y);V.push(C),q+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${m?`vec4<${K}>`:K} {\n          return bias[coords.${u?\"w\":\"y\"}${m?\"/ 4\":\"\"}];\n        }`}return`\n        ${Qt(\"uniforms.result_strides\")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${se.registerUniforms(O).declareVariables(...V,me)}\n        ${q}\n        ${cd(u,I,z,P,s,t,G[0],G[1],G[2],K)}\n        ${m?dt(g,y,K,void 0,!u,T):lt(g,y,K,void 0,!u,T,!1,void 0,a)}`};return{name:\"Conv2DMatMul\",shaderCache:{hint:`${t.cacheKey};${$};${m};${I};${z};${P};${v};${x};${T}`,inputDependencies:ne},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:J}),getShaderSource:Q}}});var Mr,Ni,Wi=E(()=>{\"use strict\";R();L();W();Ur();Ve();Mr=(e,t,r)=>{let n=e.length>2,o=n?\"value += b[output_channel];\":\"\",i=e[0].dims,s=e[1].dims,a=s[0]/t.group,u=t.format===\"NHWC\",d=Jt(i,s,t.dilations,t.pads,t.strides,u),c=_.size(d),l=[{type:12,data:c},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:a}];Ae(t,l),l.push(...k(i,s));let p=[\"rank\",\"rank\"];n&&(l.push(...k(e[2].dims)),p.push(\"rank\")),l.push(...k(d));let f=m=>{let h=A(\"output\",e[0].dataType,d.length),b=X(h.type.tensor),y=Ce(t,h.type.value,b),g=S(\"x\",e[0].dataType,i.length),w=S(\"w\",e[1].dataType,s.length),$=[g,w];n&&$.push(S(\"b\",e[2].dataType,e[2].dims.length));let v=[{name:\"output_size\",type:\"u32\"},{name:\"dilations\",type:\"u32\",length:t.dilations.length},{name:\"strides\",type:\"u32\",length:2},{name:\"pads\",type:\"u32\",length:2},{name:\"output_channels_per_group\",type:\"u32\"}];return Ee(t,v),`\n  ${m.registerUniforms(v).declareVariables(...$,h)}\n\n  ${m.mainStart()}\n    ${m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let outputIndices = ${h.offsetToIndices(\"global_idx\")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${u?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${u?1:2}], outputIndices[${u?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel / uniforms.output_channels_per_group;\n\n    var value: ${h.type.value} = ${h.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[${u?1:2}]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[${u?2:3}]) {\n            continue;\n          }\n\n          let xVal = ${u?g.get(\"batch\",\"xHeight\",\"xWidth\",\"input_channel\"):g.get(\"batch\",\"input_channel\",\"xHeight\",\"xWidth\")};\n          let wVal = ${w.get(\"output_channel\",\"wInChannel\",\"wHeight\",\"wWidth\")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${o}\n    ${y}\n    ${h.setByOffset(\"global_idx\",\"value\")}\n  }`};return{name:\"GroupedConv\",shaderCache:{hint:t.cacheKey,inputDependencies:p},getRunData:()=>({outputs:[{dims:r?r(d):d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:l}),getShaderSource:f}},Ni=(e,t,r)=>{let n=e.length>2,o=ee(r[3]),i=ee(r[2]),s=_.size(r)/o/i,a=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/o],u=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/o],d=[r[0],r[1],r[2],r[3]/o],c=[{type:12,data:s},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Ae(t,c),c.push(...k(a,u,d));let l=(i-1)*t.strides[1]+u[1],p=f=>{let m=A(\"output\",e[0].dataType,d.length,o),h=X(m.type.tensor),b=Ce(t,m.type.value,h),y=S(\"x\",e[0].dataType,a.length,o),g=S(\"w\",e[1].dataType,u.length,o),w=[y,g];n&&w.push(S(\"b\",e[2].dataType,e[2].dims,o));let $=n?\"value += b[output_channel];\":\"\",v=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"i32\",length:2},{name:\"pads\",type:\"i32\",length:2}];return Ee(t,v),`\n  ${f.registerUniforms(v).declareVariables(...w,m)}\n  ${f.mainStart()}\n    ${f.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${i}u;\n    let col = (index1 % width1) * ${i}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${y.type.value}, ${l}>;\n    var values: array<${m.type.value}, ${i}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${l}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${y.get(\"batch\",\"u32(x_height)\",\"u32(x_width)\",\"input_channel\")};\n          } else {\n            x_vals[i] = ${y.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {\n          let w_val = ${g.get(\"w_height\",\"w_width\",\"0\",\"output_channel\")};\n          for (var i = 0u; i < ${i}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${i}u; i++) {\n      var value = values[i];\n      ${$}\n      ${b}\n      ${m.set(\"batch\",\"row\",\"col + i\",\"output_channel\",\"value\")};\n    }\n  }`};return{name:\"GroupedConv-Vectorize\",shaderCache:{hint:`${t.cacheKey};${o};${i};${l};${u[0]};${u[1]}`,inputDependencies:n?[\"rank\",\"rank\",\"type\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:c}),getShaderSource:p}}});var Vr,pd,Gi,Nr=E(()=>{\"use strict\";R();L();ct();W();Ve();Vr=(e,t,r,n,o=!1)=>{let i=e[0].dims,s=e[1].dims,a=i[i.length-2],u=s[s.length-1],d=i[i.length-1],c=ee(u),l=ee(d),p=ee(a),f=_.size(r)/c/p,m=e.length>2,h=n?n.slice(0,-2):r.slice(0,-2),y=[_.size(h),a,u],g=[{type:12,data:f},{type:12,data:a},{type:12,data:u},{type:12,data:d}];Ae(t,g),g.push(...k(h,i,s)),m&&g.push(...k(e[2].dims)),g.push(...k(y));let w=$=>{let v=Wt(\"batch_dims\",e[0].dataType,h.length),x=S(\"a\",e[0].dataType,i.length,l),T=S(\"b\",e[1].dataType,s.length,c),I=A(\"output\",e[0].dataType,y.length,c),z=X(I.type.tensor),P=Ce(t,I.type.value,z),G=[x,T],J=\"\";if(m){let M=o?c:1;G.push(S(\"bias\",e[2].dataType,e[2].dims.length,M)),J=`${o?`value += bias[col / ${M}];`:`value += ${I.type.value}(bias[row + i]);`}`}let ne=i.slice(0,-2),Q=s.slice(0,-2),se=Je(ne,h),O=Je(Q,h),Y=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"}];Ee(t,Y);let K=(M,H)=>{let V=M.rank,me=M.name;if(V===2)return`var ${me}_indices = ${M.type.indices}(0u, 0u);`;let C=v.rank,B=`var ${me}_indices: ${M.type.indices};`;for(let F=V-2-1,Ie=C-1;F>=0;F--,Ie--)B+=`\n${me}_indices[${F}] = ${C>1?`batch_indices[${Ie}]`:\"batch_indices\"};`;return H.forEach(F=>{B+=`\n${me}_indices[${F}] = 0;`}),B+=`${me}_indices[${V-2}] = 0u;\n                     ${me}_indices[${V-1}] = 0u;`,B},q=()=>{let M=`var a_data: ${x.type.value};`;for(let H=0;H<l;H++)M+=`\n              let b_data${H} = b[(b_offset + (k + ${H}) * uniforms.N + col) / ${c}];`;for(let H=0;H<p;H++){M+=`a_data = a[(a_offset + (row + ${H}) * uniforms.K + k) / ${l}];`;for(let V=0;V<l;V++)M+=`\n            values[${H}] = fma(${T.type.value}(a_data${l===1?\"\":`[${V}]`}), b_data${V}, values[${H}]);\n`}return M};return`\n  ${$.registerUniforms(Y).registerInternalVariables(v).declareVariables(...G,I)}\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let col = (global_idx % (uniforms.N / ${c})) * ${c};\n    var index1 = global_idx / (uniforms.N / ${c});\n    let stride1 = uniforms.M / ${p};\n    let row = (index1 % stride1) * ${p};\n    let batch = index1 / stride1;\n\n    ${r.length===2?\"\":`let batch_indices = ${v.offsetToIndices(\"batch\")};`}\n    ${K(x,se)}\n    let a_offset = ${x.indicesToOffset(\"a_indices\")};\n    ${K(T,O)}\n    let b_offset = ${T.indicesToOffset(\"b_indices\")};\n    var values: array<${I.type.value}, ${p}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${l}) {\n      ${q()}\n    }\n    for (var i = 0u; i < ${p}u; i++) {\n      var value = values[i];\n      ${J}\n      ${P}\n      let cur_indices = ${I.type.indices}(batch, row + i, col);\n      let offset = ${I.indicesToOffset(\"cur_indices\")};\n      ${I.setByOffset(`offset / ${c}`,\"value\")};\n    }\n  }\n  `};return{name:\"MatMulNaive\",shaderCache:{hint:`${t.activation};${c};${l};${p};${o}`,inputDependencies:m?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:g}),getShaderSource:w}},pd=e=>{if(!e||e.length!==2)throw new Error(\"MatMul requires 2 inputs.\");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error(\"shared dimension does not match.\")},Gi=e=>{pd(e.inputs);let t=ke.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error(\"Can't use matmul on the given tensors\");let r=t[t.length-1],n=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&n<8?e.compute(Vr(e.inputs,{activation:\"\"},t)):e.compute(Xt(e.inputs,{activation:\"\"},t))}});var Jt,Wr,md,Li,Gr,fd,hd,Lr,Ur=E(()=>{\"use strict\";L();Vi();ct();Wi();Ve();Nr();Ze();Jt=(e,t,r,n,o,i)=>{let s=e[0],a=e.slice(i?1:2,i?3:4),u=a.length,d=t[0],l=t.slice(2).map((m,h)=>m+(m-1)*(r[h]-1)),f=a.map((m,h)=>m+n[h]+n[h+u]).map((m,h)=>Math.floor((m-l[h]+o[h])/o[h]));return f.splice(0,0,s),f.splice(i?3:1,0,d),f},Wr=[2,3,1,0],md=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error(\"currently only support conv 1D and 2D\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let r=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],n=e[1].dims[1]*t.group;if(r!==n)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error(\"invalid bias\");let o=e[0].dims.length-2;if(t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\")},Li=(e,t)=>{let r=e.kernelShape.slice();for(let i=2;i<t[1].dims.length;++i)r[i-2]===0&&(r[i-2]=t[1].dims[i]);let n=e.pads.slice();Fe.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,n,e.format===\"NHWC\",e.autoPad);let o=Object.assign({},e);return Object.assign(o,{kernelShape:r,pads:n}),o},Gr=e=>{let t=jt(e),r=e.format,n=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],o=e.dilations,i=e.group,s=e.kernel_shape,a=e.pads,u=e.strides,d=e.w_is_const();return{autoPad:n,format:r,dilations:o,group:i,kernelShape:s,pads:a,strides:u,wIsConst:d,...t,cacheKey:`${e.format};${t.activation};`}},fd=(e,t,r)=>{let n=Li(r,t),o=r.format===\"NHWC\";if(r.group!==1){if(!e.adapterInfo.isArchitecture(\"ampere\")&&o&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1){let T=Jt(t[0].dims,t[1].dims,r.dilations,n.pads,r.strides,o),I=e.kernelCustomData.wT??e.compute(ge(t[1],Wr),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let z=[t[0],I];t.length===3&&z.push(t[2]),e.compute(Ni(z,n,T),{inputs:z})}else e.compute(Mr(t,n));return}let i=t.length===3,s=t[0].dims[o?1:2],a=t[0].dims[o?2:3],u=t[0].dims[o?3:1],d=t[1].dims[2],c=t[1].dims[3],l=Jt(t[0].dims,t[1].dims,r.dilations,n.pads,r.strides,o),p=l[o?1:2],f=l[o?2:3],m=l[o?3:1],h=o&&d===s&&c===a&&r.pads[0]===0&&r.pads[1]===0;if(h||d===1&&c===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let x=l[0],T,I,z,P=[];if(o){let ne=e.kernelCustomData.wT??e.compute(ge(t[1],Wr),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=ne),h){let Q=s*a*u;T=t[0].reshape([1,x,Q]),I=ne.reshape([1,Q,m]),z=[1,x,m]}else T=t[0].reshape([x,s*a,u]),I=ne.reshape([1,u,m]),z=[x,p*f,m];P.push(T),P.push(I)}else T=t[0].reshape([x,u,s*a]),I=t[1].reshape([1,m,u]),z=[x,m,p*f],P.push(I),P.push(T);i&&P.push(t[2]);let G=z[2],J=P[0].dims[P[0].dims.length-1];G<8&&J<8?e.compute(Vr(P,n,l,z,o),{inputs:P}):e.compute(Xt(P,n,l,z,o),{inputs:P});return}let b=!0,y=e.kernelCustomData.wT??e.compute(ge(t[1],Wr),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=y);let g=[t[0],y];i&&g.push(t[2]);let w=o?p*f:m,$=o?m:p*f,v=d*c*u;e.compute(Ui(g,n,l,w,$,v,i,b),{inputs:g})},hd=(e,t)=>{let r=t.format===\"NHWC\",n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&n.push(e.inputs[2]);let o=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),s=[1].concat(t.dilations),a=[1].concat(t.kernelShape),u=Li({...t,pads:o,strides:i,dilations:s,kernelShape:a},n);e.compute(Mr(n,u,d=>r?[d[0],d[2],d[3]]:[]))},Lr=(e,t)=>{md(e.inputs,t),e.inputs[0].dims.length===3?hd(e,t):fd(e,e.inputs,t)}});var gd,Hi,qi=E(()=>{\"use strict\";R();Me();W();Ve();Yt();Rr();ct();gd=(e,t=!1,r,n,o=4)=>{let i=y=>{switch(y){case 1:return\"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return ${n}(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${y} is not supported.`)}},s=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,a=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,u=e?\"i32(uniforms.x_shape[1])\":\"i32(uniforms.x_shape[2])\",d=e?\"i32(uniforms.x_shape[2])\":\"i32(uniforms.x_shape[3])\",c=e?\"row\":\"col\",l=e?\"col\":\"row\",p=`\n      let inChannels = ${e?\"i32(uniforms.x_shape[3])\":\"i32(uniforms.x_shape[1])\"};\n      let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n      let outRow = ${c} / outWidth;\n      let outCol = ${c} % outWidth;\n\n      let WRow = ${l} / (uniforms.filter_dims[1] * inChannels);\n      let WCol = ${l} / inChannels % uniforms.filter_dims[1];\n      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(${u}) || fract(xR) > 0.0) {\n        return ${n}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${d}) || fract(xC) > 0.0) {\n        return ${n}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${l} % inChannels;\n      ${s}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${o}];`,f=e?`\n      let col = colIn * ${o};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n        ${p}\n      }\n      return ${n}(0.0);`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n        ${p}\n      }\n      return ${n}(0.0);`,m=`\n      let col = colIn * ${o};\n      let inChannels = ${e?\"i32(uniforms.x_shape[3])\":\"i32(uniforms.x_shape[1])\"};\n      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);\n      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];\n      if (${e?\"row < uniforms.dim_inner && col < uniforms.dim_b_outer\":\"row < uniforms.dim_inner && col < uniforms.dim_a_outer\"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${i(o)}\n      }\n      return ${n}(0.0);\n      `,h=Ce(r,n);return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${n} {\n    ${e?f:m}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${n} {\n    ${e?m:f}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${n}) {\n    let col = colIn * ${o};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n      var value = valueInput;\n      let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n      ${a}\n      ${Zt(t)}\n      ${h}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${o}] = value;\n    }\n  }`},Hi=(e,t,r,n,o,i,s,a)=>{let u=t.format===\"NHWC\",d=u?e[0].dims[3]:e[0].dims[1],c=r[0],l=u?r[2]:r[3],p=u?r[1]:r[2],f=u?r[3]:r[1],m=u&&d%4===0&&d%3&&f%4===0,h=u?f:l*p,b=u?l*p:f,y=[8,8,1],g=n<=8?[4,1,1]:[4,4,1],w=[Math.ceil(h/y[0]/g[0]),Math.ceil(b/y[1]/g[1]),Math.ceil(c/y[2]/g[2])];re(\"verbose\",()=>`[conv_backprop_mm_webgpu] dispatch = ${w}`);let $=m?4:1,v=Math.max(y[0]*$,y[1]),x=m?4:1,T=[t.kernelShape[u?1:2],t.kernelShape[u?2:3]],I=[T[0]+(t.dilations[0]<=1?0:(T[0]-1)*(t.dilations[0]-1)),T[1]+(t.dilations[1]<=1?0:(T[1]-1)*(t.dilations[1]-1))],z=[I[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),I[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],P=[{type:6,data:n},{type:6,data:o},{type:6,data:i},{type:6,data:t.strides},{type:6,data:t.dilations},{type:6,data:T},{type:6,data:z}];Ae(t,P),P.push(...k(e[0].dims,e[1].dims));let G=[\"rank\",\"rank\"];s&&(P.push(...k(e[2].dims)),G.push(\"rank\")),P.push(...k(r));let J=ne=>{let Q=S(\"x\",e[0].dataType,e[0].dims.length,x),se=S(\"w\",e[1].dataType,e[1].dims.length,1),O=A(\"result\",e[0].dataType,r.length,x),Y=[Q,se],K=\"\";if(s){let H=S(\"bias\",e[2].dataType,e[2].dims.length,x);Y.push(H),K+=`\n          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${H.type.value} {\n            return bias[coords.${u?\"w\":\"y\"}${m?\"/ 4\":\"\"}];\n          }`}let q=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"},{name:\"strides\",type:\"i32\",length:2},{name:\"dilations\",type:\"i32\",length:2},{name:\"filter_dims\",type:\"i32\",length:T.length},{name:\"pads\",type:\"i32\",length:z.length}];Ee(t,q);let M=X(e[0].dataType,1);if(M!==\"f16\"&&M!==\"f32\")throw new Error(`elemType ${M} is not supported.`);return`\n        ${Qt(\"uniforms.result_strides\")}\n        ${ne.registerUniforms(q).declareVariables(...Y,O)};\n        ${K}\n        ${gd(u,s,t,Q.type.value,$)}\n        ${m?dt(g,y,M,void 0,!u,v):lt(g,y,M,void 0,!u,v,!1,void 0,a)}`};return{name:\"Conv2DTransposeMatMul\",shaderCache:{hint:`${t.cacheKey};${g};${y};${m}`,inputDependencies:G},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:P}),getShaderSource:J}}});var yd,Hr,Fi=E(()=>{\"use strict\";R();Me();L();W();yd=(e,t,r,n,o,i=!1,s,a,u=!1)=>{let d=u?1:2,c=u?2:3,l=u?3:1,p=i?2:1,f=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${i?`vec4<${s}>`:s}) {\n    result[flatIndex] = ${i?`vec4<${s}>`:s}(value);\n  }`;n&&(f+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${i?`vec4<${s}>`:s} {\n      return bias[coords.${u?\"w\":\"y\"}${i?\"/ 4\":\"\"}];\n    }`);let m=i?4:1,h=S(\"W\",t[1].dataType,t[1].dims.length,m),b=S(\"Dy\",t[0].dataType,t[0].dims.length,m),y=[b,h];n&&y.push(S(\"bias\",t[2].dataType,[r[l]].length,m));let g=A(\"result\",t[0].dataType,r.length,m),w=`{\n        let batch: u32 = ${o?\"global_id.z\":\"workgroup_id.z\"} / uniforms.result_shape[1];\n        let r = ${o?\"global_id.z\":\"workgroup_id.z\"} % uniforms.result_shape[1];\n        let c = ${o?\"global_id.y\":\"workgroup_id.y\"} * ${p};\n        let d1: u32 = ${o?\"global_id.x\":\"workgroup_id.x\"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${s}>, ${p}>;\n        for (var i = 0; i < ${p}; i++) {\n          dotProd[i] = vec4<${s}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {\n          var dyR = (${s}(dyCorner.x) + ${s}(wR)) / ${s}(uniforms.strides.x);\n          let wRPerm = uniforms.filter_dims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${s}(uniforms.Dy_shape[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {\n            let dyC = (${s}(dyCorner.y) + ${s}(wC)) / ${s}(uniforms.strides.y);\n            let dyC2 = (${s}(dyCorner.y) + 1.0 + ${s}(wC)) / ${s}(uniforms.strides.y);\n            let wCPerm = uniforms.filter_dims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${s}(uniforms.Dy_shape[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${s}(uniforms.Dy_shape[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1\",\"d2\")};\n                let wValue1 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1 + 1\",\"d2\")};\n                let wValue2 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1 + 2\",\"d2\")};\n                let wValue3 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1 + 3\",\"d2\")};\n\n                var xValue = ${b.get(\"batch\",\"idyR\",\"idyC\",\"d2\")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${b.get(\"batch\",\"idyR\",\"idyC2\",\"d2\")};\n\n                dotProd[1] = dotProd[1] + vec4<${s}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = uniforms.Dy_shape[${l}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1\",\"d2\")};\n                let wValue1 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1 + 1\",\"d2\")};\n                let wValue2 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1 + 2\",\"d2\")};\n                let wValue3 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1 + 3\",\"d2\")};\n\n                var xValue = ${b.get(\"batch\",\"idyR\",\"idyC\",\"d2\")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1\",\"d2\")};\n                let wValue1 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1 + 1\",\"d2\")};\n                let wValue2 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1 + 2\",\"d2\")};\n                let wValue3 = ${h.get(\"u32(wRPerm)\",\"u32(wCPerm)\",\"d1 + 3\",\"d2\")};\n\n                var xValue = ${b.get(\"batch\",\"idyR\",\"idyC2\",\"d2\")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${p}; i = i + 1) {\n          let value = dotProd[i] + ${n?\"bias[c+i]\":`vec4<${s}>(0.0)`};\n          ${g.set(\"batch\",\"r\",\"c + i\",\"d1\",\"value\")};\n        }\n      }`,$=`\n          let outputIndices = ${g.offsetToIndices(\"global_idx\")};\n          let batch = ${g.indicesGet(\"outputIndices\",0)};\n          let d1 = ${g.indicesGet(\"outputIndices\",l)};\n          let r = ${g.indicesGet(\"outputIndices\",d)};\n          let c = ${g.indicesGet(\"outputIndices\",c)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / uniforms.output_channels_per_group;\n          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = ${s}(0.0);\n          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n            if (wR % uniforms.dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${s}(dyRCorner) + ${s}(wR)) / ${s}(uniforms.strides[0]);\n            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n            if (dyR < 0.0 || dyR >= ${s}(uniforms.Dy_shape[${d}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n              if (wC % uniforms.dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${s}(dyCCorner) + ${s}(wC)) / ${s}(uniforms.strides.y);\n              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n              if (dyC < 0.0 || dyC >= ${s}(uniforms.Dy_shape[${c}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * uniforms.input_channels_per_group;\n              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {\n                let xValue = ${u?b.get(\"batch\",\"idyR\",\"idyC\",\"inputChannel\"):b.get(\"batch\",\"inputChannel\",\"idyR\",\"idyC\")};\n                let wValue = ${h.get(\"inputChannel\",\"wOutChannel\",\"u32(wRPerm)\",\"u32(wCPerm)\")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${n?\"bias[d1]\":`${s}(0.0)`};\n          ${g.setByOffset(\"global_idx\",\"value\")};\n        `;return`\n  ${e.registerUniforms(a).declareVariables(...y,g)}\n  ${f}\n\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")};\n  ${i?w:$}}`},Hr=(e,t,r)=>{let n=e.length>2,o=t.outputShape,i=_.size(o),s=[Math.ceil(i/64),1,1];re(\"verbose\",()=>`[conv2d_backprop_webgpu] dispatch = ${s}`);let a=t.format===\"NHWC\",u=[\"rank\",\"rank\"],d=[t.strides[0],t.strides[1]],c=[t.kernelShape[a?1:2],t.kernelShape[a?2:3]],l=[t.dilations[0],t.dilations[1]],p=[c[0]+(t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)),c[1]+(t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1))],f=[p[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),p[1]-1-Math.floor(t.pads[1]+t.pads[3])/2],m=!1,h=t.group,b=e[1].dims,y=b[0]/h,g=b[1],w=[{type:12,data:i},{type:12,data:d},{type:12,data:c},{type:12,data:l},{type:12,data:p},{type:6,data:f},{type:12,data:y},{type:12,data:g},...k(e[0].dims,e[1].dims)];n&&(w.push(...k(e[2].dims)),u.push(\"rank\")),w.push(...k(o));let $=s[1]===1&&s[2]===1,v=x=>{let T=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"u32\",length:d.length},{name:\"filter_dims\",type:\"u32\",length:c.length},{name:\"dilations\",type:\"u32\",length:c.length},{name:\"effective_filter_dims\",type:\"u32\",length:p.length},{name:\"pads\",type:\"i32\",length:f.length},{name:\"input_channels_per_group\",type:\"u32\"},{name:\"output_channels_per_group\",type:\"u32\"}],I=X(e[0].dataType);return`${yd(x,e,o,n,$,m,I,T,a)}`};return{name:\"ConvTranspose2D\",shaderCache:{hint:`${t.cacheKey};`,inputDependencies:u},getRunData:()=>({dispatchGroup:{x:s[0],y:s[1],z:s[2]},outputs:[{dims:r?r(o):o,dataType:e[0].dataType}],programUniforms:w}),getShaderSource:v}}});var bd,wd,$d,Ki,ji,vd,_d,Sd,xd,Zi,Yi=E(()=>{\"use strict\";qi();Fi();Ve();Ze();bd=(e,t,r,n,o,i)=>(e-1)*t+r+(n-1)*o+1-i,wd=(e,t,r,n,o)=>{let i=Math.floor(e/2);t===\"SAME_UPPER\"?(r[n]=i,r[o]=e-i):t===\"SAME_LOWER\"&&(r[n]=e-i,r[o]=i)},$d=(e,t,r,n,o,i,s,a,u,d)=>{let c=e.length-2,l=d.length===0;if(u.length===0)for(let m=0;m<c;++m)u.push(0);let p=e[0],f=t[a?3:1]*o;for(let m=0,h=e.length-c-(a?1:0);m<c;++m,++h){let b=e[h],y=l?b*s[m]:d[m],g=bd(b,s[m],i[m],t[h],r[m],y);wd(g,n,i,m,m+c),l&&d.push(s[m]*(b-1)+u[m]+(t[h]-1)*r[m]+1-i[m]-i[m+c])}d.splice(0,0,p),d.splice(a?3:1,0,f)},Ki=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((l,p)=>l*p,1)===0){r.length=0;for(let l=2;l<t[1].dims.length;++l)r.push(t[1].dims[l])}let n=e.format===\"NHWC\";r.splice(0,0,t[1].dims[0]),r.splice(n?3:1,0,t[1].dims[1]);let o=e.pads.slice(),i=e.outputShape.slice(),s=e.outputPadding.slice(),a=t[0].dims,u=e.dilations.slice();if(u.reduce((l,p)=>l+p,0)===0){let l=t[0].dims.length-2;u=new Array(l).fill(1)}let d=e.strides.slice();if(d.reduce((l,p)=>l+p,0)===0){let l=t[0].dims.length-2;d=new Array(l).fill(1)}$d(a,r,u,e.autoPad,e.group,o,d,n,s,i);let c=Object.assign({},e);return Object.assign(c,{kernelShape:r,pads:o,outputPadding:s,outputShape:i,dilations:u,strides:d}),c},ji=e=>{let t=jt(e),r=e.format,n=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][typeof e.autoPad>\"u\"?0:e.autoPad],o=e.dilations,i=e.group,s=e.kernelShape,a=e.pads,u=e.strides,d=e.wIsConst(),c=e.outputPadding,l=e.outputShape;return{autoPad:n,format:r,dilations:o,group:i,kernelShape:s,outputPadding:c,outputShape:l,pads:a,strides:u,wIsConst:d,...t,cacheKey:`${e.format};${t.activation};`}},vd=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error(\"currently only support 2-dimensional conv\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let r=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],n=e[1].dims[0];if(r!==n)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");let o=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==o))throw new Error(\"invalid bias\");let i=e[0].dims.length-2;if(t.dilations.reduce((c,l)=>c+l,0)>0&&t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.reduce((c,l)=>c+l,0)>0&&t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.reduce((c,l)=>c+l,0)>0&&t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.outputPadding.length!==i&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${i}D`);if(t.kernelShape.reduce((c,l)=>c+l,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error(\"invalid output shape\")},_d=[2,3,1,0],Sd=(e,t,r)=>{let n=Ki(r,t),o=r.format===\"NHWC\",i=n.outputShape,s=i[o?3:1],a=t[0].dims[o?3:1];if(n.group!==1||s===1&&a===1){e.compute(Hr(t,n));return}let u=i[o?1:2],d=i[o?2:3],c=t[1].dims[2],l=t[1].dims[3],p=o?u*d:s,f=o?s:u*d,m=c*l*a,h=!0,b=e.kernelCustomData.wT??e.compute(ge(t[1],_d),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=b);let y=[t[0],b],g=t.length===3;g&&(!o&&t[2].dims.length===1?y.push(t[2].reshape([t[2].dims[0],1,1])):y.push(t[2])),e.compute(Hi(y,n,i,p,f,m,g,h),{inputs:y})},xd=(e,t)=>{let r=t.format===\"NHWC\",n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&n.push(e.inputs[2]);let o=t.kernelShape;(o.length===0||o[0]===0)&&(o=[e.inputs[1].dims[2]]);let i=t.dilations;(i.length===0||i[0]===0)&&(i=[1]);let s=t.strides;(s.length===0||s[0]===0)&&(s=[1]);let a=t.pads;a.length===0&&(a=[0,0]),a=[0,a[0],0,a[1]],s=[1].concat(s),i=[1].concat(i),o=[1].concat(o);let u=Ki({...t,pads:a,strides:s,dilations:i,kernelShape:o},n);e.compute(Hr(n,u,d=>r?[d[0],d[2],d[3]]:[d[0],d[1],d[3]]))},Zi=(e,t)=>{vd(e.inputs,t),e.inputs[0].dims.length===3?xd(e,t):Sd(e,e.inputs,t)}});var Id,Qi,Xi,Ji=E(()=>{\"use strict\";R();L();ae();W();Id=(e,t,r,n)=>{let o=_.size(t),i=t.length,s=S(\"input\",e,i),a=A(\"output\",e,i),u=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),d=_.normalizeAxis(u,i),c=l=>{let p=` i32(${s.indicesGet(\"inputIndices\",\"uniforms.axis\")}) `,f=D(\"uniforms.input_shape\",\"uniforms.axis\",i),m=n.reverse?p+(n.exclusive?\" + 1\":\"\"):\"0\",h=n.reverse?f:p+(n.exclusive?\"\":\" + 1\");return`\n                ${l.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axis\",\"u32\").declareVariables(s,a)}\n                ${l.mainStart()}\n                  ${l.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n                  var inputIndices = ${a.offsetToIndices(\"global_idx\")};\n                  var sum = ${a.type.value}(0);\n                  let first : i32 = ${m};\n                  let last : i32 = ${h};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${s.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(i)\")};\n                    sum = sum + ${s.getByIndices(\"inputIndices\")};\n                  }\n                  ${a.setByOffset(\"global_idx\",\"sum\")};\n                }`};return{name:\"CumSum\",shaderCache:{hint:n.cacheKey,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:12,data:o},{type:12,data:d},...k(t,t)]}),getShaderSource:c}},Qi=(e,t)=>{let r=e.inputs[0].dims,n=e.inputs[0].dataType,o=e.inputs[1];e.compute(Id(n,r,o,t),{inputs:[0]})},Xi=e=>{let t=e.exclusive===1,r=e.reverse===1;return U({exclusive:t,reverse:r})}});var Td,Cd,Ad,es,ts,rs=E(()=>{\"use strict\";R();L();ae();W();Td=e=>{if(!e||e.length!==1)throw new Error(\"DepthToSpace requires 1 input.\");if(e[0].dims.length!==4)throw new Error(\"DepthToSpace requires 4D input.\")},Cd=(e,t,r,n)=>{let o=[];o.push(`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let i=0;i<t;++i)o.push(r.indicesSet(\"a\",e[i],`i[${i}]`));return o.push(\"return a;}\"),o.join(`\n`)},Ad=(e,t)=>{let r,n,o,i,s,a,u=t.format===\"NHWC\",d=t.blocksize,c=t.mode===\"DCR\";u?([r,n,o,i]=e.dims,s=c?[r,n,o,d,d,i/d**2]:[r,n,o,i/d**2,d,d],a=c?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([r,n,o,i]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],s=c?[r,d,d,i/d**2,n,o]:[r,i/d**2,d,d,n,o],a=c?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let l=e.reshape(s),p=l.dims.length,f=e.dataType,m=S(\"a\",f,p),h=A(\"output\",f,p),b=y=>`\n  ${y.registerUniform(\"output_size\",\"u32\").declareVariables(m,h)}\n\n  ${Cd(a,p,m,h)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${h.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${h.setByOffset(\"global_idx\",m.getByIndices(\"aIndices\"))}\n  }`;return{name:\"DepthToSpace\",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:[\"rank\"]},getRunData:y=>{let g=u?[r,n*d,o*d,i/d**2]:[r,i/d**2,n*d,o*d],w=_.size(g),$=l.dims,v=_.sortBasedOnPerm($,a);return{outputs:[{dims:g,dataType:y[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:[{type:12,data:w},...k($,v)]}},getShaderSource:b}},es=(e,t)=>{Td(e.inputs),e.compute(Ad(e.inputs[0],t))},ts=e=>U({blocksize:e.blocksize,mode:e.mode,format:e.format})});var qr,er,ns,Ed,kd,Fr,Kr,os,Pd,is,ss,as=E(()=>{\"use strict\";R();L();ae();W();qr=\"[a-zA-Z]|\\\\.\\\\.\\\\.\",er=\"(\"+qr+\")+\",ns=\"^\"+er+\"$\",Ed=\"(\"+er+\",)*\"+er,kd=\"^\"+Ed+\"$\",Fr=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let n=this.symbolToIndices.get(t);n===void 0?n=[r]:n.push(r),this.symbolToIndices.set(t,n)}},Kr=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,o]=r.includes(\"->\")?r.split(\"->\",2):[r,\"\"];if(!n.match(RegExp(kd)))throw new Error(\"Invalid LHS term\");if(n.split(\",\").forEach((a,u)=>{let d=t[u].dims.slice();if(!a.match(RegExp(ns)))throw new Error(\"Invalid LHS term\");let c=this.processTerm(a,!0,d,u);this.lhs.push(c)}),o===\"\")o+=[...this.symbolToInfo.entries()].filter(([a,u])=>u.count===1||a===\"...\").map(([a])=>a).join(\"\");else if(!o.match(RegExp(er)))throw new Error(\"Invalid RHS\");o.match(RegExp(qr,\"g\"))?.forEach(a=>{if(a===\"...\")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let u=this.symbolToInfo.get(a);if(u===void 0)throw new Error(\"Invalid RHS symbol\");this.outputDims.push(u.dimValue)}}),this.rhs=this.processTerm(o,!1,this.outputDims)}addSymbol(t,r,n){let o=this.symbolToInfo.get(t);if(o!==void 0){if(o.dimValue!==r&&o.count!==1)throw new Error(\"Dimension mismatch\");o.count++,o.inputIndices.push(n)}else o={count:1,dimValue:r,inputIndices:[n]};this.symbolToInfo.set(t,o)}processTerm(t,r,n,o=-1){let i=n.length,s=!1,a=[],u=0;if(!t.match(RegExp(ns))&&!r&&t!==\"\")throw new Error(\"Invalid LHS term\");let d=t.match(RegExp(qr,\"g\")),c=new Fr(o);return d?.forEach((l,p)=>{if(l===\"...\"){if(s)throw new Error(\"Only one ellipsis is allowed per input term\");s=!0;let f=i-d.length+1;if(f<0)throw new Error(\"Ellipsis out of bounds\");if(a=n.slice(u,u+f),this.hasEllipsis){if(this.ellipsisDims.length!==a.length||this.ellipsisDims.toString()!==a.toString())throw new Error(\"Ellipsis dimensions mismatch\")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=a;else throw new Error(\"Ellipsis must be specified in the LHS\");for(let m=0;m<a.length;m++){let h=String.fromCharCode(\"0\".charCodeAt(0)+m);c.addSymbol(h,p+m),this.addSymbol(h,n[u++],o)}}else c.addSymbol(l,p+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(l,n[u++],o)}),c}},os=e=>e+\"_max\",Pd=(e,t,r,n)=>{let i=e.map(c=>c.length).map((c,l)=>S(`input${l}`,t,c)),s=_.size(n),a=A(\"output\",t,n.length),u=[...r.symbolToInfo.keys()].filter(c=>!r.rhs.symbolToIndices.has(c)),d=c=>{let l=[],p=\"var prod = 1.0;\",f=\"var sum = 0.0;\",m=\"sum += prod;\",h=[],b=[],y=[],g=[],w=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((v,x)=>{if(r.rhs.symbolToIndices.has(x)){let T=r.rhs.symbolToIndices.get(x)?.[0];T!==void 0&&r.lhs.forEach((I,z)=>{if(v.inputIndices.includes(z)){let P=I.symbolToIndices.get(x);if(P===void 0)throw new Error(\"Invalid symbol error\");P.forEach(G=>{l.push(`${i[z].indicesSet(`input${z}Indices`,G,a.indicesGet(\"outputIndices\",T))}`)})}})}else r.lhs.forEach((T,I)=>{if(v.inputIndices.includes(I)){let z=T.symbolToIndices.get(x);if(z===void 0)throw new Error(\"Invalid symbol error\");z.forEach(P=>{h.push(`${i[I].indicesSet(`input${I}Indices`,P,`${x}`)}`)}),g.push(`prod *= ${i[I].getByIndices(`input${I}Indices`)};`)}}),b.push(`for(var ${x}: u32 = 0; ${x} < uniforms.${os(x)}; ${x}++) {`),y.push(\"}\")});let $=w?[...l,`let sum = ${i.map((v,x)=>v.getByIndices(`input${x}Indices`)).join(\" * \")};`]:[...l,f,...b,...h,p,...g,m,...y];return`\n            ${c.registerUniforms(u.map(v=>({name:`${os(v)}`,type:\"u32\"}))).registerUniform(\"outputSize\",\"u32\").declareVariables(...i,a)}\n\n            ${c.mainStart()}\n            ${c.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n            var outputIndices = ${a.offsetToIndices(\"global_idx\")};\n            ${i.map((v,x)=>`var input${x}Indices: ${i[x].type.indices};`).join(`\n`)}\n            ${$.join(`\n`)};\n            ${a.setByOffset(\"global_idx\",\"sum\")};\n          }`};return{name:\"Einsum\",shaderCache:{hint:r.equation,inputDependencies:e.map(()=>\"rank\")},getRunData:()=>{let c=u.filter(p=>r.symbolToInfo.has(p)).map(p=>({type:12,data:r.symbolToInfo.get(p)?.dimValue||0}));c.push({type:12,data:s});let l=e.map((p,f)=>[...k(p)]).reduce((p,f)=>p.concat(f),c);return l.push(...k(n)),{outputs:[{dims:n,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:l}},getShaderSource:d}},is=(e,t)=>{let r=new Kr(e.inputs,t.equation),n=r.outputDims,o=e.inputs.map((i,s)=>i.dims);e.compute(Pd(o,e.inputs[0].dataType,r,n))},ss=e=>{let t=e.equation.replace(/\\s+/g,\"\");return U({equation:t})}});var zd,us,Od,Bd,ds,ls=E(()=>{\"use strict\";R();L();W();zd=e=>{if(!e||e.length!==2)throw new Error(\"Expand requires 2 input.\");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=r.length<t.length?0:r.length-t.length,o=t.length<r.length?0:t.length-r.length;for(;n<r.length&&o<t.length;++n,++o)if(r[n]!==t[o]&&r[n]!==1&&t[o]!==1)throw new Error(\"Expand requires shape to be broadcastable to input\")},us=(e,t)=>{let r=e.length-t.length,n=[];for(let o=0;o<r;++o)n.push(e[o]);for(let o=0;o<t.length;++o)n.push(t[o]===1?e[o+r]:t[o]);return n},Od=(e,t)=>e.length>t.length?us(e,t):us(t,e),Bd=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=Od(t,r),o=e[0].dataType,i=o===9?4:1,s=Math.ceil(_.size(n)/i),a=d=>{let c=S(\"input\",o,t.length,i),l=A(\"output\",o,n.length,i),p;if(o===9){let f=(m,h,b=\"\")=>`\n          let outputIndices${h} = ${l.offsetToIndices(`outputOffset + ${h}u`)};\n          let offset${h} = ${c.broadcastedIndicesToOffset(`outputIndices${h}`,l)};\n          let index${h} = offset${h} / 4u;\n          let component${h} = offset${h} % 4u;\n          ${m}[${h}] = ${b}(${c.getByOffset(`index${h}`)}[component${h}]);\n        `;p=`\n        let outputOffset = global_idx * ${i};\n        var data = vec4<u32>(0);\n        ${f(\"data\",0,\"u32\")}\n        ${f(\"data\",1,\"u32\")}\n        ${f(\"data\",2,\"u32\")}\n        ${f(\"data\",3,\"u32\")}\n        ${l.setByOffset(\"global_idx\",\"data\")}\n      }`}else p=`\n        let outputIndices = ${l.offsetToIndices(\"global_idx\")};\n        let inputOffset = ${c.broadcastedIndicesToOffset(\"outputIndices\",l)};\n        ${l.setByOffset(\"global_idx\",c.getByOffset(\"inputOffset\"))}\n      }`;return`\n    ${d.registerUniform(\"vec_size\",\"u32\").declareVariables(c,l)}\n    ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n    ${p}`},u=[{type:12,data:s},...k(t,n)];return{name:\"Expand\",shaderCache:{hint:`${n.length}`,inputDependencies:[\"rank\"]},getShaderSource:a,getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:u})}},ds=e=>{zd(e.inputs),e.compute(Bd(e.inputs),{inputs:[0]})}});var Dd,cs,ps=E(()=>{\"use strict\";R();L();W();Kt();Dd=e=>{let t=e[0].dataType,r=_.size(e[0].dims),n=_.size(e[1].dims),o=n%4===0,i=s=>{let a=S(\"x\",t,[1],4),u=S(\"bias\",t,[1],4),d=A(\"y\",t,[1],4),c=[{name:\"output_vec_size\",type:\"u32\"},{name:\"bias_size\",type:\"u32\"}],l=f=>`\n      let bias${f}_offset: u32 = (global_idx * 4 + ${f}) % uniforms.bias_size;\n      let bias${f} = ${u.getByOffset(`bias${f}_offset / 4`)}[bias${f}_offset % 4];`,p=o?`\n      let bias = ${u.getByOffset(\"global_idx % (uniforms.bias_size / 4)\")};`:`${l(0)}${l(1)}${l(2)}${l(3)}\n      let bias = ${a.type.value}(bias0, bias1, bias2, bias3);`;return`${s.registerUniforms(c).declareVariables(a,u,d)}\n\n    ${Br(le(t))}\n\n    ${s.mainStart(Ke)}\n      ${s.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_vec_size\")}\n\n      let x = ${a.getByOffset(\"global_idx\")};\n      ${p}\n      let x_in = x + bias;\n      ${d.setByOffset(\"global_idx\",Dr(\"x_in\"))}\n    }`};return{name:\"FastGeluWithBias\",shaderCache:{hint:`${o}`,inputDependencies:[\"type\",\"type\"]},getShaderSource:i,getRunData:s=>({outputs:[{dims:s[0].dims,dataType:s[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:n}],dispatchGroup:{x:Math.ceil(r/Ke/4)}})}},cs=e=>{e.inputs.length<2||_.size(e.inputs[1].dims)===0?yi(e):e.compute(Dd(e.inputs))}});var Rd,Md,ms,fs,hs=E(()=>{\"use strict\";R();L();ae();W();Rd=e=>{if(!e||e.length!==2)throw new Error(\"Gather requires 2 inputs.\")},Md=(e,t)=>{let r=e[0].dims,n=e[1].dims,o=r.length,i=_.normalizeAxis(t.axis,o),s=r.slice(0);s.splice(i,1,...n);let a=r[i],u=e[0].dataType===9?4:1,d=Math.ceil(_.size(s)/u),c=[{type:12,data:d},{type:6,data:a},{type:12,data:i},...k(e[0].dims,e[1].dims,s)],l=p=>{let f=S(\"data\",e[0].dataType,e[0].dims.length,u),m=S(\"inputIndices\",e[1].dataType,e[1].dims.length),h=A(\"output\",e[0].dataType,s.length,u),b=g=>{let w=n.length,$=`var indicesIndices${g}  = ${m.type.indices}(0);`;for(let v=0;v<w;v++)$+=`${w>1?`indicesIndices${g}[${v}]`:`indicesIndices${g}`} = ${s.length>1?`outputIndices${g}[uniforms.axis + ${v}]`:`outputIndices${g}`};`;$+=`\n          var idx${g} = ${m.getByIndices(`indicesIndices${g}`)};\n          if (idx${g} < 0) {\n            idx${g} = idx${g} + uniforms.axisDimLimit;\n          }\n          var dataIndices${g} : ${f.type.indices};\n        `;for(let v=0,x=0;v<o;v++)v===i?($+=`${o>1?`dataIndices${g}[${v}]`:`dataIndices${g}`} = u32(idx${g});`,x+=w):($+=`${o>1?`dataIndices${g}[${v}]`:`dataIndices${g}`} = ${s.length>1?`outputIndices${g}[${x}]`:`outputIndices${g}`};`,x++);return $},y;if(e[0].dataType===9){let g=(w,$,v=\"\")=>`\n          let outputIndices${$} = ${h.offsetToIndices(`outputOffset + ${$}u`)};\n          ${b($)};\n          let offset${$} = ${f.indicesToOffset(`dataIndices${$}`)};\n          let index${$} = offset${$} / 4u;\n          let component${$} = offset${$} % 4u;\n          ${w}[${$}] = ${v}(${f.getByOffset(`index${$}`)}[component${$}]);\n        `;y=`\n        let outputOffset = global_idx * ${u};\n        var value = vec4<u32>(0);\n        ${g(\"value\",0,\"u32\")}\n        ${g(\"value\",1,\"u32\")}\n        ${g(\"value\",2,\"u32\")}\n        ${g(\"value\",3,\"u32\")}\n        ${h.setByOffset(\"global_idx\",\"value\")}\n      `}else y=`\n      let outputIndices = ${h.offsetToIndices(\"global_idx\")};\n      ${b(\"\")};\n      let value = ${f.getByIndices(\"dataIndices\")};\n      ${h.setByOffset(\"global_idx\",\"value\")};\n      `;return`\n      ${p.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(f,m,h)}\n      ${p.mainStart()}\n        ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        ${y}\n      }`};return{name:\"Gather\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:c}),getShaderSource:l}},ms=e=>U({axis:e.axis}),fs=(e,t)=>{let r=e.inputs;Rd(r),e.compute(Md(e.inputs,t))}});var Ud,Vd,gs,ys,bs=E(()=>{\"use strict\";R();L();ae();W();Ud=e=>{if(!e||e.length!==2)throw new Error(\"GatherElements requires 2 inputs.\");if(e[0].dims.length<1)throw new Error(\"GatherElements requires that the data input be rank >= 1.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Vd=(e,t)=>{let r=e[0].dims,n=e[0].dataType,o=r.length,i=e[1].dims,s=e[1].dataType,a=_.normalizeAxis(t.axis,o),u=r[a],d=i.slice(0),c=_.size(d),l=S(\"input\",n,o),p=S(\"indicesInput\",s,i.length),f=A(\"output\",n,d.length),m=[{type:12,data:c},{type:6,data:u},{type:12,data:a}];return m.push(...k(r,i,d)),{name:\"GatherElements\",shaderCache:{inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:m}),getShaderSource:y=>`\n      ${y.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(l,p,f)}\n      ${y.mainStart()}\n      ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n      let outputIndices = ${f.offsetToIndices(\"global_idx\")};\n\n      var idx = ${p.getByOffset(\"global_idx\")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${l.type.indices}(outputIndices);\n      ${l.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(idx)\")};\n      let value = ${l.getByIndices(\"inputIndices\")};\n\n      ${f.setByOffset(\"global_idx\",\"value\")};\n  }`}},gs=e=>U({axis:e.axis}),ys=(e,t)=>{let r=e.inputs;Ud(r),e.compute(Vd(e.inputs,t))}});var Nd,Wd,ws,$s,vs=E(()=>{\"use strict\";R();L();W();Nd=e=>{if(!e)throw new Error(\"Input is missing\");if(e.length<2||e.length>3)throw new Error(\"Invaid input number.\");if(e.length===3&&e[2].dims.length>2)throw new Error(\"Invalid input shape of C\");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"Input types are mismatched\")},Wd=(e,t)=>{let r=e[0].dims.slice(),n=e[1].dims.slice(),[o,i,s]=Ut.getShapeOfGemmResult(r,t.transA,n,t.transB,e.length===3?e[2].dims:void 0),a=[o,i];if(!a)throw new Error(\"Can't use gemm on the given tensors\");let u=_.size(a),d=[{type:12,data:u},{type:12,data:o},{type:12,data:i},{type:12,data:s},{type:1,data:t.alpha},{type:1,data:t.beta}],c=[\"type\",\"type\"];e.length===3&&(d.push(...k(e[2].dims)),c.push(\"rank\")),d.push(...k(a));let l=p=>{let f=\"\";t.transA&&t.transB?f=\"value += a[k * uniforms.M + m] * b[n * uniforms.K + k];\":t.transA&&!t.transB?f=\"value += a[k * uniforms.M + m] * b[k * uniforms.N + n];\":!t.transA&&t.transB?f=\"value += a[m * uniforms.K + k] * b[n * uniforms.K + k];\":!t.transA&&!t.transB&&(f=\"value += a[m * uniforms.K + k] * b[k * uniforms.N + n];\");let m=t.alpha===1?\"\":\"value *= uniforms.alpha;\",h=S(\"a\",e[0].dataType,e[0].dims),b=S(\"b\",e[1].dataType,e[1].dims),y=h.type.value,g=null,w=[h,b];e.length===3&&(g=S(\"c\",e[2].dataType,e[2].dims.length),w.push(g));let $=A(\"output\",e[0].dataType,a.length);w.push($);let v=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}];return`\n  ${p.registerUniforms(v).declareVariables(...w)}\n\n  ${p.mainStart()}\n    ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${y}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${f}\n    }\n\n    ${m}\n    ${(()=>g!=null?`let cOffset = ${g.broadcastedIndicesToOffset(\"vec2(m, n)\",$)}; value += ${y}(uniforms.beta) * ${g.getByOffset(\"cOffset\")};`:\"\")()}\n    output[global_idx] = value;\n  }`};return{name:\"Gemm\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d}),getShaderSource:l}},ws=e=>{let t=e.transA,r=e.transB,n=e.alpha,o=e.beta;return{transA:t,transB:r,alpha:n,beta:o,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},$s=(e,t)=>{Nd(e.inputs),e.compute(Wd(e.inputs,t))}});var ye,Hd,Ss,_s,qd,pt,xs,jr=E(()=>{\"use strict\";R();L();ae();Mt();Ht();W();Ze();ye=(e,t)=>e.length>t&&e[t].dims.length>0&&_.size(e[t].dims)>0?e[t]:void 0,Hd=(e,t)=>{let r=e[0],n=ye(e,1),o=ye(e,2),i=ye(e,3),s=ye(e,4),a=ye(e,5),u=ye(e,6),d=ye(e,7);if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let c=!1,l=r.dims[0],p=r.dims[1],f=r.dims.length===3?c?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],m=p,h=0,b=0,y=Math.floor(f/t.numHeads);if(u&&d){if(u.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(u.dims[0]!==l||u.dims[1]!==t.numHeads||u.dims[3]!==y)throw new Error('Input \"past_key\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(d.dims[0]!==l||d.dims[1]!==t.numHeads||d.dims[3]!==y)throw new Error('Input \"past_value\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[2]!==d.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have same dim 2 (past_sequence_length)');if(d.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');h=u.dims[2],b=u.dims[2]}else if(u||d)throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let g;if(n){if(r.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(n.dims.length===3){if(n.dims[2]!==r.dims[2])throw new Error('Input \"query\" and \"key\" shall have same dim 2 (hidden_size)');g=2,m=n.dims[1]}else if(n.dims.length===5){if(n.dims[2]!==t.numHeads||n.dims[3]!==2||n.dims[4]!==y)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');g=5,m=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==y)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');g=0,m=n.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}if(i){if(i.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimension');if(o&&r.dims.length===5&&r.dims[3]===2)throw new Error(\"bias is not allowed for packed kv.\")}let w=0;if(s){w=8;let I=s.dims;throw I.length===1?I[0]===l?w=1:I[0]===3*l+2&&(w=3):I.length===2&&I[0]===l&&I[1]===m&&(w=5),w===8?new Error('Input \"key_padding_mask\" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error(\"Mask not supported\")}let $=!1,v=f;if(o){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(r.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(m!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');v=o.dims[2]}else{if(m!==o.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');v=o.dims[1]*o.dims[3],$=!0}}let x=h+m,T=!1;if(s)throw new Error(\"Key padding mask is not supported\");if(a){if(a.dims.length!==4)throw new Error('Input \"relative_position_bias\" is expected to have 4 dimensions');if(a.dims[0]!==l&&a.dims[0]!==1||a.dims[1]!==t.numHeads||a.dims[2]!==p||a.dims[3]!==x)throw new Error('Input \"relative_position_bias\" shape (batch_size, 1, sequence_length, kv_sequence_length)')}return{batchSize:l,sequenceLength:p,pastSequenceLength:h,kvSequenceLength:m,totalSequenceLength:x,maxSequenceLength:b,inputHiddenSize:0,hiddenSize:f,vHiddenSize:v,headSize:y,vHeadSize:Math.floor(v/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:w,scale:t.scale,broadcastResPosBias:T,passPastInKv:$,qkvFormat:g}},Ss=e=>U({...e}),_s=U({perm:[0,2,1,3]}),qd=(e,t,r,n,o,i,s)=>{let a=[n,o,i],u=_.size(a),d=[{type:12,data:u},{type:12,data:s},{type:12,data:i}],c=l=>{let p=A(\"qkv_with_bias\",t.dataType,a),f=S(\"qkv\",t.dataType,a),m=S(\"bias\",r.dataType,a),h=[{name:\"output_size\",type:\"u32\"},{name:\"bias_offset\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"}];return`\n  ${l.registerUniforms(h).declareVariables(f,m,p)}\n  ${l.mainStart()}\n    ${l.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:\"MultiHeadAttentionAddBias\",shaderCache:{inputDependencies:[\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d}),getShaderSource:c},{inputs:[t,r],outputs:[-1]})[0]},pt=(e,t,r,n,o,i,s,a)=>{let u=i;if(s){if(n===1)throw new Error(\"AddBiasReshape is not implemented. Please export your model with packed QKV or KV\");return u=qd(e,i,s,t,n,r*o,a),u=u.reshape([t,n,r,o]),e.compute(ge(u,_s.perm),{inputs:[u],outputs:[-1]})[0]}else return i.dims.length===3&&(u=i.reshape([t,n,r,o])),e.compute(ge(u,_s.perm),{inputs:[u],outputs:[-1]})[0]},xs=(e,t)=>{let r=Hd(e.inputs,t),n=e.inputs[0],o=ye(e.inputs,1),i=ye(e.inputs,2),s=ye(e.inputs,3),a=ye(e.inputs,4),u=ye(e.inputs,5),d=ye(e.inputs,6),c=ye(e.inputs,7);if(n.dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(o?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let l=o&&i&&o.dims.length===4&&i.dims.length===4,p=pt(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,n,s,0);if(l)return et(e,p,o,i,a,void 0,d,c,u,r,t);if(!o||!i)throw new Error(\"key and value must be provided\");let f=pt(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,o,s,r.hiddenSize),m=pt(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,i,s,2*r.hiddenSize);et(e,p,f,m,a,void 0,d,c,u,r,t)}});var Is,Fd,Kd,Zr,Ts,Yr=E(()=>{\"use strict\";R();L();W();Is=e=>Array.from(e.getBigInt64Array(),Number),Fd=e=>{if(!e||e.length!==2)throw new Error(\"Tile requires 2 inputs.\");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error(\"Tile only support float, float16, int32, and uint32 data types\");if(e[1].dataType!==7)throw new Error(\"Tile `repeats` input should be of int64 data type\");if(e[1].dims.length!==1)throw new Error(\"Tile `repeats` input should be 1-D\");if(Is(e[1]).length!==e[0].dims.length)throw new Error(\"Tile `repeats` input should have same number of elements as rank of input data tensor\")},Kd=(e,t)=>{let r=[];for(let n=0;n<e.length;++n)r.push(e[n]*t[n]);return r},Zr=(e,t)=>{let r=e[0].dims,n=t??Is(e[1]),o=Kd(r,n),i=_.size(o),s=e[0].dataType,a=S(\"input\",s,r.length),u=A(\"output\",s,o.length),d=c=>`\n      const inputShape = ${a.indices(...r)};\n      ${c.registerUniform(\"output_size\",\"u32\").declareVariables(a,u)}\n      ${c.mainStart()}\n      ${c.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let output_indices = ${u.offsetToIndices(\"global_idx\")};\n      var input_indices: ${a.type.indices};\n      for (var i = 0; i < ${r.length}; i++) {\n        let input_dim_i = ${a.indicesGet(\"uniforms.input_shape\",\"i\")};\n        let input_dim_value = ${u.indicesGet(\"output_indices\",\"i\")}  % input_dim_i;\n\n        ${a.indicesSet(\"input_indices\",\"i\",\"input_dim_value\")}\n      }\n      ${u.setByOffset(\"global_idx\",a.getByIndices(\"input_indices\"))}\n    }`;return{name:\"Tile\",shaderCache:{hint:`${n}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...k(e[0].dims,o)]}),getShaderSource:d}},Ts=e=>{Fd(e.inputs),e.compute(Zr(e.inputs),{inputs:[0]})}});var jd,Cs,Es,Zd,As,ks,Ps=E(()=>{\"use strict\";R();L();ae();Ht();W();jr();Yr();Ze();jd=(e,t)=>{let r=e[0],n=e[1],o=e[2],i=e[3],s=e[4];if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let a=!1,u=r.dims[0],d=r.dims[1],c=r.dims.length===3?a?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],l=d,p=0,f=0,m=Math.floor(c/t.numHeads),h=i&&i.dims.length!==0,b=s&&s.dims.length!==0,y=!0;if(h&&b){if(i.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(s.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');y?(p=i.dims[1],f=i.dims[1]):(p=i.dims[2],f=i.dims[2])}else if(h||b)throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let g;if(n){if(r.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(n.dims.length===3){if(r.dims[2]%n.dims[2]!==0)throw new Error('Dimension 2 of \"query\" should be a multiple of \"key\"');g=2,l=n.dims[1]}else if(n.dims.length===5){if(n.dims[2]!==t.numHeads||n.dims[3]!==2||n.dims[4]!==m)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');g=5,l=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==m)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');g=0,l=n.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}let w=0,$=!1,v=c;if(o){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(r.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(l!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');v=o.dims[2]}else{if(l!==o.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');v=o.dims[1]*o.dims[3],$=!0}}let x=p+l,T=!1;return{batchSize:u,sequenceLength:d,pastSequenceLength:p,kvSequenceLength:l,totalSequenceLength:x,maxSequenceLength:f,inputHiddenSize:0,hiddenSize:c,vHiddenSize:v,headSize:m,vHeadSize:Math.floor(v/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:w,scale:t.scale,broadcastResPosBias:T,passPastInKv:$,qkvFormat:g,isPastkvBSNH:y}},Cs=(e,t,r,n)=>{let o=[n.batchSize,n.totalSequenceLength,n.kvNumHeads,n.headSize],i=4,s=_.size(o)/i,a=n.totalSequenceLength,u=A(\"present_kv\",r,o.length,i),d=S(\"new_kv\",e.dataType,e.dims.length,i),c=t?S(\"past_kv\",t.dataType,t.dims.length,i):void 0,l=Math.ceil(n.headSize/i),p={x:a,y:e.dims[0],z:1},f=t?[\"rank\",\"rank\"]:[\"rank\"],m=[{type:12,data:s},{type:12,data:n.pastSequenceLength},{type:12,data:n.kvSequenceLength},{type:12,data:n.totalSequenceLength}],h=[d];c?(m.push(...k(e.dims),...k(t.dims),...k(o)),h.push(c)):m.push(...k(e.dims),...k(o));let b=[{name:\"output_size\",type:\"u32\"},{name:\"past_seqlen\",type:\"u32\"},{name:\"new_seqlen\",type:\"u32\"},{name:\"present_seqlen\",type:\"u32\"}],y=`      let past_batch_stride = uniforms.past_seqlen * num_heads * H;\n        var past_head_stride = uniforms.past_seqlen * H;\n        if (is_bsnh) {\n          past_head_stride = H;\n        }\n        let in_offset = b * past_batch_stride + s * row_stride + n * past_head_stride + h;\n        present_kv[out_offset] = past_kv[in_offset];`,g=`      let new_batch_stride = uniforms.new_seqlen * num_heads * H;\n        let new_row_stride = num_heads * H;\n        let new_head_stride = H;\n        let in_offset = b * new_batch_stride + (s - past_seqlen) * new_row_stride + n * new_head_stride + h;\n        present_kv[out_offset] = new_kv[in_offset];`,w=t?`if (s < past_seqlen) {\n        ${y}\n        } else if (s < past_seqlen + uniforms.new_seqlen) {\n        ${g}\n        }`:`if (s < past_seqlen + uniforms.new_seqlen) {\n          ${g}\n        }`,$=v=>`\n\n  ${v.registerUniforms(b).declareVariables(...h,u)}\n  ${v.mainStart([l,n.kvNumHeads,1])}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    var indices = ${u.offsetToIndices(\"global_idx\")};\n    let h = local_id.x;\n    let n = local_id.y;\n    let s = workgroup_id.x;\n    let b = workgroup_id.y;\n    let num_heads = ${n.kvNumHeads}u;\n    let H = ${l}u;\n\n    let present_seqlen = uniforms.present_seqlen;\n    let present_batch_stride = present_seqlen * num_heads * H;\n    var row_stride = H;\n    let is_bsnh = ${n.isPastkvBSNH};\n\n    if (is_bsnh) {\n      row_stride = num_heads * H;\n    }\n    var present_head_stride = present_seqlen * H;\n    if (is_bsnh) {\n      present_head_stride = H;\n    }\n\n    let past_seqlen = uniforms.past_seqlen;\n\n    let out_offset = b * present_batch_stride + s * row_stride + n * present_head_stride + h;\n    ${w}\n  }`;return{name:\"ConcatPastNew\",shaderCache:{hint:`${n.kvNumHeads}${l}${!!t}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:o,dataType:r}],dispatchGroup:p,programUniforms:m}),getShaderSource:$}},Es=e=>U({...e}),Zd=U({perm:[0,2,1,3]}),As=(e,t,r,n,o)=>{let i=t,s=n.kvNumHeads,a=n.nReps;return t.dims.length===3&&n.kvSequenceLength!==0&&(i=t.reshape([n.batchSize,n.kvSequenceLength,s,n.headSize])),r?i=e.compute(Cs(i,r,i.dataType,n),{inputs:[i,r],outputs:[n.isPastkvBSNH?o:-1]})[0]:i=e.compute(Cs(i,void 0,i.dataType,n),{inputs:[i],outputs:[n.isPastkvBSNH?o:-1]})[0],a!==1&&(i=e.compute(Zr([i],[1,1,1,a]),{inputs:[i],outputs:[-1]})[0],i=i.reshape([n.batchSize,n.totalSequenceLength,s*a,n.headSize])),e.compute(ge(i,Zd.perm),{inputs:[i],outputs:[-1]})[0]},ks=(e,t)=>{let r=jd(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(e.inputs[1]?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let n=pt(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,e.inputs[0],void 0,0),o=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,i=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,s=As(e,e.inputs[1],o,r,1),a=As(e,e.inputs[2],i,r,2);et(e,n,s,a,void 0,void 0,void 0,void 0,void 0,r,t)}});var Yd,Qd,Xd,zs,Os=E(()=>{\"use strict\";R();L();W();Yd=(e,t)=>{let r=e[0].dims,n=r,o=2,i=_.sizeToDimension(r,o),s=_.sizeFromDimension(r,o),a=ee(s),u=s/a,d=[r[0],r[1],u],c=[\"rank\",\"type\",\"type\"],l=[{type:12,data:s},{type:12,data:u}];l.push(...k(d,d));let p=f=>{let m=S(\"x\",e[0].dataType,d.length,a),h=S(\"scale\",e[1].dataType,e[1].dims),b=S(\"bias\",e[2].dataType,e[2].dims),y=A(\"output\",e[0].dataType,d.length,a),g=[m,h,b,y],w=m.type.value,$=a===1?\"f32\":`vec${a}<f32>`,v=64,x=[{name:\"normSize\",type:\"u32\"},{name:\"normPackedSize\",type:\"u32\"}];return`\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${$}, ${v}>;\n  const workgroupSize = ${v}u;\n  ${f.registerUniforms(x).declareVariables(...g)}\n  ${f.mainStart(v)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / uniforms.x_shape[1];\n    let channel = norm % uniforms.x_shape[1];\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${$}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      initial = initial + ${$}(${m.get(\"batch\",\"channel\",\"h\")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${Te(\"workgroupShared[0]\",a)} / f32(uniforms.normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${$}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let deviation =  ${$}(${m.get(\"batch\",\"channel\",\"h\")}) - ${$}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${Te(\"workgroupShared[0]\",a)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${t.epsilon}));\n    let channelScale = invStdDev * f32(${h.getByOffset(\"channel\")});\n    let channelShift = f32(${b.getByOffset(\"channel\")}) - meanShared * channelScale;\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let value = ${m.get(\"batch\",\"channel\",\"h\")} * ${w}(${$}(channelScale)) + ${w}(${$}(channelShift));\n      ${y.set(\"batch\",\"channel\",\"h\",\"value\")};\n    }\n  }`};return{name:\"InstanceNormalization\",shaderCache:{hint:`${t.epsilon};${a}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:i},programUniforms:l}),getShaderSource:p}},Qd=(e,t,r,n,o,i,s,a)=>{let u=ee(s),d=64,c=u===1?\"vec2f\":`mat2x${u}f`,l=u===1?\"f32\":`vec${u}f`,p=(x,T)=>`${c}(${x}, ${T})`,f=o*s/u,m=Math.ceil(i/d),h=[\"type\"],b=[{type:12,data:m},{type:12,data:i},{type:12,data:Math.floor(s/u)},{type:12,data:Math.floor(i*s/u)}],y=x=>{let T=S(\"input\",t.dataType,t.dims,u);return`\n  ${x.declareVariables(T)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${c}>;\n  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n  ${x.mainStart(d)}\n    let currentImageNumber = global_idx / ${d} / uniforms.C;\n    let currentChannelNumber = (global_idx / ${d}) % uniforms.C;\n    let wgOffset = local_id.x * uniforms.wg_size;\n    if (wgOffset >= uniforms.H) {\n        return;\n    }\n    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);\n\n    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;\n    var sum = ${Ue(\"f32\",u)};\n    var squaredSum = ${Ue(\"f32\",u)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${l}(input[offset + i * uniforms.C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${p(\"sum\",\"squaredSum\")};\n  }`},g=e.compute({name:\"InstanceNormComputeMean\",shaderCache:{hint:`${u}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:[o,s,d,2],dataType:1}],dispatchGroup:{x:o*s/u},programUniforms:b}),getShaderSource:y},{inputs:[t],outputs:[-1]})[0],w=[{type:12,data:f},{type:12,data:i},{type:12,data:Math.floor(s/u)},{type:12,data:Math.floor(d*s/u)}],$=[\"type\",\"type\",\"type\"],v=x=>{let T=S(\"scale\",r.dataType,r.dims,u),I=S(\"bias\",n.dataType,n.dims,u);return`\n  @group(0) @binding(0) var<storage, read> input : array<${c}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${T.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${I.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${c}>;\n  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};\n  @group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n  ${x.mainStart()}\n    ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.units_of_work\")}\n    let currentImageNumber = global_idx / uniforms.C;\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let offset = currentImageNumber * uniforms.image_size;\n    var sum = ${Ue(\"f32\",u)};\n    var squaredSum = ${Ue(\"f32\",u)};\n    for (var i: u32 = 0; i < min(${d}, uniforms.H); i++) {\n        let value = input[offset + i + currentChannelNumber * ${d}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(uniforms.H);\n    squaredSum = squaredSum / f32(uniforms.H);\n    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${a}));\n    let channelScale = invStdDev * ${l}(scale[currentChannelNumber]);\n    let channelShift = ${l}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${p(\"channelScale\",\"channelShift\")};\n  }`};return e.compute({name:\"InstanceNormComputeChannelScaleShift\",shaderCache:{hint:`${u};${a}`,inputDependencies:$},getRunData:()=>({outputs:[{dims:[o,s,2],dataType:1}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:w}),getShaderSource:v},{inputs:[g,r,n],outputs:[-1]})[0]},Xd=(e,t,r)=>{let n=t[0].dims,o=n,i=n[0],s=n[n.length-1],a=_.sizeFromDimension(n,1)/s,u=ee(s),d=_.size(o)/u,c=[{type:12,data:a},{type:12,data:Math.floor(s/u)}],l=[\"type\",\"type\"],p=Qd(e,t[0],t[1],t[2],i,a,s,r.epsilon),f=m=>{let h=X(t[0].dataType),b=u===1?\"vec2f\":`mat2x${u}f`,y=u===1?h:`vec${u}<${h}>`,g=S(\"input\",t[0].dataType,t[0].dims,u),w=A(\"output\",t[0].dataType,o,u);return`\n  @group(0) @binding(0) var<storage, read> input : array<${g.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${b}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${w.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${m.mainStart()}\n    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${y}(scale[0]), ${y}(scale[1]));\n  }`};e.compute({name:\"InstanceNormalizationNHWC\",shaderCache:{hint:`${u}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:c}),getShaderSource:f},{inputs:[t[0],p]})},zs=(e,t)=>{t.format===\"NHWC\"?Xd(e,e.inputs,t):e.compute(Yd(e.inputs,t))}});var Jd,el,Bs,Ds=E(()=>{\"use strict\";R();L();W();Jd=e=>{if(!e||e.length<2)throw new Error(\"layerNorm requires at least 2 inputs.\")},el=(e,t,r)=>{let n=t.simplified,o=e[0].dims,i=e[1],s=!n&&e[2],a=o,u=_.normalizeAxis(t.axis,o.length),d=_.sizeToDimension(o,u),c=_.sizeFromDimension(o,u),l=_.size(i.dims),p=s?_.size(s.dims):0;if(l!==c||s&&p!==c)throw new Error(`Size of X.shape()[axis:] == ${c}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${l} and bias size of ${p}`);let f=[];for(let v=0;v<o.length;++v)v<u?f.push(o[v]):f.push(1);let m=ee(c),h=[\"type\",\"type\"],b=[{type:12,data:d},{type:1,data:c},{type:12,data:Math.floor(c/m)},{type:1,data:t.epsilon}];s&&h.push(\"type\");let y=r>1,g=r>2,w=v=>{let x=X(e[0].dataType),T=[S(\"x\",e[0].dataType,e[0].dims,m),S(\"scale\",i.dataType,i.dims,m)];s&&T.push(S(\"bias\",s.dataType,s.dims,m)),T.push(A(\"output\",e[0].dataType,a,m)),y&&T.push(A(\"mean_data_output\",1,f)),g&&T.push(A(\"inv_std_output\",1,f));let I=[{name:\"norm_count\",type:\"u32\"},{name:\"norm_size\",type:\"f32\"},{name:\"norm_size_vectorized\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}];return`\n  ${v.registerUniforms(I).declareVariables(...T)}\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.norm_count\")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${Ue(\"f32\",m)};\n    var mean_square_vector = ${Ue(\"f32\",m)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${je(x,m,\"x[h + offset]\")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${Te(\"mean_vector\",m)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${Te(\"mean_square_vector\",m)} / uniforms.norm_size ${n?\"\":\"- mean * mean\"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${je(x,m,\"x[j + offset]\")};\n      let f32scale = ${je(x,m,\"scale[j]\")};\n      output[j + offset] = ${T[0].type.value}((f32input ${n?\"\":\"- mean\"}) * inv_std_dev * f32scale\n        ${s?`+ ${je(x,m,\"bias[j]\")}`:\"\"}\n      );\n    }\n\n    ${y?\"mean_data_output[global_idx] = mean\":\"\"};\n    ${g?\"inv_std_output[global_idx] = inv_std_dev\":\"\"};\n  }`},$=[{dims:a,dataType:e[0].dataType}];return y&&$.push({dims:f,dataType:1}),g&&$.push({dims:f,dataType:1}),{name:\"LayerNormalization\",shaderCache:{hint:`${m};${r};${n}`,inputDependencies:h},getRunData:()=>({outputs:$,dispatchGroup:{x:Math.ceil(d/64)},programUniforms:b}),getShaderSource:w}},Bs=(e,t)=>{Jd(e.inputs),e.compute(el(e.inputs,t,e.outputCount))}});var tl,rl,Rs,Ms,Us=E(()=>{\"use strict\";R();L();ae();W();tl=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"MatMulNBits requires 3 or 4 inputs\");let r=e[0],n=r.dims.length;if(r.dims[n-1]!==t.k)throw new Error(\"The last dim of input shape does not match the k value\");let o=Math.floor((t.k+t.blockSize-1)/t.blockSize),i=t.blockSize/8*t.bits,s=e[1];if(!_.areEqual(s.dims,[t.n,o,i]))throw new Error(\"The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize\");let u=e[2].dims;if(_.size(u)!==t.n*o)throw new Error(\"scales input size error.\");if(e.length===4){let c=e[3].dims,l=t.bits>4?t.n*o:t.n*Math.floor((o+1)/2);if(_.size(c)!==l)throw new Error(\"zeroPoints input size error.\")}},rl=(e,t,r,n)=>{let o=e[0].dims,i=o.length,s=Math.floor((t.k+t.blockSize-1)/t.blockSize),a=o[i-2],u=t.k,d=t.n,c=o.slice(0,i-2),l=_.size(c),f=t.blockSize/8*t.bits/4,m=e[0].dataType,h=ee(a),b=ee(t.k),y=ee(f),g=qe(m),w=a*s*g,$=Math.floor(n/w),v=s<=r[0]&&$>0,x=!v||$>=4?ee(d):$>=2&&ee(d)>=2?2:1,T=c.concat([a,d]),I=_.size(T)/x/h,z=v?[]:[{type:12,data:I},{type:12,data:t.blockSize}],P=[l,a,u/b],G=_.convertShape(e[1].dims).slice();G.splice(-1,1,f/y),z.push(...k(P)),z.push(...k(G)),z.push(...k(e[2].dims)),e.length===4&&z.push(...k(_.convertShape(e[3].dims)));let J=[l,a,d/x];z.push(...k(J));let ne=Q=>{let se=P.length,O=S(\"a\",e[0].dataType,se,b),Y=S(\"b\",12,G.length,y),K=S(\"scales\",e[2].dataType,e[2].dims.length),q=[O,Y,K],M=e.length===4?S(\"zero_points\",12,e[3].dims.length):void 0;M&&q.push(M);let H=J.length,V=A(\"output\",e[0].dataType,H,x),me=[{name:\"output_size\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}],C=X(e[0].dataType),B=(()=>{switch(b){case 1:return`array<${C}, 8>`;case 2:return`mat4x2<${C}>`;case 4:return`mat2x4<${C}>`;default:throw new Error(`${b}-component is not supported.`)}})(),F=`\n        for (var word: u32 = 0; word < ${f}; word += ${y}) {\n          ${Y.indicesSet(\"b_indices\",\"2\",\"word\")};\n          let b_data = ${Y.getByIndices(\"b_indices\")};\n          for (var i: u32 = 0; i < ${y}; i++) {\n            let b_value: u32 = ${y===1?\"b_data\":\"b_data[word + i]\"};\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            let b_value_lower: vec4<u32> = unpack4xU8(b_value & b_mask);\n            let b_value_upper: vec4<u32> = unpack4xU8((b_value >> 4) & b_mask);\n            let b_quantized_values = ${B}(${Array.from({length:4},(fe,ue)=>`${C}(b_value_lower[${ue}]), ${C}(b_value_upper[${ue}])`).join(\", \")});\n            let b_dequantized_values = ${(()=>b===1?`${B}(${Array.from({length:8},(fe,ue)=>`(b_quantized_values[${ue}] - zero_point) * scale`).join(\", \")});`:`(b_quantized_values - ${B}(${Array(8).fill(\"zero_point\").join(\",\")})) * scale;`)()};\n            // Number of B elements per 32-bit word is 32/bits = 32/4 = 8\n            for (var m: u32 = 0; m < ${v?a:h}u; m++) {\n              ${O.indicesSet(\"a_indices\",se-2,v?\"m\":`row * ${h} + m`)};\n              ${O.indicesSet(\"a_indices\",se-1,\"word_offset\")};\n              var input_offset = ${O.indicesToOffset(\"a_indices\")};\n              var a_data: ${B};\n              for (var j: u32 = 0; j < ${8/b}; j++) {\n                a_data[j] = ${O.getByOffset(\"input_offset\")};\n                input_offset++;\n              }\n              ${v?\"workgroup_shared[workgroup_shared_offset + m]\":\"output_values[m]\"}${x>1?\"[c]\":\"\"} += ${Array.from({length:8/b},(fe,ue)=>`${b===1?`a_data[${ue}] * b_dequantized_values[${ue}]`:`dot(a_data[${ue}], b_dequantized_values[${ue}])`}`).join(\" + \")};\n            }\n            word_offset += ${8/b};\n          }\n        }`,Ie=M?`\n          zero_point_offset += 4;\n          if (zero_point_offset == 32) {\n            zero_point_offset = 0;\n            zero_point_index++;\n            zero_point_word = ${M.getByOffset(\"zero_point_index\")};\n          }`:\"\";return v?`\n        var<workgroup> workgroup_shared: array<${V.type.value}, ${a*s}>;\n        ${Q.declareVariables(...q,V)}\n        ${Q.mainStart([s,1,1])}\n          var a_indices: ${O.type.indices};\n          var block = local_id.x;\n          var col = workgroup_id.y;\n          var batch = workgroup_id.z;\n          ${O.indicesSet(\"a_indices\",\"0\",\"batch\")};\n          // Two zero points are packed into one byte when uniforms.bits is 4.\n          for (var c: u32 = 0; c < ${x}; c++) {\n            let col_times_components_plus_c = col * ${x} + c;\n              ${M?`\n            var zero_point_bytes_per_col: u32 = (${s} + 1) / 2;\n            var zero_point_byte_count: u32 = col_times_components_plus_c * zero_point_bytes_per_col + (block >> 0x1u);\n            var zero_point_word_index: u32 = zero_point_byte_count >> 0x2u;\n            var zero_point_byte_offset: u32 = zero_point_byte_count & 0x3u;\n            var zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32 = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            var zero_point_word: u32 = ${M.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;`:\"\"}\n            var b_indices: ${Y.type.indices};\n            ${Y.indicesSet(\"b_indices\",\"0\",\"col_times_components_plus_c\")};\n            // The scale and zero points are computed per block.\n            var scales_index = col_times_components_plus_c * ${s} + block;\n            let scale = ${K.getByOffset(\"scales_index\")};\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${C}(${M?\"(zero_point_word) & 0xFu\":8});\n            ${Y.indicesSet(\"b_indices\",\"1\",\"block\")};\n            var word_offset: u32 = block * ${t.blockSize/b};\n            var workgroup_shared_offset: u32 = block * ${a};\n            ${F}\n          }\n          workgroupBarrier();\n          var output_indices: ${V.type.indices};\n          var elements_per_thread: u32 = ${Math.ceil(a/s)};\n          ${V.indicesSet(\"output_indices\",\"0\",\"batch\")};\n          ${V.indicesSet(\"output_indices\",H-1,\"col\")};\n          ${V.indicesSet(\"output_indices\",H-2,\"local_id.x * elements_per_thread\")};\n          var output_offset = ${V.indicesToOffset(\"output_indices\")};\n          for (var m: u32 = 0u; m < elements_per_thread; m++) {\n            var row = m + local_id.x * elements_per_thread;\n            if (row < ${a}) {\n              var output_value: ${V.type.value} = ${V.type.value}(0);\n              var workgroup_shared_offset: u32 = row;\n              for (var b: u32 = 0u; b < ${s}u; b++) {\n                output_value += workgroup_shared[workgroup_shared_offset];\n                workgroup_shared_offset += ${a};\n              }\n              ${V.setByOffset(\"output_offset\",\"output_value\")};\n              output_offset += ${d/x};\n            }\n          }\n        }`:`\n        ${Q.registerUniforms(me).declareVariables(...q,V)}\n        ${Q.mainStart()}\n          ${Q.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          var output_values: array<${V.type.value}, ${h}>;\n          var output_indices = ${V.offsetToIndices(\"global_idx\")};\n          var col = ${V.indicesGet(\"output_indices\",H-1)};\n          var row = ${V.indicesGet(\"output_indices\",H-2)};\n          var a_indices: ${O.type.indices} = output_indices;\n          // Two zero points are packed into one byte because uniforms.bits <= 4.\n          // zero_point_offset is either 0 or 4. It is bit offset within one byte.\n          // TODO support zero_point_offset for bits > 4\n          ${M?`\n          var zero_point_abs_offset = col * ${x} * ((${s} + 1) / 2);\n          var zero_point_index: u32 = zero_point_abs_offset / 4;\n          var zero_point_word: u32 = ${M.getByOffset(\"zero_point_index\")};\n          var zero_point_offset: u32 = (zero_point_abs_offset % 4) * 8;`:\"\"}\n          var scale_index = col * ${s*x};\n          var b_indices: ${Y.type.indices};\n          for (var c: u32 = 0; c < ${x}; c++) {\n            ${Y.indicesSet(\"b_indices\",\"0\",`col * ${x} + c`)};\n            var block_offset: u32 = 0;\n            for (var block: u32 = 0; block < ${s}; block++) {\n              // The scale and zero points are computed per block.\n              let scale = ${K.getByOffset(\"scale_index\")};\n              // The default zero point is 8 for unsigned 4-bit quantization.\n              let zero_point = ${C}(${M?\"extractBits(zero_point_word, zero_point_offset, 4)\":8});\n              ${Y.indicesSet(\"b_indices\",\"1\",\"block\")};\n              var word_offset: u32 = block_offset;\n              ${F}\n              scale_index++;\n              ${Ie}\n              block_offset += uniforms.block_size / ${b};\n            }\n            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.\n            ${M?`if (zero_point_offset % 8 > 0) {\n                ${Ie}\n              }`:\"\"}\n            }\n            for (var k: u32 = 0u; k < ${h}u; k++) {\n              ${V.indicesSet(\"output_indices\",H-2,`${h} * row + k`)};\n              ${V.setByIndices(\"output_indices\",\"output_values[k]\")}\n            }\n        }`};return{name:v?\"BlockwiseMatMulNBits\":\"MatMulNBits\",shaderCache:{hint:`${t.cacheKey};${a};${m};${e.length}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:T,dataType:m}],name:v?\"BlockwiseMatMulNBits\":\"MatMulNBits\",dispatchGroup:v?{x:1,y:Math.ceil(d/x),z:l}:{x:Math.ceil(I/64)},programUniforms:z}),getShaderSource:ne}},Rs=(e,t)=>{tl(e.inputs,t);let r=e.getMaxComputeWorkgroupSizes(),n=e.getMaxComputeWorkgroupStoragesize();e.compute(rl(e.inputs,t,r,n))},Ms=e=>U(e)});var nl,ol,il,sl,al,ul,dl,ll,Vs,Ns=E(()=>{\"use strict\";R();L();W();nl=e=>{if(!e||e.length<1)throw new Error(\"Too few inputs\");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error(\"Input type must be float or float16.\");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error(\"The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].\")}},ol=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n            k = i32(${e.indicesGet(\"indices\",o)}) - ${D(\"uniforms.pads\",o,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${D(\"uniforms.x_shape\",o,t)})) {\n              break;\n            }\n            offset += k * i32(${D(\"uniforms.x_strides\",o,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${n}\n            value = x[offset];\n          }\n      `},il=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${D(\"uniforms.pads\",o,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${D(\"uniforms.x_shape\",o,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${D(\"uniforms.x_shape\",o,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${D(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},sl=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${D(\"uniforms.pads\",o,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${D(\"uniforms.x_shape\",o,t)})) {\n                  k = i32(${D(\"uniforms.x_shape\",o,t)}) - 1;\n                }\n                offset += k * i32(${D(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},al=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${D(\"uniforms.pads\",o,r)};\n                if (k < 0)  {\n                  k += i32(${D(\"uniforms.x_shape\",o,t)}]);\n                }\n                if (k >= i32(${D(\"uniforms.x_shape\",o,t)})) {\n                  k -= i32(${D(\"uniforms.x_shape\",o,t)});\n                }\n                offset += k * i32(${D(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},ul=(e,t,r)=>{switch(r.mode){case 0:return ol(e,t,r.pads.length);case 1:return il(e,t,r.pads.length);case 2:return sl(e,t,r.pads.length);case 3:return al(e,t,r.pads.length);default:throw new Error(\"Invalid mode\")}},dl=(e,t)=>{let r=_.padShape(e[0].dims.slice(),t.pads),n=e[0].dims,o=_.size(r),i=[{type:12,data:o},{type:6,data:t.pads}];t.mode===0&&i.push({type:e[0].dataType,data:t.value}),i.push(...k(e[0].dims,r));let s=[\"rank\"],a=u=>{let d=A(\"output\",e[0].dataType,r.length),c=S(\"x\",e[0].dataType,n.length),l=c.type.value,p=ul(d,n.length,t),f=[{name:\"output_size\",type:\"u32\"},{name:\"pads\",type:\"i32\",length:t.pads.length}];return t.mode===0&&f.push({name:\"constant_value\",type:l}),`\n            ${u.registerUniforms(f).declareVariables(c,d)}\n            ${u.mainStart()}\n            ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n            let indices = ${d.offsetToIndices(\"global_idx\")};\n\n            var value = ${l}(0);\n            ${p}\n            output[global_idx] = value;\n        }`};return{name:\"Pad\",shaderCache:{hint:`${t.mode}`,inputDependencies:s},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(_.size(r)/64)},programUniforms:i}),getShaderSource:a}},ll=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),n=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,o=e[0].dims.length,i=new Int32Array(2*o).fill(0);if(e.length>=4){let a=e[3].getBigInt64Array();for(let u=0;u<a.length;u++)i[Number(a[u])]=Number(r[u]),i[Number(a[u])+o]=Number(r[u+a.length])}else r.forEach((a,u)=>i[Number(u)]=Number(a));let s=[];return i.forEach(a=>s.push(a)),{mode:t.mode,value:n,pads:s}}else return t},Vs=(e,t)=>{nl(e.inputs);let r=ll(e.inputs,t);e.compute(dl(e.inputs,r),{inputs:[0]})}});var tr,Ws,Gs,Ls,Hs,cl,pl,qs,Fs,Ks,js,Zs,Ys,Qs,Xs,Js,ea,ta,ra,na=E(()=>{\"use strict\";_e();R();L();W();tr=e=>{if(j.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error(\"Pool ops requires 1 input.\")},Ws=(e,t,r)=>{let n=t.format===\"NHWC\",o=e.dims.slice();n&&o.splice(1,0,o.pop());let i=Object.hasOwnProperty.call(t,\"dilations\"),s=t.kernelShape.slice(),a=t.strides.slice(),u=i?t.dilations.slice():[],d=t.pads.slice();Fe.adjustPoolAttributes(r,o,s,a,u,d);let c=Fe.computePoolOutputShape(r,o,a,u,s,d,t.autoPad),l=Object.assign({},t);i?Object.assign(l,{kernelShape:s,strides:a,pads:d,dilations:u,cacheKey:t.cacheKey}):Object.assign(l,{kernelShape:s,strides:a,pads:d,cacheKey:t.cacheKey});let p=c.slice();return p.push(p.splice(1,1)[0]),[l,n?p:c]},Gs=(e,t)=>{let r=t.format===\"NHWC\",n=_.size(e),o=_.size(t.kernelShape),i=[{type:12,data:n},{type:12,data:o}],s=[{name:\"outputSize\",type:\"u32\"},{name:\"kernelSize\",type:\"u32\"}];if(t.kernelShape.length<=2){let a=t.kernelShape[t.kernelShape.length-1],u=t.strides[t.strides.length-1],d=t.pads[t.pads.length/2-1],c=t.pads[t.pads.length-1],l=!!(d+c);i.push({type:12,data:a},{type:12,data:u},{type:12,data:d},{type:12,data:c}),s.push({name:\"kw\",type:\"u32\"},{name:\"sw\",type:\"u32\"},{name:\"pwStart\",type:\"u32\"},{name:\"pwEnd\",type:\"u32\"});let p=!1;if(t.kernelShape.length===2){let f=t.kernelShape[t.kernelShape.length-2],m=t.strides[t.strides.length-2],h=t.pads[t.pads.length/2-2],b=t.pads[t.pads.length-2];p=!!(h+b),i.push({type:12,data:f},{type:12,data:m},{type:12,data:h},{type:12,data:b}),s.push({name:\"kh\",type:\"u32\"},{name:\"sh\",type:\"u32\"},{name:\"phStart\",type:\"u32\"},{name:\"phEnd\",type:\"u32\"})}return[i,s,!0,l,p]}else{if(r)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let a=_.computeStrides(t.kernelShape);i.push({type:12,data:a},{type:12,data:t.pads},{type:12,data:t.strides}),s.push({name:\"kernelStrides\",type:\"u32\",length:a.length},{name:\"pads\",type:\"u32\",length:t.pads.length},{name:\"strides\",type:\"u32\",length:t.strides.length});let u=t.pads.reduce((d,c)=>d+c);return[i,s,!!u,!1,!1]}},Ls=(e,t,r,n,o,i,s,a,u,d,c,l)=>{let p=o.format===\"NHWC\",f=t.type.value,m=A(\"output\",t.type.tensor,n);if(o.kernelShape.length<=2){let h=\"\",b=\"\",y=\"\",g=r-(p?2:1);if(c?h=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${g}] = indices[${g}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${g}] < 0 || xIndices[${g}]\n                      >= uniforms.x_shape[${g}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${i}\n                }`:h=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${g}] = indices[${g}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${i}\n                }`,o.kernelShape.length===2){let $=r-(p?3:2);l?b=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${$}] = indices[${$}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${$}] < 0 || xIndices[${$}] >= uniforms.x_shape[${$}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:b=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${$}] = indices[${$}] * uniforms.sh - uniforms.phStart + j;\n                `,y=`\n              }\n            `}return`\n            ${e.registerUniforms(u).declareVariables(t,m)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n              let indices = ${m.offsetToIndices(\"global_idx\")};\n              var xIndices = ${m.offsetToIndices(\"global_idx\")};\n\n              var value = ${f}(${a});\n              var pad = 0;\n              ${b}\n              ${h}\n              ${y}\n              ${s}\n\n              output[global_idx] = value;\n            }`}else{if(p)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let h=o.kernelShape.length,b=o.pads.length,y=\"\";return d?y=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                ${i}\n              }`:y=`\n              }\n              let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n              ${i}\n            `,`\n            ${e.registerUniforms(u).declareVariables(t,m)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n              let indices = ${m.offsetToIndices(\"global_idx\")};\n              var xIndices = ${m.offsetToIndices(\"global_idx\")};\n\n              var offsets: array<u32, ${h}>;\n\n              var value = ${f}(${a});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${h-1}u; j++) {\n                  offsets[j] = offset / ${D(\"uniforms.kernelStrides\",\"j\",h)};\n                  offset -= offsets[j] * ${D(\"uniforms.kernelStrides\",\"j\",h)};\n                }\n                offsets[${h-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-h}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${D(\"uniforms.strides\",`j - ${r-h}u`,h)}\n                    + offsets[j - ${r-h}u] - ${D(\"uniforms.pads\",\"j - 2u\",b)};\n                  ${y}\n              }\n              ${s}\n\n              output[global_idx] = value;\n            }`}},Hs=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,cl=e=>`${Hs(e)};${e.countIncludePad}`,pl=e=>`${Hs(e)};${e.storageOrder};${e.dilations}`,qs=e=>({format:e.format,autoPad:[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Fs=(e,t,r,n)=>{let[o,i]=Ws(t,n,r),s=S(\"x\",t.dataType,t.dims.length),a=s.type.value,u=\"value += x_val;\",d=\"\";o.countIncludePad?d+=`value /= ${a}(uniforms.kernelSize);`:d+=`value /= ${a}(i32(uniforms.kernelSize) - pad);`;let[c,l,p,f,m]=Gs(i,o);c.push(...k(t.dims,i));let h=[\"rank\"];return{name:e,shaderCache:{hint:`${n.cacheKey};${p};${f};${m}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(_.size(i)/64)},programUniforms:c}),getShaderSource:b=>Ls(b,s,t.dims.length,i.length,o,u,d,0,l,p,f,m)}},Ks=e=>{let t=e.count_include_pad!==0,r=qs(e);if(r.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");let n={countIncludePad:t,...r,cacheKey:\"\"};return{...n,cacheKey:cl(n)}},js=(e,t)=>{tr(e.inputs),e.compute(Fs(\"AveragePool\",e.inputs[0],!1,t))},Zs={autoPad:\"\",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Ys=e=>{let t=e.format;return{format:t,...Zs,cacheKey:t}},Qs=(e,t)=>{tr(e.inputs),e.compute(Fs(\"GlobalAveragePool\",e.inputs[0],!0,t))},Xs=(e,t,r,n)=>{let[o,i]=Ws(t,n,r),s=`\n      value = max(x_val, value);\n    `,a=\"\",u=S(\"x\",t.dataType,t.dims.length),d=[\"rank\"],[c,l,p,f,m]=Gs(i,o);return c.push(...k(t.dims,i)),{name:e,shaderCache:{hint:`${n.cacheKey};${p};${f};${m}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(_.size(i)/64)},programUniforms:c}),getShaderSource:h=>Ls(h,u,t.dims.length,i.length,o,s,a,t.dataType===10?-65504:-1e5,l,p,f,m)}},Js=(e,t)=>{tr(e.inputs),e.compute(Xs(\"MaxPool\",e.inputs[0],!1,t))},ea=e=>{let t=e.storage_order,r=e.dilations,n=qs(e);if(t!==0)throw new Error(\"column major storage order is not yet supported for MaxPool\");if(n.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");let o={storageOrder:t,dilations:r,...n,cacheKey:\"\"};return{...o,cacheKey:pl(o)}},ta=e=>{let t=e.format;return{format:t,...Zs,cacheKey:t}},ra=(e,t)=>{tr(e.inputs),e.compute(Xs(\"GlobalMaxPool\",e.inputs[0],!0,t))}});var fl,hl,oa,ia=E(()=>{\"use strict\";_e();R();W();fl=(e,t,r)=>{let n=e===t,o=e<t&&r<0,i=e>t&&r>0;if(n||o||i)throw new Error(\"Range these inputs' contents are invalid.\")},hl=(e,t,r,n)=>{let o=Math.abs(Math.ceil((t-e)/r)),i=[o],s=o,a=[{type:12,data:s},{type:n,data:e},{type:n,data:r},...k(i)],u=d=>{let c=A(\"output\",n,i.length),l=c.type.value,p=[{name:\"outputSize\",type:\"u32\"},{name:\"start\",type:l},{name:\"delta\",type:l}];return`\n        ${d.registerUniforms(p).declareVariables(c)}\n        ${d.mainStart()}\n        ${d.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        output[global_idx] = uniforms.start + ${l}(global_idx) * uniforms.delta;\n      }`};return{name:\"Range\",shaderCache:{hint:`${n}`},getShaderSource:u,getRunData:()=>({outputs:[{dims:i,dataType:n}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:a})}},oa=e=>{let t=0,r=0,n=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],n=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],n=e.inputs[2].getFloat32Array()[0]),j.webgpu.validateInputContent&&fl(t,r,n),e.compute(hl(t,r,n,e.inputs[0].dataType),{inputs:[]})}});var gl,yl,bl,wl,$l,vl,_l,Sl,xl,Il,Tl,sa,Cl,Al,El,kl,Pl,aa,ua,da=E(()=>{\"use strict\";R();L();ae();W();gl=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error(\"Resize requires scales input values to be positive\")})),e.length>0){if(t.mode===\"linear\"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode===\"cubic\"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error(\"Resize requires scales input size to be 2 or 4 for cubic mode\")}},yl=(e,t,r)=>{t.every(o=>o>=0&&o<r||(()=>{throw new Error(\"Resize requires axes input values to be positive and less than rank\")}));let n=new Array(r).fill(1);return t.forEach((o,i)=>n[o]=e[i]),n},bl=(e,t,r,n,o,i)=>{let[s,a,u]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],d=e[0].dims.length;if(s>0&&e.length>s&&e[s].dims.length>0)e[s].getFloat32Array().forEach(c=>i.push(c));else if(t.coordinateTransformMode===\"tf_crop_and_resize\")throw new Error(\"Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize\");if(a>0&&e.length>a&&e[a].dims.length>0){if(e[a].getFloat32Array().forEach(c=>n.push(c)),n.length!==0&&n.length!==d&&r>=18&&n.length!==t.axes.length)throw new Error(\"Resize requires scales input size to be same as input rank or axes size for opset 18 and up\");gl(n,t),t.axes.length>0&&yl(n,t.axes,d).forEach((c,l)=>n[l]=c)}if(u>0&&e.length>u&&(e[u].getBigInt64Array().forEach(c=>o.push(Number(c))),o.length!==d||r>=18&&o.length===t.axes.length))throw new Error(\"Resize requires sizes input size to be same as input rank or axes size for opset 18 and up\");if(t.axes.length>0){if(n.length!==t.axes.length)throw new Error('Resize requires \"scales\" input size to be of axes rank when axes attributes is specified');if(o.length!==t.axes.length)throw new Error('Resize requires \"sizes\" input size to be of rank axes rank when axes attributes is specified')}if(typeof n<\"u\"&&typeof o<\"u\"&&n.length>0&&o.length>d)throw new Error(\"Resize requires only of scales or sizes to be specified\")},wl=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case\"asymmetric\":return`return ${t}(xResized) / ${t}(xScale);`;case\"pytorch_half_pixel\":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case\"tf_half_pixel_for_nn\":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case\"align_corners\":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\n                    return whole + fract;\n                  }`;case\"tf_crop_and_resize\":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case\"half_pixel_symmetric\":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case\"half_pixel\":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+\"}\",$l=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case\"round_prefer_ceil\":return\"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }\";case\"floor\":return\"return floor(xOriginal);\";case\"ceil\":return\"return ceil(xOriginal);\";case\"round_prefer_floor\":return\"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }\";case\"simple\":default:if(t<11)return\"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }\";throw new Error(`Nearest mode ${e} is not supported`)}})()+\"}\",vl=(e,t,r)=>{let n=new Array(r).fill(0).concat(new Array(r).fill(1)),o=e.length===0?n:e.slice();return t.length>0?(t.forEach((i,s)=>{n[i]=o[s],n[s+r]=o[t.length+s]}),n):o},_l=(e,t,r,n)=>{let o=[];if(r.length>0)if(n.length>0){if(e.forEach(i=>o.push(i)),Math.max(...n)>e.length)throw new Error(\"axes is out of bound\");n.forEach((i,s)=>o[i]=r[s])}else r.forEach(i=>o.push(i));else{if(t.length===0)throw new Error(\"Resize requires either scales or sizes.\");o=e.map((i,s)=>Math.round(i*t[s]))}return o},Sl=(e,t,r)=>{let n=(()=>{switch(r.keepAspectRatioPolicy){case\"not_larger\":return r.axes.length>0?Math.min(...r.axes.map(i=>t[i]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case\"not_smaller\":return r.axes.length>0?Math.max(...r.axes.map(i=>t[i]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let o=e.slice();return r.axes.length>0?(r.axes.forEach(i=>t[i]=n),r.axes.forEach(i=>o[i]=Math.round(e[i]*t[i]))):(t.fill(n,0,t.length),o.forEach((i,s)=>o[s]=Math.round(i*t[s]))),o},xl=(e,t,r,n,o)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet(\"output_indices\",\"i\")};\n        var scale = ${D(\"uniforms.scales\",\"i\",n)};\n        var roi_low = ${D(\"uniforms.roi\",\"i\",o)};\n        var roi_hi = ${D(\"uniforms.roi\",`i + ${t.length}`,o)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${D(\"uniforms.input_shape\",\"i\",t.length)};\n          var output_shape_i = ${D(\"uniforms.output_shape\",\"i\",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Il=(e,t,r,n,o,i,s)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n        var input_index: u32;\n        var scale = ${D(\"uniforms.scales\",\"i\",o)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${D(\"uniforms.roi\",\"i\",i)};\n          var roi_hi = ${D(\"uniforms.roi\",`i + ${r.length}`,i)};\n          var input_shape_i = ${D(\"uniforms.input_shape\",\"i\",r.length)};\n          var output_shape_i = ${D(\"uniforms.output_shape\",\"i\",n.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${s} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet(\"input_indices\",\"i\",\" input_index\")}\n      }\n      return input_indices;\n    }`,Tl=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet(\"input_indices\",\"i\")};\n        if (input_index < 0 || input_index >= ${D(\"uniforms.input_shape\",\"i\",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,sa=(e,t,r,n)=>e.rank>n?`\n    ${e.indicesSet(\"input_indices\",t,\"channel\")};\n    ${e.indicesSet(\"input_indices\",r,\"batch\")};\n`:\"\",Cl=(e,t,r,n,o)=>{let[s,a,u,d]=r.length===2?[-1,0,1,-1]:[0,2,3,1],c=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${c} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",a,`max(0, min(row, ${r[a]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",u,`max(0, min(col, ${r[u]} - 1))`)};\n      ${sa(e,d,s,2)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${c} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${c} = originalIndices[${a}];\n      var col:${c} = originalIndices[${u}];\n      ${n?`if (row < 0 || row > (${r[a]} - 1) || col < 0 || col > (${r[u]} - 1)) {\n        return ${o};\n      }`:\"\"};\n      row = max(0, min(row, ${r[a]} - 1));\n      col = max(0, min(col, ${r[u]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${d}])`:\"0\"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${s}])`:\"0\"};\n      var x11: ${c} = getInputValue(batch, channel, row1, col1);\n      var x12: ${c} = getInputValue(batch, channel, row1, col2);\n      var x21: ${c} = getInputValue(batch, channel, row2, col1);\n      var x22: ${c} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${c} = abs(row - ${c}(row1));\n      var dx2: ${c} = abs(${c}(row2) - row);\n      var dy1: ${c} = abs(col - ${c}(col1));\n      var dy2: ${c} = abs(${c}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Al=(e,t,r,n,o,i,s,a,u,d)=>{let c=r.length===2,l=!0,[p,f]=c?[0,1]:l?[2,3]:[1,2],m=e.type.value,h=b=>{let y=b===p?\"row\":\"col\";return`\n      fn ${y}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${m} {\n        var output_index = ${t.indicesGet(\"output_indices\",b)};\n        var originalIdx: ${m} = getOriginalCoordinateFromResizedCoordinate(output_index, ${o[b]},\n        ${n[b]}, ${r[b]}, ${i[b]}, ${i[b]} + ${r.length});\n        var fractOriginalIdx: ${m} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${a} && (originalIdx < 0 || originalIdx > (${r[b]} - 1))) {\n          return ${u};\n        }\n        var data: array<${m}, 4> = array<${m}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${y}: ${m} = originalIdx + ${m}(i);\n          if (${y} < 0 || ${y} >= ${r[b]}) {\n            ${(()=>d?`coefs[i + 1] = 0.0;\n                        continue;`:a?`return ${u};`:`${y} = max(0, min(${y}, ${r[b]} - 1));`)()};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet(\"input_indices_copy\",b,`u32(${y})`)};\n          data[i + 1] = ${b===p?e.getByIndices(\"input_indices_copy\"):\"rowCubicInterpolation(input_indices_copy, output_indices)\"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${h(p)};\n    ${h(f)};\n  fn getCubicInterpolationCoefs(s: ${m}) -> array<${m}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${m}, 4> = array<${m}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${m} = 1.0 - absS;\n    var twoMinusAbsS: ${m} = 2.0 - absS;\n    var onePlusAbsS: ${m} = 1.0 + absS;\n    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};\n    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${m}, 4>, coefs: array<${m}, 4>) -> ${m} {\n    var coefsSum: ${m} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${m} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},El=(e,t,r,n,o)=>{let[s,a,u,d,c]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],l=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${l} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",a,`max(0, min(depth, ${r[a]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",u,`max(0, min(height, ${r[u]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(width, ${r[d]} - 1))`)};\n      ${sa(e,c,s,3)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${l} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${l} = originalIndices[${a}];\n      var height:${l} = originalIndices[${u}];\n      var width:${l} = originalIndices[${d}];\n      ${n?`if (depth < 0 || depth > (${r[a]} - 1) || height < 0 || height > (${r[u]} - 1) || width < 0 || (width > ${r[d]} - 1)) {\n      return ${o};\n        }`:\"\"};\n\n    depth = max(0, min(depth, ${r[a]} - 1));\n      height = max(0, min(height, ${r[u]} - 1));\n      width = max(0, min(width, ${r[d]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${c}])`:\"0\"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${s}])`:\"0\"};\n\n      var x111: ${l} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${l} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${l} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${l} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${l} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${l} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${l} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${l} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${l} = abs(depth - ${l}(depth1));\n      var dx2: ${l} = abs(${l}(depth2) - depth);\n      var dy1: ${l} = abs(height - ${l}(height1));\n      var dy2: ${l} = abs(${l}(height2) - height);\n      var dz1: ${l} = abs(width - ${l}(width1));\n      var dz2: ${l} = abs(${l}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},kl=(e,t,r,n,o,i)=>{let s=e.dims,a=vl(i,t.axes,s.length),u=_l(s,n,o,t.axes),d=n.slice();n.length===0&&(d=s.map((g,w)=>g===0?1:u[w]/g),t.keepAspectRatioPolicy!==\"stretch\"&&(u=Sl(s,d,t)));let c=A(\"output\",e.dataType,u.length),l=S(\"input\",e.dataType,s.length),p=_.size(u),f=s.length===u.length&&s.every((g,w)=>g===u[w]),m=t.coordinateTransformMode===\"tf_crop_and_resize\",h=t.extrapolationValue,b=l.type.value,y=g=>`\n      ${f?\"\":`\n      ${wl(t.coordinateTransformMode,b)};\n      ${(()=>{switch(t.mode){case\"nearest\":return`\n              ${Tl(l,s)};\n              ${$l(t.nearestMode,r,b)};\n              ${Il(l,c,s,u,d.length,a.length,m)};\n              `;case\"linear\":return`\n              ${xl(c,s,u,d.length,a.length)};\n              ${(()=>{if(s.length===2||s.length===4)return`${Cl(l,c,s,m,h)}`;if(s.length===3||s.length===5)return`${El(l,c,s,m,h)}`;throw Error(\"Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.\")})()};\n            `;case\"cubic\":return`\n            ${(()=>{if(s.length===2||s.length===4)return`${Al(l,c,s,u,d,a,t.cubicCoeffA,m,t.extrapolationValue,t.excludeOutside)}`;throw Error(\"Cubic mode only supports input dims 2 and 4 are supported in linear mode.\")})()};\n            `;default:throw Error(\"Invalid resize mode\")}})()};\n      `}\n      ${g.registerUniform(\"output_size\",\"u32\").registerUniform(\"scales\",\"f32\",d.length).registerUniform(\"roi\",\"f32\",a.length).declareVariables(l,c)}\n      ${g.mainStart()}\n        ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n        ${f?\"output[global_idx] = input[global_idx];\":`\n        let output_indices = ${c.offsetToIndices(\"global_idx\")};\n        var input_indices: ${l.type.indices};\n        ${(()=>{switch(t.mode){case\"nearest\":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${l.getByIndices(\"input_indices\")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case\"linear\":return`output[global_idx] = ${s.length===2||s.length===4?\"bilinearInterpolation\":\"trilinearInterpolation\"}(output_indices);`;case\"cubic\":return\"output[global_idx] = bicubicInterpolation(output_indices);\";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:\"Resize\",shaderCache:{hint:`${t.cacheKey}|${r}|${d.length>0?d:\"\"}|${o.length>0?o:\"\"}|${a.length>0?a:\"\"}|${f}|${s}`,inputDependencies:[\"rank\"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:u,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:[{type:12,data:p},{type:1,data:d},{type:1,data:a},...k(s,u)]})}},Pl=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},aa=(e,t)=>{let r=[],n=[],o=[],i=Pl(e);if(t.antialias!==0)throw Error(\"Only default value (0) for Antialias attribute is supported\");bl(e.inputs,t,i,r,n,o),e.compute(kl(e.inputs[0],t,i,r,n,o),{inputs:[0]})},ua=e=>{let t=e.antialias,r=e.axes,n=e.coordinateTransformMode,o=e.cubicCoeffA,i=e.excludeOutside!==0,s=e.extrapolationValue,a=e.keepAspectRatioPolicy,u=e.mode,d=e.nearestMode===\"\"?\"simple\":e.nearestMode;return U({antialias:t,axes:r,coordinateTransformMode:n,cubicCoeffA:o,excludeOutside:i,extrapolationValue:s,keepAspectRatioPolicy:a,mode:u,nearestMode:d})}});var zl,Ol,la,ca=E(()=>{\"use strict\";R();L();ae();W();zl=(e,t)=>{let[r,n,o,i]=e,{numHeads:s,rotaryEmbeddingDim:a}=t;if(r.dims.length!==3&&r.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);if(!_.areEqual(n.dims,[])&&!_.areEqual(n.dims,[1])&&n.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${n.dims.length}`);if(o.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${o.dims.length}`);if(i.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${i.dims.length}`);if(!_.areEqual(o.dims,i.dims))throw new Error(\"Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape\");if(a>0&&s===0)throw new Error(\"num_heads must be provided if rotary_embedding_dim is specified\");let u=r.dims[0],d=r.dims[r.dims.length-2],c=o.dims[0],l=_.sizeFromDimension(r.dims,1)/d,p=a===0?o.dims[1]*2:l/s;if(a>p)throw new Error(\"rotary_embedding_dim must be less than or equal to head_size\");if(n.dims.length===2){if(u!==n.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${n.dims[0]}`);if(d!==n.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${n.dims[1]}`)}if(p/2!==o.dims[1]&&a/2!==o.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${o.dims[1]}`);if(d>c)throw new Error(\"Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported\")},Ol=(e,t)=>{let{interleaved:r,numHeads:n,rotaryEmbeddingDim:o,scale:i}=t,s=e[0].dims[0],a=_.sizeFromDimension(e[0].dims,1),u=e[0].dims[e[0].dims.length-2],d=a/u,c=e[2].dims[1],l=o===0?c*2:d/n,p=new Array(s,u,d/l,l-c),f=_.computeStrides(p),m=[{type:1,data:i},{type:12,data:p},{type:12,data:f},...e[0].dims.length===3?new Array({type:12,data:[a,d,l,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[a,l,u*l,1]}):[],...k(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],h=b=>{let y=S(\"input\",e[0].dataType,e[0].dims.length),g=S(\"position_ids\",e[1].dataType,e[1].dims.length),w=S(\"cos_cache\",e[2].dataType,e[2].dims.length),$=S(\"sin_cache\",e[3].dataType,e[3].dims.length),v=A(\"output\",e[0].dataType,e[0].dims.length);return b.registerUniforms([{name:\"scale\",type:\"f32\"},{name:\"global_shape\",type:\"u32\",length:p.length},{name:\"global_strides\",type:\"u32\",length:f.length},{name:\"input_output_strides\",type:\"u32\",length:f.length}]),`\n        ${b.declareVariables(y,g,w,$,v)}\n\n        ${b.mainStart(Ke)}\n          let half_rotary_emb_dim = uniforms.${w.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${b.guardAgainstOutOfBoundsWorkgroupSizes(\"size\")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${g.broadcastedIndicesToOffset(\"bsnh.xy\",A(\"\",g.type.tensor,2))};\n            let position_id =\n                u32(${g.getByOffset(\"position_ids_idx\")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});\n            let j = i + select(half_rotary_emb_dim, 1, ${r});\n            let re = ${y.getByOffset(\"i\")} * ${w.get(\"position_id\",\"bsnh[3]\")} -\n                ${y.getByOffset(\"j\")} * ${$.get(\"position_id\",\"bsnh[3]\")};\n            ${v.setByOffset(\"i\",\"re\")}\n            let im = ${y.getByOffset(\"i\")} * ${$.get(\"position_id\",\"bsnh[3]\")} +\n                ${y.getByOffset(\"j\")} * ${w.get(\"position_id\",\"bsnh[3]\")};\n            ${v.setByOffset(\"j\",\"im\")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${v.setByOffset(\"k\",y.getByOffset(\"k\"))}\n          }\n        }`};return{name:\"RotaryEmbedding\",shaderCache:{hint:U({interleaved:r}).cacheKey,inputDependencies:[\"rank\",\"rank\",\"rank\",\"rank\"]},getShaderSource:h,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(_.size(p)/Ke)},programUniforms:m})}},la=(e,t)=>{zl(e.inputs,t),e.compute(Ol(e.inputs,t))}});var Bl,Dl,pa,ma=E(()=>{\"use strict\";R();L();W();Bl=e=>{if(!e||e.length<3)throw new Error(\"layerNorm requires at least 3 inputs.\");let t=e[0],r=e[1],n=e[2];if(t.dataType!==r.dataType||t.dataType!==n.dataType)throw new Error(\"All inputs must have the same data type\");if(t.dims.length!==3&&t.dims.length!==2)throw new Error(\"Input must be 2D or 3D\");if(r.dims.length!==3&&r.dims.length!==2)throw new Error(\"Skip must be 2D or 3D\");let o=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==o)throw new Error(\"Skip must have the same hidden size as input\");if(r.dims[r.dims.length-2]!==i)throw new Error(\"Skip must have the same sequence length as input\");if(n.dims.length!==1)throw new Error(\"Gamma must be 1D\");if(n.dims[n.dims.length-1]!==o)throw new Error(\"Gamma must have the same hidden size as input\");if(e.length>3){let s=e[3];if(s.dims.length!==1)throw new Error(\"Beta must be 1D\");if(s.dims[s.dims.length-1]!==o)throw new Error(\"Beta must have the same hidden size as input\")}if(e.length>4){let s=e[4];if(s.dims.length!==1)throw new Error(\"Bias must be 1D\");if(s.dims[s.dims.length-1]!==o)throw new Error(\"Bias must have the same hidden size as input\")}},Dl=(e,t,r,n)=>{let o=t.simplified,i=e[0].dims,s=_.size(i),a=i,u=s,d=i.slice(-1)[0],c=n?i.slice(0,-1).concat(1):[],l=!o&&e.length>3,p=e.length>4,f=n&&r>1,m=n&&r>2,h=r>3,b=64,y=ee(d),g=[{type:12,data:u},{type:12,data:y},{type:12,data:d},{type:1,data:t.epsilon}],w=v=>{let x=[{name:\"output_size\",type:\"u32\"},{name:\"components\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}],T=[S(\"x\",e[0].dataType,e[0].dims,y),S(\"skip\",e[1].dataType,e[1].dims,y),S(\"gamma\",e[2].dataType,e[2].dims,y)];l&&T.push(S(\"beta\",e[3].dataType,e[3].dims,y)),p&&T.push(S(\"bias\",e[4].dataType,e[4].dims,y)),T.push(A(\"output\",e[0].dataType,a,y)),f&&T.push(A(\"mean_output\",1,c)),m&&T.push(A(\"inv_std_output\",1,c)),h&&T.push(A(\"input_skip_bias_sum\",e[0].dataType,a,y));let I=X(e[0].dataType),z=X(1,y);return`\n\n      ${v.registerUniforms(x).declareVariables(...T)}\n      var<workgroup> sum_shared : array<${z}, ${b}>;\n      var<workgroup> sum_squared_shared : array<${z}, ${b}>;\n\n      ${v.mainStart([b,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / ${b};\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / ${b};\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == ${b-1}) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${p?\"bias[offset1d + i]\":I+\"(0.0)\"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${h?\"input_skip_bias_sum[offset + i] = value;\":\"\"}\n          output[offset + i] = value;\n          let f32_value = ${je(I,y,\"value\")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = ${b};\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${Te(\"sum\",y)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${Te(\"square_sum\",y)} / f32(uniforms.hidden_size) ${o?\"\":\"- mean * mean\"} + uniforms.epsilon);\n        ${f?\"mean_output[global_idx] = mean;\":\"\"}\n        ${m?\"inv_std_output[global_idx] = inv_std_dev;\":\"\"}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${o?\"\":`- ${I}(mean)`}) *\n            ${I}(inv_std_dev) * gamma[offset1d + i]\n            ${l?\"+ beta[offset1d + i]\":\"\"};\n        }\n      }`},$=[{dims:a,dataType:e[0].dataType}];return r>1&&$.push({dims:c,dataType:1}),r>2&&$.push({dims:c,dataType:1}),r>3&&$.push({dims:i,dataType:e[0].dataType}),{name:\"SkipLayerNormalization\",shaderCache:{hint:`${y};${f};${m};${h}`,inputDependencies:e.map((v,x)=>\"type\")},getShaderSource:w,getRunData:()=>({outputs:$,dispatchGroup:{x:Math.ceil(u/d)},programUniforms:g})}},pa=(e,t)=>{Bl(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(Dl(e.inputs,t,e.outputCount,!1),{outputs:n})}});var Rl,rr,Ml,fa,Ul,Vl,ha,ga,ya=E(()=>{\"use strict\";R();L();ae();W();Rl=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error(\"axes, starts and ends must have the same length\")}else if(t.starts.length!==t.ends.length)throw new Error(\"starts and ends must have the same length\");e.slice(1).forEach((r,n)=>{if(e[n+1].dataType!==6&&e[n+1].dataType!==7)throw new Error(`Input ${n} must be an array of int32 or int64`)})},rr=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(n=>r.push(Number(n)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(n=>r.push(Number(n)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Ml=(e,t)=>{if(e.length>1){let r=rr(e,1),n=rr(e,2),o=rr(e,3);return o.length===0&&(o=[...Array(e[0].dims.length).keys()]),U({starts:r,ends:n,axes:o})}else return t},fa=(e,t,r,n,o)=>{let i=e;return e<0&&(i+=r[n[t]]),o[t]<0?Math.max(0,Math.min(i,r[n[t]]-1)):Math.max(0,Math.min(i,r[n[t]]))},Ul=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${D(\"uniforms.input_shape\",\"i\",r.length)};\n            let steps_i = ${D(\"uniforms.steps\",\"i\",r.length)};\n            let signs_i = ${D(\"uniforms.signs\",\"i\",r.length)};\n            let starts_i = ${D(\"uniforms.starts\",\"i\",r.length)};\n            var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")};\n          }\n          return input_indices;\n      }`,Vl=(e,t)=>{let r=e[0].dims,n=_.size(r),o=t.axes.length>0?_.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],i=rr(e,4);i.forEach(y=>y!==0||(()=>{throw new Error(\"step cannot be 0\")})),i.length===0&&(i=Array(o.length).fill(1));let s=t.starts.map((y,g)=>fa(y,g,r,o,i)),a=t.ends.map((y,g)=>fa(y,g,r,o,i));if(o.length!==s.length||o.length!==a.length)throw new Error(\"start, ends and axes should have the same number of elements\");if(o.length!==r.length)for(let y=0;y<r.length;++y)o.includes(y)||(s.splice(y,0,0),a.splice(y,0,r[y]),i.splice(y,0,1));let u=i.map(y=>Math.sign(y));i.forEach((y,g,w)=>{if(y<0){let $=(a[g]-s[g])/y,v=s[g],x=v+$*i[g];s[g]=x,a[g]=v,w[g]=-y}});let d=r.slice(0);o.forEach((y,g)=>{d[y]=Math.ceil((a[y]-s[y])/i[y])});let c={dims:d,dataType:e[0].dataType},l=A(\"output\",e[0].dataType,d.length),p=S(\"input\",e[0].dataType,e[0].dims.length),f=_.size(d),m=[{name:\"outputSize\",type:\"u32\"},{name:\"starts\",type:\"u32\",length:s.length},{name:\"signs\",type:\"i32\",length:u.length},{name:\"steps\",type:\"u32\",length:i.length}],h=[{type:12,data:f},{type:12,data:s},{type:6,data:u},{type:12,data:i},...k(e[0].dims,d)],b=y=>`\n      ${y.registerUniforms(m).declareVariables(p,l)}\n        ${Ul(p,l,r)}\n        ${y.mainStart()}\n          ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n          let output_indices = ${l.offsetToIndices(\"global_idx\")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${l.setByOffset(\"global_idx\",p.getByIndices(\"input_indices\"))}\n      }`;return{name:\"Slice\",shaderCache:{hint:`${u.length}_${s.length}_${i.length}`,inputDependencies:[\"rank\"]},getShaderSource:b,getRunData:()=>({outputs:[c],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:h})}},ha=(e,t)=>{Rl(e.inputs,t);let r=Ml(e.inputs,t);e.compute(Vl(e.inputs,r),{inputs:[0]})},ga=e=>{let t=e.starts,r=e.ends,n=e.axes;return U({starts:t,ends:r,axes:n})}});var Nl,Wl,ba,wa,$a=E(()=>{\"use strict\";R();L();ae();W();Nl=e=>{if(!e||e.length!==1)throw new Error(\"Softmax op requires 1 input.\")},Wl=(e,t)=>{let r=e.dims,n=_.size(r),o=64,i=t.axis;if(i<0&&(i=r.length+i),i<r.length-1)throw new Error(\"softmax only supports last axis for now.\");let s=r[i],a=n/s,u=ee(s),d=s/u,c=(b,y)=>y===4?`max(max(${b}.x, ${b}.y), max(${b}.z, ${b}.w))`:y===2?`max(${b}.x, ${b}.y)`:y===3?`max(max(${b}.x, ${b}.y), ${b}.z)`:b,l=S(\"x\",e.dataType,e.dims,u),p=A(\"result\",e.dataType,e.dims,u),f=l.type.value,m=X(e.dataType)===\"f32\"?`var threadMax = ${f}(-3.402823e+38f);`:`var threadMax = ${f}(-65504.0h);`,h=b=>`\n      var<workgroup> rowMaxShared : ${f};\n      var<workgroup> rowSumShared : ${f};\n      var<workgroup> threadShared : array<${f}, ${o}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${f} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${f}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${b.registerUniform(\"packedCols\",\"i32\").declareVariables(l,p)}\n      ${b.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${o};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${m}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${f}(${c(\"threadShared[0]\",u)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${f}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${f}(${Te(\"threadShared[0]\",u)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:\"Softmax\",shaderCache:{hint:`${u}`,inputDependencies:[\"type\"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:a},programUniforms:[{type:6,data:d}]}),getShaderSource:h}},ba=(e,t)=>{Nl(e.inputs),e.compute(Wl(e.inputs[0],t))},wa=e=>U({axis:e.axis})});var Gl,Ll,Hl,ql,Fl,va,_a,Sa=E(()=>{\"use strict\";R();L();ae();W();Gl=e=>{if(!e||e.length<1)throw new Error(\"too few inputs\")},Ll=(e,t)=>{let r=[],n=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),n=r.length),U({numOutputs:n,axis:t.axis,splitSizes:r})},Hl=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${D(\"uniforms.size_in_split_axis\",\"i\",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,ql=e=>{let t=e.length,r=[];for(let n=0;n<t;++n){let o=e[n].setByIndices(\"indices\",\"input[global_idx]\");t===1?r.push(o):n===0?r.push(`if (output_number == ${n}u) { ${o} }`):n===t-1?r.push(`else { ${o} }`):r.push(`else if (output_number == ${n}) { ${o} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Fl=(e,t)=>{let r=e[0].dims,n=_.size(r),o=e[0].dataType,i=_.normalizeAxis(t.axis,r.length),s=new Array(t.numOutputs),a=S(\"input\",o,r.length),u=new Array(t.numOutputs),d=[],c=[],l=0,p=[{type:12,data:n}];for(let m=0;m<t.numOutputs;m++){l+=t.splitSizes[m],u[m]=l;let h=r.slice();h[t.axis]=t.splitSizes[m],c.push(h),s[m]=A(`output${m}`,o,h.length),d.push({dims:c[m],dataType:e[0].dataType})}p.push({type:12,data:u},...k(r,...c));let f=m=>`\n  ${m.registerUniform(\"input_size\",\"u32\").registerUniform(\"size_in_split_axis\",\"u32\",u.length).declareVariables(a,...s)}\n  ${Hl(u.length)}\n  ${ql(s)}\n\n  ${m.mainStart()}\n    ${m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.input_size\")}\n\n    var indices = ${a.offsetToIndices(\"global_idx\")};\n    var index = ${a.indicesGet(\"indices\",i)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${D(\"uniforms.size_in_split_axis\",\"output_number - 1u\",u.length)};\n      ${a.indicesSet(\"indices\",i,\"index\")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:\"Split\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\"]},getShaderSource:f,getRunData:()=>({outputs:d,dispatchGroup:{x:Math.ceil(n/64)},programUniforms:p})}},va=(e,t)=>{Gl(e.inputs);let r=e.inputs.length===1?t:Ll(e.inputs,t);e.compute(Fl(e.inputs,r),{inputs:[0]})},_a=e=>{let t=e.axis,r=e.splitSizes,n=e.numOutputs<0?r.length:e.numOutputs;if(n!==r.length)throw new Error(\"numOutputs and splitSizes lengh must be equal\");return U({axis:t,numOutputs:n,splitSizes:r})}});var Kl,jl,xa,Ia=E(()=>{\"use strict\";R();L();W();Kl=(e,t,r,n,o)=>{let i=A(\"output_data\",o,r.length,4),s=S(\"a_data\",t[1].dataType,t[1].dims.length,4),a=S(\"b_data\",t[2].dataType,t[2].dims.length,4),u=S(\"c_data\",t[0].dataType,t[0].dims.length,4),d,c=(l,p,f)=>`select(${p}, ${l}, ${f})`;if(!n)d=i.setByOffset(\"global_idx\",c(s.getByOffset(\"global_idx\"),a.getByOffset(\"global_idx\"),u.getByOffset(\"global_idx\")));else{let l=(p,f,m=\"\")=>{let h=`a_data[index_a${f}][component_a${f}]`,b=`b_data[index_b${f}][component_b${f}]`,y=`bool(c_data[index_c${f}] & (0xffu << (component_c${f} * 8)))`;return`\n            let output_indices${f} = ${i.offsetToIndices(`global_idx * 4u + ${f}u`)};\n            let offset_a${f} = ${s.broadcastedIndicesToOffset(`output_indices${f}`,i)};\n            let offset_b${f} = ${a.broadcastedIndicesToOffset(`output_indices${f}`,i)};\n            let offset_c${f} = ${u.broadcastedIndicesToOffset(`output_indices${f}`,i)};\n            let index_a${f} = offset_a${f} / 4u;\n            let index_b${f} = offset_b${f} / 4u;\n            let index_c${f} = offset_c${f} / 4u;\n            let component_a${f} = offset_a${f} % 4u;\n            let component_b${f} = offset_b${f} % 4u;\n            let component_c${f} = offset_c${f} % 4u;\n            ${p}[${f}] = ${m}(${c(h,b,y)});\n          `};o===9?d=`\n            var data = vec4<u32>(0);\n            ${l(\"data\",0,\"u32\")}\n            ${l(\"data\",1,\"u32\")}\n            ${l(\"data\",2,\"u32\")}\n            ${l(\"data\",3,\"u32\")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:d=`\n            ${l(\"output_data[global_idx]\",0)}\n            ${l(\"output_data[global_idx]\",1)}\n            ${l(\"output_data[global_idx]\",2)}\n            ${l(\"output_data[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(u,s,a,i)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${d}\n      }`},jl=e=>{let t=e[1].dims,r=e[2].dims,n=e[0].dims,o=e[1].dataType,i=!(_.areEqual(t,r)&&_.areEqual(r,n)),s=t,a=_.size(t);if(i){let d=ke.calcShape(ke.calcShape(t,r,!1),n,!1);if(!d)throw new Error(\"Can't perform where op on the given tensors\");s=d,a=_.size(s)}let u=Math.ceil(a/4);return{name:\"Where\",shaderCache:{inputDependencies:[\"rank\",\"rank\",\"rank\"]},getShaderSource:d=>Kl(d,e,s,i,o),getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(a/64/4)},programUniforms:[{type:12,data:u},...k(n,t,r,s)]})}},xa=e=>{e.compute(jl(e.inputs))}});var Ta,Ca=E(()=>{\"use strict\";Oo();Ht();Ro();Uo();_i();Oi();Ri();Ur();Yi();Ji();rs();as();ls();ps();hs();bs();vs();Ps();Os();Ds();Nr();Us();jr();Ns();na();ia();Gt();da();ca();ma();ya();$a();Sa();Yr();Ze();Kt();Ia();Ta=new Map([[\"Abs\",[Vo]],[\"Acos\",[No]],[\"Acosh\",[Wo]],[\"Add\",[Si]],[\"ArgMax\",[zo,Or]],[\"ArgMin\",[Po,Or]],[\"Asin\",[Go]],[\"Asinh\",[Lo]],[\"Atan\",[Ho]],[\"Atanh\",[qo]],[\"Attention\",[Bo]],[\"AveragePool\",[js,Ks]],[\"BatchNormalization\",[Do]],[\"BiasAdd\",[Mo]],[\"BiasSplitGelu\",[vi]],[\"Cast\",[Ko,Fo]],[\"Ceil\",[Zo]],[\"Clip\",[jo]],[\"Concat\",[Bi,Di]],[\"Conv\",[Lr,Gr]],[\"ConvTranspose\",[Zi,ji]],[\"Cos\",[Yo]],[\"Cosh\",[Qo]],[\"CumSum\",[Qi,Xi]],[\"DepthToSpace\",[es,ts]],[\"Div\",[xi]],[\"Einsum\",[is,ss]],[\"Elu\",[Xo,qt]],[\"Equal\",[Ii]],[\"Erf\",[Jo]],[\"Exp\",[ei]],[\"Expand\",[ds]],[\"FastGelu\",[cs]],[\"Floor\",[ti]],[\"FusedConv\",[Lr,Gr]],[\"Gather\",[fs,ms]],[\"GatherElements\",[ys,gs]],[\"Gelu\",[ri]],[\"Gemm\",[$s,ws]],[\"GlobalAveragePool\",[Qs,Ys]],[\"GlobalMaxPool\",[ra,ta]],[\"Greater\",[Ei]],[\"GreaterOrEqual\",[Pi]],[\"GroupQueryAttention\",[ks,Es]],[\"HardSigmoid\",[li,di]],[\"InstanceNormalization\",[zs]],[\"LayerNormalization\",[Bs]],[\"LeakyRelu\",[ni,qt]],[\"Less\",[ki]],[\"LessOrEqual\",[zi]],[\"Log\",[wi]],[\"MatMul\",[Gi]],[\"MatMulNBits\",[Rs,Ms]],[\"MaxPool\",[Js,ea]],[\"Mul\",[Ti]],[\"MultiHeadAttention\",[xs,Ss]],[\"Neg\",[ii]],[\"Not\",[oi]],[\"Pad\",[Vs]],[\"Pow\",[Ci]],[\"Range\",[oa]],[\"Reciprocal\",[si]],[\"ReduceMin\",[Io]],[\"ReduceMean\",[$o]],[\"ReduceMax\",[xo]],[\"ReduceSum\",[Co]],[\"ReduceProd\",[To]],[\"ReduceL1\",[vo]],[\"ReduceL2\",[_o]],[\"ReduceLogSum\",[Eo]],[\"ReduceLogSumExp\",[So]],[\"ReduceSumSquare\",[Ao]],[\"Relu\",[ai]],[\"Resize\",[aa,ua]],[\"RotaryEmbedding\",[la]],[\"Sigmoid\",[ui]],[\"Sin\",[ci]],[\"Sinh\",[pi]],[\"Slice\",[ha,ga]],[\"SkipLayerNormalization\",[pa]],[\"Split\",[va,_a]],[\"Sqrt\",[mi]],[\"Softmax\",[ba,wa]],[\"Sub\",[Ai]],[\"Tan\",[fi]],[\"Tanh\",[gi]],[\"ThresholdedRelu\",[bi,qt]],[\"Tile\",[Ts]],[\"Transpose\",[so,ao]],[\"Where\",[xa]]])});var nr,Aa=E(()=>{\"use strict\";_e();Me();W();nr=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,n,o,i){ve(t.programInfo.name);let s=this.backend.device,a=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let u=[];for(let c of r)u.push({binding:u.length,resource:{buffer:c.buffer}});for(let c of n)u.push({binding:u.length,resource:{buffer:c.buffer}});i&&u.push({binding:u.length,resource:i});let d=s.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:u,label:t.programInfo.name});if(this.backend.sessionStatus===\"capturing\"){let c={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:d,dispatchGroup:o};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(c)}a.setPipeline(t.computePipeline),a.setBindGroup(0,d),a.dispatchWorkgroups(...o),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType===\"at-passes\")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),he(t.programInfo.name)}dispose(){}build(t,r){ve(t.name);let n=this.backend.device,o=[];n.features.has(\"shader-f16\")&&o.push(\"enable f16;\");let i=oo(r,this.backend.device.limits),s=t.getShaderSource(i),a=`${o.join(`\n`)}\n${i.additionalImplementations}\n${s}`,u=n.createShaderModule({code:a,label:t.name});re(\"verbose\",()=>`[WebGPU] ${t.name} shader code: ${a}`);let d=n.createComputePipeline({compute:{module:u,entryPoint:\"main\"},layout:\"auto\",label:t.name});return he(t.name),{programInfo:t,computePipeline:d,uniformVariablesInfo:i.variablesInfo}}normalizeDispatchGroupSize(t){let r=typeof t==\"number\"?t:t.x,n=typeof t==\"number\"?1:t.y||1,o=typeof t==\"number\"?1:t.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=i&&n<=i&&o<=i)return[r,n,o];let s=r*n*o,a=Math.ceil(Math.sqrt(s));if(a>i){if(a=Math.ceil(Math.cbrt(s)),a>i)throw new Error(\"Total dispatch size exceeds WebGPU maximum.\");return[a,a,a]}else return[a,a,1]}}});var Zl,Yl,Qr,or,Ea=E(()=>{\"use strict\";_e();R();Me();Xn();no();Ca();Aa();Zl=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let n=0;n<e.length;++n){let o=e[n].dataType;switch(t[n]){case\"none\":{r.push(\"\");break}case\"type\":{r.push(`${o}`);break}case\"rank\":{let i=e[n].dims.length;r.push(`${o};${i}`);break}case\"dims\":{let i=e[n].dims.join(\",\");r.push(`${o};${i}`);break}default:throw new Error(`unsupported input dependency: ${t[n]}`)}}return r.join(\"|\")},Yl=(e,t,r)=>{let n=e.name;return e.shaderCache?.hint&&(n+=\"[\"+e.shaderCache.hint+\"]\"),n+=\":\"+r+`:${Zl(t,e.shaderCache?.inputDependencies??new Array(t.length).fill(\"dims\"))}`,n},Qr=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},or=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus=\"default\";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error(\"currentKernelCustomData(): currentKernelId is null. (should not happen)\");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let n=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n};r.features.has(\"chromium-experimental-timestamp-query-inside-passes\")?n.push(\"chromium-experimental-timestamp-query-inside-passes\"):r.features.has(\"timestamp-query\")&&n.push(\"timestamp-query\"),r.features.has(\"shader-f16\")&&n.push(\"shader-f16\"),this.device=await r.requestDevice(o),this.adapterInfo=new Qr(await r.requestAdapterInfo()),this.gpuDataManager=ro(this),this.programManager=new nr(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Yn(t.logLevel,!!t.debug),this.device.onuncapturederror=i=>{i.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${i.error.message}`)},Object.defineProperty(this.env.webgpu,\"device\",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,\"adapter\",{value:r,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<\"u\"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),r={};this.queryType===\"at-passes\"&&(r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;ve(),this.endComputePass();let t;this.queryType!==\"none\"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!==\"none\"&&t.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.getMappedRange()),n=this.pendingQueries.get(t);for(let o=0;o<r.length/2;o++){let i=n[o],s=i.kernelId,a=this.kernels.get(s),u=a.kernelType,d=a.kernelName,c=i.programName,l=i.inputTensorViews,p=i.outputTensorViews,f=r[o*2],m=r[o*2+1];typeof this.queryTimeBase>\"u\"&&(this.queryTimeBase=f);let h=Number(f-this.queryTimeBase),b=Number(m-this.queryTimeBase);if(!Number.isSafeInteger(h)||!Number.isSafeInteger(b))throw new RangeError(\"incorrect timestamp range\");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:l.map(y=>({dims:y.dims,dataType:Re(y.dataType)})),outputsMetadata:p.map(y=>({dims:y.dims,dataType:Re(y.dataType)})),kernelId:s,kernelType:u,kernelName:d,programName:c,startTime:h,endTime:b});else{let y=\"\";l.forEach((w,$)=>{y+=`input[${$}]: [${w.dims}] | ${Re(w.dataType)}, `});let g=\"\";p.forEach((w,$)=>{g+=`output[${$}]: [${w.dims}] | ${Re(w.dataType)}, `}),console.log(`[profiling] kernel \"${s}|${u}|${d}|${c}\" ${y}${g}execution time: ${b-h} ns`)}vt(\"GPU\",`${c}::${f}::${m}`)}t.unmap(),this.pendingQueries.delete(t)}),he()}run(t,r,n,o,i,s){ve(t.name);let a=[];for(let w=0;w<r.length;++w){let $=r[w].data;if($===0)continue;let v=this.gpuDataManager.get($);if(!v)throw new Error(`no GPU data for input: ${$}`);a.push(v)}let{outputs:u,dispatchGroup:d,programUniforms:c}=t.getRunData(r),l=n.length===0?u.map((w,$)=>$):n;if(l.length!==u.length)throw new Error(`Output size ${l.length} must be equal to ${u.length}.`);let p=[],f=[];for(let w=0;w<u.length;++w){if(!Number.isInteger(l[w])||l[w]<-3||l[w]>=s)throw new Error(`Invalid output index: ${l[w]}`);if(l[w]===-3)continue;let $=l[w]===-1,v=l[w]===-2,x=$||v?i(u[w].dataType,u[w].dims):o(l[w],u[w].dataType,u[w].dims);if(p.push(x),x.data===0)continue;let T=this.gpuDataManager.get(x.data);if(!T)throw new Error(`no GPU data for output: ${x.data}`);if($&&this.temporaryData.push(T),v){let I=this.kernelPersistentData.get(this.currentKernelId);I||(I=[],this.kernelPersistentData.set(this.currentKernelId,I)),I.push(T)}f.push(T)}if(a.length!==r.length||f.length!==p.length){if(f.length===0)return he(t.name),p;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let m;if(c){let w=0,$=[];c.forEach(I=>{let z=typeof I.data==\"number\"?[I.data]:I.data;if(z.length===0)return;let P=I.type===10?2:4,G,J;I.type===10?(J=z.length>4?16:z.length>2?8:z.length*P,G=z.length>4?16:P*z.length):(J=z.length<=2?z.length*P:16,G=16),w=Math.ceil(w/J)*J,$.push(w);let ne=I.type===10?8:4;w+=z.length>4?Math.ceil(z.length/ne)*G:z.length*P});let v=16;w=Math.ceil(w/v)*v;let x=new ArrayBuffer(w);c.forEach((I,z)=>{let P=$[z],G=typeof I.data==\"number\"?[I.data]:I.data;if(I.type===6)new Int32Array(x,P,G.length).set(G);else if(I.type===12)new Uint32Array(x,P,G.length).set(G);else if(I.type===10)new Uint16Array(x,P,G.length).set(G);else if(I.type===1)new Float32Array(x,P,G.length).set(G);else throw new Error(`Unsupported uniform type: ${Re(I.type)}`)});let T=this.gpuDataManager.create(w,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(T.buffer,0,x,0,w),this.gpuDataManager.release(T.id),m={offset:0,size:w,buffer:T.buffer}}let h=this.programManager.normalizeDispatchGroupSize(d),b=h[1]===1&&h[2]===1,y=Yl(t,r,b),g=this.programManager.getArtifact(y);if(g||(g=this.programManager.build(t,h),this.programManager.setArtifact(y,g),re(\"info\",()=>`[artifact] key: ${y}, programName: ${t.name}`)),c&&g.uniformVariablesInfo){if(c.length!==g.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${g.uniformVariablesInfo.length}, got ${c.length} in program \"${g.programInfo.name}\".`);for(let w=0;w<c.length;w++){let $=c[w],v=$.type,x=typeof $.data==\"number\"?1:$.data.length,[T,I]=g.uniformVariablesInfo[w];if(v!==T||x!==I)throw new Error(`Uniform variable ${w} mismatch: expect type ${T} with size ${I}, got type ${v} with size ${x} in program \"${g.programInfo.name}\".`)}}if(re(\"info\",()=>`[ProgramManager] run \"${t.name}\" (key=${y}) with ${h[0]}x${h[1]}x${h[2]}`),this.queryType!==\"none\"||this.sessionStatus===\"capturing\"){let w={kernelId:this.currentKernelId,programName:g.programInfo.name,inputTensorViews:r,outputTensorViews:p};this.pendingKernels.push(w),this.sessionStatus===\"capturing\"&&this.capturedPendingKernels.get(this.currentSessionId).push(w)}return this.programManager.run(g,a,f,h,m),he(t.name),p}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,n,o){let i=Ta.get(t);if(!i)throw new Error(`kernel not implemented: ${t}`);let s={kernelType:t,kernelName:o,kernelEntry:i[0],attributes:[i[1],n]};this.kernels.set(r,s)}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let n of r)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,n){let o=this.kernels.get(t);if(!o)throw new Error(`kernel not created: ${t}`);let i=o.kernelType,s=o.kernelName,a=o.kernelEntry,u=o.attributes;if(this.currentKernelId!==null)throw new Error(`kernel \"[${i}] ${s}\" is not allowed to be called recursively`);this.currentKernelId=t,u[0]&&(u[1]=u[0](u[1]),u[0]=void 0),re(\"info\",()=>`[WebGPU] Start to run kernel \"[${i}] ${s}\"...`);let d=this.env.debug;this.temporaryData=[];try{return d&&this.device.pushErrorScope(\"validation\"),a(r,u[1]),0}catch(c){return n.push(Promise.resolve(`[WebGPU] Kernel \"[${i}] ${s}\" failed. ${c}`)),1}finally{d&&n.push(this.device.popErrorScope().then(c=>c?`GPU validation error for kernel \"[${i}] ${s}\": ${c.message}`:null));for(let c of this.temporaryData)this.gpuDataManager.release(c.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,n,o){let i=this.sessionExternalDataMapping.get(t);i||(i=new Map,this.sessionExternalDataMapping.set(t,i));let s=i.get(r),a=this.gpuDataManager.registerExternalBuffer(n,o,s?.[1]);return i.set(r,[a,n]),a}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,n){return async()=>{let o=await Tr(this,t,r);return Qn(o.buffer,n)}}writeTimestamp(t){this.queryType===\"inside-passes\"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType=\"none\",(this.env.webgpu.profiling?.mode===\"default\"||(typeof this.env.trace>\"u\"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has(\"chromium-experimental-timestamp-query-inside-passes\")?this.queryType=\"inside-passes\":this.device.features.has(\"timestamp-query\")&&(this.queryType=\"at-passes\"),this.queryType!==\"none\"&&typeof this.querySet>\"u\"&&(this.querySet=this.device.createQuerySet({type:\"timestamp\",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){re(\"info\",\"captureBegin\"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus=\"capturing\"}captureEnd(){re(\"info\",\"captureEnd\"),this.flush(),this.sessionStatus=\"default\"}replay(){re(\"info\",\"replay\"),this.sessionStatus=\"replaying\";let t=this.capturedCommandList.get(this.currentSessionId),r=this.capturedPendingKernels.get(this.currentSessionId),n=t.length;this.pendingKernels=[];for(let o=0;o<n;o++){let i=this.getComputePassEncoder(),s=t[o];this.writeTimestamp(this.pendingDispatchNumber*2),i.setPipeline(s.computePipeline),i.setBindGroup(0,s.bindGroup),i.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!==\"none\"&&this.pendingKernels.push(r[o]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType===\"at-passes\")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus=\"default\"}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var ka={};ht(ka,{init:()=>Ql});var mt,Xr,Ql,Pa=E(()=>{\"use strict\";R();Ea();Me();L();mt=class e{constructor(t,r,n,o){this.module=t;this.dataType=r;this.data=n;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error(\"Invalid data type\");let t=_.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error(\"Invalid data type\");let t=_.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error(\"Invalid data type\");let t=_.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(_.size(t)!==_.size(this.dims))throw new Error(\"Invalid new shape\");return new e(this.module,this.dataType,this.data,t)}},Xr=class{constructor(t,r,n){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=r.adapterInfo;let o=t.HEAPU32,i=n>>>2;this.opKernelContext=o[i++];let s=o[i++];this.outputCount=o[i++],this.customDataOffset=o[i++],this.customDataSize=o[i++];let a=[];for(let u=0;u<s;u++){let d=o[i++],c=o[i++],l=o[i++],p=[];for(let f=0;f<l;f++)p.push(o[i++]);a.push(new mt(t,d,c,p))}this.inputs=a}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(t,r){let n=r?.inputs?.map(a=>typeof a==\"number\"?this.inputs[a]:a)??this.inputs,o=r?.outputs??[],i=(a,u,d)=>new mt(this.module,u,this.output(a,d),d),s=(a,u)=>{let d=qe(a);if(!d)throw new Error(`Unsupported data type: ${a}`);let c=d*_.size(u),l=c>0?this.backend.gpuDataManager.create(c).id:0;return new mt(this.module,a,l,u)};return this.backend.run(t,n,o,i,s,this.outputCount)}output(t,r){let n=this.module.stackSave();try{let o=this.module.stackAlloc((1+r.length)*4),i=o>>2;this.module.HEAPU32[i++]=r.length;for(let s=0;s<r.length;s++)this.module.HEAPU32[i++]=r[s];return this.module._JsepOutput(this.opKernelContext,t,o)}catch(o){throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(n)}}},Ql=async(e,t,r,n)=>{let o=t.jsepInit;if(!o)throw new Error(\"Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.\");if(e===\"webgpu\"){let i=new or;await i.initialize(r,n),o(\"webgpu\",[i,s=>i.alloc(s),s=>i.free(s),(s,a,u,d=!1)=>{if(d)re(\"verbose\",()=>`[WebGPU] jsepCopyGpuToGpu: src=${s}, dst=${a}, size=${u}`),i.memcpy(s,a);else{re(\"verbose\",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${s}, gpuDataId=${a}, size=${u}`);let c=t.HEAPU8.subarray(s>>>0,(s>>>0)+u);i.upload(a,c)}},async(s,a,u)=>{re(\"verbose\",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${s}, dataOffset=${a}, size=${u}`),await i.download(s,()=>t.HEAPU8.subarray(a>>>0,(a>>>0)+u))},(s,a,u)=>i.createKernel(s,a,u,t.UTF8ToString(t._JsepGetNodeName(a))),s=>i.releaseKernel(s),(s,a,u,d)=>{re(\"verbose\",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${s}, contextDataOffset=${a}`);let c=new Xr(t,i,a);return i.computeKernel(s,c,d)},()=>i.captureBegin(),()=>i.captureEnd(),()=>i.replay()])}else o(\"webnn\")}});var Xl,Tt,Ct,Ye,Jl,it,At,Et,za,kt,Pt,zt,yr=E(()=>{\"use strict\";qn();Kn();R();Le();Bt();_r();Xl=(e,t)=>{oe()._OrtInit(e,t)!==0&&te(\"Can't initialize onnxruntime.\")},Tt=async e=>{Xl(e.wasm.numThreads,at(e.logLevel))},Ct=async(e,t)=>{{let r=(Pa(),pr(ka)).init;if(t===\"webgpu\"){if(typeof navigator>\"u\"||!navigator.gpu)throw new Error(\"WebGPU is not supported in current environment\");let n=e.webgpu.adapter;if(n){if(typeof n.limits!=\"object\"||typeof n.features!=\"object\"||typeof n.requestDevice!=\"function\")throw new Error(\"Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.\")}else{let o=e.webgpu.powerPreference;if(o!==void 0&&o!==\"low-power\"&&o!==\"high-performance\")throw new Error(`Invalid powerPreference setting: \"${o}\"`);let i=e.webgpu.forceFallbackAdapter;if(i!==void 0&&typeof i!=\"boolean\")throw new Error(`Invalid forceFallbackAdapter setting: \"${i}\"`);if(n=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:i}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.')}await r(\"webgpu\",oe(),e,n)}if(t===\"webnn\"){if(typeof navigator>\"u\"||!navigator.ml)throw new Error(\"WebNN is not supported in current environment\");await r(\"webnn\",oe(),e)}}},Ye=new Map,Jl=e=>{let t=oe(),r=t.stackSave();try{let n=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,n,n+4)!==0&&te(\"Can't get session input/output count.\"),[t.HEAP32[n/4],t.HEAP32[n/4+1]]}finally{t.stackRestore(r)}},it=e=>{let t=oe(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},At=async(e,t)=>{let r,n,o=oe();Array.isArray(e)?[r,n]=e:e.buffer===o.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=it(e);let i=0,s=0,a=0,u=[],d=[],c=[];try{if([s,u]=Fn(t),t?.externalData&&o.mountExternalData){let g=[];for(let w of t.externalData){let $=typeof w==\"string\"?w:w.path;g.push(ut(typeof w==\"string\"?w:w.data).then(v=>{o.mountExternalData($,v)}))}await Promise.all(g)}i=await o._OrtCreateSession(r,n,s),i===0&&te(\"Can't create a session.\");let[l,p]=Jl(i),f=!!t?.enableGraphCapture,m=[],h=[],b=[];for(let g=0;g<l;g++){let w=o._OrtGetInputName(i,g);w===0&&te(\"Can't get an input name.\"),d.push(w),m.push(o.UTF8ToString(w))}for(let g=0;g<p;g++){let w=o._OrtGetOutputName(i,g);w===0&&te(\"Can't get an output name.\"),c.push(w);let $=o.UTF8ToString(w);h.push($);{if(f&&t?.preferredOutputLocation===void 0){b.push(\"gpu-buffer\");continue}let v=typeof t?.preferredOutputLocation==\"string\"?t.preferredOutputLocation:t?.preferredOutputLocation?.[$]??\"cpu\";if(v!==\"cpu\"&&v!==\"cpu-pinned\"&&v!==\"gpu-buffer\")throw new Error(`Not supported preferred output location: ${v}.`);if(f&&v!==\"gpu-buffer\")throw new Error(`Not supported preferred output location: ${v}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);b.push(v)}}let y=null;return b.some(g=>g===\"gpu-buffer\")&&(a=o._OrtCreateBinding(i),a===0&&te(\"Can't create IO binding.\"),y={handle:a,outputPreferredLocations:b,outputPreferredLocationsEncoded:b.map(g=>vr(g))}),Ye.set(i,[i,d,c,y,f,!1]),[i,m,h]}catch(l){throw d.forEach(p=>o._OrtFree(p)),c.forEach(p=>o._OrtFree(p)),a!==0&&o._OrtReleaseBinding(a),i!==0&&o._OrtReleaseSession(i),l}finally{o._free(r),s!==0&&o._OrtReleaseSessionOptions(s),u.forEach(l=>o._free(l)),o.unmountExternalData?.()}},Et=e=>{let t=oe(),r=Ye.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[n,o,i,s,a]=r;s&&(a&&t._OrtClearBoundOutputs(s.handle),t._OrtReleaseBinding(s.handle)),t.jsepOnReleaseSession?.(e),o.forEach(u=>t._OrtFree(u)),i.forEach(u=>t._OrtFree(u)),t._OrtReleaseSession(n),Ye.delete(e)},za=(e,t,r,n,o,i=!1)=>{if(!e){t.push(0);return}let s=oe(),a=e[0],u=e[1],d=e[3],c,l;if(a===\"string\"&&d===\"gpu-buffer\")throw new Error(\"String tensor is not supported on GPU.\");if(i&&d!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if(d===\"gpu-buffer\"){let m=e[2].gpuBuffer,h=qe($r(a));l=u.reduce((y,g)=>y*g,1)*h;let b=s.jsepRegisterBuffer;if(!b)throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');c=b(n,o,m,l)}else{let m=e[2];if(Array.isArray(m)){l=4*m.length,c=s._malloc(l),r.push(c);let h=c/4;for(let b=0;b<m.length;b++){if(typeof m[b]!=\"string\")throw new TypeError(`tensor data at index ${b} is not a string`);s.HEAPU32[h++]=ie(m[b],r)}}else l=m.byteLength,c=s._malloc(l),r.push(c),s.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,l),c)}let p=s.stackSave(),f=s.stackAlloc(4*u.length);try{let m=f/4;u.forEach(b=>s.HEAP32[m++]=b);let h=s._OrtCreateTensor($r(a),c,l,f,u.length,vr(d));h===0&&te(`Can't create tensor for input/output. session=${n}, index=${o}.`),t.push(h)}finally{s.stackRestore(p)}},kt=async(e,t,r,n,o,i)=>{let s=oe(),a=Ye.get(e);if(!a)throw new Error(`cannot run inference. invalid session id: ${e}`);let u=a[0],d=a[1],c=a[2],l=a[3],p=a[4],f=a[5],m=t.length,h=n.length,b=0,y=[],g=[],w=[],$=[],v=s.stackSave(),x=s.stackAlloc(m*4),T=s.stackAlloc(m*4),I=s.stackAlloc(h*4),z=s.stackAlloc(h*4);try{[b,y]=Hn(i);for(let O=0;O<m;O++)za(r[O],g,$,e,t[O],p);for(let O=0;O<h;O++)za(o[O],w,$,e,m+n[O],p);let P=x/4,G=T/4,J=I/4,ne=z/4;for(let O=0;O<m;O++)s.HEAPU32[P++]=g[O],s.HEAPU32[G++]=d[t[O]];for(let O=0;O<h;O++)s.HEAPU32[J++]=w[O],s.HEAPU32[ne++]=c[n[O]];if(l&&!f){let{handle:O,outputPreferredLocations:Y,outputPreferredLocationsEncoded:K}=l;if(d.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model's input count (${d.length}).`);for(let q=0;q<m;q++){let M=t[q];await s._OrtBindInput(O,d[M],g[q])!==0&&te(`Can't bind input[${q}] for session=${e}.`)}for(let q=0;q<h;q++){let M=n[q];o[q]?.[3]?s._OrtBindOutput(O,c[M],w[q],0)!==0&&te(`Can't bind pre-allocated output[${q}] for session=${e}.`):s._OrtBindOutput(O,c[M],0,K[M])!==0&&te(`Can't bind output[${q}] to ${Y[q]} for session=${e}.`)}Ye.set(e,[u,d,c,l,p,!0])}s.jsepOnRunStart?.(u);let Q;l?Q=await s._OrtRunWithBinding(u,l.handle,h,I,b):Q=await s._OrtRun(u,T,x,m,z,h,I,b),Q!==0&&te(\"failed to call OrtRun().\");let se=[];for(let O=0;O<h;O++){let Y=s.HEAPU32[I/4+O];if(Y===w[O]){se.push(o[O]);continue}let K=s.stackSave(),q=s.stackAlloc(4*4),M=!1,H,V=0;try{s._OrtGetTensorData(Y,q,q+4,q+8,q+12)!==0&&te(`Can't access output tensor data on index ${O}.`);let C=q/4,B=s.HEAPU32[C++];V=s.HEAPU32[C++];let F=s.HEAPU32[C++],Ie=s.HEAPU32[C++],fe=[];for(let be=0;be<Ie;be++)fe.push(s.HEAPU32[F/4+be]);s._OrtFree(F);let ue=fe.reduce((be,we)=>be*we,1);H=Re(B);let rn=l?.outputPreferredLocations[n[O]];if(H===\"string\"){if(rn===\"gpu-buffer\")throw new Error(\"String tensor is not supported on GPU.\");let be=[],we=V/4;for(let Xe=0;Xe<ue;Xe++){let nn=s.HEAPU32[we++],qa=Xe===ue-1?void 0:s.HEAPU32[we]-nn;be.push(s.UTF8ToString(nn,qa))}se.push([H,fe,be,\"cpu\"])}else if(rn===\"gpu-buffer\"&&ue>0){let be=s.jsepGetBuffer;if(!be)throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');let we=be(V),Xe=qe(B);if(Xe===void 0||!Rt(H))throw new Error(`Unsupported data type: ${H}`);M=!0,se.push([H,fe,{gpuBuffer:we,download:s.jsepCreateDownloader(we,ue*Xe,H),dispose:()=>{s._OrtReleaseTensor(Y)}},\"gpu-buffer\"])}else{let be=Dt(H),we=new be(ue);new Uint8Array(we.buffer,we.byteOffset,we.byteLength).set(s.HEAPU8.subarray(V,V+we.byteLength)),se.push([H,fe,we,\"cpu\"])}}finally{s.stackRestore(K),H===\"string\"&&V&&s._free(V),M||s._OrtReleaseTensor(Y)}}return l&&!p&&(s._OrtClearBoundOutputs(l.handle),Ye.set(e,[u,d,c,l,p,!1])),se}finally{s.stackRestore(v),g.forEach(P=>s._OrtReleaseTensor(P)),w.forEach(P=>s._OrtReleaseTensor(P)),$.forEach(P=>s._free(P)),b!==0&&s._OrtReleaseRunOptions(b),y.forEach(P=>s._free(P))}},Pt=e=>{let t=oe(),r=Ye.get(e);if(!r)throw new Error(\"invalid session id\");let n=r[0],o=t._OrtEndProfiling(n);o===0&&te(\"Can't get an profile file name.\"),t._OrtFree(o)},zt=e=>{let t=[];for(let r of e){let n=r[2];!Array.isArray(n)&&\"buffer\"in n&&t.push(n.buffer)}return t}});var Qe,xe,ft,sr,ar,ir,Jr,en,tt,rt,tc,Oa,Ba,Da,Ra,Ma,Ua,Va,tn=E(()=>{\"use strict\";_e();yr();Le();ot();Qe=()=>!!j.wasm.proxy&&typeof document<\"u\",ft=!1,sr=!1,ar=!1,en=new Map,tt=(e,t)=>{let r=en.get(e);r?r.push(t):en.set(e,[t])},rt=()=>{if(ft||!sr||ar||!xe)throw new Error(\"worker not ready\")},tc=e=>{switch(e.data.type){case\"init-wasm\":ft=!1,e.data.err?(ar=!0,Jr[1](e.data.err)):(sr=!0,Jr[0]()),ir&&(URL.revokeObjectURL(ir),ir=void 0);break;case\"init-ep\":case\"copy-from\":case\"create\":case\"release\":case\"run\":case\"end-profiling\":{let t=en.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}default:}},Oa=async()=>{if(!sr){if(ft)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(ar)throw new Error(\"previous call to 'initWasm()' failed.\");if(ft=!0,Qe())return new Promise((e,t)=>{xe?.terminate(),Wn().then(([r,n])=>{try{xe=n,xe.onerror=i=>t(i),xe.onmessage=tc,Jr=[e,t];let o={type:\"init-wasm\",in:j};xe.postMessage(o),ir=r}catch(o){t(o)}},t)});try{await It(j.wasm),await Tt(j),sr=!0}catch(e){throw ar=!0,e}finally{ft=!1}}},Ba=async e=>{if(Qe())return rt(),new Promise((t,r)=>{tt(\"init-ep\",[t,r]);let n={type:\"init-ep\",in:{epName:e,env:j}};xe.postMessage(n)});await Ct(j,e)},Da=async e=>Qe()?(rt(),new Promise((t,r)=>{tt(\"copy-from\",[t,r]);let n={type:\"copy-from\",in:{buffer:e}};xe.postMessage(n,[e.buffer])})):it(e),Ra=async(e,t)=>{if(Qe()){if(t?.preferredOutputLocation)throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');return rt(),new Promise((r,n)=>{tt(\"create\",[r,n]);let o={type:\"create\",in:{model:e,options:{...t}}},i=[];e instanceof Uint8Array&&i.push(e.buffer),xe.postMessage(o,i)})}else return At(e,t)},Ma=async e=>{if(Qe())return rt(),new Promise((t,r)=>{tt(\"release\",[t,r]);let n={type:\"release\",in:e};xe.postMessage(n)});Et(e)},Ua=async(e,t,r,n,o,i)=>{if(Qe()){if(r.some(s=>s[3]!==\"cpu\"))throw new Error(\"input tensor on GPU is not supported for proxy.\");if(o.some(s=>s))throw new Error(\"pre-allocated output tensor is not supported for proxy.\");return rt(),new Promise((s,a)=>{tt(\"run\",[s,a]);let u=r,d={type:\"run\",in:{sessionId:e,inputIndices:t,inputs:u,outputIndices:n,options:i}};xe.postMessage(d,zt(u))})}else return kt(e,t,r,n,o,i)},Va=async e=>{if(Qe())return rt(),new Promise((t,r)=>{tt(\"end-profiling\",[t,r]);let n={type:\"end-profiling\",in:e};xe.postMessage(n)});Pt(e)}});var Na,rc,ur,Wa=E(()=>{\"use strict\";_e();tn();R();xt();_r();Na=(e,t)=>{switch(e.location){case\"cpu\":return[e.type,e.dims,e.data,\"cpu\"];case\"gpu-buffer\":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},\"gpu-buffer\"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},rc=e=>{switch(e[3]){case\"cpu\":return new de(e[0],e[2],e[1]);case\"gpu-buffer\":{let t=e[0];if(!Rt(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:n,dispose:o}=e[2];return de.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:o})}default:throw new Error(`invalid data location: ${e[3]}`)}},ur=class{async fetchModelAndCopyToWasmMemory(t){return Da(await ut(t))}async loadModel(t,r){ve();let n;typeof t==\"string\"? false?0:n=await this.fetchModelAndCopyToWasmMemory(t):n=t,[this.sessionId,this.inputNames,this.outputNames]=await Ra(n,r),he()}async dispose(){return Ma(this.sessionId)}async run(t,r,n){ve();let o=[],i=[];Object.entries(t).forEach(p=>{let f=p[0],m=p[1],h=this.inputNames.indexOf(f);if(h===-1)throw new Error(`invalid input '${f}'`);o.push(m),i.push(h)});let s=[],a=[];Object.entries(r).forEach(p=>{let f=p[0],m=p[1],h=this.outputNames.indexOf(f);if(h===-1)throw new Error(`invalid output '${f}'`);s.push(m),a.push(h)});let u=o.map((p,f)=>Na(p,()=>`input \"${this.inputNames[i[f]]}\"`)),d=s.map((p,f)=>p?Na(p,()=>`output \"${this.outputNames[a[f]]}\"`):null),c=await Ua(this.sessionId,i,u,a,d,n),l={};for(let p=0;p<c.length;p++)l[this.outputNames[a[p]]]=s[p]??rc(c[p]);return he(),l}startProfiling(){}endProfiling(){Va(this.sessionId)}}});var nc,dr,Ga=E(()=>{\"use strict\";_e();tn();Wa();ot();nc=()=>{if((typeof j.wasm.initTimeout!=\"number\"||j.wasm.initTimeout<0)&&(j.wasm.initTimeout=0),j.wasm.simd===!1&&console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof j.wasm.proxy!=\"boolean\"&&(j.wasm.proxy=!1),typeof j.wasm.trace!=\"boolean\"&&(j.wasm.trace=!1),typeof j.wasm.numThreads!=\"number\"||!Number.isInteger(j.wasm.numThreads)||j.wasm.numThreads<=0)if(typeof self<\"u\"&&!self.crossOriginIsolated)j.wasm.numThreads=1;else{let e=typeof navigator>\"u\"?cr(\"node:os\").cpus().length:navigator.hardwareConcurrency;j.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}j.wasm.wasmPaths===void 0&&Se&&Se.indexOf(\"blob:\")!==0&&(j.wasm.wasmPaths=Se.substring(0,Se.lastIndexOf(\"/\")+1))},dr=class{async init(t){nc(),await Oa(),await Ba(t)}async createInferenceSessionHandler(t,r){let n=new ur;return await n.loadModel(t,r),Promise.resolve(n)}}});var La={};ht(La,{wasmBackend:()=>oc});var oc,Ha=E(()=>{\"use strict\";Ga();oc=new dr});_e();_e();_e();var On=\"1.19.0-dev.20240531-67bc9438d7\";var h$=gr;{let e=(Ha(),pr(La)).wasmBackend;We(\"webgpu\",e,5),We(\"webnn\",e,5),We(\"cpu\",e,10),We(\"wasm\",e,10)}Object.defineProperty(j.versions,\"web\",{value:On,enumerable:!0});\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n//# sourceMappingURL=ort.webgpu.min.mjs.map\n\n\n//# sourceURL=webpack://webgpu-prog-iso/./node_modules/onnxruntime-web/dist/ort.webgpu.min.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/app.js");
/******/ 	
/******/ })()
;